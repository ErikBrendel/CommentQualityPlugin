# id;timestamp;commentText;codeText;commentWords;codeWords
OptimizerNode -> public int getId();1426843274;Gets the ID of this node. If the id has not yet been set, this method returns -1___@return This node's id, or -1, if not yet set.;public int getId() {_		return this.id__	};gets,the,id,of,this,node,if,the,id,has,not,yet,been,set,this,method,returns,1,return,this,node,s,id,or,1,if,not,yet,set;public,int,get,id,return,this,id
OptimizerNode -> public int getId();1427097830;Gets the ID of this node. If the id has not yet been set, this method returns -1___@return This node's id, or -1, if not yet set.;public int getId() {_		return this.id__	};gets,the,id,of,this,node,if,the,id,has,not,yet,been,set,this,method,returns,1,return,this,node,s,id,or,1,if,not,yet,set;public,int,get,id,return,this,id
OptimizerNode -> public int getId();1431981454;Gets the ID of this node. If the id has not yet been set, this method returns -1___@return This node's id, or -1, if not yet set.;public int getId() {_		return this.id__	};gets,the,id,of,this,node,if,the,id,has,not,yet,been,set,this,method,returns,1,return,this,node,s,id,or,1,if,not,yet,set;public,int,get,id,return,this,id
OptimizerNode -> public int getId();1442492509;Gets the ID of this node. If the id has not yet been set, this method returns -1___@return This node's id, or -1, if not yet set.;public int getId() {_		return this.id__	};gets,the,id,of,this,node,if,the,id,has,not,yet,been,set,this,method,returns,1,return,this,node,s,id,or,1,if,not,yet,set;public,int,get,id,return,this,id
OptimizerNode -> public int getId();1446112342;Gets the ID of this node. If the id has not yet been set, this method returns -1___@return This node's id, or -1, if not yet set.;public int getId() {_		return this.id__	};gets,the,id,of,this,node,if,the,id,has,not,yet,been,set,this,method,returns,1,return,this,node,s,id,or,1,if,not,yet,set;public,int,get,id,return,this,id
OptimizerNode -> public int getId();1460563153;Gets the ID of this node. If the id has not yet been set, this method returns -1___@return This node's id, or -1, if not yet set.;public int getId() {_		return this.id__	};gets,the,id,of,this,node,if,the,id,has,not,yet,been,set,this,method,returns,1,return,this,node,s,id,or,1,if,not,yet,set;public,int,get,id,return,this,id
OptimizerNode -> public int getId();1546180287;Gets the ID of this node. If the id has not yet been set, this method returns -1___@return This node's id, or -1, if not yet set.;public int getId() {_		return this.id__	};gets,the,id,of,this,node,if,the,id,has,not,yet,been,set,this,method,returns,1,return,this,node,s,id,or,1,if,not,yet,set;public,int,get,id,return,this,id
OptimizerNode -> UnclosedBranchDescriptor -> protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector);1426843274;Creates a new branching descriptor.__@param branchingNode The node where the branch occurred (teh node with multiple outputs)._@param joinedPathsVector A bit vector describing which branches are tracked by this descriptor._The bit vector is one, where the branch is tracked, zero otherwise.;protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector) {_			this.branchingNode = branchingNode__			this.joinedPathsVector = joinedPathsVector__		};creates,a,new,branching,descriptor,param,branching,node,the,node,where,the,branch,occurred,teh,node,with,multiple,outputs,param,joined,paths,vector,a,bit,vector,describing,which,branches,are,tracked,by,this,descriptor,the,bit,vector,is,one,where,the,branch,is,tracked,zero,otherwise;protected,unclosed,branch,descriptor,optimizer,node,branching,node,long,joined,paths,vector,this,branching,node,branching,node,this,joined,paths,vector,joined,paths,vector
OptimizerNode -> UnclosedBranchDescriptor -> protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector);1427097830;Creates a new branching descriptor.__@param branchingNode The node where the branch occurred (teh node with multiple outputs)._@param joinedPathsVector A bit vector describing which branches are tracked by this descriptor._The bit vector is one, where the branch is tracked, zero otherwise.;protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector) {_			this.branchingNode = branchingNode__			this.joinedPathsVector = joinedPathsVector__		};creates,a,new,branching,descriptor,param,branching,node,the,node,where,the,branch,occurred,teh,node,with,multiple,outputs,param,joined,paths,vector,a,bit,vector,describing,which,branches,are,tracked,by,this,descriptor,the,bit,vector,is,one,where,the,branch,is,tracked,zero,otherwise;protected,unclosed,branch,descriptor,optimizer,node,branching,node,long,joined,paths,vector,this,branching,node,branching,node,this,joined,paths,vector,joined,paths,vector
OptimizerNode -> UnclosedBranchDescriptor -> protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector);1431981454;Creates a new branching descriptor.__@param branchingNode The node where the branch occurred (teh node with multiple outputs)._@param joinedPathsVector A bit vector describing which branches are tracked by this descriptor._The bit vector is one, where the branch is tracked, zero otherwise.;protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector) {_			this.branchingNode = branchingNode__			this.joinedPathsVector = joinedPathsVector__		};creates,a,new,branching,descriptor,param,branching,node,the,node,where,the,branch,occurred,teh,node,with,multiple,outputs,param,joined,paths,vector,a,bit,vector,describing,which,branches,are,tracked,by,this,descriptor,the,bit,vector,is,one,where,the,branch,is,tracked,zero,otherwise;protected,unclosed,branch,descriptor,optimizer,node,branching,node,long,joined,paths,vector,this,branching,node,branching,node,this,joined,paths,vector,joined,paths,vector
OptimizerNode -> UnclosedBranchDescriptor -> protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector);1442492509;Creates a new branching descriptor.__@param branchingNode The node where the branch occurred (teh node with multiple outputs)._@param joinedPathsVector A bit vector describing which branches are tracked by this descriptor._The bit vector is one, where the branch is tracked, zero otherwise.;protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector) {_			this.branchingNode = branchingNode__			this.joinedPathsVector = joinedPathsVector__		};creates,a,new,branching,descriptor,param,branching,node,the,node,where,the,branch,occurred,teh,node,with,multiple,outputs,param,joined,paths,vector,a,bit,vector,describing,which,branches,are,tracked,by,this,descriptor,the,bit,vector,is,one,where,the,branch,is,tracked,zero,otherwise;protected,unclosed,branch,descriptor,optimizer,node,branching,node,long,joined,paths,vector,this,branching,node,branching,node,this,joined,paths,vector,joined,paths,vector
OptimizerNode -> UnclosedBranchDescriptor -> protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector);1446112342;Creates a new branching descriptor.__@param branchingNode The node where the branch occurred (teh node with multiple outputs)._@param joinedPathsVector A bit vector describing which branches are tracked by this descriptor._The bit vector is one, where the branch is tracked, zero otherwise.;protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector) {_			this.branchingNode = branchingNode__			this.joinedPathsVector = joinedPathsVector__		};creates,a,new,branching,descriptor,param,branching,node,the,node,where,the,branch,occurred,teh,node,with,multiple,outputs,param,joined,paths,vector,a,bit,vector,describing,which,branches,are,tracked,by,this,descriptor,the,bit,vector,is,one,where,the,branch,is,tracked,zero,otherwise;protected,unclosed,branch,descriptor,optimizer,node,branching,node,long,joined,paths,vector,this,branching,node,branching,node,this,joined,paths,vector,joined,paths,vector
OptimizerNode -> UnclosedBranchDescriptor -> protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector);1460563153;Creates a new branching descriptor.__@param branchingNode The node where the branch occurred (teh node with multiple outputs)._@param joinedPathsVector A bit vector describing which branches are tracked by this descriptor._The bit vector is one, where the branch is tracked, zero otherwise.;protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector) {_			this.branchingNode = branchingNode__			this.joinedPathsVector = joinedPathsVector__		};creates,a,new,branching,descriptor,param,branching,node,the,node,where,the,branch,occurred,teh,node,with,multiple,outputs,param,joined,paths,vector,a,bit,vector,describing,which,branches,are,tracked,by,this,descriptor,the,bit,vector,is,one,where,the,branch,is,tracked,zero,otherwise;protected,unclosed,branch,descriptor,optimizer,node,branching,node,long,joined,paths,vector,this,branching,node,branching,node,this,joined,paths,vector,joined,paths,vector
OptimizerNode -> UnclosedBranchDescriptor -> protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector);1546180287;Creates a new branching descriptor.__@param branchingNode The node where the branch occurred (the node with multiple outputs)._@param joinedPathsVector A bit vector describing which branches are tracked by this descriptor._The bit vector is one, where the branch is tracked, zero otherwise.;protected UnclosedBranchDescriptor(OptimizerNode branchingNode, long joinedPathsVector) {_			this.branchingNode = branchingNode__			this.joinedPathsVector = joinedPathsVector__		};creates,a,new,branching,descriptor,param,branching,node,the,node,where,the,branch,occurred,the,node,with,multiple,outputs,param,joined,paths,vector,a,bit,vector,describing,which,branches,are,tracked,by,this,descriptor,the,bit,vector,is,one,where,the,branch,is,tracked,zero,otherwise;protected,unclosed,branch,descriptor,optimizer,node,branching,node,long,joined,paths,vector,this,branching,node,branching,node,this,joined,paths,vector,joined,paths,vector
OptimizerNode -> public Operator<?> getOperator();1426843274;Gets the operator represented by this optimizer node.__@return This node's operator.;public Operator<?> getOperator() {_		return this.operator__	};gets,the,operator,represented,by,this,optimizer,node,return,this,node,s,operator;public,operator,get,operator,return,this,operator
OptimizerNode -> public Operator<?> getOperator();1427097830;Gets the operator represented by this optimizer node.__@return This node's operator.;public Operator<?> getOperator() {_		return this.operator__	};gets,the,operator,represented,by,this,optimizer,node,return,this,node,s,operator;public,operator,get,operator,return,this,operator
OptimizerNode -> public Operator<?> getOperator();1431981454;Gets the operator represented by this optimizer node.__@return This node's operator.;public Operator<?> getOperator() {_		return this.operator__	};gets,the,operator,represented,by,this,optimizer,node,return,this,node,s,operator;public,operator,get,operator,return,this,operator
OptimizerNode -> public Operator<?> getOperator();1442492509;Gets the operator represented by this optimizer node.__@return This node's operator.;public Operator<?> getOperator() {_		return this.operator__	};gets,the,operator,represented,by,this,optimizer,node,return,this,node,s,operator;public,operator,get,operator,return,this,operator
OptimizerNode -> public Operator<?> getOperator();1446112342;Gets the operator represented by this optimizer node.__@return This node's operator.;public Operator<?> getOperator() {_		return this.operator__	};gets,the,operator,represented,by,this,optimizer,node,return,this,node,s,operator;public,operator,get,operator,return,this,operator
OptimizerNode -> public Operator<?> getOperator();1460563153;Gets the operator represented by this optimizer node.__@return This node's operator.;public Operator<?> getOperator() {_		return this.operator__	};gets,the,operator,represented,by,this,optimizer,node,return,this,node,s,operator;public,operator,get,operator,return,this,operator
OptimizerNode -> public Operator<?> getOperator();1546180287;Gets the operator represented by this optimizer node.__@return This node's operator.;public Operator<?> getOperator() {_		return this.operator__	};gets,the,operator,represented,by,this,optimizer,node,return,this,node,s,operator;public,operator,get,operator,return,this,operator
OptimizerNode -> public abstract String getOperatorName()_;1442492509;Gets the name of this node, which is the name of the function/operator, or_data source / data sink.__@return The node name.;public abstract String getOperatorName()_;gets,the,name,of,this,node,which,is,the,name,of,the,function,operator,or,data,source,data,sink,return,the,node,name;public,abstract,string,get,operator,name
OptimizerNode -> public abstract String getOperatorName()_;1446112342;Gets the name of this node, which is the name of the function/operator, or_data source / data sink.__@return The node name.;public abstract String getOperatorName()_;gets,the,name,of,this,node,which,is,the,name,of,the,function,operator,or,data,source,data,sink,return,the,node,name;public,abstract,string,get,operator,name
OptimizerNode -> public abstract String getOperatorName()_;1460563153;Gets the name of this node, which is the name of the function/operator, or_data source / data sink.__@return The node name.;public abstract String getOperatorName()_;gets,the,name,of,this,node,which,is,the,name,of,the,function,operator,or,data,source,data,sink,return,the,node,name;public,abstract,string,get,operator,name
OptimizerNode -> public abstract String getOperatorName()_;1546180287;Gets the name of this node, which is the name of the function/operator, or_data source / data sink.__@return The node name.;public abstract String getOperatorName()_;gets,the,name,of,this,node,which,is,the,name,of,the,function,operator,or,data,source,data,sink,return,the,node,name;public,abstract,string,get,operator,name
OptimizerNode -> public boolean isBranching();1426843274;Checks whether this node has branching output. A node's output is branched, if it has more_than one output connection.__@return True, if the node's output branches. False otherwise.;public boolean isBranching() {_		return getOutgoingConnections() != null && getOutgoingConnections().size() > 1__	};checks,whether,this,node,has,branching,output,a,node,s,output,is,branched,if,it,has,more,than,one,output,connection,return,true,if,the,node,s,output,branches,false,otherwise;public,boolean,is,branching,return,get,outgoing,connections,null,get,outgoing,connections,size,1
OptimizerNode -> public boolean isBranching();1427097830;Checks whether this node has branching output. A node's output is branched, if it has more_than one output connection.__@return True, if the node's output branches. False otherwise.;public boolean isBranching() {_		return getOutgoingConnections() != null && getOutgoingConnections().size() > 1__	};checks,whether,this,node,has,branching,output,a,node,s,output,is,branched,if,it,has,more,than,one,output,connection,return,true,if,the,node,s,output,branches,false,otherwise;public,boolean,is,branching,return,get,outgoing,connections,null,get,outgoing,connections,size,1
OptimizerNode -> public boolean isBranching();1431981454;Checks whether this node has branching output. A node's output is branched, if it has more_than one output connection.__@return True, if the node's output branches. False otherwise.;public boolean isBranching() {_		return getOutgoingConnections() != null && getOutgoingConnections().size() > 1__	};checks,whether,this,node,has,branching,output,a,node,s,output,is,branched,if,it,has,more,than,one,output,connection,return,true,if,the,node,s,output,branches,false,otherwise;public,boolean,is,branching,return,get,outgoing,connections,null,get,outgoing,connections,size,1
OptimizerNode -> public boolean isBranching();1442492509;Checks whether this node has branching output. A node's output is branched, if it has more_than one output connection.__@return True, if the node's output branches. False otherwise.;public boolean isBranching() {_		return getOutgoingConnections() != null && getOutgoingConnections().size() > 1__	};checks,whether,this,node,has,branching,output,a,node,s,output,is,branched,if,it,has,more,than,one,output,connection,return,true,if,the,node,s,output,branches,false,otherwise;public,boolean,is,branching,return,get,outgoing,connections,null,get,outgoing,connections,size,1
OptimizerNode -> public boolean isBranching();1446112342;Checks whether this node has branching output. A node's output is branched, if it has more_than one output connection.__@return True, if the node's output branches. False otherwise.;public boolean isBranching() {_		return getOutgoingConnections() != null && getOutgoingConnections().size() > 1__	};checks,whether,this,node,has,branching,output,a,node,s,output,is,branched,if,it,has,more,than,one,output,connection,return,true,if,the,node,s,output,branches,false,otherwise;public,boolean,is,branching,return,get,outgoing,connections,null,get,outgoing,connections,size,1
OptimizerNode -> public boolean isBranching();1460563153;Checks whether this node has branching output. A node's output is branched, if it has more_than one output connection.__@return True, if the node's output branches. False otherwise.;public boolean isBranching() {_		return getOutgoingConnections() != null && getOutgoingConnections().size() > 1__	};checks,whether,this,node,has,branching,output,a,node,s,output,is,branched,if,it,has,more,than,one,output,connection,return,true,if,the,node,s,output,branches,false,otherwise;public,boolean,is,branching,return,get,outgoing,connections,null,get,outgoing,connections,size,1
OptimizerNode -> public boolean isBranching();1546180287;Checks whether this node has branching output. A node's output is branched, if it has more_than one output connection.__@return True, if the node's output branches. False otherwise.;public boolean isBranching() {_		return getOutgoingConnections() != null && getOutgoingConnections().size() > 1__	};checks,whether,this,node,has,branching,output,a,node,s,output,is,branched,if,it,has,more,than,one,output,connection,return,true,if,the,node,s,output,branches,false,otherwise;public,boolean,is,branching,return,get,outgoing,connections,null,get,outgoing,connections,size,1
OptimizerNode -> public abstract String getName()_;1426843274;Gets the name of this node, which is the name of the function/operator, or_data source / data sink.__@return The node name.;public abstract String getName()_;gets,the,name,of,this,node,which,is,the,name,of,the,function,operator,or,data,source,data,sink,return,the,node,name;public,abstract,string,get,name
OptimizerNode -> public abstract String getName()_;1427097830;Gets the name of this node, which is the name of the function/operator, or_data source / data sink.__@return The node name.;public abstract String getName()_;gets,the,name,of,this,node,which,is,the,name,of,the,function,operator,or,data,source,data,sink,return,the,node,name;public,abstract,string,get,name
OptimizerNode -> public abstract String getName()_;1431981454;Gets the name of this node, which is the name of the function/operator, or_data source / data sink.__@return The node name.;public abstract String getName()_;gets,the,name,of,this,node,which,is,the,name,of,the,function,operator,or,data,source,data,sink,return,the,node,name;public,abstract,string,get,name
OptimizerNode -> @Override 	public abstract void accept(Visitor<OptimizerNode> visitor)_;1426843274;This method implements the visit of a depth-first graph traversing visitor. Implementers must first_call the <code>preVisit()</code> method, then hand the visitor to their children, and finally call_the <code>postVisit()</code> method.__@param visitor_The graph traversing visitor._@see org.apache.flink.util.Visitable#accept(org.apache.flink.util.Visitor);@Override_	public abstract void accept(Visitor<OptimizerNode> visitor)_;this,method,implements,the,visit,of,a,depth,first,graph,traversing,visitor,implementers,must,first,call,the,code,pre,visit,code,method,then,hand,the,visitor,to,their,children,and,finally,call,the,code,post,visit,code,method,param,visitor,the,graph,traversing,visitor,see,org,apache,flink,util,visitable,accept,org,apache,flink,util,visitor;override,public,abstract,void,accept,visitor,optimizer,node,visitor
OptimizerNode -> @Override 	public abstract void accept(Visitor<OptimizerNode> visitor)_;1427097830;This method implements the visit of a depth-first graph traversing visitor. Implementers must first_call the <code>preVisit()</code> method, then hand the visitor to their children, and finally call_the <code>postVisit()</code> method.__@param visitor_The graph traversing visitor._@see org.apache.flink.util.Visitable#accept(org.apache.flink.util.Visitor);@Override_	public abstract void accept(Visitor<OptimizerNode> visitor)_;this,method,implements,the,visit,of,a,depth,first,graph,traversing,visitor,implementers,must,first,call,the,code,pre,visit,code,method,then,hand,the,visitor,to,their,children,and,finally,call,the,code,post,visit,code,method,param,visitor,the,graph,traversing,visitor,see,org,apache,flink,util,visitable,accept,org,apache,flink,util,visitor;override,public,abstract,void,accept,visitor,optimizer,node,visitor
OptimizerNode -> @Override 	public abstract void accept(Visitor<OptimizerNode> visitor)_;1431981454;This method implements the visit of a depth-first graph traversing visitor. Implementers must first_call the <code>preVisit()</code> method, then hand the visitor to their children, and finally call_the <code>postVisit()</code> method.__@param visitor_The graph traversing visitor._@see org.apache.flink.util.Visitable#accept(org.apache.flink.util.Visitor);@Override_	public abstract void accept(Visitor<OptimizerNode> visitor)_;this,method,implements,the,visit,of,a,depth,first,graph,traversing,visitor,implementers,must,first,call,the,code,pre,visit,code,method,then,hand,the,visitor,to,their,children,and,finally,call,the,code,post,visit,code,method,param,visitor,the,graph,traversing,visitor,see,org,apache,flink,util,visitable,accept,org,apache,flink,util,visitor;override,public,abstract,void,accept,visitor,optimizer,node,visitor
OptimizerNode -> @Override 	public abstract void accept(Visitor<OptimizerNode> visitor)_;1442492509;This method implements the visit of a depth-first graph traversing visitor. Implementers must first_call the <code>preVisit()</code> method, then hand the visitor to their children, and finally call_the <code>postVisit()</code> method.__@param visitor_The graph traversing visitor._@see org.apache.flink.util.Visitable#accept(org.apache.flink.util.Visitor);@Override_	public abstract void accept(Visitor<OptimizerNode> visitor)_;this,method,implements,the,visit,of,a,depth,first,graph,traversing,visitor,implementers,must,first,call,the,code,pre,visit,code,method,then,hand,the,visitor,to,their,children,and,finally,call,the,code,post,visit,code,method,param,visitor,the,graph,traversing,visitor,see,org,apache,flink,util,visitable,accept,org,apache,flink,util,visitor;override,public,abstract,void,accept,visitor,optimizer,node,visitor
OptimizerNode -> @Override 	public abstract void accept(Visitor<OptimizerNode> visitor)_;1446112342;This method implements the visit of a depth-first graph traversing visitor. Implementers must first_call the <code>preVisit()</code> method, then hand the visitor to their children, and finally call_the <code>postVisit()</code> method.__@param visitor_The graph traversing visitor._@see org.apache.flink.util.Visitable#accept(org.apache.flink.util.Visitor);@Override_	public abstract void accept(Visitor<OptimizerNode> visitor)_;this,method,implements,the,visit,of,a,depth,first,graph,traversing,visitor,implementers,must,first,call,the,code,pre,visit,code,method,then,hand,the,visitor,to,their,children,and,finally,call,the,code,post,visit,code,method,param,visitor,the,graph,traversing,visitor,see,org,apache,flink,util,visitable,accept,org,apache,flink,util,visitor;override,public,abstract,void,accept,visitor,optimizer,node,visitor
OptimizerNode -> @Override 	public abstract void accept(Visitor<OptimizerNode> visitor)_;1460563153;This method implements the visit of a depth-first graph traversing visitor. Implementers must first_call the <code>preVisit()</code> method, then hand the visitor to their children, and finally call_the <code>postVisit()</code> method.__@param visitor_The graph traversing visitor._@see org.apache.flink.util.Visitable#accept(org.apache.flink.util.Visitor);@Override_	public abstract void accept(Visitor<OptimizerNode> visitor)_;this,method,implements,the,visit,of,a,depth,first,graph,traversing,visitor,implementers,must,first,call,the,code,pre,visit,code,method,then,hand,the,visitor,to,their,children,and,finally,call,the,code,post,visit,code,method,param,visitor,the,graph,traversing,visitor,see,org,apache,flink,util,visitable,accept,org,apache,flink,util,visitor;override,public,abstract,void,accept,visitor,optimizer,node,visitor
OptimizerNode -> @Override 	public abstract void accept(Visitor<OptimizerNode> visitor)_;1546180287;This method implements the visit of a depth-first graph traversing visitor. Implementers must first_call the <code>preVisit()</code> method, then hand the visitor to their children, and finally call_the <code>postVisit()</code> method.__@param visitor_The graph traversing visitor._@see org.apache.flink.util.Visitable#accept(org.apache.flink.util.Visitor);@Override_	public abstract void accept(Visitor<OptimizerNode> visitor)_;this,method,implements,the,visit,of,a,depth,first,graph,traversing,visitor,implementers,must,first,call,the,code,pre,visit,code,method,then,hand,the,visitor,to,their,children,and,finally,call,the,code,post,visit,code,method,param,visitor,the,graph,traversing,visitor,see,org,apache,flink,util,visitable,accept,org,apache,flink,util,visitor;override,public,abstract,void,accept,visitor,optimizer,node,visitor
OptimizerNode -> public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode);1426843274;This function connects the operators that produce the broadcast inputs to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.__@throws CompilerException;public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode) {_		_		if (!(getOperator() instanceof AbstractUdfOperator<?, ?>)) {_			return__		}__		_		AbstractUdfOperator<?, ?> operator = ((AbstractUdfOperator<?, ?>) getOperator())___		_		for (Map.Entry<String, Operator<?>> input : operator.getBroadcastInputs().entrySet()) {_			OptimizerNode predecessor = operatorToNode.get(input.getValue())__			DagConnection connection = new DagConnection(predecessor, this,_															ShipStrategyType.BROADCAST, defaultExchangeMode)__			addBroadcastConnection(input.getKey(), connection)__			predecessor.addOutgoingConnection(connection)__		}_	};this,function,connects,the,operators,that,produce,the,broadcast,inputs,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one,throws,compiler,exception;public,void,set,broadcast,inputs,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode,if,get,operator,instanceof,abstract,udf,operator,return,abstract,udf,operator,operator,abstract,udf,operator,get,operator,for,map,entry,string,operator,input,operator,get,broadcast,inputs,entry,set,optimizer,node,predecessor,operator,to,node,get,input,get,value,dag,connection,connection,new,dag,connection,predecessor,this,ship,strategy,type,broadcast,default,exchange,mode,add,broadcast,connection,input,get,key,connection,predecessor,add,outgoing,connection,connection
OptimizerNode -> public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode);1427097830;This function connects the operators that produce the broadcast inputs to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.__@throws CompilerException;public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode) {_		_		if (!(getOperator() instanceof AbstractUdfOperator<?, ?>)) {_			return__		}__		_		AbstractUdfOperator<?, ?> operator = ((AbstractUdfOperator<?, ?>) getOperator())___		_		for (Map.Entry<String, Operator<?>> input : operator.getBroadcastInputs().entrySet()) {_			OptimizerNode predecessor = operatorToNode.get(input.getValue())__			DagConnection connection = new DagConnection(predecessor, this,_															ShipStrategyType.BROADCAST, defaultExchangeMode)__			addBroadcastConnection(input.getKey(), connection)__			predecessor.addOutgoingConnection(connection)__		}_	};this,function,connects,the,operators,that,produce,the,broadcast,inputs,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one,throws,compiler,exception;public,void,set,broadcast,inputs,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode,if,get,operator,instanceof,abstract,udf,operator,return,abstract,udf,operator,operator,abstract,udf,operator,get,operator,for,map,entry,string,operator,input,operator,get,broadcast,inputs,entry,set,optimizer,node,predecessor,operator,to,node,get,input,get,value,dag,connection,connection,new,dag,connection,predecessor,this,ship,strategy,type,broadcast,default,exchange,mode,add,broadcast,connection,input,get,key,connection,predecessor,add,outgoing,connection,connection
OptimizerNode -> public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode);1431981454;This function connects the operators that produce the broadcast inputs to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.__@throws CompilerException;public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode) {_		_		if (!(getOperator() instanceof AbstractUdfOperator<?, ?>)) {_			return__		}__		_		AbstractUdfOperator<?, ?> operator = ((AbstractUdfOperator<?, ?>) getOperator())___		_		for (Map.Entry<String, Operator<?>> input : operator.getBroadcastInputs().entrySet()) {_			OptimizerNode predecessor = operatorToNode.get(input.getValue())__			DagConnection connection = new DagConnection(predecessor, this,_															ShipStrategyType.BROADCAST, defaultExchangeMode)__			addBroadcastConnection(input.getKey(), connection)__			predecessor.addOutgoingConnection(connection)__		}_	};this,function,connects,the,operators,that,produce,the,broadcast,inputs,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one,throws,compiler,exception;public,void,set,broadcast,inputs,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode,if,get,operator,instanceof,abstract,udf,operator,return,abstract,udf,operator,operator,abstract,udf,operator,get,operator,for,map,entry,string,operator,input,operator,get,broadcast,inputs,entry,set,optimizer,node,predecessor,operator,to,node,get,input,get,value,dag,connection,connection,new,dag,connection,predecessor,this,ship,strategy,type,broadcast,default,exchange,mode,add,broadcast,connection,input,get,key,connection,predecessor,add,outgoing,connection,connection
OptimizerNode -> public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode);1442492509;This function connects the operators that produce the broadcast inputs to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.__@throws CompilerException;public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode) {_		_		if (!(getOperator() instanceof AbstractUdfOperator<?, ?>)) {_			return__		}__		_		AbstractUdfOperator<?, ?> operator = ((AbstractUdfOperator<?, ?>) getOperator())___		_		for (Map.Entry<String, Operator<?>> input : operator.getBroadcastInputs().entrySet()) {_			OptimizerNode predecessor = operatorToNode.get(input.getValue())__			DagConnection connection = new DagConnection(predecessor, this,_															ShipStrategyType.BROADCAST, defaultExchangeMode)__			addBroadcastConnection(input.getKey(), connection)__			predecessor.addOutgoingConnection(connection)__		}_	};this,function,connects,the,operators,that,produce,the,broadcast,inputs,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one,throws,compiler,exception;public,void,set,broadcast,inputs,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode,if,get,operator,instanceof,abstract,udf,operator,return,abstract,udf,operator,operator,abstract,udf,operator,get,operator,for,map,entry,string,operator,input,operator,get,broadcast,inputs,entry,set,optimizer,node,predecessor,operator,to,node,get,input,get,value,dag,connection,connection,new,dag,connection,predecessor,this,ship,strategy,type,broadcast,default,exchange,mode,add,broadcast,connection,input,get,key,connection,predecessor,add,outgoing,connection,connection
OptimizerNode -> public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode);1446112342;This function connects the operators that produce the broadcast inputs to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.__@throws CompilerException;public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode) {_		_		if (!(getOperator() instanceof AbstractUdfOperator<?, ?>)) {_			return__		}__		_		AbstractUdfOperator<?, ?> operator = ((AbstractUdfOperator<?, ?>) getOperator())___		_		for (Map.Entry<String, Operator<?>> input : operator.getBroadcastInputs().entrySet()) {_			OptimizerNode predecessor = operatorToNode.get(input.getValue())__			DagConnection connection = new DagConnection(predecessor, this,_															ShipStrategyType.BROADCAST, defaultExchangeMode)__			addBroadcastConnection(input.getKey(), connection)__			predecessor.addOutgoingConnection(connection)__		}_	};this,function,connects,the,operators,that,produce,the,broadcast,inputs,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one,throws,compiler,exception;public,void,set,broadcast,inputs,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode,if,get,operator,instanceof,abstract,udf,operator,return,abstract,udf,operator,operator,abstract,udf,operator,get,operator,for,map,entry,string,operator,input,operator,get,broadcast,inputs,entry,set,optimizer,node,predecessor,operator,to,node,get,input,get,value,dag,connection,connection,new,dag,connection,predecessor,this,ship,strategy,type,broadcast,default,exchange,mode,add,broadcast,connection,input,get,key,connection,predecessor,add,outgoing,connection,connection
OptimizerNode -> public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode);1460563153;This function connects the operators that produce the broadcast inputs to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.__@throws CompilerException;public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode) {_		_		if (!(getOperator() instanceof AbstractUdfOperator<?, ?>)) {_			return__		}__		_		AbstractUdfOperator<?, ?> operator = ((AbstractUdfOperator<?, ?>) getOperator())___		_		for (Map.Entry<String, Operator<?>> input : operator.getBroadcastInputs().entrySet()) {_			OptimizerNode predecessor = operatorToNode.get(input.getValue())__			DagConnection connection = new DagConnection(predecessor, this,_															ShipStrategyType.BROADCAST, defaultExchangeMode)__			addBroadcastConnection(input.getKey(), connection)__			predecessor.addOutgoingConnection(connection)__		}_	};this,function,connects,the,operators,that,produce,the,broadcast,inputs,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one,throws,compiler,exception;public,void,set,broadcast,inputs,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode,if,get,operator,instanceof,abstract,udf,operator,return,abstract,udf,operator,operator,abstract,udf,operator,get,operator,for,map,entry,string,operator,input,operator,get,broadcast,inputs,entry,set,optimizer,node,predecessor,operator,to,node,get,input,get,value,dag,connection,connection,new,dag,connection,predecessor,this,ship,strategy,type,broadcast,default,exchange,mode,add,broadcast,connection,input,get,key,connection,predecessor,add,outgoing,connection,connection
OptimizerNode -> public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode);1546180287;This function connects the operators that produce the broadcast inputs to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.__@throws CompilerException;public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode) {_		_		if (!(getOperator() instanceof AbstractUdfOperator<?, ?>)) {_			return__		}__		_		AbstractUdfOperator<?, ?> operator = ((AbstractUdfOperator<?, ?>) getOperator())___		_		for (Map.Entry<String, Operator<?>> input : operator.getBroadcastInputs().entrySet()) {_			OptimizerNode predecessor = operatorToNode.get(input.getValue())__			DagConnection connection = new DagConnection(predecessor, this,_															ShipStrategyType.BROADCAST, defaultExchangeMode)__			addBroadcastConnection(input.getKey(), connection)__			predecessor.addOutgoingConnection(connection)__		}_	};this,function,connects,the,operators,that,produce,the,broadcast,inputs,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one,throws,compiler,exception;public,void,set,broadcast,inputs,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode,if,get,operator,instanceof,abstract,udf,operator,return,abstract,udf,operator,operator,abstract,udf,operator,get,operator,for,map,entry,string,operator,input,operator,get,broadcast,inputs,entry,set,optimizer,node,predecessor,operator,to,node,get,input,get,value,dag,connection,connection,new,dag,connection,predecessor,this,ship,strategy,type,broadcast,default,exchange,mode,add,broadcast,connection,input,get,key,connection,predecessor,add,outgoing,connection,connection
OptimizerNode -> public void initId(int id);1426843274;Sets the ID of this node.__@param id_The id for this node.;public void initId(int id) {_		if (id <= 0) {_			throw new IllegalArgumentException()__		}_		_		if (this.id == -1) {_			this.id = id__		} else {_			throw new IllegalStateException("Id has already been initialized.")__		}_	};sets,the,id,of,this,node,param,id,the,id,for,this,node;public,void,init,id,int,id,if,id,0,throw,new,illegal,argument,exception,if,this,id,1,this,id,id,else,throw,new,illegal,state,exception,id,has,already,been,initialized
OptimizerNode -> public void initId(int id);1427097830;Sets the ID of this node.__@param id_The id for this node.;public void initId(int id) {_		if (id <= 0) {_			throw new IllegalArgumentException()__		}_		_		if (this.id == -1) {_			this.id = id__		} else {_			throw new IllegalStateException("Id has already been initialized.")__		}_	};sets,the,id,of,this,node,param,id,the,id,for,this,node;public,void,init,id,int,id,if,id,0,throw,new,illegal,argument,exception,if,this,id,1,this,id,id,else,throw,new,illegal,state,exception,id,has,already,been,initialized
OptimizerNode -> public void initId(int id);1431981454;Sets the ID of this node.__@param id_The id for this node.;public void initId(int id) {_		if (id <= 0) {_			throw new IllegalArgumentException()__		}_		_		if (this.id == -1) {_			this.id = id__		} else {_			throw new IllegalStateException("Id has already been initialized.")__		}_	};sets,the,id,of,this,node,param,id,the,id,for,this,node;public,void,init,id,int,id,if,id,0,throw,new,illegal,argument,exception,if,this,id,1,this,id,id,else,throw,new,illegal,state,exception,id,has,already,been,initialized
OptimizerNode -> public void initId(int id);1442492509;Sets the ID of this node.__@param id_The id for this node.;public void initId(int id) {_		if (id <= 0) {_			throw new IllegalArgumentException()__		}_		_		if (this.id == -1) {_			this.id = id__		} else {_			throw new IllegalStateException("Id has already been initialized.")__		}_	};sets,the,id,of,this,node,param,id,the,id,for,this,node;public,void,init,id,int,id,if,id,0,throw,new,illegal,argument,exception,if,this,id,1,this,id,id,else,throw,new,illegal,state,exception,id,has,already,been,initialized
OptimizerNode -> public void initId(int id);1446112342;Sets the ID of this node.__@param id_The id for this node.;public void initId(int id) {_		if (id <= 0) {_			throw new IllegalArgumentException()__		}_		_		if (this.id == -1) {_			this.id = id__		} else {_			throw new IllegalStateException("Id has already been initialized.")__		}_	};sets,the,id,of,this,node,param,id,the,id,for,this,node;public,void,init,id,int,id,if,id,0,throw,new,illegal,argument,exception,if,this,id,1,this,id,id,else,throw,new,illegal,state,exception,id,has,already,been,initialized
OptimizerNode -> public void initId(int id);1460563153;Sets the ID of this node.__@param id_The id for this node.;public void initId(int id) {_		if (id <= 0) {_			throw new IllegalArgumentException()__		}_		_		if (this.id == -1) {_			this.id = id__		} else {_			throw new IllegalStateException("Id has already been initialized.")__		}_	};sets,the,id,of,this,node,param,id,the,id,for,this,node;public,void,init,id,int,id,if,id,0,throw,new,illegal,argument,exception,if,this,id,1,this,id,id,else,throw,new,illegal,state,exception,id,has,already,been,initialized
OptimizerNode -> public void initId(int id);1546180287;Sets the ID of this node.__@param id_The id for this node.;public void initId(int id) {_		if (id <= 0) {_			throw new IllegalArgumentException()__		}_		_		if (this.id == -1) {_			this.id = id__		} else {_			throw new IllegalStateException("Id has already been initialized.")__		}_	};sets,the,id,of,this,node,param,id,the,id,for,this,node;public,void,init,id,int,id,if,id,0,throw,new,illegal,argument,exception,if,this,id,1,this,id,id,else,throw,new,illegal,state,exception,id,has,already,been,initialized
OptimizerNode -> public void setParallelism(int parallelism);1427097830;Sets the parallelism for this optimizer node._The parallelism denotes how many parallel instances of the operator will be_spawned during the execution. If this value is set to <code>-1</code>, then the system will take_the default number of parallel instances.__@param parallelism The parallelism to set._@throws IllegalArgumentException If the parallelism is smaller than one and not -1.;public void setParallelism(int parallelism) {_		if (parallelism < 1 && parallelism != -1) {_			throw new IllegalArgumentException("Parallelism of " + parallelism + " is invalid.")__		}_		this.parallelism = parallelism__	};sets,the,parallelism,for,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,will,be,spawned,during,the,execution,if,this,value,is,set,to,code,1,code,then,the,system,will,take,the,default,number,of,parallel,instances,param,parallelism,the,parallelism,to,set,throws,illegal,argument,exception,if,the,parallelism,is,smaller,than,one,and,not,1;public,void,set,parallelism,int,parallelism,if,parallelism,1,parallelism,1,throw,new,illegal,argument,exception,parallelism,of,parallelism,is,invalid,this,parallelism,parallelism
OptimizerNode -> public void setParallelism(int parallelism);1431981454;Sets the parallelism for this optimizer node._The parallelism denotes how many parallel instances of the operator will be_spawned during the execution. If this value is set to <code>-1</code>, then the system will take_the default number of parallel instances.__@param parallelism The parallelism to set._@throws IllegalArgumentException If the parallelism is smaller than one and not -1.;public void setParallelism(int parallelism) {_		if (parallelism < 1 && parallelism != -1) {_			throw new IllegalArgumentException("Parallelism of " + parallelism + " is invalid.")__		}_		this.parallelism = parallelism__	};sets,the,parallelism,for,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,will,be,spawned,during,the,execution,if,this,value,is,set,to,code,1,code,then,the,system,will,take,the,default,number,of,parallel,instances,param,parallelism,the,parallelism,to,set,throws,illegal,argument,exception,if,the,parallelism,is,smaller,than,one,and,not,1;public,void,set,parallelism,int,parallelism,if,parallelism,1,parallelism,1,throw,new,illegal,argument,exception,parallelism,of,parallelism,is,invalid,this,parallelism,parallelism
OptimizerNode -> public void setParallelism(int parallelism);1442492509;Sets the parallelism for this optimizer node._The parallelism denotes how many parallel instances of the operator will be_spawned during the execution. If this value is set to <code>-1</code>, then the system will take_the default number of parallel instances.__@param parallelism The parallelism to set._@throws IllegalArgumentException If the parallelism is smaller than one and not -1.;public void setParallelism(int parallelism) {_		if (parallelism < 1 && parallelism != -1) {_			throw new IllegalArgumentException("Parallelism of " + parallelism + " is invalid.")__		}_		this.parallelism = parallelism__	};sets,the,parallelism,for,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,will,be,spawned,during,the,execution,if,this,value,is,set,to,code,1,code,then,the,system,will,take,the,default,number,of,parallel,instances,param,parallelism,the,parallelism,to,set,throws,illegal,argument,exception,if,the,parallelism,is,smaller,than,one,and,not,1;public,void,set,parallelism,int,parallelism,if,parallelism,1,parallelism,1,throw,new,illegal,argument,exception,parallelism,of,parallelism,is,invalid,this,parallelism,parallelism
OptimizerNode -> public void setParallelism(int parallelism);1446112342;Sets the parallelism for this optimizer node._The parallelism denotes how many parallel instances of the operator will be_spawned during the execution. If this value is set to <code>-1</code>, then the system will take_the default number of parallel instances.__@param parallelism The parallelism to set._@throws IllegalArgumentException If the parallelism is smaller than one and not -1.;public void setParallelism(int parallelism) {_		if (parallelism < 1 && parallelism != -1) {_			throw new IllegalArgumentException("Parallelism of " + parallelism + " is invalid.")__		}_		this.parallelism = parallelism__	};sets,the,parallelism,for,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,will,be,spawned,during,the,execution,if,this,value,is,set,to,code,1,code,then,the,system,will,take,the,default,number,of,parallel,instances,param,parallelism,the,parallelism,to,set,throws,illegal,argument,exception,if,the,parallelism,is,smaller,than,one,and,not,1;public,void,set,parallelism,int,parallelism,if,parallelism,1,parallelism,1,throw,new,illegal,argument,exception,parallelism,of,parallelism,is,invalid,this,parallelism,parallelism
OptimizerNode -> public void setParallelism(int parallelism);1460563153;Sets the parallelism for this optimizer node._The parallelism denotes how many parallel instances of the operator will be_spawned during the execution.__@param parallelism The parallelism to set. If this value is {@link ExecutionConfig#PARALLELISM_DEFAULT}_then the system will take the default number of parallel instances._@throws IllegalArgumentException If the parallelism is smaller than one.;public void setParallelism(int parallelism) {_		if (parallelism < 1 && parallelism != ExecutionConfig.PARALLELISM_DEFAULT) {_			throw new IllegalArgumentException("Parallelism of " + parallelism + " is invalid.")__		}_		this.parallelism = parallelism__	};sets,the,parallelism,for,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,will,be,spawned,during,the,execution,param,parallelism,the,parallelism,to,set,if,this,value,is,link,execution,config,then,the,system,will,take,the,default,number,of,parallel,instances,throws,illegal,argument,exception,if,the,parallelism,is,smaller,than,one;public,void,set,parallelism,int,parallelism,if,parallelism,1,parallelism,execution,config,throw,new,illegal,argument,exception,parallelism,of,parallelism,is,invalid,this,parallelism,parallelism
OptimizerNode -> public void setParallelism(int parallelism);1546180287;Sets the parallelism for this optimizer node._The parallelism denotes how many parallel instances of the operator will be_spawned during the execution.__@param parallelism The parallelism to set. If this value is {@link ExecutionConfig#PARALLELISM_DEFAULT}_then the system will take the default number of parallel instances._@throws IllegalArgumentException If the parallelism is smaller than one.;public void setParallelism(int parallelism) {_		if (parallelism < 1 && parallelism != ExecutionConfig.PARALLELISM_DEFAULT) {_			throw new IllegalArgumentException("Parallelism of " + parallelism + " is invalid.")__		}_		this.parallelism = parallelism__	};sets,the,parallelism,for,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,will,be,spawned,during,the,execution,param,parallelism,the,parallelism,to,set,if,this,value,is,link,execution,config,then,the,system,will,take,the,default,number,of,parallel,instances,throws,illegal,argument,exception,if,the,parallelism,is,smaller,than,one;public,void,set,parallelism,int,parallelism,if,parallelism,1,parallelism,execution,config,throw,new,illegal,argument,exception,parallelism,of,parallelism,is,invalid,this,parallelism,parallelism
OptimizerNode -> public long getMinimalMemoryAcrossAllSubTasks();1426843274;Gets the amount of memory that all subtasks of this task have jointly available.__@return The total amount of memory across all subtasks.;public long getMinimalMemoryAcrossAllSubTasks() {_		return this.minimalMemoryPerSubTask == -1 ? -1 : this.minimalMemoryPerSubTask * this.parallelism__	};gets,the,amount,of,memory,that,all,subtasks,of,this,task,have,jointly,available,return,the,total,amount,of,memory,across,all,subtasks;public,long,get,minimal,memory,across,all,sub,tasks,return,this,minimal,memory,per,sub,task,1,1,this,minimal,memory,per,sub,task,this,parallelism
OptimizerNode -> public long getMinimalMemoryAcrossAllSubTasks();1427097830;Gets the amount of memory that all subtasks of this task have jointly available.__@return The total amount of memory across all subtasks.;public long getMinimalMemoryAcrossAllSubTasks() {_		return this.minimalMemoryPerSubTask == -1 ? -1 : this.minimalMemoryPerSubTask * this.parallelism__	};gets,the,amount,of,memory,that,all,subtasks,of,this,task,have,jointly,available,return,the,total,amount,of,memory,across,all,subtasks;public,long,get,minimal,memory,across,all,sub,tasks,return,this,minimal,memory,per,sub,task,1,1,this,minimal,memory,per,sub,task,this,parallelism
OptimizerNode -> public long getMinimalMemoryAcrossAllSubTasks();1431981454;Gets the amount of memory that all subtasks of this task have jointly available.__@return The total amount of memory across all subtasks.;public long getMinimalMemoryAcrossAllSubTasks() {_		return this.minimalMemoryPerSubTask == -1 ? -1 : this.minimalMemoryPerSubTask * this.parallelism__	};gets,the,amount,of,memory,that,all,subtasks,of,this,task,have,jointly,available,return,the,total,amount,of,memory,across,all,subtasks;public,long,get,minimal,memory,across,all,sub,tasks,return,this,minimal,memory,per,sub,task,1,1,this,minimal,memory,per,sub,task,this,parallelism
OptimizerNode -> public long getMinimalMemoryAcrossAllSubTasks();1442492509;Gets the amount of memory that all subtasks of this task have jointly available.__@return The total amount of memory across all subtasks.;public long getMinimalMemoryAcrossAllSubTasks() {_		return this.minimalMemoryPerSubTask == -1 ? -1 : this.minimalMemoryPerSubTask * this.parallelism__	};gets,the,amount,of,memory,that,all,subtasks,of,this,task,have,jointly,available,return,the,total,amount,of,memory,across,all,subtasks;public,long,get,minimal,memory,across,all,sub,tasks,return,this,minimal,memory,per,sub,task,1,1,this,minimal,memory,per,sub,task,this,parallelism
OptimizerNode -> public long getMinimalMemoryAcrossAllSubTasks();1446112342;Gets the amount of memory that all subtasks of this task have jointly available.__@return The total amount of memory across all subtasks.;public long getMinimalMemoryAcrossAllSubTasks() {_		return this.minimalMemoryPerSubTask == -1 ? -1 : this.minimalMemoryPerSubTask * this.parallelism__	};gets,the,amount,of,memory,that,all,subtasks,of,this,task,have,jointly,available,return,the,total,amount,of,memory,across,all,subtasks;public,long,get,minimal,memory,across,all,sub,tasks,return,this,minimal,memory,per,sub,task,1,1,this,minimal,memory,per,sub,task,this,parallelism
OptimizerNode -> public long getMinimalMemoryAcrossAllSubTasks();1460563153;Gets the amount of memory that all subtasks of this task have jointly available.__@return The total amount of memory across all subtasks.;public long getMinimalMemoryAcrossAllSubTasks() {_		return this.minimalMemoryPerSubTask == -1 ? -1 : this.minimalMemoryPerSubTask * this.parallelism__	};gets,the,amount,of,memory,that,all,subtasks,of,this,task,have,jointly,available,return,the,total,amount,of,memory,across,all,subtasks;public,long,get,minimal,memory,across,all,sub,tasks,return,this,minimal,memory,per,sub,task,1,1,this,minimal,memory,per,sub,task,this,parallelism
OptimizerNode -> public long getMinimalMemoryAcrossAllSubTasks();1546180287;Gets the amount of memory that all subtasks of this task have jointly available.__@return The total amount of memory across all subtasks.;public long getMinimalMemoryAcrossAllSubTasks() {_		return this.minimalMemoryPerSubTask == -1 ? -1 : this.minimalMemoryPerSubTask * this.parallelism__	};gets,the,amount,of,memory,that,all,subtasks,of,this,task,have,jointly,available,return,the,total,amount,of,memory,across,all,subtasks;public,long,get,minimal,memory,across,all,sub,tasks,return,this,minimal,memory,per,sub,task,1,1,this,minimal,memory,per,sub,task,this,parallelism
OptimizerNode -> public void computeUnionOfInterestingPropertiesFromSuccessors();1426843274;Computes all the interesting properties that are relevant to this node. The interesting_properties are a union of the interesting properties on each outgoing connection._However, if two interesting properties on the outgoing connections overlap,_the interesting properties will occur only once in this set. For that, this_method deduplicates and merges the interesting properties._This method returns copies of the original interesting properties objects and_leaves the original objects, contained by the connections, unchanged.;public void computeUnionOfInterestingPropertiesFromSuccessors() {_		List<DagConnection> conns = getOutgoingConnections()__		if (conns.size() == 0) {_			_			this.intProps = new InterestingProperties()__		} else {_			this.intProps = conns.get(0).getInterestingProperties().clone()__			for (int i = 1_ i < conns.size()_ i++) {_				this.intProps.addInterestingProperties(conns.get(i).getInterestingProperties())__			}_		}_		this.intProps.dropTrivials()__	};computes,all,the,interesting,properties,that,are,relevant,to,this,node,the,interesting,properties,are,a,union,of,the,interesting,properties,on,each,outgoing,connection,however,if,two,interesting,properties,on,the,outgoing,connections,overlap,the,interesting,properties,will,occur,only,once,in,this,set,for,that,this,method,deduplicates,and,merges,the,interesting,properties,this,method,returns,copies,of,the,original,interesting,properties,objects,and,leaves,the,original,objects,contained,by,the,connections,unchanged;public,void,compute,union,of,interesting,properties,from,successors,list,dag,connection,conns,get,outgoing,connections,if,conns,size,0,this,int,props,new,interesting,properties,else,this,int,props,conns,get,0,get,interesting,properties,clone,for,int,i,1,i,conns,size,i,this,int,props,add,interesting,properties,conns,get,i,get,interesting,properties,this,int,props,drop,trivials
OptimizerNode -> public void computeUnionOfInterestingPropertiesFromSuccessors();1427097830;Computes all the interesting properties that are relevant to this node. The interesting_properties are a union of the interesting properties on each outgoing connection._However, if two interesting properties on the outgoing connections overlap,_the interesting properties will occur only once in this set. For that, this_method deduplicates and merges the interesting properties._This method returns copies of the original interesting properties objects and_leaves the original objects, contained by the connections, unchanged.;public void computeUnionOfInterestingPropertiesFromSuccessors() {_		List<DagConnection> conns = getOutgoingConnections()__		if (conns.size() == 0) {_			_			this.intProps = new InterestingProperties()__		} else {_			this.intProps = conns.get(0).getInterestingProperties().clone()__			for (int i = 1_ i < conns.size()_ i++) {_				this.intProps.addInterestingProperties(conns.get(i).getInterestingProperties())__			}_		}_		this.intProps.dropTrivials()__	};computes,all,the,interesting,properties,that,are,relevant,to,this,node,the,interesting,properties,are,a,union,of,the,interesting,properties,on,each,outgoing,connection,however,if,two,interesting,properties,on,the,outgoing,connections,overlap,the,interesting,properties,will,occur,only,once,in,this,set,for,that,this,method,deduplicates,and,merges,the,interesting,properties,this,method,returns,copies,of,the,original,interesting,properties,objects,and,leaves,the,original,objects,contained,by,the,connections,unchanged;public,void,compute,union,of,interesting,properties,from,successors,list,dag,connection,conns,get,outgoing,connections,if,conns,size,0,this,int,props,new,interesting,properties,else,this,int,props,conns,get,0,get,interesting,properties,clone,for,int,i,1,i,conns,size,i,this,int,props,add,interesting,properties,conns,get,i,get,interesting,properties,this,int,props,drop,trivials
OptimizerNode -> public void computeUnionOfInterestingPropertiesFromSuccessors();1431981454;Computes all the interesting properties that are relevant to this node. The interesting_properties are a union of the interesting properties on each outgoing connection._However, if two interesting properties on the outgoing connections overlap,_the interesting properties will occur only once in this set. For that, this_method deduplicates and merges the interesting properties._This method returns copies of the original interesting properties objects and_leaves the original objects, contained by the connections, unchanged.;public void computeUnionOfInterestingPropertiesFromSuccessors() {_		List<DagConnection> conns = getOutgoingConnections()__		if (conns.size() == 0) {_			_			this.intProps = new InterestingProperties()__		} else {_			this.intProps = conns.get(0).getInterestingProperties().clone()__			for (int i = 1_ i < conns.size()_ i++) {_				this.intProps.addInterestingProperties(conns.get(i).getInterestingProperties())__			}_		}_		this.intProps.dropTrivials()__	};computes,all,the,interesting,properties,that,are,relevant,to,this,node,the,interesting,properties,are,a,union,of,the,interesting,properties,on,each,outgoing,connection,however,if,two,interesting,properties,on,the,outgoing,connections,overlap,the,interesting,properties,will,occur,only,once,in,this,set,for,that,this,method,deduplicates,and,merges,the,interesting,properties,this,method,returns,copies,of,the,original,interesting,properties,objects,and,leaves,the,original,objects,contained,by,the,connections,unchanged;public,void,compute,union,of,interesting,properties,from,successors,list,dag,connection,conns,get,outgoing,connections,if,conns,size,0,this,int,props,new,interesting,properties,else,this,int,props,conns,get,0,get,interesting,properties,clone,for,int,i,1,i,conns,size,i,this,int,props,add,interesting,properties,conns,get,i,get,interesting,properties,this,int,props,drop,trivials
OptimizerNode -> public void computeUnionOfInterestingPropertiesFromSuccessors();1442492509;Computes all the interesting properties that are relevant to this node. The interesting_properties are a union of the interesting properties on each outgoing connection._However, if two interesting properties on the outgoing connections overlap,_the interesting properties will occur only once in this set. For that, this_method deduplicates and merges the interesting properties._This method returns copies of the original interesting properties objects and_leaves the original objects, contained by the connections, unchanged.;public void computeUnionOfInterestingPropertiesFromSuccessors() {_		List<DagConnection> conns = getOutgoingConnections()__		if (conns.size() == 0) {_			_			this.intProps = new InterestingProperties()__		} else {_			this.intProps = conns.get(0).getInterestingProperties().clone()__			for (int i = 1_ i < conns.size()_ i++) {_				this.intProps.addInterestingProperties(conns.get(i).getInterestingProperties())__			}_		}_		this.intProps.dropTrivials()__	};computes,all,the,interesting,properties,that,are,relevant,to,this,node,the,interesting,properties,are,a,union,of,the,interesting,properties,on,each,outgoing,connection,however,if,two,interesting,properties,on,the,outgoing,connections,overlap,the,interesting,properties,will,occur,only,once,in,this,set,for,that,this,method,deduplicates,and,merges,the,interesting,properties,this,method,returns,copies,of,the,original,interesting,properties,objects,and,leaves,the,original,objects,contained,by,the,connections,unchanged;public,void,compute,union,of,interesting,properties,from,successors,list,dag,connection,conns,get,outgoing,connections,if,conns,size,0,this,int,props,new,interesting,properties,else,this,int,props,conns,get,0,get,interesting,properties,clone,for,int,i,1,i,conns,size,i,this,int,props,add,interesting,properties,conns,get,i,get,interesting,properties,this,int,props,drop,trivials
OptimizerNode -> public void computeUnionOfInterestingPropertiesFromSuccessors();1446112342;Computes all the interesting properties that are relevant to this node. The interesting_properties are a union of the interesting properties on each outgoing connection._However, if two interesting properties on the outgoing connections overlap,_the interesting properties will occur only once in this set. For that, this_method deduplicates and merges the interesting properties._This method returns copies of the original interesting properties objects and_leaves the original objects, contained by the connections, unchanged.;public void computeUnionOfInterestingPropertiesFromSuccessors() {_		List<DagConnection> conns = getOutgoingConnections()__		if (conns.size() == 0) {_			_			this.intProps = new InterestingProperties()__		} else {_			this.intProps = conns.get(0).getInterestingProperties().clone()__			for (int i = 1_ i < conns.size()_ i++) {_				this.intProps.addInterestingProperties(conns.get(i).getInterestingProperties())__			}_		}_		this.intProps.dropTrivials()__	};computes,all,the,interesting,properties,that,are,relevant,to,this,node,the,interesting,properties,are,a,union,of,the,interesting,properties,on,each,outgoing,connection,however,if,two,interesting,properties,on,the,outgoing,connections,overlap,the,interesting,properties,will,occur,only,once,in,this,set,for,that,this,method,deduplicates,and,merges,the,interesting,properties,this,method,returns,copies,of,the,original,interesting,properties,objects,and,leaves,the,original,objects,contained,by,the,connections,unchanged;public,void,compute,union,of,interesting,properties,from,successors,list,dag,connection,conns,get,outgoing,connections,if,conns,size,0,this,int,props,new,interesting,properties,else,this,int,props,conns,get,0,get,interesting,properties,clone,for,int,i,1,i,conns,size,i,this,int,props,add,interesting,properties,conns,get,i,get,interesting,properties,this,int,props,drop,trivials
OptimizerNode -> public void computeUnionOfInterestingPropertiesFromSuccessors();1460563153;Computes all the interesting properties that are relevant to this node. The interesting_properties are a union of the interesting properties on each outgoing connection._However, if two interesting properties on the outgoing connections overlap,_the interesting properties will occur only once in this set. For that, this_method deduplicates and merges the interesting properties._This method returns copies of the original interesting properties objects and_leaves the original objects, contained by the connections, unchanged.;public void computeUnionOfInterestingPropertiesFromSuccessors() {_		List<DagConnection> conns = getOutgoingConnections()__		if (conns.size() == 0) {_			_			this.intProps = new InterestingProperties()__		} else {_			this.intProps = conns.get(0).getInterestingProperties().clone()__			for (int i = 1_ i < conns.size()_ i++) {_				this.intProps.addInterestingProperties(conns.get(i).getInterestingProperties())__			}_		}_		this.intProps.dropTrivials()__	};computes,all,the,interesting,properties,that,are,relevant,to,this,node,the,interesting,properties,are,a,union,of,the,interesting,properties,on,each,outgoing,connection,however,if,two,interesting,properties,on,the,outgoing,connections,overlap,the,interesting,properties,will,occur,only,once,in,this,set,for,that,this,method,deduplicates,and,merges,the,interesting,properties,this,method,returns,copies,of,the,original,interesting,properties,objects,and,leaves,the,original,objects,contained,by,the,connections,unchanged;public,void,compute,union,of,interesting,properties,from,successors,list,dag,connection,conns,get,outgoing,connections,if,conns,size,0,this,int,props,new,interesting,properties,else,this,int,props,conns,get,0,get,interesting,properties,clone,for,int,i,1,i,conns,size,i,this,int,props,add,interesting,properties,conns,get,i,get,interesting,properties,this,int,props,drop,trivials
OptimizerNode -> public void computeUnionOfInterestingPropertiesFromSuccessors();1546180287;Computes all the interesting properties that are relevant to this node. The interesting_properties are a union of the interesting properties on each outgoing connection._However, if two interesting properties on the outgoing connections overlap,_the interesting properties will occur only once in this set. For that, this_method deduplicates and merges the interesting properties._This method returns copies of the original interesting properties objects and_leaves the original objects, contained by the connections, unchanged.;public void computeUnionOfInterestingPropertiesFromSuccessors() {_		List<DagConnection> conns = getOutgoingConnections()__		if (conns.size() == 0) {_			_			this.intProps = new InterestingProperties()__		} else {_			this.intProps = conns.get(0).getInterestingProperties().clone()__			for (int i = 1_ i < conns.size()_ i++) {_				this.intProps.addInterestingProperties(conns.get(i).getInterestingProperties())__			}_		}_		this.intProps.dropTrivials()__	};computes,all,the,interesting,properties,that,are,relevant,to,this,node,the,interesting,properties,are,a,union,of,the,interesting,properties,on,each,outgoing,connection,however,if,two,interesting,properties,on,the,outgoing,connections,overlap,the,interesting,properties,will,occur,only,once,in,this,set,for,that,this,method,deduplicates,and,merges,the,interesting,properties,this,method,returns,copies,of,the,original,interesting,properties,objects,and,leaves,the,original,objects,contained,by,the,connections,unchanged;public,void,compute,union,of,interesting,properties,from,successors,list,dag,connection,conns,get,outgoing,connections,if,conns,size,0,this,int,props,new,interesting,properties,else,this,int,props,conns,get,0,get,interesting,properties,clone,for,int,i,1,i,conns,size,i,this,int,props,add,interesting,properties,conns,get,i,get,interesting,properties,this,int,props,drop,trivials
OptimizerNode -> public abstract List<DagConnection> getIncomingConnections()_;1426843274;Gets all incoming connections of this node._This method needs to be overridden by subclasses to return the children.__@return The list of incoming connections.;public abstract List<DagConnection> getIncomingConnections()_;gets,all,incoming,connections,of,this,node,this,method,needs,to,be,overridden,by,subclasses,to,return,the,children,return,the,list,of,incoming,connections;public,abstract,list,dag,connection,get,incoming,connections
OptimizerNode -> public abstract List<DagConnection> getIncomingConnections()_;1427097830;Gets all incoming connections of this node._This method needs to be overridden by subclasses to return the children.__@return The list of incoming connections.;public abstract List<DagConnection> getIncomingConnections()_;gets,all,incoming,connections,of,this,node,this,method,needs,to,be,overridden,by,subclasses,to,return,the,children,return,the,list,of,incoming,connections;public,abstract,list,dag,connection,get,incoming,connections
OptimizerNode -> public abstract List<DagConnection> getIncomingConnections()_;1431981454;Gets all incoming connections of this node._This method needs to be overridden by subclasses to return the children.__@return The list of incoming connections.;public abstract List<DagConnection> getIncomingConnections()_;gets,all,incoming,connections,of,this,node,this,method,needs,to,be,overridden,by,subclasses,to,return,the,children,return,the,list,of,incoming,connections;public,abstract,list,dag,connection,get,incoming,connections
OptimizerNode -> public abstract List<DagConnection> getIncomingConnections()_;1442492509;Gets all incoming connections of this node._This method needs to be overridden by subclasses to return the children.__@return The list of incoming connections.;public abstract List<DagConnection> getIncomingConnections()_;gets,all,incoming,connections,of,this,node,this,method,needs,to,be,overridden,by,subclasses,to,return,the,children,return,the,list,of,incoming,connections;public,abstract,list,dag,connection,get,incoming,connections
OptimizerNode -> public abstract List<DagConnection> getIncomingConnections()_;1446112342;Gets all incoming connections of this node._This method needs to be overridden by subclasses to return the children.__@return The list of incoming connections.;public abstract List<DagConnection> getIncomingConnections()_;gets,all,incoming,connections,of,this,node,this,method,needs,to,be,overridden,by,subclasses,to,return,the,children,return,the,list,of,incoming,connections;public,abstract,list,dag,connection,get,incoming,connections
OptimizerNode -> public abstract List<DagConnection> getIncomingConnections()_;1460563153;Gets all incoming connections of this node._This method needs to be overridden by subclasses to return the children.__@return The list of incoming connections.;public abstract List<DagConnection> getIncomingConnections()_;gets,all,incoming,connections,of,this,node,this,method,needs,to,be,overridden,by,subclasses,to,return,the,children,return,the,list,of,incoming,connections;public,abstract,list,dag,connection,get,incoming,connections
OptimizerNode -> public abstract List<DagConnection> getIncomingConnections()_;1546180287;Gets all incoming connections of this node._This method needs to be overridden by subclasses to return the children.__@return The list of incoming connections.;public abstract List<DagConnection> getIncomingConnections()_;gets,all,incoming,connections,of,this,node,this,method,needs,to,be,overridden,by,subclasses,to,return,the,children,return,the,list,of,incoming,connections;public,abstract,list,dag,connection,get,incoming,connections
OptimizerNode -> public List<String> getBroadcastConnectionNames();1426843274;Return the list of names associated with broadcast inputs for this node.;public List<String> getBroadcastConnectionNames() {_		return this.broadcastConnectionNames__	};return,the,list,of,names,associated,with,broadcast,inputs,for,this,node;public,list,string,get,broadcast,connection,names,return,this,broadcast,connection,names
OptimizerNode -> public List<String> getBroadcastConnectionNames();1427097830;Return the list of names associated with broadcast inputs for this node.;public List<String> getBroadcastConnectionNames() {_		return this.broadcastConnectionNames__	};return,the,list,of,names,associated,with,broadcast,inputs,for,this,node;public,list,string,get,broadcast,connection,names,return,this,broadcast,connection,names
OptimizerNode -> public List<String> getBroadcastConnectionNames();1431981454;Return the list of names associated with broadcast inputs for this node.;public List<String> getBroadcastConnectionNames() {_		return this.broadcastConnectionNames__	};return,the,list,of,names,associated,with,broadcast,inputs,for,this,node;public,list,string,get,broadcast,connection,names,return,this,broadcast,connection,names
OptimizerNode -> public List<String> getBroadcastConnectionNames();1442492509;Return the list of names associated with broadcast inputs for this node.;public List<String> getBroadcastConnectionNames() {_		return this.broadcastConnectionNames__	};return,the,list,of,names,associated,with,broadcast,inputs,for,this,node;public,list,string,get,broadcast,connection,names,return,this,broadcast,connection,names
OptimizerNode -> public List<String> getBroadcastConnectionNames();1446112342;Return the list of names associated with broadcast inputs for this node.;public List<String> getBroadcastConnectionNames() {_		return this.broadcastConnectionNames__	};return,the,list,of,names,associated,with,broadcast,inputs,for,this,node;public,list,string,get,broadcast,connection,names,return,this,broadcast,connection,names
OptimizerNode -> public List<String> getBroadcastConnectionNames();1460563153;Return the list of names associated with broadcast inputs for this node.;public List<String> getBroadcastConnectionNames() {_		return this.broadcastConnectionNames__	};return,the,list,of,names,associated,with,broadcast,inputs,for,this,node;public,list,string,get,broadcast,connection,names,return,this,broadcast,connection,names
OptimizerNode -> public List<String> getBroadcastConnectionNames();1546180287;Return the list of names associated with broadcast inputs for this node.;public List<String> getBroadcastConnectionNames() {_		return this.broadcastConnectionNames__	};return,the,list,of,names,associated,with,broadcast,inputs,for,this,node;public,list,string,get,broadcast,connection,names,return,this,broadcast,connection,names
OptimizerNode -> public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;1426843274;Tells the node to compute the interesting properties for its inputs. The interesting properties_for the node itself must have been computed before._The node must then see how many of interesting properties it preserves and add its own.__@param estimator The {@code CostEstimator} instance to use for plan cost estimation.;public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;tells,the,node,to,compute,the,interesting,properties,for,its,inputs,the,interesting,properties,for,the,node,itself,must,have,been,computed,before,the,node,must,then,see,how,many,of,interesting,properties,it,preserves,and,add,its,own,param,estimator,the,code,cost,estimator,instance,to,use,for,plan,cost,estimation;public,abstract,void,compute,interesting,properties,for,inputs,cost,estimator,estimator
OptimizerNode -> public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;1427097830;Tells the node to compute the interesting properties for its inputs. The interesting properties_for the node itself must have been computed before._The node must then see how many of interesting properties it preserves and add its own.__@param estimator The {@code CostEstimator} instance to use for plan cost estimation.;public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;tells,the,node,to,compute,the,interesting,properties,for,its,inputs,the,interesting,properties,for,the,node,itself,must,have,been,computed,before,the,node,must,then,see,how,many,of,interesting,properties,it,preserves,and,add,its,own,param,estimator,the,code,cost,estimator,instance,to,use,for,plan,cost,estimation;public,abstract,void,compute,interesting,properties,for,inputs,cost,estimator,estimator
OptimizerNode -> public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;1431981454;Tells the node to compute the interesting properties for its inputs. The interesting properties_for the node itself must have been computed before._The node must then see how many of interesting properties it preserves and add its own.__@param estimator The {@code CostEstimator} instance to use for plan cost estimation.;public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;tells,the,node,to,compute,the,interesting,properties,for,its,inputs,the,interesting,properties,for,the,node,itself,must,have,been,computed,before,the,node,must,then,see,how,many,of,interesting,properties,it,preserves,and,add,its,own,param,estimator,the,code,cost,estimator,instance,to,use,for,plan,cost,estimation;public,abstract,void,compute,interesting,properties,for,inputs,cost,estimator,estimator
OptimizerNode -> public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;1442492509;Tells the node to compute the interesting properties for its inputs. The interesting properties_for the node itself must have been computed before._The node must then see how many of interesting properties it preserves and add its own.__@param estimator The {@code CostEstimator} instance to use for plan cost estimation.;public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;tells,the,node,to,compute,the,interesting,properties,for,its,inputs,the,interesting,properties,for,the,node,itself,must,have,been,computed,before,the,node,must,then,see,how,many,of,interesting,properties,it,preserves,and,add,its,own,param,estimator,the,code,cost,estimator,instance,to,use,for,plan,cost,estimation;public,abstract,void,compute,interesting,properties,for,inputs,cost,estimator,estimator
OptimizerNode -> public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;1446112342;Tells the node to compute the interesting properties for its inputs. The interesting properties_for the node itself must have been computed before._The node must then see how many of interesting properties it preserves and add its own.__@param estimator The {@code CostEstimator} instance to use for plan cost estimation.;public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;tells,the,node,to,compute,the,interesting,properties,for,its,inputs,the,interesting,properties,for,the,node,itself,must,have,been,computed,before,the,node,must,then,see,how,many,of,interesting,properties,it,preserves,and,add,its,own,param,estimator,the,code,cost,estimator,instance,to,use,for,plan,cost,estimation;public,abstract,void,compute,interesting,properties,for,inputs,cost,estimator,estimator
OptimizerNode -> public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;1460563153;Tells the node to compute the interesting properties for its inputs. The interesting properties_for the node itself must have been computed before._The node must then see how many of interesting properties it preserves and add its own.__@param estimator The {@code CostEstimator} instance to use for plan cost estimation.;public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;tells,the,node,to,compute,the,interesting,properties,for,its,inputs,the,interesting,properties,for,the,node,itself,must,have,been,computed,before,the,node,must,then,see,how,many,of,interesting,properties,it,preserves,and,add,its,own,param,estimator,the,code,cost,estimator,instance,to,use,for,plan,cost,estimation;public,abstract,void,compute,interesting,properties,for,inputs,cost,estimator,estimator
OptimizerNode -> public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;1546180287;Tells the node to compute the interesting properties for its inputs. The interesting properties_for the node itself must have been computed before._The node must then see how many of interesting properties it preserves and add its own.__@param estimator The {@code CostEstimator} instance to use for plan cost estimation.;public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator)_;tells,the,node,to,compute,the,interesting,properties,for,its,inputs,the,interesting,properties,for,the,node,itself,must,have,been,computed,before,the,node,must,then,see,how,many,of,interesting,properties,it,preserves,and,add,its,own,param,estimator,the,code,cost,estimator,instance,to,use,for,plan,cost,estimation;public,abstract,void,compute,interesting,properties,for,inputs,cost,estimator,estimator
OptimizerNode -> public OptimizerNode(Operator<?> op);1426843274;Creates a new optimizer node that represents the given program operator.__@param op The operator that the node represents.;public OptimizerNode(Operator<?> op) {_		this.operator = op__		readStubAnnotations()__	};creates,a,new,optimizer,node,that,represents,the,given,program,operator,param,op,the,operator,that,the,node,represents;public,optimizer,node,operator,op,this,operator,op,read,stub,annotations
OptimizerNode -> public OptimizerNode(Operator<?> op);1427097830;Creates a new optimizer node that represents the given program operator.__@param op The operator that the node represents.;public OptimizerNode(Operator<?> op) {_		this.operator = op__		readStubAnnotations()__	};creates,a,new,optimizer,node,that,represents,the,given,program,operator,param,op,the,operator,that,the,node,represents;public,optimizer,node,operator,op,this,operator,op,read,stub,annotations
OptimizerNode -> public OptimizerNode(Operator<?> op);1431981454;Creates a new optimizer node that represents the given program operator.__@param op The operator that the node represents.;public OptimizerNode(Operator<?> op) {_		this.operator = op__		readStubAnnotations()__	};creates,a,new,optimizer,node,that,represents,the,given,program,operator,param,op,the,operator,that,the,node,represents;public,optimizer,node,operator,op,this,operator,op,read,stub,annotations
OptimizerNode -> public OptimizerNode(Operator<?> op);1442492509;Creates a new optimizer node that represents the given program operator.__@param op The operator that the node represents.;public OptimizerNode(Operator<?> op) {_		this.operator = op__		readStubAnnotations()__	};creates,a,new,optimizer,node,that,represents,the,given,program,operator,param,op,the,operator,that,the,node,represents;public,optimizer,node,operator,op,this,operator,op,read,stub,annotations
OptimizerNode -> public OptimizerNode(Operator<?> op);1446112342;Creates a new optimizer node that represents the given program operator.__@param op The operator that the node represents.;public OptimizerNode(Operator<?> op) {_		this.operator = op__		readStubAnnotations()__	};creates,a,new,optimizer,node,that,represents,the,given,program,operator,param,op,the,operator,that,the,node,represents;public,optimizer,node,operator,op,this,operator,op,read,stub,annotations
OptimizerNode -> public OptimizerNode(Operator<?> op);1460563153;Creates a new optimizer node that represents the given program operator.__@param op The operator that the node represents.;public OptimizerNode(Operator<?> op) {_		this.operator = op__		readStubAnnotations()__	};creates,a,new,optimizer,node,that,represents,the,given,program,operator,param,op,the,operator,that,the,node,represents;public,optimizer,node,operator,op,this,operator,op,read,stub,annotations
OptimizerNode -> public OptimizerNode(Operator<?> op);1546180287;Creates a new optimizer node that represents the given program operator.__@param op The operator that the node represents.;public OptimizerNode(Operator<?> op) {_		this.operator = op__		readStubAnnotations()__	};creates,a,new,optimizer,node,that,represents,the,given,program,operator,param,op,the,operator,that,the,node,represents;public,optimizer,node,operator,op,this,operator,op,read,stub,annotations
OptimizerNode -> public boolean haveAllOutputConnectionInterestingProperties();1426843274;Checks, if all outgoing connections have their interesting properties set from their target nodes.__@return True, if on all outgoing connections, the interesting properties are set. False otherwise.;public boolean haveAllOutputConnectionInterestingProperties() {_		for (DagConnection conn : getOutgoingConnections()) {_			if (conn.getInterestingProperties() == null) {_				return false__			}_		}_		return true__	};checks,if,all,outgoing,connections,have,their,interesting,properties,set,from,their,target,nodes,return,true,if,on,all,outgoing,connections,the,interesting,properties,are,set,false,otherwise;public,boolean,have,all,output,connection,interesting,properties,for,dag,connection,conn,get,outgoing,connections,if,conn,get,interesting,properties,null,return,false,return,true
OptimizerNode -> public boolean haveAllOutputConnectionInterestingProperties();1427097830;Checks, if all outgoing connections have their interesting properties set from their target nodes.__@return True, if on all outgoing connections, the interesting properties are set. False otherwise.;public boolean haveAllOutputConnectionInterestingProperties() {_		for (DagConnection conn : getOutgoingConnections()) {_			if (conn.getInterestingProperties() == null) {_				return false__			}_		}_		return true__	};checks,if,all,outgoing,connections,have,their,interesting,properties,set,from,their,target,nodes,return,true,if,on,all,outgoing,connections,the,interesting,properties,are,set,false,otherwise;public,boolean,have,all,output,connection,interesting,properties,for,dag,connection,conn,get,outgoing,connections,if,conn,get,interesting,properties,null,return,false,return,true
OptimizerNode -> public boolean haveAllOutputConnectionInterestingProperties();1431981454;Checks, if all outgoing connections have their interesting properties set from their target nodes.__@return True, if on all outgoing connections, the interesting properties are set. False otherwise.;public boolean haveAllOutputConnectionInterestingProperties() {_		for (DagConnection conn : getOutgoingConnections()) {_			if (conn.getInterestingProperties() == null) {_				return false__			}_		}_		return true__	};checks,if,all,outgoing,connections,have,their,interesting,properties,set,from,their,target,nodes,return,true,if,on,all,outgoing,connections,the,interesting,properties,are,set,false,otherwise;public,boolean,have,all,output,connection,interesting,properties,for,dag,connection,conn,get,outgoing,connections,if,conn,get,interesting,properties,null,return,false,return,true
OptimizerNode -> public boolean haveAllOutputConnectionInterestingProperties();1442492509;Checks, if all outgoing connections have their interesting properties set from their target nodes.__@return True, if on all outgoing connections, the interesting properties are set. False otherwise.;public boolean haveAllOutputConnectionInterestingProperties() {_		for (DagConnection conn : getOutgoingConnections()) {_			if (conn.getInterestingProperties() == null) {_				return false__			}_		}_		return true__	};checks,if,all,outgoing,connections,have,their,interesting,properties,set,from,their,target,nodes,return,true,if,on,all,outgoing,connections,the,interesting,properties,are,set,false,otherwise;public,boolean,have,all,output,connection,interesting,properties,for,dag,connection,conn,get,outgoing,connections,if,conn,get,interesting,properties,null,return,false,return,true
OptimizerNode -> public boolean haveAllOutputConnectionInterestingProperties();1446112342;Checks, if all outgoing connections have their interesting properties set from their target nodes.__@return True, if on all outgoing connections, the interesting properties are set. False otherwise.;public boolean haveAllOutputConnectionInterestingProperties() {_		for (DagConnection conn : getOutgoingConnections()) {_			if (conn.getInterestingProperties() == null) {_				return false__			}_		}_		return true__	};checks,if,all,outgoing,connections,have,their,interesting,properties,set,from,their,target,nodes,return,true,if,on,all,outgoing,connections,the,interesting,properties,are,set,false,otherwise;public,boolean,have,all,output,connection,interesting,properties,for,dag,connection,conn,get,outgoing,connections,if,conn,get,interesting,properties,null,return,false,return,true
OptimizerNode -> public boolean haveAllOutputConnectionInterestingProperties();1460563153;Checks, if all outgoing connections have their interesting properties set from their target nodes.__@return True, if on all outgoing connections, the interesting properties are set. False otherwise.;public boolean haveAllOutputConnectionInterestingProperties() {_		for (DagConnection conn : getOutgoingConnections()) {_			if (conn.getInterestingProperties() == null) {_				return false__			}_		}_		return true__	};checks,if,all,outgoing,connections,have,their,interesting,properties,set,from,their,target,nodes,return,true,if,on,all,outgoing,connections,the,interesting,properties,are,set,false,otherwise;public,boolean,have,all,output,connection,interesting,properties,for,dag,connection,conn,get,outgoing,connections,if,conn,get,interesting,properties,null,return,false,return,true
OptimizerNode -> public boolean haveAllOutputConnectionInterestingProperties();1546180287;Checks, if all outgoing connections have their interesting properties set from their target nodes.__@return True, if on all outgoing connections, the interesting properties are set. False otherwise.;public boolean haveAllOutputConnectionInterestingProperties() {_		for (DagConnection conn : getOutgoingConnections()) {_			if (conn.getInterestingProperties() == null) {_				return false__			}_		}_		return true__	};checks,if,all,outgoing,connections,have,their,interesting,properties,set,from,their,target,nodes,return,true,if,on,all,outgoing,connections,the,interesting,properties,are,set,false,otherwise;public,boolean,have,all,output,connection,interesting,properties,for,dag,connection,conn,get,outgoing,connections,if,conn,get,interesting,properties,null,return,false,return,true
OptimizerNode -> public List<DagConnection> getBroadcastConnections();1426843274;Return the list of inputs associated with broadcast variables for this node.;public List<DagConnection> getBroadcastConnections() {_		return this.broadcastConnections__	};return,the,list,of,inputs,associated,with,broadcast,variables,for,this,node;public,list,dag,connection,get,broadcast,connections,return,this,broadcast,connections
OptimizerNode -> public List<DagConnection> getBroadcastConnections();1427097830;Return the list of inputs associated with broadcast variables for this node.;public List<DagConnection> getBroadcastConnections() {_		return this.broadcastConnections__	};return,the,list,of,inputs,associated,with,broadcast,variables,for,this,node;public,list,dag,connection,get,broadcast,connections,return,this,broadcast,connections
OptimizerNode -> public List<DagConnection> getBroadcastConnections();1431981454;Return the list of inputs associated with broadcast variables for this node.;public List<DagConnection> getBroadcastConnections() {_		return this.broadcastConnections__	};return,the,list,of,inputs,associated,with,broadcast,variables,for,this,node;public,list,dag,connection,get,broadcast,connections,return,this,broadcast,connections
OptimizerNode -> public List<DagConnection> getBroadcastConnections();1442492509;Return the list of inputs associated with broadcast variables for this node.;public List<DagConnection> getBroadcastConnections() {_		return this.broadcastConnections__	};return,the,list,of,inputs,associated,with,broadcast,variables,for,this,node;public,list,dag,connection,get,broadcast,connections,return,this,broadcast,connections
OptimizerNode -> public List<DagConnection> getBroadcastConnections();1446112342;Return the list of inputs associated with broadcast variables for this node.;public List<DagConnection> getBroadcastConnections() {_		return this.broadcastConnections__	};return,the,list,of,inputs,associated,with,broadcast,variables,for,this,node;public,list,dag,connection,get,broadcast,connections,return,this,broadcast,connections
OptimizerNode -> public List<DagConnection> getBroadcastConnections();1460563153;Return the list of inputs associated with broadcast variables for this node.;public List<DagConnection> getBroadcastConnections() {_		return this.broadcastConnections__	};return,the,list,of,inputs,associated,with,broadcast,variables,for,this,node;public,list,dag,connection,get,broadcast,connections,return,this,broadcast,connections
OptimizerNode -> public List<DagConnection> getBroadcastConnections();1546180287;Return the list of inputs associated with broadcast variables for this node.;public List<DagConnection> getBroadcastConnections() {_		return this.broadcastConnections__	};return,the,list,of,inputs,associated,with,broadcast,variables,for,this,node;public,list,dag,connection,get,broadcast,connections,return,this,broadcast,connections
OptimizerNode -> protected void readStubAnnotations();1426843274;Reads all stub annotations, i.e. which fields remain constant, what cardinality bounds the_functions have, which fields remain unique.;protected void readStubAnnotations() {_		readUniqueFieldsAnnotation()__	};reads,all,stub,annotations,i,e,which,fields,remain,constant,what,cardinality,bounds,the,functions,have,which,fields,remain,unique;protected,void,read,stub,annotations,read,unique,fields,annotation
OptimizerNode -> protected void readStubAnnotations();1427097830;Reads all stub annotations, i.e. which fields remain constant, what cardinality bounds the_functions have, which fields remain unique.;protected void readStubAnnotations() {_		readUniqueFieldsAnnotation()__	};reads,all,stub,annotations,i,e,which,fields,remain,constant,what,cardinality,bounds,the,functions,have,which,fields,remain,unique;protected,void,read,stub,annotations,read,unique,fields,annotation
OptimizerNode -> protected void readStubAnnotations();1431981454;Reads all stub annotations, i.e. which fields remain constant, what cardinality bounds the_functions have, which fields remain unique.;protected void readStubAnnotations() {_		readUniqueFieldsAnnotation()__	};reads,all,stub,annotations,i,e,which,fields,remain,constant,what,cardinality,bounds,the,functions,have,which,fields,remain,unique;protected,void,read,stub,annotations,read,unique,fields,annotation
OptimizerNode -> protected void readStubAnnotations();1442492509;Reads all stub annotations, i.e. which fields remain constant, what cardinality bounds the_functions have, which fields remain unique.;protected void readStubAnnotations() {_		readUniqueFieldsAnnotation()__	};reads,all,stub,annotations,i,e,which,fields,remain,constant,what,cardinality,bounds,the,functions,have,which,fields,remain,unique;protected,void,read,stub,annotations,read,unique,fields,annotation
OptimizerNode -> protected void readStubAnnotations();1446112342;Reads all stub annotations, i.e. which fields remain constant, what cardinality bounds the_functions have, which fields remain unique.;protected void readStubAnnotations() {_		readUniqueFieldsAnnotation()__	};reads,all,stub,annotations,i,e,which,fields,remain,constant,what,cardinality,bounds,the,functions,have,which,fields,remain,unique;protected,void,read,stub,annotations,read,unique,fields,annotation
OptimizerNode -> protected void readStubAnnotations();1460563153;Reads all stub annotations, i.e. which fields remain constant, what cardinality bounds the_functions have, which fields remain unique.;protected void readStubAnnotations() {_		readUniqueFieldsAnnotation()__	};reads,all,stub,annotations,i,e,which,fields,remain,constant,what,cardinality,bounds,the,functions,have,which,fields,remain,unique;protected,void,read,stub,annotations,read,unique,fields,annotation
OptimizerNode -> protected void readStubAnnotations();1546180287;Reads all stub annotations, i.e. which fields remain constant, what cardinality bounds the_functions have, which fields remain unique.;protected void readStubAnnotations() {_		readUniqueFieldsAnnotation()__	};reads,all,stub,annotations,i,e,which,fields,remain,constant,what,cardinality,bounds,the,functions,have,which,fields,remain,unique;protected,void,read,stub,annotations,read,unique,fields,annotation
OptimizerNode -> public void addOutgoingConnection(DagConnection connection);1426843274;Adds a new outgoing connection to this node.__@param connection_The connection to add.;public void addOutgoingConnection(DagConnection connection) {_		if (this.outgoingConnections == null) {_			this.outgoingConnections = new ArrayList<DagConnection>()__		} else {_			if (this.outgoingConnections.size() == 64) {_				throw new CompilerException("Cannot currently handle nodes with more than 64 outputs.")__			}_		}__		this.outgoingConnections.add(connection)__	};adds,a,new,outgoing,connection,to,this,node,param,connection,the,connection,to,add;public,void,add,outgoing,connection,dag,connection,connection,if,this,outgoing,connections,null,this,outgoing,connections,new,array,list,dag,connection,else,if,this,outgoing,connections,size,64,throw,new,compiler,exception,cannot,currently,handle,nodes,with,more,than,64,outputs,this,outgoing,connections,add,connection
OptimizerNode -> public void addOutgoingConnection(DagConnection connection);1427097830;Adds a new outgoing connection to this node.__@param connection_The connection to add.;public void addOutgoingConnection(DagConnection connection) {_		if (this.outgoingConnections == null) {_			this.outgoingConnections = new ArrayList<DagConnection>()__		} else {_			if (this.outgoingConnections.size() == 64) {_				throw new CompilerException("Cannot currently handle nodes with more than 64 outputs.")__			}_		}__		this.outgoingConnections.add(connection)__	};adds,a,new,outgoing,connection,to,this,node,param,connection,the,connection,to,add;public,void,add,outgoing,connection,dag,connection,connection,if,this,outgoing,connections,null,this,outgoing,connections,new,array,list,dag,connection,else,if,this,outgoing,connections,size,64,throw,new,compiler,exception,cannot,currently,handle,nodes,with,more,than,64,outputs,this,outgoing,connections,add,connection
OptimizerNode -> public void addOutgoingConnection(DagConnection connection);1431981454;Adds a new outgoing connection to this node.__@param connection_The connection to add.;public void addOutgoingConnection(DagConnection connection) {_		if (this.outgoingConnections == null) {_			this.outgoingConnections = new ArrayList<DagConnection>()__		} else {_			if (this.outgoingConnections.size() == 64) {_				throw new CompilerException("Cannot currently handle nodes with more than 64 outputs.")__			}_		}__		this.outgoingConnections.add(connection)__	};adds,a,new,outgoing,connection,to,this,node,param,connection,the,connection,to,add;public,void,add,outgoing,connection,dag,connection,connection,if,this,outgoing,connections,null,this,outgoing,connections,new,array,list,dag,connection,else,if,this,outgoing,connections,size,64,throw,new,compiler,exception,cannot,currently,handle,nodes,with,more,than,64,outputs,this,outgoing,connections,add,connection
OptimizerNode -> public void addOutgoingConnection(DagConnection connection);1442492509;Adds a new outgoing connection to this node.__@param connection_The connection to add.;public void addOutgoingConnection(DagConnection connection) {_		if (this.outgoingConnections == null) {_			this.outgoingConnections = new ArrayList<DagConnection>()__		} else {_			if (this.outgoingConnections.size() == 64) {_				throw new CompilerException("Cannot currently handle nodes with more than 64 outputs.")__			}_		}__		this.outgoingConnections.add(connection)__	};adds,a,new,outgoing,connection,to,this,node,param,connection,the,connection,to,add;public,void,add,outgoing,connection,dag,connection,connection,if,this,outgoing,connections,null,this,outgoing,connections,new,array,list,dag,connection,else,if,this,outgoing,connections,size,64,throw,new,compiler,exception,cannot,currently,handle,nodes,with,more,than,64,outputs,this,outgoing,connections,add,connection
OptimizerNode -> public void addOutgoingConnection(DagConnection connection);1446112342;Adds a new outgoing connection to this node.__@param connection_The connection to add.;public void addOutgoingConnection(DagConnection connection) {_		if (this.outgoingConnections == null) {_			this.outgoingConnections = new ArrayList<DagConnection>()__		} else {_			if (this.outgoingConnections.size() == 64) {_				throw new CompilerException("Cannot currently handle nodes with more than 64 outputs.")__			}_		}__		this.outgoingConnections.add(connection)__	};adds,a,new,outgoing,connection,to,this,node,param,connection,the,connection,to,add;public,void,add,outgoing,connection,dag,connection,connection,if,this,outgoing,connections,null,this,outgoing,connections,new,array,list,dag,connection,else,if,this,outgoing,connections,size,64,throw,new,compiler,exception,cannot,currently,handle,nodes,with,more,than,64,outputs,this,outgoing,connections,add,connection
OptimizerNode -> public void addOutgoingConnection(DagConnection connection);1460563153;Adds a new outgoing connection to this node.__@param connection_The connection to add.;public void addOutgoingConnection(DagConnection connection) {_		if (this.outgoingConnections == null) {_			this.outgoingConnections = new ArrayList<DagConnection>()__		} else {_			if (this.outgoingConnections.size() == 64) {_				throw new CompilerException("Cannot currently handle nodes with more than 64 outputs.")__			}_		}__		this.outgoingConnections.add(connection)__	};adds,a,new,outgoing,connection,to,this,node,param,connection,the,connection,to,add;public,void,add,outgoing,connection,dag,connection,connection,if,this,outgoing,connections,null,this,outgoing,connections,new,array,list,dag,connection,else,if,this,outgoing,connections,size,64,throw,new,compiler,exception,cannot,currently,handle,nodes,with,more,than,64,outputs,this,outgoing,connections,add,connection
OptimizerNode -> public void addOutgoingConnection(DagConnection connection);1546180287;Adds a new outgoing connection to this node.__@param connection_The connection to add.;public void addOutgoingConnection(DagConnection connection) {_		if (this.outgoingConnections == null) {_			this.outgoingConnections = new ArrayList<DagConnection>()__		} else {_			if (this.outgoingConnections.size() == 64) {_				throw new CompilerException("Cannot currently handle nodes with more than 64 outputs.")__			}_		}__		this.outgoingConnections.add(connection)__	};adds,a,new,outgoing,connection,to,this,node,param,connection,the,connection,to,add;public,void,add,outgoing,connection,dag,connection,connection,if,this,outgoing,connections,null,this,outgoing,connections,new,array,list,dag,connection,else,if,this,outgoing,connections,size,64,throw,new,compiler,exception,cannot,currently,handle,nodes,with,more,than,64,outputs,this,outgoing,connections,add,connection
OptimizerNode -> public int getParallelism();1426843274;Gets the parallelism for the operator represented by this optimizer node._The parallelism denotes how many parallel instances of the operator on will be_spawned during the execution. If this value is <code>-1</code>, then the system will take_the default number of parallel instances.__@return The parallelism of the operator.;public int getParallelism() {_		return this.parallelism__	};gets,the,parallelism,for,the,operator,represented,by,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,on,will,be,spawned,during,the,execution,if,this,value,is,code,1,code,then,the,system,will,take,the,default,number,of,parallel,instances,return,the,parallelism,of,the,operator;public,int,get,parallelism,return,this,parallelism
OptimizerNode -> public int getParallelism();1427097830;Gets the parallelism for the operator represented by this optimizer node._The parallelism denotes how many parallel instances of the operator on will be_spawned during the execution. If this value is <code>-1</code>, then the system will take_the default number of parallel instances.__@return The parallelism of the operator.;public int getParallelism() {_		return this.parallelism__	};gets,the,parallelism,for,the,operator,represented,by,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,on,will,be,spawned,during,the,execution,if,this,value,is,code,1,code,then,the,system,will,take,the,default,number,of,parallel,instances,return,the,parallelism,of,the,operator;public,int,get,parallelism,return,this,parallelism
OptimizerNode -> public int getParallelism();1431981454;Gets the parallelism for the operator represented by this optimizer node._The parallelism denotes how many parallel instances of the operator on will be_spawned during the execution. If this value is <code>-1</code>, then the system will take_the default number of parallel instances.__@return The parallelism of the operator.;public int getParallelism() {_		return this.parallelism__	};gets,the,parallelism,for,the,operator,represented,by,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,on,will,be,spawned,during,the,execution,if,this,value,is,code,1,code,then,the,system,will,take,the,default,number,of,parallel,instances,return,the,parallelism,of,the,operator;public,int,get,parallelism,return,this,parallelism
OptimizerNode -> public int getParallelism();1442492509;Gets the parallelism for the operator represented by this optimizer node._The parallelism denotes how many parallel instances of the operator on will be_spawned during the execution. If this value is <code>-1</code>, then the system will take_the default number of parallel instances.__@return The parallelism of the operator.;public int getParallelism() {_		return this.parallelism__	};gets,the,parallelism,for,the,operator,represented,by,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,on,will,be,spawned,during,the,execution,if,this,value,is,code,1,code,then,the,system,will,take,the,default,number,of,parallel,instances,return,the,parallelism,of,the,operator;public,int,get,parallelism,return,this,parallelism
OptimizerNode -> public int getParallelism();1446112342;Gets the parallelism for the operator represented by this optimizer node._The parallelism denotes how many parallel instances of the operator on will be_spawned during the execution. If this value is <code>-1</code>, then the system will take_the default number of parallel instances.__@return The parallelism of the operator.;public int getParallelism() {_		return this.parallelism__	};gets,the,parallelism,for,the,operator,represented,by,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,on,will,be,spawned,during,the,execution,if,this,value,is,code,1,code,then,the,system,will,take,the,default,number,of,parallel,instances,return,the,parallelism,of,the,operator;public,int,get,parallelism,return,this,parallelism
OptimizerNode -> public int getParallelism();1460563153;Gets the parallelism for the operator represented by this optimizer node._The parallelism denotes how many parallel instances of the operator on will be_spawned during the execution. If this value is {@link ExecutionConfig#PARALLELISM_DEFAULT}_then the system will take the default number of parallel instances.__@return The parallelism of the operator.;public int getParallelism() {_		return this.parallelism__	};gets,the,parallelism,for,the,operator,represented,by,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,on,will,be,spawned,during,the,execution,if,this,value,is,link,execution,config,then,the,system,will,take,the,default,number,of,parallel,instances,return,the,parallelism,of,the,operator;public,int,get,parallelism,return,this,parallelism
OptimizerNode -> public int getParallelism();1546180287;Gets the parallelism for the operator represented by this optimizer node._The parallelism denotes how many parallel instances of the operator on will be_spawned during the execution. If this value is {@link ExecutionConfig#PARALLELISM_DEFAULT}_then the system will take the default number of parallel instances.__@return The parallelism of the operator.;public int getParallelism() {_		return this.parallelism__	};gets,the,parallelism,for,the,operator,represented,by,this,optimizer,node,the,parallelism,denotes,how,many,parallel,instances,of,the,operator,on,will,be,spawned,during,the,execution,if,this,value,is,link,execution,config,then,the,system,will,take,the,default,number,of,parallel,instances,return,the,parallelism,of,the,operator;public,int,get,parallelism,return,this,parallelism
OptimizerNode -> public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode, 									ExecutionMode defaultExchangeMode)_;1426843274;This function connects the predecessors to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.;public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode,_									ExecutionMode defaultExchangeMode)_;this,function,connects,the,predecessors,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one;public,abstract,void,set,input,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode
OptimizerNode -> public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode, 									ExecutionMode defaultExchangeMode)_;1427097830;This function connects the predecessors to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.;public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode,_									ExecutionMode defaultExchangeMode)_;this,function,connects,the,predecessors,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one;public,abstract,void,set,input,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode
OptimizerNode -> public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode, 									ExecutionMode defaultExchangeMode)_;1431981454;This function connects the predecessors to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.;public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode,_									ExecutionMode defaultExchangeMode)_;this,function,connects,the,predecessors,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one;public,abstract,void,set,input,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode
OptimizerNode -> public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode, 									ExecutionMode defaultExchangeMode)_;1442492509;This function connects the predecessors to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.;public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode,_									ExecutionMode defaultExchangeMode)_;this,function,connects,the,predecessors,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one;public,abstract,void,set,input,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode
OptimizerNode -> public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode, 									ExecutionMode defaultExchangeMode)_;1446112342;This function connects the predecessors to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.;public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode,_									ExecutionMode defaultExchangeMode)_;this,function,connects,the,predecessors,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one;public,abstract,void,set,input,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode
OptimizerNode -> public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode, 									ExecutionMode defaultExchangeMode)_;1460563153;This function connects the predecessors to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.;public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode,_									ExecutionMode defaultExchangeMode)_;this,function,connects,the,predecessors,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one;public,abstract,void,set,input,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode
OptimizerNode -> public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode, 									ExecutionMode defaultExchangeMode)_;1546180287;This function connects the predecessors to this operator.__@param operatorToNode The map from program operators to optimizer nodes._@param defaultExchangeMode The data exchange mode to use, if the operator does not_specify one.;public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode,_									ExecutionMode defaultExchangeMode)_;this,function,connects,the,predecessors,to,this,operator,param,operator,to,node,the,map,from,program,operators,to,optimizer,nodes,param,default,exchange,mode,the,data,exchange,mode,to,use,if,the,operator,does,not,specify,one;public,abstract,void,set,input,map,operator,optimizer,node,operator,to,node,execution,mode,default,exchange,mode
OptimizerNode -> public abstract void computeUnclosedBranchStack()_;1426843274;This method causes the node to compute the description of open branches in its sub-plan. An open branch_describes, that a (transitive) child node had multiple outputs, which have not all been re-joined in the_sub-plan. This method needs to set the <code>openBranches</code> field to a stack of unclosed branches, the_latest one top. A branch is considered closed, if some later node sees all of the branching node's outputs,_no matter if there have been more branches to different paths in the meantime.;public abstract void computeUnclosedBranchStack()_;this,method,causes,the,node,to,compute,the,description,of,open,branches,in,its,sub,plan,an,open,branch,describes,that,a,transitive,child,node,had,multiple,outputs,which,have,not,all,been,re,joined,in,the,sub,plan,this,method,needs,to,set,the,code,open,branches,code,field,to,a,stack,of,unclosed,branches,the,latest,one,top,a,branch,is,considered,closed,if,some,later,node,sees,all,of,the,branching,node,s,outputs,no,matter,if,there,have,been,more,branches,to,different,paths,in,the,meantime;public,abstract,void,compute,unclosed,branch,stack
OptimizerNode -> public abstract void computeUnclosedBranchStack()_;1427097830;This method causes the node to compute the description of open branches in its sub-plan. An open branch_describes, that a (transitive) child node had multiple outputs, which have not all been re-joined in the_sub-plan. This method needs to set the <code>openBranches</code> field to a stack of unclosed branches, the_latest one top. A branch is considered closed, if some later node sees all of the branching node's outputs,_no matter if there have been more branches to different paths in the meantime.;public abstract void computeUnclosedBranchStack()_;this,method,causes,the,node,to,compute,the,description,of,open,branches,in,its,sub,plan,an,open,branch,describes,that,a,transitive,child,node,had,multiple,outputs,which,have,not,all,been,re,joined,in,the,sub,plan,this,method,needs,to,set,the,code,open,branches,code,field,to,a,stack,of,unclosed,branches,the,latest,one,top,a,branch,is,considered,closed,if,some,later,node,sees,all,of,the,branching,node,s,outputs,no,matter,if,there,have,been,more,branches,to,different,paths,in,the,meantime;public,abstract,void,compute,unclosed,branch,stack
OptimizerNode -> public abstract void computeUnclosedBranchStack()_;1431981454;This method causes the node to compute the description of open branches in its sub-plan. An open branch_describes, that a (transitive) child node had multiple outputs, which have not all been re-joined in the_sub-plan. This method needs to set the <code>openBranches</code> field to a stack of unclosed branches, the_latest one top. A branch is considered closed, if some later node sees all of the branching node's outputs,_no matter if there have been more branches to different paths in the meantime.;public abstract void computeUnclosedBranchStack()_;this,method,causes,the,node,to,compute,the,description,of,open,branches,in,its,sub,plan,an,open,branch,describes,that,a,transitive,child,node,had,multiple,outputs,which,have,not,all,been,re,joined,in,the,sub,plan,this,method,needs,to,set,the,code,open,branches,code,field,to,a,stack,of,unclosed,branches,the,latest,one,top,a,branch,is,considered,closed,if,some,later,node,sees,all,of,the,branching,node,s,outputs,no,matter,if,there,have,been,more,branches,to,different,paths,in,the,meantime;public,abstract,void,compute,unclosed,branch,stack
OptimizerNode -> public abstract void computeUnclosedBranchStack()_;1442492509;This method causes the node to compute the description of open branches in its sub-plan. An open branch_describes, that a (transitive) child node had multiple outputs, which have not all been re-joined in the_sub-plan. This method needs to set the <code>openBranches</code> field to a stack of unclosed branches, the_latest one top. A branch is considered closed, if some later node sees all of the branching node's outputs,_no matter if there have been more branches to different paths in the meantime.;public abstract void computeUnclosedBranchStack()_;this,method,causes,the,node,to,compute,the,description,of,open,branches,in,its,sub,plan,an,open,branch,describes,that,a,transitive,child,node,had,multiple,outputs,which,have,not,all,been,re,joined,in,the,sub,plan,this,method,needs,to,set,the,code,open,branches,code,field,to,a,stack,of,unclosed,branches,the,latest,one,top,a,branch,is,considered,closed,if,some,later,node,sees,all,of,the,branching,node,s,outputs,no,matter,if,there,have,been,more,branches,to,different,paths,in,the,meantime;public,abstract,void,compute,unclosed,branch,stack
OptimizerNode -> public abstract void computeUnclosedBranchStack()_;1446112342;This method causes the node to compute the description of open branches in its sub-plan. An open branch_describes, that a (transitive) child node had multiple outputs, which have not all been re-joined in the_sub-plan. This method needs to set the <code>openBranches</code> field to a stack of unclosed branches, the_latest one top. A branch is considered closed, if some later node sees all of the branching node's outputs,_no matter if there have been more branches to different paths in the meantime.;public abstract void computeUnclosedBranchStack()_;this,method,causes,the,node,to,compute,the,description,of,open,branches,in,its,sub,plan,an,open,branch,describes,that,a,transitive,child,node,had,multiple,outputs,which,have,not,all,been,re,joined,in,the,sub,plan,this,method,needs,to,set,the,code,open,branches,code,field,to,a,stack,of,unclosed,branches,the,latest,one,top,a,branch,is,considered,closed,if,some,later,node,sees,all,of,the,branching,node,s,outputs,no,matter,if,there,have,been,more,branches,to,different,paths,in,the,meantime;public,abstract,void,compute,unclosed,branch,stack
OptimizerNode -> public abstract void computeUnclosedBranchStack()_;1460563153;This method causes the node to compute the description of open branches in its sub-plan. An open branch_describes, that a (transitive) child node had multiple outputs, which have not all been re-joined in the_sub-plan. This method needs to set the <code>openBranches</code> field to a stack of unclosed branches, the_latest one top. A branch is considered closed, if some later node sees all of the branching node's outputs,_no matter if there have been more branches to different paths in the meantime.;public abstract void computeUnclosedBranchStack()_;this,method,causes,the,node,to,compute,the,description,of,open,branches,in,its,sub,plan,an,open,branch,describes,that,a,transitive,child,node,had,multiple,outputs,which,have,not,all,been,re,joined,in,the,sub,plan,this,method,needs,to,set,the,code,open,branches,code,field,to,a,stack,of,unclosed,branches,the,latest,one,top,a,branch,is,considered,closed,if,some,later,node,sees,all,of,the,branching,node,s,outputs,no,matter,if,there,have,been,more,branches,to,different,paths,in,the,meantime;public,abstract,void,compute,unclosed,branch,stack
OptimizerNode -> public abstract void computeUnclosedBranchStack()_;1546180287;This method causes the node to compute the description of open branches in its sub-plan. An open branch_describes, that a (transitive) child node had multiple outputs, which have not all been re-joined in the_sub-plan. This method needs to set the <code>openBranches</code> field to a stack of unclosed branches, the_latest one top. A branch is considered closed, if some later node sees all of the branching node's outputs,_no matter if there have been more branches to different paths in the meantime.;public abstract void computeUnclosedBranchStack()_;this,method,causes,the,node,to,compute,the,description,of,open,branches,in,its,sub,plan,an,open,branch,describes,that,a,transitive,child,node,had,multiple,outputs,which,have,not,all,been,re,joined,in,the,sub,plan,this,method,needs,to,set,the,code,open,branches,code,field,to,a,stack,of,unclosed,branches,the,latest,one,top,a,branch,is,considered,closed,if,some,later,node,sees,all,of,the,branching,node,s,outputs,no,matter,if,there,have,been,more,branches,to,different,paths,in,the,meantime;public,abstract,void,compute,unclosed,branch,stack
OptimizerNode -> protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open, 										List<UnclosedBranchDescriptor> child2open, 										List<UnclosedBranchDescriptor> result, 										boolean markJoinedBranchesAsPipelineBreaking);1426843274;The node IDs are assigned in graph-traversal order (pre-order), hence, each list is_sorted by ID in ascending order and all consecutive lists start with IDs in ascending order.__@param markJoinedBranchesAsPipelineBreaking True, if the;protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open,_										List<UnclosedBranchDescriptor> child2open,_										List<UnclosedBranchDescriptor> result,_										boolean markJoinedBranchesAsPipelineBreaking) {__		_		removeClosedBranches(child1open)__		removeClosedBranches(child2open)__		_		result.clear()__		_		_		_		_		_		if (child1open == null || child1open.isEmpty()) {_			if(child2open != null && !child2open.isEmpty()) {_				result.addAll(child2open)__			}_			return false__		}_		_		if (child2open == null || child2open.isEmpty()) {_			result.addAll(child1open)__			return false__		}__		int index1 = child1open.size() - 1__		int index2 = child2open.size() - 1__		_		boolean didCloseABranch = false___		_		_		_		while (index1 >= 0 || index2 >= 0) {_			int id1 = -1__			int id2 = index2 >= 0 ? child2open.get(index2).getBranchingNode().getId() : -1___			while (index1 >= 0 && (id1 = child1open.get(index1).getBranchingNode().getId()) > id2) {_				result.add(child1open.get(index1))__				index1--__			}_			while (index2 >= 0 && (id2 = child2open.get(index2).getBranchingNode().getId()) > id1) {_				result.add(child2open.get(index2))__				index2--__			}__			_			if (id1 == id2) {_				didCloseABranch = true__				_				_				OptimizerNode currBanchingNode = child1open.get(index1).getBranchingNode()__				_				long vector1 = child1open.get(index1).getJoinedPathsVector()__				long vector2 = child2open.get(index2).getJoinedPathsVector()__				_				_				_				if (vector1 == vector2) {_					result.add(child1open.get(index1))__				}_				else {_					__					_					if (markJoinedBranchesAsPipelineBreaking) {_						currBanchingNode.markAllOutgoingConnectionsAsPipelineBreaking()__					}__					if (this.hereJoinedBranches == null) {_						this.hereJoinedBranches = new ArrayList<OptimizerNode>(2)__					}_					this.hereJoinedBranches.add(currBanchingNode)___					_					long joinedInputs = vector1 | vector2___					_					long allInputs = (0x1L << currBanchingNode.getOutgoingConnections().size()) - 1___					if (joinedInputs == allInputs) {_						_						addClosedBranch(currBanchingNode)__					} else {_						_						result.add(new UnclosedBranchDescriptor(currBanchingNode, joinedInputs))__					}_				}__				index1--__				index2--__			}_		}__		_		Collections.reverse(result)__		return didCloseABranch__	};the,node,ids,are,assigned,in,graph,traversal,order,pre,order,hence,each,list,is,sorted,by,id,in,ascending,order,and,all,consecutive,lists,start,with,ids,in,ascending,order,param,mark,joined,branches,as,pipeline,breaking,true,if,the;protected,final,boolean,merge,lists,list,unclosed,branch,descriptor,child1open,list,unclosed,branch,descriptor,child2open,list,unclosed,branch,descriptor,result,boolean,mark,joined,branches,as,pipeline,breaking,remove,closed,branches,child1open,remove,closed,branches,child2open,result,clear,if,child1open,null,child1open,is,empty,if,child2open,null,child2open,is,empty,result,add,all,child2open,return,false,if,child2open,null,child2open,is,empty,result,add,all,child1open,return,false,int,index1,child1open,size,1,int,index2,child2open,size,1,boolean,did,close,abranch,false,while,index1,0,index2,0,int,id1,1,int,id2,index2,0,child2open,get,index2,get,branching,node,get,id,1,while,index1,0,id1,child1open,get,index1,get,branching,node,get,id,id2,result,add,child1open,get,index1,index1,while,index2,0,id2,child2open,get,index2,get,branching,node,get,id,id1,result,add,child2open,get,index2,index2,if,id1,id2,did,close,abranch,true,optimizer,node,curr,banching,node,child1open,get,index1,get,branching,node,long,vector1,child1open,get,index1,get,joined,paths,vector,long,vector2,child2open,get,index2,get,joined,paths,vector,if,vector1,vector2,result,add,child1open,get,index1,else,if,mark,joined,branches,as,pipeline,breaking,curr,banching,node,mark,all,outgoing,connections,as,pipeline,breaking,if,this,here,joined,branches,null,this,here,joined,branches,new,array,list,optimizer,node,2,this,here,joined,branches,add,curr,banching,node,long,joined,inputs,vector1,vector2,long,all,inputs,0x1l,curr,banching,node,get,outgoing,connections,size,1,if,joined,inputs,all,inputs,add,closed,branch,curr,banching,node,else,result,add,new,unclosed,branch,descriptor,curr,banching,node,joined,inputs,index1,index2,collections,reverse,result,return,did,close,abranch
OptimizerNode -> protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open, 										List<UnclosedBranchDescriptor> child2open, 										List<UnclosedBranchDescriptor> result, 										boolean markJoinedBranchesAsPipelineBreaking);1427097830;The node IDs are assigned in graph-traversal order (pre-order), hence, each list is_sorted by ID in ascending order and all consecutive lists start with IDs in ascending order.__@param markJoinedBranchesAsPipelineBreaking True, if the;protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open,_										List<UnclosedBranchDescriptor> child2open,_										List<UnclosedBranchDescriptor> result,_										boolean markJoinedBranchesAsPipelineBreaking) {__		_		removeClosedBranches(child1open)__		removeClosedBranches(child2open)__		_		result.clear()__		_		_		_		_		_		if (child1open == null || child1open.isEmpty()) {_			if(child2open != null && !child2open.isEmpty()) {_				result.addAll(child2open)__			}_			return false__		}_		_		if (child2open == null || child2open.isEmpty()) {_			result.addAll(child1open)__			return false__		}__		int index1 = child1open.size() - 1__		int index2 = child2open.size() - 1__		_		boolean didCloseABranch = false___		_		_		_		while (index1 >= 0 || index2 >= 0) {_			int id1 = -1__			int id2 = index2 >= 0 ? child2open.get(index2).getBranchingNode().getId() : -1___			while (index1 >= 0 && (id1 = child1open.get(index1).getBranchingNode().getId()) > id2) {_				result.add(child1open.get(index1))__				index1--__			}_			while (index2 >= 0 && (id2 = child2open.get(index2).getBranchingNode().getId()) > id1) {_				result.add(child2open.get(index2))__				index2--__			}__			_			if (id1 == id2) {_				didCloseABranch = true__				_				_				OptimizerNode currBanchingNode = child1open.get(index1).getBranchingNode()__				_				long vector1 = child1open.get(index1).getJoinedPathsVector()__				long vector2 = child2open.get(index2).getJoinedPathsVector()__				_				_				_				if (vector1 == vector2) {_					result.add(child1open.get(index1))__				}_				else {_					__					_					if (markJoinedBranchesAsPipelineBreaking) {_						currBanchingNode.markAllOutgoingConnectionsAsPipelineBreaking()__					}__					if (this.hereJoinedBranches == null) {_						this.hereJoinedBranches = new ArrayList<OptimizerNode>(2)__					}_					this.hereJoinedBranches.add(currBanchingNode)___					_					long joinedInputs = vector1 | vector2___					_					long allInputs = (0x1L << currBanchingNode.getOutgoingConnections().size()) - 1___					if (joinedInputs == allInputs) {_						_						addClosedBranch(currBanchingNode)__					} else {_						_						result.add(new UnclosedBranchDescriptor(currBanchingNode, joinedInputs))__					}_				}__				index1--__				index2--__			}_		}__		_		Collections.reverse(result)__		return didCloseABranch__	};the,node,ids,are,assigned,in,graph,traversal,order,pre,order,hence,each,list,is,sorted,by,id,in,ascending,order,and,all,consecutive,lists,start,with,ids,in,ascending,order,param,mark,joined,branches,as,pipeline,breaking,true,if,the;protected,final,boolean,merge,lists,list,unclosed,branch,descriptor,child1open,list,unclosed,branch,descriptor,child2open,list,unclosed,branch,descriptor,result,boolean,mark,joined,branches,as,pipeline,breaking,remove,closed,branches,child1open,remove,closed,branches,child2open,result,clear,if,child1open,null,child1open,is,empty,if,child2open,null,child2open,is,empty,result,add,all,child2open,return,false,if,child2open,null,child2open,is,empty,result,add,all,child1open,return,false,int,index1,child1open,size,1,int,index2,child2open,size,1,boolean,did,close,abranch,false,while,index1,0,index2,0,int,id1,1,int,id2,index2,0,child2open,get,index2,get,branching,node,get,id,1,while,index1,0,id1,child1open,get,index1,get,branching,node,get,id,id2,result,add,child1open,get,index1,index1,while,index2,0,id2,child2open,get,index2,get,branching,node,get,id,id1,result,add,child2open,get,index2,index2,if,id1,id2,did,close,abranch,true,optimizer,node,curr,banching,node,child1open,get,index1,get,branching,node,long,vector1,child1open,get,index1,get,joined,paths,vector,long,vector2,child2open,get,index2,get,joined,paths,vector,if,vector1,vector2,result,add,child1open,get,index1,else,if,mark,joined,branches,as,pipeline,breaking,curr,banching,node,mark,all,outgoing,connections,as,pipeline,breaking,if,this,here,joined,branches,null,this,here,joined,branches,new,array,list,optimizer,node,2,this,here,joined,branches,add,curr,banching,node,long,joined,inputs,vector1,vector2,long,all,inputs,0x1l,curr,banching,node,get,outgoing,connections,size,1,if,joined,inputs,all,inputs,add,closed,branch,curr,banching,node,else,result,add,new,unclosed,branch,descriptor,curr,banching,node,joined,inputs,index1,index2,collections,reverse,result,return,did,close,abranch
OptimizerNode -> protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open, 										List<UnclosedBranchDescriptor> child2open, 										List<UnclosedBranchDescriptor> result, 										boolean markJoinedBranchesAsPipelineBreaking);1431981454;The node IDs are assigned in graph-traversal order (pre-order), hence, each list is_sorted by ID in ascending order and all consecutive lists start with IDs in ascending order.__@param markJoinedBranchesAsPipelineBreaking True, if the;protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open,_										List<UnclosedBranchDescriptor> child2open,_										List<UnclosedBranchDescriptor> result,_										boolean markJoinedBranchesAsPipelineBreaking) {__		_		removeClosedBranches(child1open)__		removeClosedBranches(child2open)__		_		result.clear()__		_		_		_		_		_		if (child1open == null || child1open.isEmpty()) {_			if(child2open != null && !child2open.isEmpty()) {_				result.addAll(child2open)__			}_			return false__		}_		_		if (child2open == null || child2open.isEmpty()) {_			result.addAll(child1open)__			return false__		}__		int index1 = child1open.size() - 1__		int index2 = child2open.size() - 1__		_		boolean didCloseABranch = false___		_		_		_		while (index1 >= 0 || index2 >= 0) {_			int id1 = -1__			int id2 = index2 >= 0 ? child2open.get(index2).getBranchingNode().getId() : -1___			while (index1 >= 0 && (id1 = child1open.get(index1).getBranchingNode().getId()) > id2) {_				result.add(child1open.get(index1))__				index1--__			}_			while (index2 >= 0 && (id2 = child2open.get(index2).getBranchingNode().getId()) > id1) {_				result.add(child2open.get(index2))__				index2--__			}__			_			if (id1 == id2) {_				didCloseABranch = true__				_				_				OptimizerNode currBanchingNode = child1open.get(index1).getBranchingNode()__				_				long vector1 = child1open.get(index1).getJoinedPathsVector()__				long vector2 = child2open.get(index2).getJoinedPathsVector()__				_				_				_				if (vector1 == vector2) {_					result.add(child1open.get(index1))__				}_				else {_					__					_					if (markJoinedBranchesAsPipelineBreaking) {_						currBanchingNode.markAllOutgoingConnectionsAsPipelineBreaking()__					}__					if (this.hereJoinedBranches == null) {_						this.hereJoinedBranches = new ArrayList<OptimizerNode>(2)__					}_					this.hereJoinedBranches.add(currBanchingNode)___					_					long joinedInputs = vector1 | vector2___					_					long allInputs = (0x1L << currBanchingNode.getOutgoingConnections().size()) - 1___					if (joinedInputs == allInputs) {_						_						addClosedBranch(currBanchingNode)__					} else {_						_						result.add(new UnclosedBranchDescriptor(currBanchingNode, joinedInputs))__					}_				}__				index1--__				index2--__			}_		}__		_		Collections.reverse(result)__		return didCloseABranch__	};the,node,ids,are,assigned,in,graph,traversal,order,pre,order,hence,each,list,is,sorted,by,id,in,ascending,order,and,all,consecutive,lists,start,with,ids,in,ascending,order,param,mark,joined,branches,as,pipeline,breaking,true,if,the;protected,final,boolean,merge,lists,list,unclosed,branch,descriptor,child1open,list,unclosed,branch,descriptor,child2open,list,unclosed,branch,descriptor,result,boolean,mark,joined,branches,as,pipeline,breaking,remove,closed,branches,child1open,remove,closed,branches,child2open,result,clear,if,child1open,null,child1open,is,empty,if,child2open,null,child2open,is,empty,result,add,all,child2open,return,false,if,child2open,null,child2open,is,empty,result,add,all,child1open,return,false,int,index1,child1open,size,1,int,index2,child2open,size,1,boolean,did,close,abranch,false,while,index1,0,index2,0,int,id1,1,int,id2,index2,0,child2open,get,index2,get,branching,node,get,id,1,while,index1,0,id1,child1open,get,index1,get,branching,node,get,id,id2,result,add,child1open,get,index1,index1,while,index2,0,id2,child2open,get,index2,get,branching,node,get,id,id1,result,add,child2open,get,index2,index2,if,id1,id2,did,close,abranch,true,optimizer,node,curr,banching,node,child1open,get,index1,get,branching,node,long,vector1,child1open,get,index1,get,joined,paths,vector,long,vector2,child2open,get,index2,get,joined,paths,vector,if,vector1,vector2,result,add,child1open,get,index1,else,if,mark,joined,branches,as,pipeline,breaking,curr,banching,node,mark,all,outgoing,connections,as,pipeline,breaking,if,this,here,joined,branches,null,this,here,joined,branches,new,array,list,optimizer,node,2,this,here,joined,branches,add,curr,banching,node,long,joined,inputs,vector1,vector2,long,all,inputs,0x1l,curr,banching,node,get,outgoing,connections,size,1,if,joined,inputs,all,inputs,add,closed,branch,curr,banching,node,else,result,add,new,unclosed,branch,descriptor,curr,banching,node,joined,inputs,index1,index2,collections,reverse,result,return,did,close,abranch
OptimizerNode -> protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open, 										List<UnclosedBranchDescriptor> child2open, 										List<UnclosedBranchDescriptor> result, 										boolean markJoinedBranchesAsPipelineBreaking);1442492509;The node IDs are assigned in graph-traversal order (pre-order), hence, each list is_sorted by ID in ascending order and all consecutive lists start with IDs in ascending order.__@param markJoinedBranchesAsPipelineBreaking True, if the;protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open,_										List<UnclosedBranchDescriptor> child2open,_										List<UnclosedBranchDescriptor> result,_										boolean markJoinedBranchesAsPipelineBreaking) {__		_		removeClosedBranches(child1open)__		removeClosedBranches(child2open)__		_		result.clear()__		_		_		_		_		_		if (child1open == null || child1open.isEmpty()) {_			if(child2open != null && !child2open.isEmpty()) {_				result.addAll(child2open)__			}_			return false__		}_		_		if (child2open == null || child2open.isEmpty()) {_			result.addAll(child1open)__			return false__		}__		int index1 = child1open.size() - 1__		int index2 = child2open.size() - 1__		_		boolean didCloseABranch = false___		_		_		_		while (index1 >= 0 || index2 >= 0) {_			int id1 = -1__			int id2 = index2 >= 0 ? child2open.get(index2).getBranchingNode().getId() : -1___			while (index1 >= 0 && (id1 = child1open.get(index1).getBranchingNode().getId()) > id2) {_				result.add(child1open.get(index1))__				index1--__			}_			while (index2 >= 0 && (id2 = child2open.get(index2).getBranchingNode().getId()) > id1) {_				result.add(child2open.get(index2))__				index2--__			}__			_			if (id1 == id2) {_				didCloseABranch = true__				_				_				OptimizerNode currBanchingNode = child1open.get(index1).getBranchingNode()__				_				long vector1 = child1open.get(index1).getJoinedPathsVector()__				long vector2 = child2open.get(index2).getJoinedPathsVector()__				_				_				_				if (vector1 == vector2) {_					result.add(child1open.get(index1))__				}_				else {_					__					_					if (markJoinedBranchesAsPipelineBreaking) {_						currBanchingNode.markAllOutgoingConnectionsAsPipelineBreaking()__					}__					if (this.hereJoinedBranches == null) {_						this.hereJoinedBranches = new ArrayList<OptimizerNode>(2)__					}_					this.hereJoinedBranches.add(currBanchingNode)___					_					long joinedInputs = vector1 | vector2___					_					long allInputs = (0x1L << currBanchingNode.getOutgoingConnections().size()) - 1___					if (joinedInputs == allInputs) {_						_						addClosedBranch(currBanchingNode)__					} else {_						_						result.add(new UnclosedBranchDescriptor(currBanchingNode, joinedInputs))__					}_				}__				index1--__				index2--__			}_		}__		_		Collections.reverse(result)__		return didCloseABranch__	};the,node,ids,are,assigned,in,graph,traversal,order,pre,order,hence,each,list,is,sorted,by,id,in,ascending,order,and,all,consecutive,lists,start,with,ids,in,ascending,order,param,mark,joined,branches,as,pipeline,breaking,true,if,the;protected,final,boolean,merge,lists,list,unclosed,branch,descriptor,child1open,list,unclosed,branch,descriptor,child2open,list,unclosed,branch,descriptor,result,boolean,mark,joined,branches,as,pipeline,breaking,remove,closed,branches,child1open,remove,closed,branches,child2open,result,clear,if,child1open,null,child1open,is,empty,if,child2open,null,child2open,is,empty,result,add,all,child2open,return,false,if,child2open,null,child2open,is,empty,result,add,all,child1open,return,false,int,index1,child1open,size,1,int,index2,child2open,size,1,boolean,did,close,abranch,false,while,index1,0,index2,0,int,id1,1,int,id2,index2,0,child2open,get,index2,get,branching,node,get,id,1,while,index1,0,id1,child1open,get,index1,get,branching,node,get,id,id2,result,add,child1open,get,index1,index1,while,index2,0,id2,child2open,get,index2,get,branching,node,get,id,id1,result,add,child2open,get,index2,index2,if,id1,id2,did,close,abranch,true,optimizer,node,curr,banching,node,child1open,get,index1,get,branching,node,long,vector1,child1open,get,index1,get,joined,paths,vector,long,vector2,child2open,get,index2,get,joined,paths,vector,if,vector1,vector2,result,add,child1open,get,index1,else,if,mark,joined,branches,as,pipeline,breaking,curr,banching,node,mark,all,outgoing,connections,as,pipeline,breaking,if,this,here,joined,branches,null,this,here,joined,branches,new,array,list,optimizer,node,2,this,here,joined,branches,add,curr,banching,node,long,joined,inputs,vector1,vector2,long,all,inputs,0x1l,curr,banching,node,get,outgoing,connections,size,1,if,joined,inputs,all,inputs,add,closed,branch,curr,banching,node,else,result,add,new,unclosed,branch,descriptor,curr,banching,node,joined,inputs,index1,index2,collections,reverse,result,return,did,close,abranch
OptimizerNode -> protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open, 										List<UnclosedBranchDescriptor> child2open, 										List<UnclosedBranchDescriptor> result, 										boolean markJoinedBranchesAsPipelineBreaking);1446112342;The node IDs are assigned in graph-traversal order (pre-order), hence, each list is_sorted by ID in ascending order and all consecutive lists start with IDs in ascending order.__@param markJoinedBranchesAsPipelineBreaking True, if the;protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open,_										List<UnclosedBranchDescriptor> child2open,_										List<UnclosedBranchDescriptor> result,_										boolean markJoinedBranchesAsPipelineBreaking) {__		_		removeClosedBranches(child1open)__		removeClosedBranches(child2open)__		_		result.clear()__		_		_		_		_		_		if (child1open == null || child1open.isEmpty()) {_			if(child2open != null && !child2open.isEmpty()) {_				result.addAll(child2open)__			}_			return false__		}_		_		if (child2open == null || child2open.isEmpty()) {_			result.addAll(child1open)__			return false__		}__		int index1 = child1open.size() - 1__		int index2 = child2open.size() - 1__		_		boolean didCloseABranch = false___		_		_		_		while (index1 >= 0 || index2 >= 0) {_			int id1 = -1__			int id2 = index2 >= 0 ? child2open.get(index2).getBranchingNode().getId() : -1___			while (index1 >= 0 && (id1 = child1open.get(index1).getBranchingNode().getId()) > id2) {_				result.add(child1open.get(index1))__				index1--__			}_			while (index2 >= 0 && (id2 = child2open.get(index2).getBranchingNode().getId()) > id1) {_				result.add(child2open.get(index2))__				index2--__			}__			_			if (id1 == id2) {_				didCloseABranch = true__				_				_				OptimizerNode currBanchingNode = child1open.get(index1).getBranchingNode()__				_				long vector1 = child1open.get(index1).getJoinedPathsVector()__				long vector2 = child2open.get(index2).getJoinedPathsVector()__				_				_				_				if (vector1 == vector2) {_					result.add(child1open.get(index1))__				}_				else {_					__					_					if (markJoinedBranchesAsPipelineBreaking) {_						currBanchingNode.markAllOutgoingConnectionsAsPipelineBreaking()__					}__					if (this.hereJoinedBranches == null) {_						this.hereJoinedBranches = new ArrayList<OptimizerNode>(2)__					}_					this.hereJoinedBranches.add(currBanchingNode)___					_					long joinedInputs = vector1 | vector2___					_					long allInputs = (0x1L << currBanchingNode.getOutgoingConnections().size()) - 1___					if (joinedInputs == allInputs) {_						_						addClosedBranch(currBanchingNode)__					} else {_						_						result.add(new UnclosedBranchDescriptor(currBanchingNode, joinedInputs))__					}_				}__				index1--__				index2--__			}_		}__		_		Collections.reverse(result)__		return didCloseABranch__	};the,node,ids,are,assigned,in,graph,traversal,order,pre,order,hence,each,list,is,sorted,by,id,in,ascending,order,and,all,consecutive,lists,start,with,ids,in,ascending,order,param,mark,joined,branches,as,pipeline,breaking,true,if,the;protected,final,boolean,merge,lists,list,unclosed,branch,descriptor,child1open,list,unclosed,branch,descriptor,child2open,list,unclosed,branch,descriptor,result,boolean,mark,joined,branches,as,pipeline,breaking,remove,closed,branches,child1open,remove,closed,branches,child2open,result,clear,if,child1open,null,child1open,is,empty,if,child2open,null,child2open,is,empty,result,add,all,child2open,return,false,if,child2open,null,child2open,is,empty,result,add,all,child1open,return,false,int,index1,child1open,size,1,int,index2,child2open,size,1,boolean,did,close,abranch,false,while,index1,0,index2,0,int,id1,1,int,id2,index2,0,child2open,get,index2,get,branching,node,get,id,1,while,index1,0,id1,child1open,get,index1,get,branching,node,get,id,id2,result,add,child1open,get,index1,index1,while,index2,0,id2,child2open,get,index2,get,branching,node,get,id,id1,result,add,child2open,get,index2,index2,if,id1,id2,did,close,abranch,true,optimizer,node,curr,banching,node,child1open,get,index1,get,branching,node,long,vector1,child1open,get,index1,get,joined,paths,vector,long,vector2,child2open,get,index2,get,joined,paths,vector,if,vector1,vector2,result,add,child1open,get,index1,else,if,mark,joined,branches,as,pipeline,breaking,curr,banching,node,mark,all,outgoing,connections,as,pipeline,breaking,if,this,here,joined,branches,null,this,here,joined,branches,new,array,list,optimizer,node,2,this,here,joined,branches,add,curr,banching,node,long,joined,inputs,vector1,vector2,long,all,inputs,0x1l,curr,banching,node,get,outgoing,connections,size,1,if,joined,inputs,all,inputs,add,closed,branch,curr,banching,node,else,result,add,new,unclosed,branch,descriptor,curr,banching,node,joined,inputs,index1,index2,collections,reverse,result,return,did,close,abranch
OptimizerNode -> protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open, 										List<UnclosedBranchDescriptor> child2open, 										List<UnclosedBranchDescriptor> result, 										boolean markJoinedBranchesAsPipelineBreaking);1460563153;The node IDs are assigned in graph-traversal order (pre-order), hence, each list is_sorted by ID in ascending order and all consecutive lists start with IDs in ascending order.__@param markJoinedBranchesAsPipelineBreaking True, if the;protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open,_										List<UnclosedBranchDescriptor> child2open,_										List<UnclosedBranchDescriptor> result,_										boolean markJoinedBranchesAsPipelineBreaking) {__		_		removeClosedBranches(child1open)__		removeClosedBranches(child2open)__		_		result.clear()__		_		_		_		_		_		if (child1open == null || child1open.isEmpty()) {_			if(child2open != null && !child2open.isEmpty()) {_				result.addAll(child2open)__			}_			return false__		}_		_		if (child2open == null || child2open.isEmpty()) {_			result.addAll(child1open)__			return false__		}__		int index1 = child1open.size() - 1__		int index2 = child2open.size() - 1__		_		boolean didCloseABranch = false___		_		_		_		while (index1 >= 0 || index2 >= 0) {_			int id1 = -1__			int id2 = index2 >= 0 ? child2open.get(index2).getBranchingNode().getId() : -1___			while (index1 >= 0 && (id1 = child1open.get(index1).getBranchingNode().getId()) > id2) {_				result.add(child1open.get(index1))__				index1--__			}_			while (index2 >= 0 && (id2 = child2open.get(index2).getBranchingNode().getId()) > id1) {_				result.add(child2open.get(index2))__				index2--__			}__			_			if (id1 == id2) {_				didCloseABranch = true__				_				_				OptimizerNode currBanchingNode = child1open.get(index1).getBranchingNode()__				_				long vector1 = child1open.get(index1).getJoinedPathsVector()__				long vector2 = child2open.get(index2).getJoinedPathsVector()__				_				_				_				if (vector1 == vector2) {_					result.add(child1open.get(index1))__				}_				else {_					__					_					if (markJoinedBranchesAsPipelineBreaking) {_						currBanchingNode.markAllOutgoingConnectionsAsPipelineBreaking()__					}__					if (this.hereJoinedBranches == null) {_						this.hereJoinedBranches = new ArrayList<OptimizerNode>(2)__					}_					this.hereJoinedBranches.add(currBanchingNode)___					_					long joinedInputs = vector1 | vector2___					_					long allInputs = (0x1L << currBanchingNode.getOutgoingConnections().size()) - 1___					if (joinedInputs == allInputs) {_						_						addClosedBranch(currBanchingNode)__					} else {_						_						result.add(new UnclosedBranchDescriptor(currBanchingNode, joinedInputs))__					}_				}__				index1--__				index2--__			}_		}__		_		Collections.reverse(result)__		return didCloseABranch__	};the,node,ids,are,assigned,in,graph,traversal,order,pre,order,hence,each,list,is,sorted,by,id,in,ascending,order,and,all,consecutive,lists,start,with,ids,in,ascending,order,param,mark,joined,branches,as,pipeline,breaking,true,if,the;protected,final,boolean,merge,lists,list,unclosed,branch,descriptor,child1open,list,unclosed,branch,descriptor,child2open,list,unclosed,branch,descriptor,result,boolean,mark,joined,branches,as,pipeline,breaking,remove,closed,branches,child1open,remove,closed,branches,child2open,result,clear,if,child1open,null,child1open,is,empty,if,child2open,null,child2open,is,empty,result,add,all,child2open,return,false,if,child2open,null,child2open,is,empty,result,add,all,child1open,return,false,int,index1,child1open,size,1,int,index2,child2open,size,1,boolean,did,close,abranch,false,while,index1,0,index2,0,int,id1,1,int,id2,index2,0,child2open,get,index2,get,branching,node,get,id,1,while,index1,0,id1,child1open,get,index1,get,branching,node,get,id,id2,result,add,child1open,get,index1,index1,while,index2,0,id2,child2open,get,index2,get,branching,node,get,id,id1,result,add,child2open,get,index2,index2,if,id1,id2,did,close,abranch,true,optimizer,node,curr,banching,node,child1open,get,index1,get,branching,node,long,vector1,child1open,get,index1,get,joined,paths,vector,long,vector2,child2open,get,index2,get,joined,paths,vector,if,vector1,vector2,result,add,child1open,get,index1,else,if,mark,joined,branches,as,pipeline,breaking,curr,banching,node,mark,all,outgoing,connections,as,pipeline,breaking,if,this,here,joined,branches,null,this,here,joined,branches,new,array,list,optimizer,node,2,this,here,joined,branches,add,curr,banching,node,long,joined,inputs,vector1,vector2,long,all,inputs,0x1l,curr,banching,node,get,outgoing,connections,size,1,if,joined,inputs,all,inputs,add,closed,branch,curr,banching,node,else,result,add,new,unclosed,branch,descriptor,curr,banching,node,joined,inputs,index1,index2,collections,reverse,result,return,did,close,abranch
OptimizerNode -> protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open, 										List<UnclosedBranchDescriptor> child2open, 										List<UnclosedBranchDescriptor> result, 										boolean markJoinedBranchesAsPipelineBreaking);1546180287;The node IDs are assigned in graph-traversal order (pre-order), hence, each list is_sorted by ID in ascending order and all consecutive lists start with IDs in ascending order.__@param markJoinedBranchesAsPipelineBreaking True, if the;protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open,_										List<UnclosedBranchDescriptor> child2open,_										List<UnclosedBranchDescriptor> result,_										boolean markJoinedBranchesAsPipelineBreaking) {__		_		removeClosedBranches(child1open)__		removeClosedBranches(child2open)__		_		result.clear()__		_		_		_		_		_		if (child1open == null || child1open.isEmpty()) {_			if(child2open != null && !child2open.isEmpty()) {_				result.addAll(child2open)__			}_			return false__		}_		_		if (child2open == null || child2open.isEmpty()) {_			result.addAll(child1open)__			return false__		}__		int index1 = child1open.size() - 1__		int index2 = child2open.size() - 1__		_		boolean didCloseABranch = false___		_		_		_		while (index1 >= 0 || index2 >= 0) {_			int id1 = -1__			int id2 = index2 >= 0 ? child2open.get(index2).getBranchingNode().getId() : -1___			while (index1 >= 0 && (id1 = child1open.get(index1).getBranchingNode().getId()) > id2) {_				result.add(child1open.get(index1))__				index1--__			}_			while (index2 >= 0 && (id2 = child2open.get(index2).getBranchingNode().getId()) > id1) {_				result.add(child2open.get(index2))__				index2--__			}__			_			if (id1 == id2) {_				didCloseABranch = true__				_				_				OptimizerNode currBanchingNode = child1open.get(index1).getBranchingNode()__				_				long vector1 = child1open.get(index1).getJoinedPathsVector()__				long vector2 = child2open.get(index2).getJoinedPathsVector()__				_				_				_				if (vector1 == vector2) {_					result.add(child1open.get(index1))__				}_				else {_					__					_					if (markJoinedBranchesAsPipelineBreaking) {_						currBanchingNode.markAllOutgoingConnectionsAsPipelineBreaking()__					}__					if (this.hereJoinedBranches == null) {_						this.hereJoinedBranches = new ArrayList<OptimizerNode>(2)__					}_					this.hereJoinedBranches.add(currBanchingNode)___					_					long joinedInputs = vector1 | vector2___					_					long allInputs = (0x1L << currBanchingNode.getOutgoingConnections().size()) - 1___					if (joinedInputs == allInputs) {_						_						addClosedBranch(currBanchingNode)__					} else {_						_						result.add(new UnclosedBranchDescriptor(currBanchingNode, joinedInputs))__					}_				}__				index1--__				index2--__			}_		}__		_		Collections.reverse(result)__		return didCloseABranch__	};the,node,ids,are,assigned,in,graph,traversal,order,pre,order,hence,each,list,is,sorted,by,id,in,ascending,order,and,all,consecutive,lists,start,with,ids,in,ascending,order,param,mark,joined,branches,as,pipeline,breaking,true,if,the;protected,final,boolean,merge,lists,list,unclosed,branch,descriptor,child1open,list,unclosed,branch,descriptor,child2open,list,unclosed,branch,descriptor,result,boolean,mark,joined,branches,as,pipeline,breaking,remove,closed,branches,child1open,remove,closed,branches,child2open,result,clear,if,child1open,null,child1open,is,empty,if,child2open,null,child2open,is,empty,result,add,all,child2open,return,false,if,child2open,null,child2open,is,empty,result,add,all,child1open,return,false,int,index1,child1open,size,1,int,index2,child2open,size,1,boolean,did,close,abranch,false,while,index1,0,index2,0,int,id1,1,int,id2,index2,0,child2open,get,index2,get,branching,node,get,id,1,while,index1,0,id1,child1open,get,index1,get,branching,node,get,id,id2,result,add,child1open,get,index1,index1,while,index2,0,id2,child2open,get,index2,get,branching,node,get,id,id1,result,add,child2open,get,index2,index2,if,id1,id2,did,close,abranch,true,optimizer,node,curr,banching,node,child1open,get,index1,get,branching,node,long,vector1,child1open,get,index1,get,joined,paths,vector,long,vector2,child2open,get,index2,get,joined,paths,vector,if,vector1,vector2,result,add,child1open,get,index1,else,if,mark,joined,branches,as,pipeline,breaking,curr,banching,node,mark,all,outgoing,connections,as,pipeline,breaking,if,this,here,joined,branches,null,this,here,joined,branches,new,array,list,optimizer,node,2,this,here,joined,branches,add,curr,banching,node,long,joined,inputs,vector1,vector2,long,all,inputs,0x1l,curr,banching,node,get,outgoing,connections,size,1,if,joined,inputs,all,inputs,add,closed,branch,curr,banching,node,else,result,add,new,unclosed,branch,descriptor,curr,banching,node,joined,inputs,index1,index2,collections,reverse,result,return,did,close,abranch
OptimizerNode -> public InterestingProperties getInterestingProperties();1426843274;Gets the properties that are interesting for this node to produce.__@return The interesting properties for this node, or null, if not yet computed.;public InterestingProperties getInterestingProperties() {_		return this.intProps__	};gets,the,properties,that,are,interesting,for,this,node,to,produce,return,the,interesting,properties,for,this,node,or,null,if,not,yet,computed;public,interesting,properties,get,interesting,properties,return,this,int,props
OptimizerNode -> public InterestingProperties getInterestingProperties();1427097830;Gets the properties that are interesting for this node to produce.__@return The interesting properties for this node, or null, if not yet computed.;public InterestingProperties getInterestingProperties() {_		return this.intProps__	};gets,the,properties,that,are,interesting,for,this,node,to,produce,return,the,interesting,properties,for,this,node,or,null,if,not,yet,computed;public,interesting,properties,get,interesting,properties,return,this,int,props
OptimizerNode -> public InterestingProperties getInterestingProperties();1431981454;Gets the properties that are interesting for this node to produce.__@return The interesting properties for this node, or null, if not yet computed.;public InterestingProperties getInterestingProperties() {_		return this.intProps__	};gets,the,properties,that,are,interesting,for,this,node,to,produce,return,the,interesting,properties,for,this,node,or,null,if,not,yet,computed;public,interesting,properties,get,interesting,properties,return,this,int,props
OptimizerNode -> public InterestingProperties getInterestingProperties();1442492509;Gets the properties that are interesting for this node to produce.__@return The interesting properties for this node, or null, if not yet computed.;public InterestingProperties getInterestingProperties() {_		return this.intProps__	};gets,the,properties,that,are,interesting,for,this,node,to,produce,return,the,interesting,properties,for,this,node,or,null,if,not,yet,computed;public,interesting,properties,get,interesting,properties,return,this,int,props
OptimizerNode -> public InterestingProperties getInterestingProperties();1446112342;Gets the properties that are interesting for this node to produce.__@return The interesting properties for this node, or null, if not yet computed.;public InterestingProperties getInterestingProperties() {_		return this.intProps__	};gets,the,properties,that,are,interesting,for,this,node,to,produce,return,the,interesting,properties,for,this,node,or,null,if,not,yet,computed;public,interesting,properties,get,interesting,properties,return,this,int,props
OptimizerNode -> public InterestingProperties getInterestingProperties();1460563153;Gets the properties that are interesting for this node to produce.__@return The interesting properties for this node, or null, if not yet computed.;public InterestingProperties getInterestingProperties() {_		return this.intProps__	};gets,the,properties,that,are,interesting,for,this,node,to,produce,return,the,interesting,properties,for,this,node,or,null,if,not,yet,computed;public,interesting,properties,get,interesting,properties,return,this,int,props
OptimizerNode -> public InterestingProperties getInterestingProperties();1546180287;Gets the properties that are interesting for this node to produce.__@return The interesting properties for this node, or null, if not yet computed.;public InterestingProperties getInterestingProperties() {_		return this.intProps__	};gets,the,properties,that,are,interesting,for,this,node,to,produce,return,the,interesting,properties,for,this,node,or,null,if,not,yet,computed;public,interesting,properties,get,interesting,properties,return,this,int,props
OptimizerNode -> protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2);1426843274;Checks whether to candidate plans for the sub-plan of this node are comparable. The two_alternative plans are comparable, if__a) There is no branch in the sub-plan of this node_b) Both candidates have the same candidate as the child at the last open branch.__@param plan1 The root node of the first candidate plan._@param plan2 The root node of the second candidate plan._@return True if the nodes are branch compatible in the inputs.;protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2) {_		if (plan1 == null || plan2 == null) {_			throw new NullPointerException()__		}_		_		_		_		if (this.hereJoinedBranches == null || this.hereJoinedBranches.isEmpty()) {_			return true__		}__		for (OptimizerNode joinedBrancher : hereJoinedBranches) {_			final PlanNode branch1Cand = plan1.getCandidateAtBranchPoint(joinedBrancher)__			final PlanNode branch2Cand = plan2.getCandidateAtBranchPoint(joinedBrancher)__			_			if (branch1Cand != null && branch2Cand != null && branch1Cand != branch2Cand) {_				return false__			}_		}_		return true__	};checks,whether,to,candidate,plans,for,the,sub,plan,of,this,node,are,comparable,the,two,alternative,plans,are,comparable,if,a,there,is,no,branch,in,the,sub,plan,of,this,node,b,both,candidates,have,the,same,candidate,as,the,child,at,the,last,open,branch,param,plan1,the,root,node,of,the,first,candidate,plan,param,plan2,the,root,node,of,the,second,candidate,plan,return,true,if,the,nodes,are,branch,compatible,in,the,inputs;protected,boolean,are,branch,compatible,plan,node,plan1,plan,node,plan2,if,plan1,null,plan2,null,throw,new,null,pointer,exception,if,this,here,joined,branches,null,this,here,joined,branches,is,empty,return,true,for,optimizer,node,joined,brancher,here,joined,branches,final,plan,node,branch1cand,plan1,get,candidate,at,branch,point,joined,brancher,final,plan,node,branch2cand,plan2,get,candidate,at,branch,point,joined,brancher,if,branch1cand,null,branch2cand,null,branch1cand,branch2cand,return,false,return,true
OptimizerNode -> protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2);1427097830;Checks whether to candidate plans for the sub-plan of this node are comparable. The two_alternative plans are comparable, if__a) There is no branch in the sub-plan of this node_b) Both candidates have the same candidate as the child at the last open branch.__@param plan1 The root node of the first candidate plan._@param plan2 The root node of the second candidate plan._@return True if the nodes are branch compatible in the inputs.;protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2) {_		if (plan1 == null || plan2 == null) {_			throw new NullPointerException()__		}_		_		_		_		if (this.hereJoinedBranches == null || this.hereJoinedBranches.isEmpty()) {_			return true__		}__		for (OptimizerNode joinedBrancher : hereJoinedBranches) {_			final PlanNode branch1Cand = plan1.getCandidateAtBranchPoint(joinedBrancher)__			final PlanNode branch2Cand = plan2.getCandidateAtBranchPoint(joinedBrancher)__			_			if (branch1Cand != null && branch2Cand != null && branch1Cand != branch2Cand) {_				return false__			}_		}_		return true__	};checks,whether,to,candidate,plans,for,the,sub,plan,of,this,node,are,comparable,the,two,alternative,plans,are,comparable,if,a,there,is,no,branch,in,the,sub,plan,of,this,node,b,both,candidates,have,the,same,candidate,as,the,child,at,the,last,open,branch,param,plan1,the,root,node,of,the,first,candidate,plan,param,plan2,the,root,node,of,the,second,candidate,plan,return,true,if,the,nodes,are,branch,compatible,in,the,inputs;protected,boolean,are,branch,compatible,plan,node,plan1,plan,node,plan2,if,plan1,null,plan2,null,throw,new,null,pointer,exception,if,this,here,joined,branches,null,this,here,joined,branches,is,empty,return,true,for,optimizer,node,joined,brancher,here,joined,branches,final,plan,node,branch1cand,plan1,get,candidate,at,branch,point,joined,brancher,final,plan,node,branch2cand,plan2,get,candidate,at,branch,point,joined,brancher,if,branch1cand,null,branch2cand,null,branch1cand,branch2cand,return,false,return,true
OptimizerNode -> protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2);1431981454;Checks whether to candidate plans for the sub-plan of this node are comparable. The two_alternative plans are comparable, if__a) There is no branch in the sub-plan of this node_b) Both candidates have the same candidate as the child at the last open branch.__@param plan1 The root node of the first candidate plan._@param plan2 The root node of the second candidate plan._@return True if the nodes are branch compatible in the inputs.;protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2) {_		if (plan1 == null || plan2 == null) {_			throw new NullPointerException()__		}_		_		_		_		if (this.hereJoinedBranches == null || this.hereJoinedBranches.isEmpty()) {_			return true__		}__		for (OptimizerNode joinedBrancher : hereJoinedBranches) {_			final PlanNode branch1Cand = plan1.getCandidateAtBranchPoint(joinedBrancher)__			final PlanNode branch2Cand = plan2.getCandidateAtBranchPoint(joinedBrancher)__			_			if (branch1Cand != null && branch2Cand != null && branch1Cand != branch2Cand) {_				return false__			}_		}_		return true__	};checks,whether,to,candidate,plans,for,the,sub,plan,of,this,node,are,comparable,the,two,alternative,plans,are,comparable,if,a,there,is,no,branch,in,the,sub,plan,of,this,node,b,both,candidates,have,the,same,candidate,as,the,child,at,the,last,open,branch,param,plan1,the,root,node,of,the,first,candidate,plan,param,plan2,the,root,node,of,the,second,candidate,plan,return,true,if,the,nodes,are,branch,compatible,in,the,inputs;protected,boolean,are,branch,compatible,plan,node,plan1,plan,node,plan2,if,plan1,null,plan2,null,throw,new,null,pointer,exception,if,this,here,joined,branches,null,this,here,joined,branches,is,empty,return,true,for,optimizer,node,joined,brancher,here,joined,branches,final,plan,node,branch1cand,plan1,get,candidate,at,branch,point,joined,brancher,final,plan,node,branch2cand,plan2,get,candidate,at,branch,point,joined,brancher,if,branch1cand,null,branch2cand,null,branch1cand,branch2cand,return,false,return,true
OptimizerNode -> protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2);1442492509;Checks whether to candidate plans for the sub-plan of this node are comparable. The two_alternative plans are comparable, if__a) There is no branch in the sub-plan of this node_b) Both candidates have the same candidate as the child at the last open branch.__@param plan1 The root node of the first candidate plan._@param plan2 The root node of the second candidate plan._@return True if the nodes are branch compatible in the inputs.;protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2) {_		if (plan1 == null || plan2 == null) {_			throw new NullPointerException()__		}_		_		_		_		if (this.hereJoinedBranches == null || this.hereJoinedBranches.isEmpty()) {_			return true__		}__		for (OptimizerNode joinedBrancher : hereJoinedBranches) {_			final PlanNode branch1Cand = plan1.getCandidateAtBranchPoint(joinedBrancher)__			final PlanNode branch2Cand = plan2.getCandidateAtBranchPoint(joinedBrancher)__			_			if (branch1Cand != null && branch2Cand != null && branch1Cand != branch2Cand) {_				return false__			}_		}_		return true__	};checks,whether,to,candidate,plans,for,the,sub,plan,of,this,node,are,comparable,the,two,alternative,plans,are,comparable,if,a,there,is,no,branch,in,the,sub,plan,of,this,node,b,both,candidates,have,the,same,candidate,as,the,child,at,the,last,open,branch,param,plan1,the,root,node,of,the,first,candidate,plan,param,plan2,the,root,node,of,the,second,candidate,plan,return,true,if,the,nodes,are,branch,compatible,in,the,inputs;protected,boolean,are,branch,compatible,plan,node,plan1,plan,node,plan2,if,plan1,null,plan2,null,throw,new,null,pointer,exception,if,this,here,joined,branches,null,this,here,joined,branches,is,empty,return,true,for,optimizer,node,joined,brancher,here,joined,branches,final,plan,node,branch1cand,plan1,get,candidate,at,branch,point,joined,brancher,final,plan,node,branch2cand,plan2,get,candidate,at,branch,point,joined,brancher,if,branch1cand,null,branch2cand,null,branch1cand,branch2cand,return,false,return,true
OptimizerNode -> protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2);1446112342;Checks whether to candidate plans for the sub-plan of this node are comparable. The two_alternative plans are comparable, if__a) There is no branch in the sub-plan of this node_b) Both candidates have the same candidate as the child at the last open branch.__@param plan1 The root node of the first candidate plan._@param plan2 The root node of the second candidate plan._@return True if the nodes are branch compatible in the inputs.;protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2) {_		if (plan1 == null || plan2 == null) {_			throw new NullPointerException()__		}_		_		_		_		if (this.hereJoinedBranches == null || this.hereJoinedBranches.isEmpty()) {_			return true__		}__		for (OptimizerNode joinedBrancher : hereJoinedBranches) {_			final PlanNode branch1Cand = plan1.getCandidateAtBranchPoint(joinedBrancher)__			final PlanNode branch2Cand = plan2.getCandidateAtBranchPoint(joinedBrancher)__			_			if (branch1Cand != null && branch2Cand != null && branch1Cand != branch2Cand) {_				return false__			}_		}_		return true__	};checks,whether,to,candidate,plans,for,the,sub,plan,of,this,node,are,comparable,the,two,alternative,plans,are,comparable,if,a,there,is,no,branch,in,the,sub,plan,of,this,node,b,both,candidates,have,the,same,candidate,as,the,child,at,the,last,open,branch,param,plan1,the,root,node,of,the,first,candidate,plan,param,plan2,the,root,node,of,the,second,candidate,plan,return,true,if,the,nodes,are,branch,compatible,in,the,inputs;protected,boolean,are,branch,compatible,plan,node,plan1,plan,node,plan2,if,plan1,null,plan2,null,throw,new,null,pointer,exception,if,this,here,joined,branches,null,this,here,joined,branches,is,empty,return,true,for,optimizer,node,joined,brancher,here,joined,branches,final,plan,node,branch1cand,plan1,get,candidate,at,branch,point,joined,brancher,final,plan,node,branch2cand,plan2,get,candidate,at,branch,point,joined,brancher,if,branch1cand,null,branch2cand,null,branch1cand,branch2cand,return,false,return,true
OptimizerNode -> protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2);1460563153;Checks whether to candidate plans for the sub-plan of this node are comparable. The two_alternative plans are comparable, if__a) There is no branch in the sub-plan of this node_b) Both candidates have the same candidate as the child at the last open branch.__@param plan1 The root node of the first candidate plan._@param plan2 The root node of the second candidate plan._@return True if the nodes are branch compatible in the inputs.;protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2) {_		if (plan1 == null || plan2 == null) {_			throw new NullPointerException()__		}_		_		_		_		if (this.hereJoinedBranches == null || this.hereJoinedBranches.isEmpty()) {_			return true__		}__		for (OptimizerNode joinedBrancher : hereJoinedBranches) {_			final PlanNode branch1Cand = plan1.getCandidateAtBranchPoint(joinedBrancher)__			final PlanNode branch2Cand = plan2.getCandidateAtBranchPoint(joinedBrancher)__			_			if (branch1Cand != null && branch2Cand != null && branch1Cand != branch2Cand) {_				return false__			}_		}_		return true__	};checks,whether,to,candidate,plans,for,the,sub,plan,of,this,node,are,comparable,the,two,alternative,plans,are,comparable,if,a,there,is,no,branch,in,the,sub,plan,of,this,node,b,both,candidates,have,the,same,candidate,as,the,child,at,the,last,open,branch,param,plan1,the,root,node,of,the,first,candidate,plan,param,plan2,the,root,node,of,the,second,candidate,plan,return,true,if,the,nodes,are,branch,compatible,in,the,inputs;protected,boolean,are,branch,compatible,plan,node,plan1,plan,node,plan2,if,plan1,null,plan2,null,throw,new,null,pointer,exception,if,this,here,joined,branches,null,this,here,joined,branches,is,empty,return,true,for,optimizer,node,joined,brancher,here,joined,branches,final,plan,node,branch1cand,plan1,get,candidate,at,branch,point,joined,brancher,final,plan,node,branch2cand,plan2,get,candidate,at,branch,point,joined,brancher,if,branch1cand,null,branch2cand,null,branch1cand,branch2cand,return,false,return,true
OptimizerNode -> protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2);1546180287;Checks whether to candidate plans for the sub-plan of this node are comparable. The two_alternative plans are comparable, if__a) There is no branch in the sub-plan of this node_b) Both candidates have the same candidate as the child at the last open branch.__@param plan1 The root node of the first candidate plan._@param plan2 The root node of the second candidate plan._@return True if the nodes are branch compatible in the inputs.;protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2) {_		if (plan1 == null || plan2 == null) {_			throw new NullPointerException()__		}_		_		_		_		if (this.hereJoinedBranches == null || this.hereJoinedBranches.isEmpty()) {_			return true__		}__		for (OptimizerNode joinedBrancher : hereJoinedBranches) {_			final PlanNode branch1Cand = plan1.getCandidateAtBranchPoint(joinedBrancher)__			final PlanNode branch2Cand = plan2.getCandidateAtBranchPoint(joinedBrancher)__			_			if (branch1Cand != null && branch2Cand != null && branch1Cand != branch2Cand) {_				return false__			}_		}_		return true__	};checks,whether,to,candidate,plans,for,the,sub,plan,of,this,node,are,comparable,the,two,alternative,plans,are,comparable,if,a,there,is,no,branch,in,the,sub,plan,of,this,node,b,both,candidates,have,the,same,candidate,as,the,child,at,the,last,open,branch,param,plan1,the,root,node,of,the,first,candidate,plan,param,plan2,the,root,node,of,the,second,candidate,plan,return,true,if,the,nodes,are,branch,compatible,in,the,inputs;protected,boolean,are,branch,compatible,plan,node,plan1,plan,node,plan2,if,plan1,null,plan2,null,throw,new,null,pointer,exception,if,this,here,joined,branches,null,this,here,joined,branches,is,empty,return,true,for,optimizer,node,joined,brancher,here,joined,branches,final,plan,node,branch1cand,plan1,get,candidate,at,branch,point,joined,brancher,final,plan,node,branch2cand,plan2,get,candidate,at,branch,point,joined,brancher,if,branch1cand,null,branch2cand,null,branch1cand,branch2cand,return,false,return,true
OptimizerNode -> public Set<FieldSet> getUniqueFields();1426843274;Gets the FieldSets which are unique in the output of the node.;public Set<FieldSet> getUniqueFields() {_		return this.uniqueFields == null ? Collections.<FieldSet>emptySet() : this.uniqueFields__	};gets,the,field,sets,which,are,unique,in,the,output,of,the,node;public,set,field,set,get,unique,fields,return,this,unique,fields,null,collections,field,set,empty,set,this,unique,fields
OptimizerNode -> public Set<FieldSet> getUniqueFields();1427097830;Gets the FieldSets which are unique in the output of the node.;public Set<FieldSet> getUniqueFields() {_		return this.uniqueFields == null ? Collections.<FieldSet>emptySet() : this.uniqueFields__	};gets,the,field,sets,which,are,unique,in,the,output,of,the,node;public,set,field,set,get,unique,fields,return,this,unique,fields,null,collections,field,set,empty,set,this,unique,fields
OptimizerNode -> public Set<FieldSet> getUniqueFields();1431981454;Gets the FieldSets which are unique in the output of the node.;public Set<FieldSet> getUniqueFields() {_		return this.uniqueFields == null ? Collections.<FieldSet>emptySet() : this.uniqueFields__	};gets,the,field,sets,which,are,unique,in,the,output,of,the,node;public,set,field,set,get,unique,fields,return,this,unique,fields,null,collections,field,set,empty,set,this,unique,fields
OptimizerNode -> public Set<FieldSet> getUniqueFields();1442492509;Gets the FieldSets which are unique in the output of the node.;public Set<FieldSet> getUniqueFields() {_		return this.uniqueFields == null ? Collections.<FieldSet>emptySet() : this.uniqueFields__	};gets,the,field,sets,which,are,unique,in,the,output,of,the,node;public,set,field,set,get,unique,fields,return,this,unique,fields,null,collections,field,set,empty,set,this,unique,fields
OptimizerNode -> public Set<FieldSet> getUniqueFields();1446112342;Gets the FieldSets which are unique in the output of the node.;public Set<FieldSet> getUniqueFields() {_		return this.uniqueFields == null ? Collections.<FieldSet>emptySet() : this.uniqueFields__	};gets,the,field,sets,which,are,unique,in,the,output,of,the,node;public,set,field,set,get,unique,fields,return,this,unique,fields,null,collections,field,set,empty,set,this,unique,fields
OptimizerNode -> public Set<FieldSet> getUniqueFields();1460563153;Gets the FieldSets which are unique in the output of the node.;public Set<FieldSet> getUniqueFields() {_		return this.uniqueFields == null ? Collections.<FieldSet>emptySet() : this.uniqueFields__	};gets,the,field,sets,which,are,unique,in,the,output,of,the,node;public,set,field,set,get,unique,fields,return,this,unique,fields,null,collections,field,set,empty,set,this,unique,fields
OptimizerNode -> public Set<FieldSet> getUniqueFields();1546180287;Gets the FieldSets which are unique in the output of the node.;public Set<FieldSet> getUniqueFields() {_		return this.uniqueFields == null ? Collections.<FieldSet>emptySet() : this.uniqueFields__	};gets,the,field,sets,which,are,unique,in,the,output,of,the,node;public,set,field,set,get,unique,fields,return,this,unique,fields,null,collections,field,set,empty,set,this,unique,fields
OptimizerNode -> public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;1426843274;Computes the plan alternatives for this node, an implicitly for all nodes that are children of_this node. This method must determine for each alternative the global and local properties_and the costs. This method may recursively call <code>getAlternatives()</code> on its children_to get their plan alternatives, and build its own alternatives on top of those.__@param estimator_The cost estimator used to estimate the costs of each plan alternative._@return A list containing all plan alternatives.;public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;computes,the,plan,alternatives,for,this,node,an,implicitly,for,all,nodes,that,are,children,of,this,node,this,method,must,determine,for,each,alternative,the,global,and,local,properties,and,the,costs,this,method,may,recursively,call,code,get,alternatives,code,on,its,children,to,get,their,plan,alternatives,and,build,its,own,alternatives,on,top,of,those,param,estimator,the,cost,estimator,used,to,estimate,the,costs,of,each,plan,alternative,return,a,list,containing,all,plan,alternatives;public,abstract,list,plan,node,get,alternative,plans,cost,estimator,estimator
OptimizerNode -> public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;1427097830;Computes the plan alternatives for this node, an implicitly for all nodes that are children of_this node. This method must determine for each alternative the global and local properties_and the costs. This method may recursively call <code>getAlternatives()</code> on its children_to get their plan alternatives, and build its own alternatives on top of those.__@param estimator_The cost estimator used to estimate the costs of each plan alternative._@return A list containing all plan alternatives.;public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;computes,the,plan,alternatives,for,this,node,an,implicitly,for,all,nodes,that,are,children,of,this,node,this,method,must,determine,for,each,alternative,the,global,and,local,properties,and,the,costs,this,method,may,recursively,call,code,get,alternatives,code,on,its,children,to,get,their,plan,alternatives,and,build,its,own,alternatives,on,top,of,those,param,estimator,the,cost,estimator,used,to,estimate,the,costs,of,each,plan,alternative,return,a,list,containing,all,plan,alternatives;public,abstract,list,plan,node,get,alternative,plans,cost,estimator,estimator
OptimizerNode -> public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;1431981454;Computes the plan alternatives for this node, an implicitly for all nodes that are children of_this node. This method must determine for each alternative the global and local properties_and the costs. This method may recursively call <code>getAlternatives()</code> on its children_to get their plan alternatives, and build its own alternatives on top of those.__@param estimator_The cost estimator used to estimate the costs of each plan alternative._@return A list containing all plan alternatives.;public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;computes,the,plan,alternatives,for,this,node,an,implicitly,for,all,nodes,that,are,children,of,this,node,this,method,must,determine,for,each,alternative,the,global,and,local,properties,and,the,costs,this,method,may,recursively,call,code,get,alternatives,code,on,its,children,to,get,their,plan,alternatives,and,build,its,own,alternatives,on,top,of,those,param,estimator,the,cost,estimator,used,to,estimate,the,costs,of,each,plan,alternative,return,a,list,containing,all,plan,alternatives;public,abstract,list,plan,node,get,alternative,plans,cost,estimator,estimator
OptimizerNode -> public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;1442492509;Computes the plan alternatives for this node, an implicitly for all nodes that are children of_this node. This method must determine for each alternative the global and local properties_and the costs. This method may recursively call <code>getAlternatives()</code> on its children_to get their plan alternatives, and build its own alternatives on top of those.__@param estimator_The cost estimator used to estimate the costs of each plan alternative._@return A list containing all plan alternatives.;public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;computes,the,plan,alternatives,for,this,node,an,implicitly,for,all,nodes,that,are,children,of,this,node,this,method,must,determine,for,each,alternative,the,global,and,local,properties,and,the,costs,this,method,may,recursively,call,code,get,alternatives,code,on,its,children,to,get,their,plan,alternatives,and,build,its,own,alternatives,on,top,of,those,param,estimator,the,cost,estimator,used,to,estimate,the,costs,of,each,plan,alternative,return,a,list,containing,all,plan,alternatives;public,abstract,list,plan,node,get,alternative,plans,cost,estimator,estimator
OptimizerNode -> public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;1446112342;Computes the plan alternatives for this node, an implicitly for all nodes that are children of_this node. This method must determine for each alternative the global and local properties_and the costs. This method may recursively call <code>getAlternatives()</code> on its children_to get their plan alternatives, and build its own alternatives on top of those.__@param estimator_The cost estimator used to estimate the costs of each plan alternative._@return A list containing all plan alternatives.;public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;computes,the,plan,alternatives,for,this,node,an,implicitly,for,all,nodes,that,are,children,of,this,node,this,method,must,determine,for,each,alternative,the,global,and,local,properties,and,the,costs,this,method,may,recursively,call,code,get,alternatives,code,on,its,children,to,get,their,plan,alternatives,and,build,its,own,alternatives,on,top,of,those,param,estimator,the,cost,estimator,used,to,estimate,the,costs,of,each,plan,alternative,return,a,list,containing,all,plan,alternatives;public,abstract,list,plan,node,get,alternative,plans,cost,estimator,estimator
OptimizerNode -> public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;1460563153;Computes the plan alternatives for this node, an implicitly for all nodes that are children of_this node. This method must determine for each alternative the global and local properties_and the costs. This method may recursively call <code>getAlternatives()</code> on its children_to get their plan alternatives, and build its own alternatives on top of those.__@param estimator_The cost estimator used to estimate the costs of each plan alternative._@return A list containing all plan alternatives.;public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;computes,the,plan,alternatives,for,this,node,an,implicitly,for,all,nodes,that,are,children,of,this,node,this,method,must,determine,for,each,alternative,the,global,and,local,properties,and,the,costs,this,method,may,recursively,call,code,get,alternatives,code,on,its,children,to,get,their,plan,alternatives,and,build,its,own,alternatives,on,top,of,those,param,estimator,the,cost,estimator,used,to,estimate,the,costs,of,each,plan,alternative,return,a,list,containing,all,plan,alternatives;public,abstract,list,plan,node,get,alternative,plans,cost,estimator,estimator
OptimizerNode -> public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;1546180287;Computes the plan alternatives for this node, an implicitly for all nodes that are children of_this node. This method must determine for each alternative the global and local properties_and the costs. This method may recursively call <code>getAlternatives()</code> on its children_to get their plan alternatives, and build its own alternatives on top of those.__@param estimator_The cost estimator used to estimate the costs of each plan alternative._@return A list containing all plan alternatives.;public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator)_;computes,the,plan,alternatives,for,this,node,an,implicitly,for,all,nodes,that,are,children,of,this,node,this,method,must,determine,for,each,alternative,the,global,and,local,properties,and,the,costs,this,method,may,recursively,call,code,get,alternatives,code,on,its,children,to,get,their,plan,alternatives,and,build,its,own,alternatives,on,top,of,those,param,estimator,the,cost,estimator,used,to,estimate,the,costs,of,each,plan,alternative,return,a,list,containing,all,plan,alternatives;public,abstract,list,plan,node,get,alternative,plans,cost,estimator,estimator
OptimizerNode -> public void addBroadcastConnection(String name, DagConnection broadcastConnection);1426843274;Adds the broadcast connection identified by the given {@code name} to this node.__@param broadcastConnection The connection to add.;public void addBroadcastConnection(String name, DagConnection broadcastConnection) {_		this.broadcastConnectionNames.add(name)__		this.broadcastConnections.add(broadcastConnection)__	};adds,the,broadcast,connection,identified,by,the,given,code,name,to,this,node,param,broadcast,connection,the,connection,to,add;public,void,add,broadcast,connection,string,name,dag,connection,broadcast,connection,this,broadcast,connection,names,add,name,this,broadcast,connections,add,broadcast,connection
OptimizerNode -> public void addBroadcastConnection(String name, DagConnection broadcastConnection);1427097830;Adds the broadcast connection identified by the given {@code name} to this node.__@param broadcastConnection The connection to add.;public void addBroadcastConnection(String name, DagConnection broadcastConnection) {_		this.broadcastConnectionNames.add(name)__		this.broadcastConnections.add(broadcastConnection)__	};adds,the,broadcast,connection,identified,by,the,given,code,name,to,this,node,param,broadcast,connection,the,connection,to,add;public,void,add,broadcast,connection,string,name,dag,connection,broadcast,connection,this,broadcast,connection,names,add,name,this,broadcast,connections,add,broadcast,connection
OptimizerNode -> public void addBroadcastConnection(String name, DagConnection broadcastConnection);1431981454;Adds the broadcast connection identified by the given {@code name} to this node.__@param broadcastConnection The connection to add.;public void addBroadcastConnection(String name, DagConnection broadcastConnection) {_		this.broadcastConnectionNames.add(name)__		this.broadcastConnections.add(broadcastConnection)__	};adds,the,broadcast,connection,identified,by,the,given,code,name,to,this,node,param,broadcast,connection,the,connection,to,add;public,void,add,broadcast,connection,string,name,dag,connection,broadcast,connection,this,broadcast,connection,names,add,name,this,broadcast,connections,add,broadcast,connection
OptimizerNode -> public void addBroadcastConnection(String name, DagConnection broadcastConnection);1442492509;Adds the broadcast connection identified by the given {@code name} to this node.__@param broadcastConnection The connection to add.;public void addBroadcastConnection(String name, DagConnection broadcastConnection) {_		this.broadcastConnectionNames.add(name)__		this.broadcastConnections.add(broadcastConnection)__	};adds,the,broadcast,connection,identified,by,the,given,code,name,to,this,node,param,broadcast,connection,the,connection,to,add;public,void,add,broadcast,connection,string,name,dag,connection,broadcast,connection,this,broadcast,connection,names,add,name,this,broadcast,connections,add,broadcast,connection
OptimizerNode -> public void addBroadcastConnection(String name, DagConnection broadcastConnection);1446112342;Adds the broadcast connection identified by the given {@code name} to this node.__@param broadcastConnection The connection to add.;public void addBroadcastConnection(String name, DagConnection broadcastConnection) {_		this.broadcastConnectionNames.add(name)__		this.broadcastConnections.add(broadcastConnection)__	};adds,the,broadcast,connection,identified,by,the,given,code,name,to,this,node,param,broadcast,connection,the,connection,to,add;public,void,add,broadcast,connection,string,name,dag,connection,broadcast,connection,this,broadcast,connection,names,add,name,this,broadcast,connections,add,broadcast,connection
OptimizerNode -> public void addBroadcastConnection(String name, DagConnection broadcastConnection);1460563153;Adds the broadcast connection identified by the given {@code name} to this node.__@param broadcastConnection The connection to add.;public void addBroadcastConnection(String name, DagConnection broadcastConnection) {_		this.broadcastConnectionNames.add(name)__		this.broadcastConnections.add(broadcastConnection)__	};adds,the,broadcast,connection,identified,by,the,given,code,name,to,this,node,param,broadcast,connection,the,connection,to,add;public,void,add,broadcast,connection,string,name,dag,connection,broadcast,connection,this,broadcast,connection,names,add,name,this,broadcast,connections,add,broadcast,connection
OptimizerNode -> public void addBroadcastConnection(String name, DagConnection broadcastConnection);1546180287;Adds the broadcast connection identified by the given {@code name} to this node.__@param broadcastConnection The connection to add.;public void addBroadcastConnection(String name, DagConnection broadcastConnection) {_		this.broadcastConnectionNames.add(name)__		this.broadcastConnections.add(broadcastConnection)__	};adds,the,broadcast,connection,identified,by,the,given,code,name,to,this,node,param,broadcast,connection,the,connection,to,add;public,void,add,broadcast,connection,string,name,dag,connection,broadcast,connection,this,broadcast,connection,names,add,name,this,broadcast,connections,add,broadcast,connection
OptimizerNode -> public void computeOutputEstimates(DataStatistics statistics);1426843274;Causes this node to compute its output estimates (such as number of rows, size in bytes)_based on the inputs and the compiler hints. The compiler hints are instantiated with conservative_default values which are used if no other values are provided. Nodes may access the statistics to_determine relevant information.__@param statistics_The statistics object which may be accessed to get statistical information._The parameter may be null, if no statistics are available.;public void computeOutputEstimates(DataStatistics statistics) {_		_		for (DagConnection c : getIncomingConnections()) {_			if (c.getSource() == null) {_				throw new CompilerException("Bug: Estimate computation called before inputs have been set.")__			}_		}_		_		_		computeOperatorSpecificDefaultEstimates(statistics)__		_		if (this.estimatedOutputSize < 0) {_			this.estimatedOutputSize = -1__		}_		if (this.estimatedNumRecords < 0) {_			this.estimatedNumRecords = -1__		}_		_		_		if (getOperator() == null || getOperator().getCompilerHints() == null) {_			return __		}_		_		CompilerHints hints = getOperator().getCompilerHints()__		if (hints.getOutputSize() >= 0) {_			this.estimatedOutputSize = hints.getOutputSize()__		}_		_		if (hints.getOutputCardinality() >= 0) {_			this.estimatedNumRecords = hints.getOutputCardinality()__		}_		_		if (hints.getFilterFactor() >= 0.0f) {_			if (this.estimatedNumRecords >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedNumRecords * hints.getFilterFactor())__				_				if (this.estimatedOutputSize >= 0) {_					this.estimatedOutputSize = (long) (this.estimatedOutputSize * hints.getFilterFactor())__				}_			}_			else if (this instanceof SingleInputNode) {_				OptimizerNode pred = ((SingleInputNode) this).getPredecessorNode()__				if (pred != null && pred.getEstimatedNumRecords() >= 0) {_					this.estimatedNumRecords = (long) (pred.getEstimatedNumRecords() * hints.getFilterFactor())__				}_			}_		}_		_		_		if (hints.getAvgOutputRecordSize() >= 1) {_			_			if (this.estimatedNumRecords == -1 && this.estimatedOutputSize >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedOutputSize / hints.getAvgOutputRecordSize())__			}_			else if (this.estimatedOutputSize == -1 && this.estimatedNumRecords >= 0) {_				this.estimatedOutputSize = (long) (this.estimatedNumRecords * hints.getAvgOutputRecordSize())__			}_		}_	};causes,this,node,to,compute,its,output,estimates,such,as,number,of,rows,size,in,bytes,based,on,the,inputs,and,the,compiler,hints,the,compiler,hints,are,instantiated,with,conservative,default,values,which,are,used,if,no,other,values,are,provided,nodes,may,access,the,statistics,to,determine,relevant,information,param,statistics,the,statistics,object,which,may,be,accessed,to,get,statistical,information,the,parameter,may,be,null,if,no,statistics,are,available;public,void,compute,output,estimates,data,statistics,statistics,for,dag,connection,c,get,incoming,connections,if,c,get,source,null,throw,new,compiler,exception,bug,estimate,computation,called,before,inputs,have,been,set,compute,operator,specific,default,estimates,statistics,if,this,estimated,output,size,0,this,estimated,output,size,1,if,this,estimated,num,records,0,this,estimated,num,records,1,if,get,operator,null,get,operator,get,compiler,hints,null,return,compiler,hints,hints,get,operator,get,compiler,hints,if,hints,get,output,size,0,this,estimated,output,size,hints,get,output,size,if,hints,get,output,cardinality,0,this,estimated,num,records,hints,get,output,cardinality,if,hints,get,filter,factor,0,0f,if,this,estimated,num,records,0,this,estimated,num,records,long,this,estimated,num,records,hints,get,filter,factor,if,this,estimated,output,size,0,this,estimated,output,size,long,this,estimated,output,size,hints,get,filter,factor,else,if,this,instanceof,single,input,node,optimizer,node,pred,single,input,node,this,get,predecessor,node,if,pred,null,pred,get,estimated,num,records,0,this,estimated,num,records,long,pred,get,estimated,num,records,hints,get,filter,factor,if,hints,get,avg,output,record,size,1,if,this,estimated,num,records,1,this,estimated,output,size,0,this,estimated,num,records,long,this,estimated,output,size,hints,get,avg,output,record,size,else,if,this,estimated,output,size,1,this,estimated,num,records,0,this,estimated,output,size,long,this,estimated,num,records,hints,get,avg,output,record,size
OptimizerNode -> public void computeOutputEstimates(DataStatistics statistics);1427097830;Causes this node to compute its output estimates (such as number of rows, size in bytes)_based on the inputs and the compiler hints. The compiler hints are instantiated with conservative_default values which are used if no other values are provided. Nodes may access the statistics to_determine relevant information.__@param statistics_The statistics object which may be accessed to get statistical information._The parameter may be null, if no statistics are available.;public void computeOutputEstimates(DataStatistics statistics) {_		_		for (DagConnection c : getIncomingConnections()) {_			if (c.getSource() == null) {_				throw new CompilerException("Bug: Estimate computation called before inputs have been set.")__			}_		}_		_		_		computeOperatorSpecificDefaultEstimates(statistics)__		_		if (this.estimatedOutputSize < 0) {_			this.estimatedOutputSize = -1__		}_		if (this.estimatedNumRecords < 0) {_			this.estimatedNumRecords = -1__		}_		_		_		if (getOperator() == null || getOperator().getCompilerHints() == null) {_			return __		}_		_		CompilerHints hints = getOperator().getCompilerHints()__		if (hints.getOutputSize() >= 0) {_			this.estimatedOutputSize = hints.getOutputSize()__		}_		_		if (hints.getOutputCardinality() >= 0) {_			this.estimatedNumRecords = hints.getOutputCardinality()__		}_		_		if (hints.getFilterFactor() >= 0.0f) {_			if (this.estimatedNumRecords >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedNumRecords * hints.getFilterFactor())__				_				if (this.estimatedOutputSize >= 0) {_					this.estimatedOutputSize = (long) (this.estimatedOutputSize * hints.getFilterFactor())__				}_			}_			else if (this instanceof SingleInputNode) {_				OptimizerNode pred = ((SingleInputNode) this).getPredecessorNode()__				if (pred != null && pred.getEstimatedNumRecords() >= 0) {_					this.estimatedNumRecords = (long) (pred.getEstimatedNumRecords() * hints.getFilterFactor())__				}_			}_		}_		_		_		if (hints.getAvgOutputRecordSize() >= 1) {_			_			if (this.estimatedNumRecords == -1 && this.estimatedOutputSize >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedOutputSize / hints.getAvgOutputRecordSize())__			}_			else if (this.estimatedOutputSize == -1 && this.estimatedNumRecords >= 0) {_				this.estimatedOutputSize = (long) (this.estimatedNumRecords * hints.getAvgOutputRecordSize())__			}_		}_	};causes,this,node,to,compute,its,output,estimates,such,as,number,of,rows,size,in,bytes,based,on,the,inputs,and,the,compiler,hints,the,compiler,hints,are,instantiated,with,conservative,default,values,which,are,used,if,no,other,values,are,provided,nodes,may,access,the,statistics,to,determine,relevant,information,param,statistics,the,statistics,object,which,may,be,accessed,to,get,statistical,information,the,parameter,may,be,null,if,no,statistics,are,available;public,void,compute,output,estimates,data,statistics,statistics,for,dag,connection,c,get,incoming,connections,if,c,get,source,null,throw,new,compiler,exception,bug,estimate,computation,called,before,inputs,have,been,set,compute,operator,specific,default,estimates,statistics,if,this,estimated,output,size,0,this,estimated,output,size,1,if,this,estimated,num,records,0,this,estimated,num,records,1,if,get,operator,null,get,operator,get,compiler,hints,null,return,compiler,hints,hints,get,operator,get,compiler,hints,if,hints,get,output,size,0,this,estimated,output,size,hints,get,output,size,if,hints,get,output,cardinality,0,this,estimated,num,records,hints,get,output,cardinality,if,hints,get,filter,factor,0,0f,if,this,estimated,num,records,0,this,estimated,num,records,long,this,estimated,num,records,hints,get,filter,factor,if,this,estimated,output,size,0,this,estimated,output,size,long,this,estimated,output,size,hints,get,filter,factor,else,if,this,instanceof,single,input,node,optimizer,node,pred,single,input,node,this,get,predecessor,node,if,pred,null,pred,get,estimated,num,records,0,this,estimated,num,records,long,pred,get,estimated,num,records,hints,get,filter,factor,if,hints,get,avg,output,record,size,1,if,this,estimated,num,records,1,this,estimated,output,size,0,this,estimated,num,records,long,this,estimated,output,size,hints,get,avg,output,record,size,else,if,this,estimated,output,size,1,this,estimated,num,records,0,this,estimated,output,size,long,this,estimated,num,records,hints,get,avg,output,record,size
OptimizerNode -> public void computeOutputEstimates(DataStatistics statistics);1431981454;Causes this node to compute its output estimates (such as number of rows, size in bytes)_based on the inputs and the compiler hints. The compiler hints are instantiated with conservative_default values which are used if no other values are provided. Nodes may access the statistics to_determine relevant information.__@param statistics_The statistics object which may be accessed to get statistical information._The parameter may be null, if no statistics are available.;public void computeOutputEstimates(DataStatistics statistics) {_		_		for (DagConnection c : getIncomingConnections()) {_			if (c.getSource() == null) {_				throw new CompilerException("Bug: Estimate computation called before inputs have been set.")__			}_		}_		_		_		computeOperatorSpecificDefaultEstimates(statistics)__		_		if (this.estimatedOutputSize < 0) {_			this.estimatedOutputSize = -1__		}_		if (this.estimatedNumRecords < 0) {_			this.estimatedNumRecords = -1__		}_		_		_		if (getOperator() == null || getOperator().getCompilerHints() == null) {_			return __		}_		_		CompilerHints hints = getOperator().getCompilerHints()__		if (hints.getOutputSize() >= 0) {_			this.estimatedOutputSize = hints.getOutputSize()__		}_		_		if (hints.getOutputCardinality() >= 0) {_			this.estimatedNumRecords = hints.getOutputCardinality()__		}_		_		if (hints.getFilterFactor() >= 0.0f) {_			if (this.estimatedNumRecords >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedNumRecords * hints.getFilterFactor())__				_				if (this.estimatedOutputSize >= 0) {_					this.estimatedOutputSize = (long) (this.estimatedOutputSize * hints.getFilterFactor())__				}_			}_			else if (this instanceof SingleInputNode) {_				OptimizerNode pred = ((SingleInputNode) this).getPredecessorNode()__				if (pred != null && pred.getEstimatedNumRecords() >= 0) {_					this.estimatedNumRecords = (long) (pred.getEstimatedNumRecords() * hints.getFilterFactor())__				}_			}_		}_		_		_		if (hints.getAvgOutputRecordSize() >= 1) {_			_			if (this.estimatedNumRecords == -1 && this.estimatedOutputSize >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedOutputSize / hints.getAvgOutputRecordSize())__			}_			else if (this.estimatedOutputSize == -1 && this.estimatedNumRecords >= 0) {_				this.estimatedOutputSize = (long) (this.estimatedNumRecords * hints.getAvgOutputRecordSize())__			}_		}_	};causes,this,node,to,compute,its,output,estimates,such,as,number,of,rows,size,in,bytes,based,on,the,inputs,and,the,compiler,hints,the,compiler,hints,are,instantiated,with,conservative,default,values,which,are,used,if,no,other,values,are,provided,nodes,may,access,the,statistics,to,determine,relevant,information,param,statistics,the,statistics,object,which,may,be,accessed,to,get,statistical,information,the,parameter,may,be,null,if,no,statistics,are,available;public,void,compute,output,estimates,data,statistics,statistics,for,dag,connection,c,get,incoming,connections,if,c,get,source,null,throw,new,compiler,exception,bug,estimate,computation,called,before,inputs,have,been,set,compute,operator,specific,default,estimates,statistics,if,this,estimated,output,size,0,this,estimated,output,size,1,if,this,estimated,num,records,0,this,estimated,num,records,1,if,get,operator,null,get,operator,get,compiler,hints,null,return,compiler,hints,hints,get,operator,get,compiler,hints,if,hints,get,output,size,0,this,estimated,output,size,hints,get,output,size,if,hints,get,output,cardinality,0,this,estimated,num,records,hints,get,output,cardinality,if,hints,get,filter,factor,0,0f,if,this,estimated,num,records,0,this,estimated,num,records,long,this,estimated,num,records,hints,get,filter,factor,if,this,estimated,output,size,0,this,estimated,output,size,long,this,estimated,output,size,hints,get,filter,factor,else,if,this,instanceof,single,input,node,optimizer,node,pred,single,input,node,this,get,predecessor,node,if,pred,null,pred,get,estimated,num,records,0,this,estimated,num,records,long,pred,get,estimated,num,records,hints,get,filter,factor,if,hints,get,avg,output,record,size,1,if,this,estimated,num,records,1,this,estimated,output,size,0,this,estimated,num,records,long,this,estimated,output,size,hints,get,avg,output,record,size,else,if,this,estimated,output,size,1,this,estimated,num,records,0,this,estimated,output,size,long,this,estimated,num,records,hints,get,avg,output,record,size
OptimizerNode -> public void computeOutputEstimates(DataStatistics statistics);1442492509;Causes this node to compute its output estimates (such as number of rows, size in bytes)_based on the inputs and the compiler hints. The compiler hints are instantiated with conservative_default values which are used if no other values are provided. Nodes may access the statistics to_determine relevant information.__@param statistics_The statistics object which may be accessed to get statistical information._The parameter may be null, if no statistics are available.;public void computeOutputEstimates(DataStatistics statistics) {_		_		for (DagConnection c : getIncomingConnections()) {_			if (c.getSource() == null) {_				throw new CompilerException("Bug: Estimate computation called before inputs have been set.")__			}_		}_		_		_		computeOperatorSpecificDefaultEstimates(statistics)__		_		if (this.estimatedOutputSize < 0) {_			this.estimatedOutputSize = -1__		}_		if (this.estimatedNumRecords < 0) {_			this.estimatedNumRecords = -1__		}_		_		_		if (getOperator() == null || getOperator().getCompilerHints() == null) {_			return __		}_		_		CompilerHints hints = getOperator().getCompilerHints()__		if (hints.getOutputSize() >= 0) {_			this.estimatedOutputSize = hints.getOutputSize()__		}_		_		if (hints.getOutputCardinality() >= 0) {_			this.estimatedNumRecords = hints.getOutputCardinality()__		}_		_		if (hints.getFilterFactor() >= 0.0f) {_			if (this.estimatedNumRecords >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedNumRecords * hints.getFilterFactor())__				_				if (this.estimatedOutputSize >= 0) {_					this.estimatedOutputSize = (long) (this.estimatedOutputSize * hints.getFilterFactor())__				}_			}_			else if (this instanceof SingleInputNode) {_				OptimizerNode pred = ((SingleInputNode) this).getPredecessorNode()__				if (pred != null && pred.getEstimatedNumRecords() >= 0) {_					this.estimatedNumRecords = (long) (pred.getEstimatedNumRecords() * hints.getFilterFactor())__				}_			}_		}_		_		_		if (hints.getAvgOutputRecordSize() >= 1) {_			_			if (this.estimatedNumRecords == -1 && this.estimatedOutputSize >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedOutputSize / hints.getAvgOutputRecordSize())__			}_			else if (this.estimatedOutputSize == -1 && this.estimatedNumRecords >= 0) {_				this.estimatedOutputSize = (long) (this.estimatedNumRecords * hints.getAvgOutputRecordSize())__			}_		}_	};causes,this,node,to,compute,its,output,estimates,such,as,number,of,rows,size,in,bytes,based,on,the,inputs,and,the,compiler,hints,the,compiler,hints,are,instantiated,with,conservative,default,values,which,are,used,if,no,other,values,are,provided,nodes,may,access,the,statistics,to,determine,relevant,information,param,statistics,the,statistics,object,which,may,be,accessed,to,get,statistical,information,the,parameter,may,be,null,if,no,statistics,are,available;public,void,compute,output,estimates,data,statistics,statistics,for,dag,connection,c,get,incoming,connections,if,c,get,source,null,throw,new,compiler,exception,bug,estimate,computation,called,before,inputs,have,been,set,compute,operator,specific,default,estimates,statistics,if,this,estimated,output,size,0,this,estimated,output,size,1,if,this,estimated,num,records,0,this,estimated,num,records,1,if,get,operator,null,get,operator,get,compiler,hints,null,return,compiler,hints,hints,get,operator,get,compiler,hints,if,hints,get,output,size,0,this,estimated,output,size,hints,get,output,size,if,hints,get,output,cardinality,0,this,estimated,num,records,hints,get,output,cardinality,if,hints,get,filter,factor,0,0f,if,this,estimated,num,records,0,this,estimated,num,records,long,this,estimated,num,records,hints,get,filter,factor,if,this,estimated,output,size,0,this,estimated,output,size,long,this,estimated,output,size,hints,get,filter,factor,else,if,this,instanceof,single,input,node,optimizer,node,pred,single,input,node,this,get,predecessor,node,if,pred,null,pred,get,estimated,num,records,0,this,estimated,num,records,long,pred,get,estimated,num,records,hints,get,filter,factor,if,hints,get,avg,output,record,size,1,if,this,estimated,num,records,1,this,estimated,output,size,0,this,estimated,num,records,long,this,estimated,output,size,hints,get,avg,output,record,size,else,if,this,estimated,output,size,1,this,estimated,num,records,0,this,estimated,output,size,long,this,estimated,num,records,hints,get,avg,output,record,size
OptimizerNode -> public void computeOutputEstimates(DataStatistics statistics);1446112342;Causes this node to compute its output estimates (such as number of rows, size in bytes)_based on the inputs and the compiler hints. The compiler hints are instantiated with conservative_default values which are used if no other values are provided. Nodes may access the statistics to_determine relevant information.__@param statistics_The statistics object which may be accessed to get statistical information._The parameter may be null, if no statistics are available.;public void computeOutputEstimates(DataStatistics statistics) {_		_		for (DagConnection c : getIncomingConnections()) {_			if (c.getSource() == null) {_				throw new CompilerException("Bug: Estimate computation called before inputs have been set.")__			}_		}_		_		_		computeOperatorSpecificDefaultEstimates(statistics)__		_		if (this.estimatedOutputSize < 0) {_			this.estimatedOutputSize = -1__		}_		if (this.estimatedNumRecords < 0) {_			this.estimatedNumRecords = -1__		}_		_		_		if (getOperator() == null || getOperator().getCompilerHints() == null) {_			return __		}_		_		CompilerHints hints = getOperator().getCompilerHints()__		if (hints.getOutputSize() >= 0) {_			this.estimatedOutputSize = hints.getOutputSize()__		}_		_		if (hints.getOutputCardinality() >= 0) {_			this.estimatedNumRecords = hints.getOutputCardinality()__		}_		_		if (hints.getFilterFactor() >= 0.0f) {_			if (this.estimatedNumRecords >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedNumRecords * hints.getFilterFactor())__				_				if (this.estimatedOutputSize >= 0) {_					this.estimatedOutputSize = (long) (this.estimatedOutputSize * hints.getFilterFactor())__				}_			}_			else if (this instanceof SingleInputNode) {_				OptimizerNode pred = ((SingleInputNode) this).getPredecessorNode()__				if (pred != null && pred.getEstimatedNumRecords() >= 0) {_					this.estimatedNumRecords = (long) (pred.getEstimatedNumRecords() * hints.getFilterFactor())__				}_			}_		}_		_		_		if (hints.getAvgOutputRecordSize() >= 1) {_			_			if (this.estimatedNumRecords == -1 && this.estimatedOutputSize >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedOutputSize / hints.getAvgOutputRecordSize())__			}_			else if (this.estimatedOutputSize == -1 && this.estimatedNumRecords >= 0) {_				this.estimatedOutputSize = (long) (this.estimatedNumRecords * hints.getAvgOutputRecordSize())__			}_		}_	};causes,this,node,to,compute,its,output,estimates,such,as,number,of,rows,size,in,bytes,based,on,the,inputs,and,the,compiler,hints,the,compiler,hints,are,instantiated,with,conservative,default,values,which,are,used,if,no,other,values,are,provided,nodes,may,access,the,statistics,to,determine,relevant,information,param,statistics,the,statistics,object,which,may,be,accessed,to,get,statistical,information,the,parameter,may,be,null,if,no,statistics,are,available;public,void,compute,output,estimates,data,statistics,statistics,for,dag,connection,c,get,incoming,connections,if,c,get,source,null,throw,new,compiler,exception,bug,estimate,computation,called,before,inputs,have,been,set,compute,operator,specific,default,estimates,statistics,if,this,estimated,output,size,0,this,estimated,output,size,1,if,this,estimated,num,records,0,this,estimated,num,records,1,if,get,operator,null,get,operator,get,compiler,hints,null,return,compiler,hints,hints,get,operator,get,compiler,hints,if,hints,get,output,size,0,this,estimated,output,size,hints,get,output,size,if,hints,get,output,cardinality,0,this,estimated,num,records,hints,get,output,cardinality,if,hints,get,filter,factor,0,0f,if,this,estimated,num,records,0,this,estimated,num,records,long,this,estimated,num,records,hints,get,filter,factor,if,this,estimated,output,size,0,this,estimated,output,size,long,this,estimated,output,size,hints,get,filter,factor,else,if,this,instanceof,single,input,node,optimizer,node,pred,single,input,node,this,get,predecessor,node,if,pred,null,pred,get,estimated,num,records,0,this,estimated,num,records,long,pred,get,estimated,num,records,hints,get,filter,factor,if,hints,get,avg,output,record,size,1,if,this,estimated,num,records,1,this,estimated,output,size,0,this,estimated,num,records,long,this,estimated,output,size,hints,get,avg,output,record,size,else,if,this,estimated,output,size,1,this,estimated,num,records,0,this,estimated,output,size,long,this,estimated,num,records,hints,get,avg,output,record,size
OptimizerNode -> public void computeOutputEstimates(DataStatistics statistics);1460563153;Causes this node to compute its output estimates (such as number of rows, size in bytes)_based on the inputs and the compiler hints. The compiler hints are instantiated with conservative_default values which are used if no other values are provided. Nodes may access the statistics to_determine relevant information.__@param statistics_The statistics object which may be accessed to get statistical information._The parameter may be null, if no statistics are available.;public void computeOutputEstimates(DataStatistics statistics) {_		_		for (DagConnection c : getIncomingConnections()) {_			if (c.getSource() == null) {_				throw new CompilerException("Bug: Estimate computation called before inputs have been set.")__			}_		}_		_		_		computeOperatorSpecificDefaultEstimates(statistics)__		_		if (this.estimatedOutputSize < 0) {_			this.estimatedOutputSize = -1__		}_		if (this.estimatedNumRecords < 0) {_			this.estimatedNumRecords = -1__		}_		_		_		if (getOperator() == null || getOperator().getCompilerHints() == null) {_			return __		}_		_		CompilerHints hints = getOperator().getCompilerHints()__		if (hints.getOutputSize() >= 0) {_			this.estimatedOutputSize = hints.getOutputSize()__		}_		_		if (hints.getOutputCardinality() >= 0) {_			this.estimatedNumRecords = hints.getOutputCardinality()__		}_		_		if (hints.getFilterFactor() >= 0.0f) {_			if (this.estimatedNumRecords >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedNumRecords * hints.getFilterFactor())__				_				if (this.estimatedOutputSize >= 0) {_					this.estimatedOutputSize = (long) (this.estimatedOutputSize * hints.getFilterFactor())__				}_			}_			else if (this instanceof SingleInputNode) {_				OptimizerNode pred = ((SingleInputNode) this).getPredecessorNode()__				if (pred != null && pred.getEstimatedNumRecords() >= 0) {_					this.estimatedNumRecords = (long) (pred.getEstimatedNumRecords() * hints.getFilterFactor())__				}_			}_		}_		_		_		if (hints.getAvgOutputRecordSize() >= 1) {_			_			if (this.estimatedNumRecords == -1 && this.estimatedOutputSize >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedOutputSize / hints.getAvgOutputRecordSize())__			}_			else if (this.estimatedOutputSize == -1 && this.estimatedNumRecords >= 0) {_				this.estimatedOutputSize = (long) (this.estimatedNumRecords * hints.getAvgOutputRecordSize())__			}_		}_	};causes,this,node,to,compute,its,output,estimates,such,as,number,of,rows,size,in,bytes,based,on,the,inputs,and,the,compiler,hints,the,compiler,hints,are,instantiated,with,conservative,default,values,which,are,used,if,no,other,values,are,provided,nodes,may,access,the,statistics,to,determine,relevant,information,param,statistics,the,statistics,object,which,may,be,accessed,to,get,statistical,information,the,parameter,may,be,null,if,no,statistics,are,available;public,void,compute,output,estimates,data,statistics,statistics,for,dag,connection,c,get,incoming,connections,if,c,get,source,null,throw,new,compiler,exception,bug,estimate,computation,called,before,inputs,have,been,set,compute,operator,specific,default,estimates,statistics,if,this,estimated,output,size,0,this,estimated,output,size,1,if,this,estimated,num,records,0,this,estimated,num,records,1,if,get,operator,null,get,operator,get,compiler,hints,null,return,compiler,hints,hints,get,operator,get,compiler,hints,if,hints,get,output,size,0,this,estimated,output,size,hints,get,output,size,if,hints,get,output,cardinality,0,this,estimated,num,records,hints,get,output,cardinality,if,hints,get,filter,factor,0,0f,if,this,estimated,num,records,0,this,estimated,num,records,long,this,estimated,num,records,hints,get,filter,factor,if,this,estimated,output,size,0,this,estimated,output,size,long,this,estimated,output,size,hints,get,filter,factor,else,if,this,instanceof,single,input,node,optimizer,node,pred,single,input,node,this,get,predecessor,node,if,pred,null,pred,get,estimated,num,records,0,this,estimated,num,records,long,pred,get,estimated,num,records,hints,get,filter,factor,if,hints,get,avg,output,record,size,1,if,this,estimated,num,records,1,this,estimated,output,size,0,this,estimated,num,records,long,this,estimated,output,size,hints,get,avg,output,record,size,else,if,this,estimated,output,size,1,this,estimated,num,records,0,this,estimated,output,size,long,this,estimated,num,records,hints,get,avg,output,record,size
OptimizerNode -> public void computeOutputEstimates(DataStatistics statistics);1546180287;Causes this node to compute its output estimates (such as number of rows, size in bytes)_based on the inputs and the compiler hints. The compiler hints are instantiated with conservative_default values which are used if no other values are provided. Nodes may access the statistics to_determine relevant information.__@param statistics_The statistics object which may be accessed to get statistical information._The parameter may be null, if no statistics are available.;public void computeOutputEstimates(DataStatistics statistics) {_		_		for (DagConnection c : getIncomingConnections()) {_			if (c.getSource() == null) {_				throw new CompilerException("Bug: Estimate computation called before inputs have been set.")__			}_		}_		_		_		computeOperatorSpecificDefaultEstimates(statistics)__		_		if (this.estimatedOutputSize < 0) {_			this.estimatedOutputSize = -1__		}_		if (this.estimatedNumRecords < 0) {_			this.estimatedNumRecords = -1__		}_		_		_		if (getOperator() == null || getOperator().getCompilerHints() == null) {_			return __		}_		_		CompilerHints hints = getOperator().getCompilerHints()__		if (hints.getOutputSize() >= 0) {_			this.estimatedOutputSize = hints.getOutputSize()__		}_		_		if (hints.getOutputCardinality() >= 0) {_			this.estimatedNumRecords = hints.getOutputCardinality()__		}_		_		if (hints.getFilterFactor() >= 0.0f) {_			if (this.estimatedNumRecords >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedNumRecords * hints.getFilterFactor())__				_				if (this.estimatedOutputSize >= 0) {_					this.estimatedOutputSize = (long) (this.estimatedOutputSize * hints.getFilterFactor())__				}_			}_			else if (this instanceof SingleInputNode) {_				OptimizerNode pred = ((SingleInputNode) this).getPredecessorNode()__				if (pred != null && pred.getEstimatedNumRecords() >= 0) {_					this.estimatedNumRecords = (long) (pred.getEstimatedNumRecords() * hints.getFilterFactor())__				}_			}_		}_		_		_		if (hints.getAvgOutputRecordSize() >= 1) {_			_			if (this.estimatedNumRecords == -1 && this.estimatedOutputSize >= 0) {_				this.estimatedNumRecords = (long) (this.estimatedOutputSize / hints.getAvgOutputRecordSize())__			}_			else if (this.estimatedOutputSize == -1 && this.estimatedNumRecords >= 0) {_				this.estimatedOutputSize = (long) (this.estimatedNumRecords * hints.getAvgOutputRecordSize())__			}_		}_	};causes,this,node,to,compute,its,output,estimates,such,as,number,of,rows,size,in,bytes,based,on,the,inputs,and,the,compiler,hints,the,compiler,hints,are,instantiated,with,conservative,default,values,which,are,used,if,no,other,values,are,provided,nodes,may,access,the,statistics,to,determine,relevant,information,param,statistics,the,statistics,object,which,may,be,accessed,to,get,statistical,information,the,parameter,may,be,null,if,no,statistics,are,available;public,void,compute,output,estimates,data,statistics,statistics,for,dag,connection,c,get,incoming,connections,if,c,get,source,null,throw,new,compiler,exception,bug,estimate,computation,called,before,inputs,have,been,set,compute,operator,specific,default,estimates,statistics,if,this,estimated,output,size,0,this,estimated,output,size,1,if,this,estimated,num,records,0,this,estimated,num,records,1,if,get,operator,null,get,operator,get,compiler,hints,null,return,compiler,hints,hints,get,operator,get,compiler,hints,if,hints,get,output,size,0,this,estimated,output,size,hints,get,output,size,if,hints,get,output,cardinality,0,this,estimated,num,records,hints,get,output,cardinality,if,hints,get,filter,factor,0,0f,if,this,estimated,num,records,0,this,estimated,num,records,long,this,estimated,num,records,hints,get,filter,factor,if,this,estimated,output,size,0,this,estimated,output,size,long,this,estimated,output,size,hints,get,filter,factor,else,if,this,instanceof,single,input,node,optimizer,node,pred,single,input,node,this,get,predecessor,node,if,pred,null,pred,get,estimated,num,records,0,this,estimated,num,records,long,pred,get,estimated,num,records,hints,get,filter,factor,if,hints,get,avg,output,record,size,1,if,this,estimated,num,records,1,this,estimated,output,size,0,this,estimated,num,records,long,this,estimated,output,size,hints,get,avg,output,record,size,else,if,this,estimated,output,size,1,this,estimated,num,records,0,this,estimated,output,size,long,this,estimated,num,records,hints,get,avg,output,record,size
OptimizerNode -> public List<DagConnection> getOutgoingConnections();1426843274;The list of outgoing connections from this node to succeeding tasks.__@return The list of outgoing connections.;public List<DagConnection> getOutgoingConnections() {_		return this.outgoingConnections__	};the,list,of,outgoing,connections,from,this,node,to,succeeding,tasks,return,the,list,of,outgoing,connections;public,list,dag,connection,get,outgoing,connections,return,this,outgoing,connections
OptimizerNode -> public List<DagConnection> getOutgoingConnections();1427097830;The list of outgoing connections from this node to succeeding tasks.__@return The list of outgoing connections.;public List<DagConnection> getOutgoingConnections() {_		return this.outgoingConnections__	};the,list,of,outgoing,connections,from,this,node,to,succeeding,tasks,return,the,list,of,outgoing,connections;public,list,dag,connection,get,outgoing,connections,return,this,outgoing,connections
OptimizerNode -> public List<DagConnection> getOutgoingConnections();1431981454;The list of outgoing connections from this node to succeeding tasks.__@return The list of outgoing connections.;public List<DagConnection> getOutgoingConnections() {_		return this.outgoingConnections__	};the,list,of,outgoing,connections,from,this,node,to,succeeding,tasks,return,the,list,of,outgoing,connections;public,list,dag,connection,get,outgoing,connections,return,this,outgoing,connections
OptimizerNode -> public List<DagConnection> getOutgoingConnections();1442492509;The list of outgoing connections from this node to succeeding tasks.__@return The list of outgoing connections.;public List<DagConnection> getOutgoingConnections() {_		return this.outgoingConnections__	};the,list,of,outgoing,connections,from,this,node,to,succeeding,tasks,return,the,list,of,outgoing,connections;public,list,dag,connection,get,outgoing,connections,return,this,outgoing,connections
OptimizerNode -> public List<DagConnection> getOutgoingConnections();1446112342;The list of outgoing connections from this node to succeeding tasks.__@return The list of outgoing connections.;public List<DagConnection> getOutgoingConnections() {_		return this.outgoingConnections__	};the,list,of,outgoing,connections,from,this,node,to,succeeding,tasks,return,the,list,of,outgoing,connections;public,list,dag,connection,get,outgoing,connections,return,this,outgoing,connections
OptimizerNode -> public List<DagConnection> getOutgoingConnections();1460563153;The list of outgoing connections from this node to succeeding tasks.__@return The list of outgoing connections.;public List<DagConnection> getOutgoingConnections() {_		return this.outgoingConnections__	};the,list,of,outgoing,connections,from,this,node,to,succeeding,tasks,return,the,list,of,outgoing,connections;public,list,dag,connection,get,outgoing,connections,return,this,outgoing,connections
OptimizerNode -> public List<DagConnection> getOutgoingConnections();1546180287;The list of outgoing connections from this node to succeeding tasks.__@return The list of outgoing connections.;public List<DagConnection> getOutgoingConnections() {_		return this.outgoingConnections__	};the,list,of,outgoing,connections,from,this,node,to,succeeding,tasks,return,the,list,of,outgoing,connections;public,list,dag,connection,get,outgoing,connections,return,this,outgoing,connections
