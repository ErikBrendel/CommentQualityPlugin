# id;timestamp;commentText;codeText;commentWords;codeWords
Optimizer -> public Optimizer(DataStatistics stats, Configuration config);1427784999;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__@param stats_The statistics to be used to determine the input properties.;public Optimizer(DataStatistics stats, Configuration config) {_		this(stats, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,param,stats,the,statistics,to,be,used,to,determine,the,input,properties;public,optimizer,data,statistics,stats,configuration,config,this,stats,new,default,cost,estimator,config
Optimizer -> public Optimizer(DataStatistics stats, Configuration config);1431981454;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__@param stats_The statistics to be used to determine the input properties.;public Optimizer(DataStatistics stats, Configuration config) {_		this(stats, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,param,stats,the,statistics,to,be,used,to,determine,the,input,properties;public,optimizer,data,statistics,stats,configuration,config,this,stats,new,default,cost,estimator,config
Optimizer -> public Optimizer(DataStatistics stats, Configuration config);1436966346;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__@param stats_The statistics to be used to determine the input properties.;public Optimizer(DataStatistics stats, Configuration config) {_		this(stats, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,param,stats,the,statistics,to,be,used,to,determine,the,input,properties;public,optimizer,data,statistics,stats,configuration,config,this,stats,new,default,cost,estimator,config
Optimizer -> public Optimizer(DataStatistics stats, Configuration config);1444404795;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__@param stats_The statistics to be used to determine the input properties.;public Optimizer(DataStatistics stats, Configuration config) {_		this(stats, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,param,stats,the,statistics,to,be,used,to,determine,the,input,properties;public,optimizer,data,statistics,stats,configuration,config,this,stats,new,default,cost,estimator,config
Optimizer -> public Optimizer(DataStatistics stats, Configuration config);1450712612;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__@param stats_The statistics to be used to determine the input properties.;public Optimizer(DataStatistics stats, Configuration config) {_		this(stats, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,param,stats,the,statistics,to,be,used,to,determine,the,input,properties;public,optimizer,data,statistics,stats,configuration,config,this,stats,new,default,cost,estimator,config
Optimizer -> public Optimizer(DataStatistics stats, Configuration config);1460472696;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__@param stats_The statistics to be used to determine the input properties.;public Optimizer(DataStatistics stats, Configuration config) {_		this(stats, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,param,stats,the,statistics,to,be,used,to,determine,the,input,properties;public,optimizer,data,statistics,stats,configuration,config,this,stats,new,default,cost,estimator,config
Optimizer -> public Optimizer(DataStatistics stats, Configuration config);1517324056;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__@param stats_The statistics to be used to determine the input properties.;public Optimizer(DataStatistics stats, Configuration config) {_		this(stats, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,param,stats,the,statistics,to,be,used,to,determine,the,input,properties;public,optimizer,data,statistics,stats,configuration,config,this,stats,new,default,cost,estimator,config
Optimizer -> public Optimizer(DataStatistics stats, Configuration config);1522323145;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__@param stats_The statistics to be used to determine the input properties.;public Optimizer(DataStatistics stats, Configuration config) {_		this(stats, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,param,stats,the,statistics,to,be,used,to,determine,the,input,properties;public,optimizer,data,statistics,stats,configuration,config,this,stats,new,default,cost,estimator,config
Optimizer -> public Optimizer(DataStatistics stats, CostEstimator estimator);1426843274;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param stats_The statistics to be used to determine the input properties._@param estimator_The <tt>CostEstimator</tt> to use to cost the individual operations.;public Optimizer(DataStatistics stats, CostEstimator estimator) {_		this.statistics = stats__		this.costEstimator = estimator___		_		this.defaultDegreeOfParallelism = GlobalConfiguration.getInteger(_				ConfigConstants.DEFAULT_PARALLELIZATION_DEGREE_KEY,_				ConfigConstants.DEFAULT_PARALLELIZATION_DEGREE)__		_		if (defaultDegreeOfParallelism < 1) {_			LOG.warn("Config value " + defaultDegreeOfParallelism + " for option "_					+ ConfigConstants.DEFAULT_PARALLELIZATION_DEGREE + " is invalid. Ignoring and using a value of 1.")__			this.defaultDegreeOfParallelism = 1__		}_	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,stats,the,statistics,to,be,used,to,determine,the,input,properties,param,estimator,the,tt,cost,estimator,tt,to,use,to,cost,the,individual,operations;public,optimizer,data,statistics,stats,cost,estimator,estimator,this,statistics,stats,this,cost,estimator,estimator,this,default,degree,of,parallelism,global,configuration,get,integer,config,constants,config,constants,if,default,degree,of,parallelism,1,log,warn,config,value,default,degree,of,parallelism,for,option,config,constants,is,invalid,ignoring,and,using,a,value,of,1,this,default,degree,of,parallelism,1
Optimizer -> public Optimizer(DataStatistics stats, CostEstimator estimator);1427097830;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param stats_The statistics to be used to determine the input properties._@param estimator_The <tt>CostEstimator</tt> to use to cost the individual operations.;public Optimizer(DataStatistics stats, CostEstimator estimator) {_		this.statistics = stats__		this.costEstimator = estimator___		_		this.defaultParallelism = GlobalConfiguration.getInteger(_				ConfigConstants.DEFAULT_PARALLELISM_KEY,_				ConfigConstants.DEFAULT_PARALLELISM)__		_		if (defaultParallelism < 1) {_			LOG.warn("Config value " + defaultParallelism + " for option "_					+ ConfigConstants.DEFAULT_PARALLELISM + " is invalid. Ignoring and using a value of 1.")__			this.defaultParallelism = 1__		}_	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,stats,the,statistics,to,be,used,to,determine,the,input,properties,param,estimator,the,tt,cost,estimator,tt,to,use,to,cost,the,individual,operations;public,optimizer,data,statistics,stats,cost,estimator,estimator,this,statistics,stats,this,cost,estimator,estimator,this,default,parallelism,global,configuration,get,integer,config,constants,config,constants,if,default,parallelism,1,log,warn,config,value,default,parallelism,for,option,config,constants,is,invalid,ignoring,and,using,a,value,of,1,this,default,parallelism,1
Optimizer -> public Optimizer(DataStatistics stats, CostEstimator estimator);1427097836;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param stats_The statistics to be used to determine the input properties._@param estimator_The <tt>CostEstimator</tt> to use to cost the individual operations.;public Optimizer(DataStatistics stats, CostEstimator estimator) {_		this.statistics = stats__		this.costEstimator = estimator___		_		_		this.defaultParallelism = GlobalConfiguration.getInteger(_				ConfigConstants.DEFAULT_PARALLELISM_KEY_OLD,_				ConfigConstants.DEFAULT_PARALLELISM)__		_		this.defaultParallelism = GlobalConfiguration.getInteger(_				ConfigConstants.DEFAULT_PARALLELISM_KEY,_				this.defaultParallelism)___		if (defaultParallelism < 1) {_			LOG.warn("Config value " + defaultParallelism + " for option "_					+ ConfigConstants.DEFAULT_PARALLELISM + " is invalid. Ignoring and using a value of 1.")__			this.defaultParallelism = 1__		}_	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,stats,the,statistics,to,be,used,to,determine,the,input,properties,param,estimator,the,tt,cost,estimator,tt,to,use,to,cost,the,individual,operations;public,optimizer,data,statistics,stats,cost,estimator,estimator,this,statistics,stats,this,cost,estimator,estimator,this,default,parallelism,global,configuration,get,integer,config,constants,config,constants,this,default,parallelism,global,configuration,get,integer,config,constants,this,default,parallelism,if,default,parallelism,1,log,warn,config,value,default,parallelism,for,option,config,constants,is,invalid,ignoring,and,using,a,value,of,1,this,default,parallelism,1
Optimizer -> private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException;1426843274;Translates the given program to an OptimizedPlan. The optimized plan describes for each operator_which strategy to use (such as hash join versus sort-merge join), what data exchange method to use_(local pipe forward, shuffle, broadcast), what exchange mode to use (pipelined, batch),_where to cache intermediate results, etc,__The optimization happens in multiple phases:_<ol>_<li>Create optimizer dag implementation of the program.__<tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li>_<li>Compute interesting properties and auxiliary structures.</li>_<li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as_opposed to the Database approaches), because we support plans that are not trees.</li>_</ol>__@param program The program to be translated._@param postPasser The function to be used for post passing the optimizer's plan and setting the_data type specific serialization routines._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException {_		if (program == null || postPasser == null) {_			throw new NullPointerException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Beginning compilation of program '" + program.getJobName() + '\'')__		}__		final ExecutionMode defaultDataExchangeMode = program.getExecutionConfig().getExecutionMode()___		final int defaultParallelism = program.getDefaultParallelism() > 0 ?_			program.getDefaultParallelism() : this.defaultDegreeOfParallelism___		_		LOG.debug("Using a default parallelism of {}",  defaultParallelism)__		LOG.debug("Using default data exchange mode {}", defaultDataExchangeMode)___		_		_		_		_		_		_		_		__		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(defaultParallelism, defaultDataExchangeMode)__		program.accept(graphCreator)___		_		_		_		OptimizerNode rootNode__		if (graphCreator.getSinks().size() == 1) {_			rootNode = graphCreator.getSinks().get(0)__		}_		else if (graphCreator.getSinks().size() > 1) {_			Iterator<DataSinkNode> iter = graphCreator.getSinks().iterator()__			rootNode = iter.next()___			while (iter.hasNext()) {_				rootNode = new SinkJoiner(rootNode, iter.next())__			}_		}_		else {_			throw new CompilerException("Bug: The optimizer plan representation has no sinks.")__		}__		_		_		rootNode.accept(new IdAndEstimatesVisitor(this.statistics))___		_		_		_		BranchesVisitor branchingVisitor = new BranchesVisitor()__		rootNode.accept(branchingVisitor)___		_		InterestingPropertyVisitor propsVisitor = new InterestingPropertyVisitor(this.costEstimator)__		rootNode.accept(propsVisitor)__		_		_		if (rootNode.getOpenBranches() != null && rootNode.getOpenBranches().size() > 0) {_			throw new CompilerException("Bug: Logic for branching plans (non-tree plans) has an error, and does not " +_					"track the re-joining of branches correctly.")__		}__		_		List<PlanNode> bestPlan = rootNode.getAlternativePlans(this.costEstimator)___		if (bestPlan.size() != 1) {_			throw new CompilerException("Error in compiler: more than one best plan was created!")__		}__		_		_		PlanNode bestPlanRoot = bestPlan.get(0)__		List<SinkPlanNode> bestPlanSinks = new ArrayList<SinkPlanNode>(4)___		if (bestPlanRoot instanceof SinkPlanNode) {_			bestPlanSinks.add((SinkPlanNode) bestPlanRoot)__		} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {_			((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks)__		}_		_		DeadlockPreventer dp = new DeadlockPreventer()__		dp.resolveDeadlocks(bestPlanSinks)___		_		OptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program)__		_		plan.accept(new BinaryUnionReplacer())__		_		_		postPasser.postPass(plan)__		_		return plan__	};translates,the,given,program,to,an,optimized,plan,the,optimized,plan,describes,for,each,operator,which,strategy,to,use,such,as,hash,join,versus,sort,merge,join,what,data,exchange,method,to,use,local,pipe,forward,shuffle,broadcast,what,exchange,mode,to,use,pipelined,batch,where,to,cache,intermediate,results,etc,the,optimization,happens,in,multiple,phases,ol,li,create,optimizer,dag,implementation,of,the,program,tt,optimizer,node,tt,representations,of,the,pacts,assign,parallelism,and,compute,size,estimates,li,li,compute,interesting,properties,and,auxiliary,structures,li,li,enumerate,plan,alternatives,this,cannot,be,done,in,the,same,step,as,the,interesting,property,computation,as,opposed,to,the,database,approaches,because,we,support,plans,that,are,not,trees,li,ol,param,program,the,program,to,be,translated,param,post,passer,the,function,to,be,used,for,post,passing,the,optimizer,s,plan,and,setting,the,data,type,specific,serialization,routines,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;private,optimized,plan,compile,plan,program,optimizer,post,pass,post,passer,throws,compiler,exception,if,program,null,post,passer,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,beginning,compilation,of,program,program,get,job,name,final,execution,mode,default,data,exchange,mode,program,get,execution,config,get,execution,mode,final,int,default,parallelism,program,get,default,parallelism,0,program,get,default,parallelism,this,default,degree,of,parallelism,log,debug,using,a,default,parallelism,of,default,parallelism,log,debug,using,default,data,exchange,mode,default,data,exchange,mode,graph,creating,visitor,graph,creator,new,graph,creating,visitor,default,parallelism,default,data,exchange,mode,program,accept,graph,creator,optimizer,node,root,node,if,graph,creator,get,sinks,size,1,root,node,graph,creator,get,sinks,get,0,else,if,graph,creator,get,sinks,size,1,iterator,data,sink,node,iter,graph,creator,get,sinks,iterator,root,node,iter,next,while,iter,has,next,root,node,new,sink,joiner,root,node,iter,next,else,throw,new,compiler,exception,bug,the,optimizer,plan,representation,has,no,sinks,root,node,accept,new,id,and,estimates,visitor,this,statistics,branches,visitor,branching,visitor,new,branches,visitor,root,node,accept,branching,visitor,interesting,property,visitor,props,visitor,new,interesting,property,visitor,this,cost,estimator,root,node,accept,props,visitor,if,root,node,get,open,branches,null,root,node,get,open,branches,size,0,throw,new,compiler,exception,bug,logic,for,branching,plans,non,tree,plans,has,an,error,and,does,not,track,the,re,joining,of,branches,correctly,list,plan,node,best,plan,root,node,get,alternative,plans,this,cost,estimator,if,best,plan,size,1,throw,new,compiler,exception,error,in,compiler,more,than,one,best,plan,was,created,plan,node,best,plan,root,best,plan,get,0,list,sink,plan,node,best,plan,sinks,new,array,list,sink,plan,node,4,if,best,plan,root,instanceof,sink,plan,node,best,plan,sinks,add,sink,plan,node,best,plan,root,else,if,best,plan,root,instanceof,sink,joiner,plan,node,sink,joiner,plan,node,best,plan,root,get,data,sinks,best,plan,sinks,deadlock,preventer,dp,new,deadlock,preventer,dp,resolve,deadlocks,best,plan,sinks,optimized,plan,plan,new,plan,finalizer,create,final,plan,best,plan,sinks,program,get,job,name,program,plan,accept,new,binary,union,replacer,post,passer,post,pass,plan,return,plan
Optimizer -> private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException;1427097830;Translates the given program to an OptimizedPlan. The optimized plan describes for each operator_which strategy to use (such as hash join versus sort-merge join), what data exchange method to use_(local pipe forward, shuffle, broadcast), what exchange mode to use (pipelined, batch),_where to cache intermediate results, etc,__The optimization happens in multiple phases:_<ol>_<li>Create optimizer dag implementation of the program.__<tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li>_<li>Compute interesting properties and auxiliary structures.</li>_<li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as_opposed to the Database approaches), because we support plans that are not trees.</li>_</ol>__@param program The program to be translated._@param postPasser The function to be used for post passing the optimizer's plan and setting the_data type specific serialization routines._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException {_		if (program == null || postPasser == null) {_			throw new NullPointerException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Beginning compilation of program '" + program.getJobName() + '\'')__		}__		final ExecutionMode defaultDataExchangeMode = program.getExecutionConfig().getExecutionMode()___		final int defaultParallelism = program.getDefaultParallelism() > 0 ?_			program.getDefaultParallelism() : this.defaultParallelism___		_		LOG.debug("Using a default parallelism of {}",  defaultParallelism)__		LOG.debug("Using default data exchange mode {}", defaultDataExchangeMode)___		_		_		_		_		_		_		_		__		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(defaultParallelism, defaultDataExchangeMode)__		program.accept(graphCreator)___		_		_		_		OptimizerNode rootNode__		if (graphCreator.getSinks().size() == 1) {_			rootNode = graphCreator.getSinks().get(0)__		}_		else if (graphCreator.getSinks().size() > 1) {_			Iterator<DataSinkNode> iter = graphCreator.getSinks().iterator()__			rootNode = iter.next()___			while (iter.hasNext()) {_				rootNode = new SinkJoiner(rootNode, iter.next())__			}_		}_		else {_			throw new CompilerException("Bug: The optimizer plan representation has no sinks.")__		}__		_		_		rootNode.accept(new IdAndEstimatesVisitor(this.statistics))___		_		_		_		BranchesVisitor branchingVisitor = new BranchesVisitor()__		rootNode.accept(branchingVisitor)___		_		InterestingPropertyVisitor propsVisitor = new InterestingPropertyVisitor(this.costEstimator)__		rootNode.accept(propsVisitor)__		_		_		if (rootNode.getOpenBranches() != null && rootNode.getOpenBranches().size() > 0) {_			throw new CompilerException("Bug: Logic for branching plans (non-tree plans) has an error, and does not " +_					"track the re-joining of branches correctly.")__		}__		_		List<PlanNode> bestPlan = rootNode.getAlternativePlans(this.costEstimator)___		if (bestPlan.size() != 1) {_			throw new CompilerException("Error in compiler: more than one best plan was created!")__		}__		_		_		PlanNode bestPlanRoot = bestPlan.get(0)__		List<SinkPlanNode> bestPlanSinks = new ArrayList<SinkPlanNode>(4)___		if (bestPlanRoot instanceof SinkPlanNode) {_			bestPlanSinks.add((SinkPlanNode) bestPlanRoot)__		} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {_			((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks)__		}_		_		DeadlockPreventer dp = new DeadlockPreventer()__		dp.resolveDeadlocks(bestPlanSinks)___		_		OptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program)__		_		plan.accept(new BinaryUnionReplacer())__		_		_		postPasser.postPass(plan)__		_		return plan__	};translates,the,given,program,to,an,optimized,plan,the,optimized,plan,describes,for,each,operator,which,strategy,to,use,such,as,hash,join,versus,sort,merge,join,what,data,exchange,method,to,use,local,pipe,forward,shuffle,broadcast,what,exchange,mode,to,use,pipelined,batch,where,to,cache,intermediate,results,etc,the,optimization,happens,in,multiple,phases,ol,li,create,optimizer,dag,implementation,of,the,program,tt,optimizer,node,tt,representations,of,the,pacts,assign,parallelism,and,compute,size,estimates,li,li,compute,interesting,properties,and,auxiliary,structures,li,li,enumerate,plan,alternatives,this,cannot,be,done,in,the,same,step,as,the,interesting,property,computation,as,opposed,to,the,database,approaches,because,we,support,plans,that,are,not,trees,li,ol,param,program,the,program,to,be,translated,param,post,passer,the,function,to,be,used,for,post,passing,the,optimizer,s,plan,and,setting,the,data,type,specific,serialization,routines,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;private,optimized,plan,compile,plan,program,optimizer,post,pass,post,passer,throws,compiler,exception,if,program,null,post,passer,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,beginning,compilation,of,program,program,get,job,name,final,execution,mode,default,data,exchange,mode,program,get,execution,config,get,execution,mode,final,int,default,parallelism,program,get,default,parallelism,0,program,get,default,parallelism,this,default,parallelism,log,debug,using,a,default,parallelism,of,default,parallelism,log,debug,using,default,data,exchange,mode,default,data,exchange,mode,graph,creating,visitor,graph,creator,new,graph,creating,visitor,default,parallelism,default,data,exchange,mode,program,accept,graph,creator,optimizer,node,root,node,if,graph,creator,get,sinks,size,1,root,node,graph,creator,get,sinks,get,0,else,if,graph,creator,get,sinks,size,1,iterator,data,sink,node,iter,graph,creator,get,sinks,iterator,root,node,iter,next,while,iter,has,next,root,node,new,sink,joiner,root,node,iter,next,else,throw,new,compiler,exception,bug,the,optimizer,plan,representation,has,no,sinks,root,node,accept,new,id,and,estimates,visitor,this,statistics,branches,visitor,branching,visitor,new,branches,visitor,root,node,accept,branching,visitor,interesting,property,visitor,props,visitor,new,interesting,property,visitor,this,cost,estimator,root,node,accept,props,visitor,if,root,node,get,open,branches,null,root,node,get,open,branches,size,0,throw,new,compiler,exception,bug,logic,for,branching,plans,non,tree,plans,has,an,error,and,does,not,track,the,re,joining,of,branches,correctly,list,plan,node,best,plan,root,node,get,alternative,plans,this,cost,estimator,if,best,plan,size,1,throw,new,compiler,exception,error,in,compiler,more,than,one,best,plan,was,created,plan,node,best,plan,root,best,plan,get,0,list,sink,plan,node,best,plan,sinks,new,array,list,sink,plan,node,4,if,best,plan,root,instanceof,sink,plan,node,best,plan,sinks,add,sink,plan,node,best,plan,root,else,if,best,plan,root,instanceof,sink,joiner,plan,node,sink,joiner,plan,node,best,plan,root,get,data,sinks,best,plan,sinks,deadlock,preventer,dp,new,deadlock,preventer,dp,resolve,deadlocks,best,plan,sinks,optimized,plan,plan,new,plan,finalizer,create,final,plan,best,plan,sinks,program,get,job,name,program,plan,accept,new,binary,union,replacer,post,passer,post,pass,plan,return,plan
Optimizer -> private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException;1427097836;Translates the given program to an OptimizedPlan. The optimized plan describes for each operator_which strategy to use (such as hash join versus sort-merge join), what data exchange method to use_(local pipe forward, shuffle, broadcast), what exchange mode to use (pipelined, batch),_where to cache intermediate results, etc,__The optimization happens in multiple phases:_<ol>_<li>Create optimizer dag implementation of the program.__<tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li>_<li>Compute interesting properties and auxiliary structures.</li>_<li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as_opposed to the Database approaches), because we support plans that are not trees.</li>_</ol>__@param program The program to be translated._@param postPasser The function to be used for post passing the optimizer's plan and setting the_data type specific serialization routines._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException {_		if (program == null || postPasser == null) {_			throw new NullPointerException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Beginning compilation of program '" + program.getJobName() + '\'')__		}__		final ExecutionMode defaultDataExchangeMode = program.getExecutionConfig().getExecutionMode()___		final int defaultParallelism = program.getDefaultParallelism() > 0 ?_			program.getDefaultParallelism() : this.defaultParallelism___		_		LOG.debug("Using a default parallelism of {}",  defaultParallelism)__		LOG.debug("Using default data exchange mode {}", defaultDataExchangeMode)___		_		_		_		_		_		_		_		__		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(defaultParallelism, defaultDataExchangeMode)__		program.accept(graphCreator)___		_		_		_		OptimizerNode rootNode__		if (graphCreator.getSinks().size() == 1) {_			rootNode = graphCreator.getSinks().get(0)__		}_		else if (graphCreator.getSinks().size() > 1) {_			Iterator<DataSinkNode> iter = graphCreator.getSinks().iterator()__			rootNode = iter.next()___			while (iter.hasNext()) {_				rootNode = new SinkJoiner(rootNode, iter.next())__			}_		}_		else {_			throw new CompilerException("Bug: The optimizer plan representation has no sinks.")__		}__		_		_		rootNode.accept(new IdAndEstimatesVisitor(this.statistics))___		_		_		_		BranchesVisitor branchingVisitor = new BranchesVisitor()__		rootNode.accept(branchingVisitor)___		_		InterestingPropertyVisitor propsVisitor = new InterestingPropertyVisitor(this.costEstimator)__		rootNode.accept(propsVisitor)__		_		_		if (rootNode.getOpenBranches() != null && rootNode.getOpenBranches().size() > 0) {_			throw new CompilerException("Bug: Logic for branching plans (non-tree plans) has an error, and does not " +_					"track the re-joining of branches correctly.")__		}__		_		List<PlanNode> bestPlan = rootNode.getAlternativePlans(this.costEstimator)___		if (bestPlan.size() != 1) {_			throw new CompilerException("Error in compiler: more than one best plan was created!")__		}__		_		_		PlanNode bestPlanRoot = bestPlan.get(0)__		List<SinkPlanNode> bestPlanSinks = new ArrayList<SinkPlanNode>(4)___		if (bestPlanRoot instanceof SinkPlanNode) {_			bestPlanSinks.add((SinkPlanNode) bestPlanRoot)__		} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {_			((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks)__		}_		_		DeadlockPreventer dp = new DeadlockPreventer()__		dp.resolveDeadlocks(bestPlanSinks)___		_		OptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program)__		_		plan.accept(new BinaryUnionReplacer())__		_		_		postPasser.postPass(plan)__		_		return plan__	};translates,the,given,program,to,an,optimized,plan,the,optimized,plan,describes,for,each,operator,which,strategy,to,use,such,as,hash,join,versus,sort,merge,join,what,data,exchange,method,to,use,local,pipe,forward,shuffle,broadcast,what,exchange,mode,to,use,pipelined,batch,where,to,cache,intermediate,results,etc,the,optimization,happens,in,multiple,phases,ol,li,create,optimizer,dag,implementation,of,the,program,tt,optimizer,node,tt,representations,of,the,pacts,assign,parallelism,and,compute,size,estimates,li,li,compute,interesting,properties,and,auxiliary,structures,li,li,enumerate,plan,alternatives,this,cannot,be,done,in,the,same,step,as,the,interesting,property,computation,as,opposed,to,the,database,approaches,because,we,support,plans,that,are,not,trees,li,ol,param,program,the,program,to,be,translated,param,post,passer,the,function,to,be,used,for,post,passing,the,optimizer,s,plan,and,setting,the,data,type,specific,serialization,routines,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;private,optimized,plan,compile,plan,program,optimizer,post,pass,post,passer,throws,compiler,exception,if,program,null,post,passer,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,beginning,compilation,of,program,program,get,job,name,final,execution,mode,default,data,exchange,mode,program,get,execution,config,get,execution,mode,final,int,default,parallelism,program,get,default,parallelism,0,program,get,default,parallelism,this,default,parallelism,log,debug,using,a,default,parallelism,of,default,parallelism,log,debug,using,default,data,exchange,mode,default,data,exchange,mode,graph,creating,visitor,graph,creator,new,graph,creating,visitor,default,parallelism,default,data,exchange,mode,program,accept,graph,creator,optimizer,node,root,node,if,graph,creator,get,sinks,size,1,root,node,graph,creator,get,sinks,get,0,else,if,graph,creator,get,sinks,size,1,iterator,data,sink,node,iter,graph,creator,get,sinks,iterator,root,node,iter,next,while,iter,has,next,root,node,new,sink,joiner,root,node,iter,next,else,throw,new,compiler,exception,bug,the,optimizer,plan,representation,has,no,sinks,root,node,accept,new,id,and,estimates,visitor,this,statistics,branches,visitor,branching,visitor,new,branches,visitor,root,node,accept,branching,visitor,interesting,property,visitor,props,visitor,new,interesting,property,visitor,this,cost,estimator,root,node,accept,props,visitor,if,root,node,get,open,branches,null,root,node,get,open,branches,size,0,throw,new,compiler,exception,bug,logic,for,branching,plans,non,tree,plans,has,an,error,and,does,not,track,the,re,joining,of,branches,correctly,list,plan,node,best,plan,root,node,get,alternative,plans,this,cost,estimator,if,best,plan,size,1,throw,new,compiler,exception,error,in,compiler,more,than,one,best,plan,was,created,plan,node,best,plan,root,best,plan,get,0,list,sink,plan,node,best,plan,sinks,new,array,list,sink,plan,node,4,if,best,plan,root,instanceof,sink,plan,node,best,plan,sinks,add,sink,plan,node,best,plan,root,else,if,best,plan,root,instanceof,sink,joiner,plan,node,sink,joiner,plan,node,best,plan,root,get,data,sinks,best,plan,sinks,deadlock,preventer,dp,new,deadlock,preventer,dp,resolve,deadlocks,best,plan,sinks,optimized,plan,plan,new,plan,finalizer,create,final,plan,best,plan,sinks,program,get,job,name,program,plan,accept,new,binary,union,replacer,post,passer,post,pass,plan,return,plan
Optimizer -> private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException;1427784999;Translates the given program to an OptimizedPlan. The optimized plan describes for each operator_which strategy to use (such as hash join versus sort-merge join), what data exchange method to use_(local pipe forward, shuffle, broadcast), what exchange mode to use (pipelined, batch),_where to cache intermediate results, etc,__The optimization happens in multiple phases:_<ol>_<li>Create optimizer dag implementation of the program.__<tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li>_<li>Compute interesting properties and auxiliary structures.</li>_<li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as_opposed to the Database approaches), because we support plans that are not trees.</li>_</ol>__@param program The program to be translated._@param postPasser The function to be used for post passing the optimizer's plan and setting the_data type specific serialization routines._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException {_		if (program == null || postPasser == null) {_			throw new NullPointerException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Beginning compilation of program '" + program.getJobName() + '\'')__		}__		final ExecutionMode defaultDataExchangeMode = program.getExecutionConfig().getExecutionMode()___		final int defaultParallelism = program.getDefaultParallelism() > 0 ?_			program.getDefaultParallelism() : this.defaultParallelism___		_		LOG.debug("Using a default parallelism of {}",  defaultParallelism)__		LOG.debug("Using default data exchange mode {}", defaultDataExchangeMode)___		_		_		_		_		_		_		_		__		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(defaultParallelism, defaultDataExchangeMode)__		program.accept(graphCreator)___		_		_		_		OptimizerNode rootNode__		if (graphCreator.getSinks().size() == 1) {_			rootNode = graphCreator.getSinks().get(0)__		}_		else if (graphCreator.getSinks().size() > 1) {_			Iterator<DataSinkNode> iter = graphCreator.getSinks().iterator()__			rootNode = iter.next()___			while (iter.hasNext()) {_				rootNode = new SinkJoiner(rootNode, iter.next())__			}_		}_		else {_			throw new CompilerException("Bug: The optimizer plan representation has no sinks.")__		}__		_		_		rootNode.accept(new IdAndEstimatesVisitor(this.statistics))___		_		_		_		BranchesVisitor branchingVisitor = new BranchesVisitor()__		rootNode.accept(branchingVisitor)___		_		InterestingPropertyVisitor propsVisitor = new InterestingPropertyVisitor(this.costEstimator)__		rootNode.accept(propsVisitor)__		_		_		if (rootNode.getOpenBranches() != null && rootNode.getOpenBranches().size() > 0) {_			throw new CompilerException("Bug: Logic for branching plans (non-tree plans) has an error, and does not " +_					"track the re-joining of branches correctly.")__		}__		_		List<PlanNode> bestPlan = rootNode.getAlternativePlans(this.costEstimator)___		if (bestPlan.size() != 1) {_			throw new CompilerException("Error in compiler: more than one best plan was created!")__		}__		_		_		PlanNode bestPlanRoot = bestPlan.get(0)__		List<SinkPlanNode> bestPlanSinks = new ArrayList<SinkPlanNode>(4)___		if (bestPlanRoot instanceof SinkPlanNode) {_			bestPlanSinks.add((SinkPlanNode) bestPlanRoot)__		} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {_			((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks)__		}_		_		DeadlockPreventer dp = new DeadlockPreventer()__		dp.resolveDeadlocks(bestPlanSinks)___		_		OptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program)__		_		plan.accept(new BinaryUnionReplacer())__		_		_		postPasser.postPass(plan)__		_		return plan__	};translates,the,given,program,to,an,optimized,plan,the,optimized,plan,describes,for,each,operator,which,strategy,to,use,such,as,hash,join,versus,sort,merge,join,what,data,exchange,method,to,use,local,pipe,forward,shuffle,broadcast,what,exchange,mode,to,use,pipelined,batch,where,to,cache,intermediate,results,etc,the,optimization,happens,in,multiple,phases,ol,li,create,optimizer,dag,implementation,of,the,program,tt,optimizer,node,tt,representations,of,the,pacts,assign,parallelism,and,compute,size,estimates,li,li,compute,interesting,properties,and,auxiliary,structures,li,li,enumerate,plan,alternatives,this,cannot,be,done,in,the,same,step,as,the,interesting,property,computation,as,opposed,to,the,database,approaches,because,we,support,plans,that,are,not,trees,li,ol,param,program,the,program,to,be,translated,param,post,passer,the,function,to,be,used,for,post,passing,the,optimizer,s,plan,and,setting,the,data,type,specific,serialization,routines,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;private,optimized,plan,compile,plan,program,optimizer,post,pass,post,passer,throws,compiler,exception,if,program,null,post,passer,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,beginning,compilation,of,program,program,get,job,name,final,execution,mode,default,data,exchange,mode,program,get,execution,config,get,execution,mode,final,int,default,parallelism,program,get,default,parallelism,0,program,get,default,parallelism,this,default,parallelism,log,debug,using,a,default,parallelism,of,default,parallelism,log,debug,using,default,data,exchange,mode,default,data,exchange,mode,graph,creating,visitor,graph,creator,new,graph,creating,visitor,default,parallelism,default,data,exchange,mode,program,accept,graph,creator,optimizer,node,root,node,if,graph,creator,get,sinks,size,1,root,node,graph,creator,get,sinks,get,0,else,if,graph,creator,get,sinks,size,1,iterator,data,sink,node,iter,graph,creator,get,sinks,iterator,root,node,iter,next,while,iter,has,next,root,node,new,sink,joiner,root,node,iter,next,else,throw,new,compiler,exception,bug,the,optimizer,plan,representation,has,no,sinks,root,node,accept,new,id,and,estimates,visitor,this,statistics,branches,visitor,branching,visitor,new,branches,visitor,root,node,accept,branching,visitor,interesting,property,visitor,props,visitor,new,interesting,property,visitor,this,cost,estimator,root,node,accept,props,visitor,if,root,node,get,open,branches,null,root,node,get,open,branches,size,0,throw,new,compiler,exception,bug,logic,for,branching,plans,non,tree,plans,has,an,error,and,does,not,track,the,re,joining,of,branches,correctly,list,plan,node,best,plan,root,node,get,alternative,plans,this,cost,estimator,if,best,plan,size,1,throw,new,compiler,exception,error,in,compiler,more,than,one,best,plan,was,created,plan,node,best,plan,root,best,plan,get,0,list,sink,plan,node,best,plan,sinks,new,array,list,sink,plan,node,4,if,best,plan,root,instanceof,sink,plan,node,best,plan,sinks,add,sink,plan,node,best,plan,root,else,if,best,plan,root,instanceof,sink,joiner,plan,node,sink,joiner,plan,node,best,plan,root,get,data,sinks,best,plan,sinks,deadlock,preventer,dp,new,deadlock,preventer,dp,resolve,deadlocks,best,plan,sinks,optimized,plan,plan,new,plan,finalizer,create,final,plan,best,plan,sinks,program,get,job,name,program,plan,accept,new,binary,union,replacer,post,passer,post,pass,plan,return,plan
Optimizer -> private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException;1431981454;Translates the given program to an OptimizedPlan. The optimized plan describes for each operator_which strategy to use (such as hash join versus sort-merge join), what data exchange method to use_(local pipe forward, shuffle, broadcast), what exchange mode to use (pipelined, batch),_where to cache intermediate results, etc,__The optimization happens in multiple phases:_<ol>_<li>Create optimizer dag implementation of the program.__<tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li>_<li>Compute interesting properties and auxiliary structures.</li>_<li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as_opposed to the Database approaches), because we support plans that are not trees.</li>_</ol>__@param program The program to be translated._@param postPasser The function to be used for post passing the optimizer's plan and setting the_data type specific serialization routines._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException {_		if (program == null || postPasser == null) {_			throw new NullPointerException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Beginning compilation of program '" + program.getJobName() + '\'')__		}__		final ExecutionMode defaultDataExchangeMode = program.getExecutionConfig().getExecutionMode()___		final int defaultParallelism = program.getDefaultParallelism() > 0 ?_			program.getDefaultParallelism() : this.defaultParallelism___		_		LOG.debug("Using a default parallelism of {}",  defaultParallelism)__		LOG.debug("Using default data exchange mode {}", defaultDataExchangeMode)___		_		_		_		_		_		_		_		__		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(defaultParallelism, defaultDataExchangeMode)__		program.accept(graphCreator)___		_		_		_		OptimizerNode rootNode__		if (graphCreator.getSinks().size() == 1) {_			rootNode = graphCreator.getSinks().get(0)__		}_		else if (graphCreator.getSinks().size() > 1) {_			Iterator<DataSinkNode> iter = graphCreator.getSinks().iterator()__			rootNode = iter.next()___			while (iter.hasNext()) {_				rootNode = new SinkJoiner(rootNode, iter.next())__			}_		}_		else {_			throw new CompilerException("Bug: The optimizer plan representation has no sinks.")__		}__		_		_		rootNode.accept(new IdAndEstimatesVisitor(this.statistics))___		_		_		_		BranchesVisitor branchingVisitor = new BranchesVisitor()__		rootNode.accept(branchingVisitor)___		_		InterestingPropertyVisitor propsVisitor = new InterestingPropertyVisitor(this.costEstimator)__		rootNode.accept(propsVisitor)__		_		_		if (rootNode.getOpenBranches() != null && rootNode.getOpenBranches().size() > 0) {_			throw new CompilerException("Bug: Logic for branching plans (non-tree plans) has an error, and does not " +_					"track the re-joining of branches correctly.")__		}__		_		List<PlanNode> bestPlan = rootNode.getAlternativePlans(this.costEstimator)___		if (bestPlan.size() != 1) {_			throw new CompilerException("Error in compiler: more than one best plan was created!")__		}__		_		_		PlanNode bestPlanRoot = bestPlan.get(0)__		List<SinkPlanNode> bestPlanSinks = new ArrayList<SinkPlanNode>(4)___		if (bestPlanRoot instanceof SinkPlanNode) {_			bestPlanSinks.add((SinkPlanNode) bestPlanRoot)__		} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {_			((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks)__		}__		_		OptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program)__		_		plan.accept(new BinaryUnionReplacer())__		_		_		postPasser.postPass(plan)__		_		return plan__	};translates,the,given,program,to,an,optimized,plan,the,optimized,plan,describes,for,each,operator,which,strategy,to,use,such,as,hash,join,versus,sort,merge,join,what,data,exchange,method,to,use,local,pipe,forward,shuffle,broadcast,what,exchange,mode,to,use,pipelined,batch,where,to,cache,intermediate,results,etc,the,optimization,happens,in,multiple,phases,ol,li,create,optimizer,dag,implementation,of,the,program,tt,optimizer,node,tt,representations,of,the,pacts,assign,parallelism,and,compute,size,estimates,li,li,compute,interesting,properties,and,auxiliary,structures,li,li,enumerate,plan,alternatives,this,cannot,be,done,in,the,same,step,as,the,interesting,property,computation,as,opposed,to,the,database,approaches,because,we,support,plans,that,are,not,trees,li,ol,param,program,the,program,to,be,translated,param,post,passer,the,function,to,be,used,for,post,passing,the,optimizer,s,plan,and,setting,the,data,type,specific,serialization,routines,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;private,optimized,plan,compile,plan,program,optimizer,post,pass,post,passer,throws,compiler,exception,if,program,null,post,passer,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,beginning,compilation,of,program,program,get,job,name,final,execution,mode,default,data,exchange,mode,program,get,execution,config,get,execution,mode,final,int,default,parallelism,program,get,default,parallelism,0,program,get,default,parallelism,this,default,parallelism,log,debug,using,a,default,parallelism,of,default,parallelism,log,debug,using,default,data,exchange,mode,default,data,exchange,mode,graph,creating,visitor,graph,creator,new,graph,creating,visitor,default,parallelism,default,data,exchange,mode,program,accept,graph,creator,optimizer,node,root,node,if,graph,creator,get,sinks,size,1,root,node,graph,creator,get,sinks,get,0,else,if,graph,creator,get,sinks,size,1,iterator,data,sink,node,iter,graph,creator,get,sinks,iterator,root,node,iter,next,while,iter,has,next,root,node,new,sink,joiner,root,node,iter,next,else,throw,new,compiler,exception,bug,the,optimizer,plan,representation,has,no,sinks,root,node,accept,new,id,and,estimates,visitor,this,statistics,branches,visitor,branching,visitor,new,branches,visitor,root,node,accept,branching,visitor,interesting,property,visitor,props,visitor,new,interesting,property,visitor,this,cost,estimator,root,node,accept,props,visitor,if,root,node,get,open,branches,null,root,node,get,open,branches,size,0,throw,new,compiler,exception,bug,logic,for,branching,plans,non,tree,plans,has,an,error,and,does,not,track,the,re,joining,of,branches,correctly,list,plan,node,best,plan,root,node,get,alternative,plans,this,cost,estimator,if,best,plan,size,1,throw,new,compiler,exception,error,in,compiler,more,than,one,best,plan,was,created,plan,node,best,plan,root,best,plan,get,0,list,sink,plan,node,best,plan,sinks,new,array,list,sink,plan,node,4,if,best,plan,root,instanceof,sink,plan,node,best,plan,sinks,add,sink,plan,node,best,plan,root,else,if,best,plan,root,instanceof,sink,joiner,plan,node,sink,joiner,plan,node,best,plan,root,get,data,sinks,best,plan,sinks,optimized,plan,plan,new,plan,finalizer,create,final,plan,best,plan,sinks,program,get,job,name,program,plan,accept,new,binary,union,replacer,post,passer,post,pass,plan,return,plan
Optimizer -> private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException;1436966346;Translates the given program to an OptimizedPlan. The optimized plan describes for each operator_which strategy to use (such as hash join versus sort-merge join), what data exchange method to use_(local pipe forward, shuffle, broadcast), what exchange mode to use (pipelined, batch),_where to cache intermediate results, etc,__The optimization happens in multiple phases:_<ol>_<li>Create optimizer dag implementation of the program.__<tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li>_<li>Compute interesting properties and auxiliary structures.</li>_<li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as_opposed to the Database approaches), because we support plans that are not trees.</li>_</ol>__@param program The program to be translated._@param postPasser The function to be used for post passing the optimizer's plan and setting the_data type specific serialization routines._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException {_		if (program == null || postPasser == null) {_			throw new NullPointerException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Beginning compilation of program '" + program.getJobName() + '\'')__		}__		final ExecutionMode defaultDataExchangeMode = program.getExecutionConfig().getExecutionMode()___		final int defaultParallelism = program.getDefaultParallelism() > 0 ?_			program.getDefaultParallelism() : this.defaultParallelism___		_		LOG.debug("Using a default parallelism of {}",  defaultParallelism)__		LOG.debug("Using default data exchange mode {}", defaultDataExchangeMode)___		_		_		_		_		_		_		_		__		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(defaultParallelism, defaultDataExchangeMode)__		program.accept(graphCreator)___		_		_		_		OptimizerNode rootNode__		if (graphCreator.getSinks().size() == 1) {_			rootNode = graphCreator.getSinks().get(0)__		}_		else if (graphCreator.getSinks().size() > 1) {_			Iterator<DataSinkNode> iter = graphCreator.getSinks().iterator()__			rootNode = iter.next()___			while (iter.hasNext()) {_				rootNode = new SinkJoiner(rootNode, iter.next())__			}_		}_		else {_			throw new CompilerException("Bug: The optimizer plan representation has no sinks.")__		}__		_		_		rootNode.accept(new IdAndEstimatesVisitor(this.statistics))___		_		_		_		BranchesVisitor branchingVisitor = new BranchesVisitor()__		rootNode.accept(branchingVisitor)___		_		InterestingPropertyVisitor propsVisitor = new InterestingPropertyVisitor(this.costEstimator)__		rootNode.accept(propsVisitor)__		_		_		if (rootNode.getOpenBranches() != null && rootNode.getOpenBranches().size() > 0) {_			throw new CompilerException("Bug: Logic for branching plans (non-tree plans) has an error, and does not " +_					"track the re-joining of branches correctly.")__		}__		_		List<PlanNode> bestPlan = rootNode.getAlternativePlans(this.costEstimator)___		if (bestPlan.size() != 1) {_			throw new CompilerException("Error in compiler: more than one best plan was created!")__		}__		_		_		PlanNode bestPlanRoot = bestPlan.get(0)__		List<SinkPlanNode> bestPlanSinks = new ArrayList<SinkPlanNode>(4)___		if (bestPlanRoot instanceof SinkPlanNode) {_			bestPlanSinks.add((SinkPlanNode) bestPlanRoot)__		} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {_			((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks)__		}__		_		OptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program)__		_		plan.accept(new BinaryUnionReplacer())__		_		_		postPasser.postPass(plan)__		_		return plan__	};translates,the,given,program,to,an,optimized,plan,the,optimized,plan,describes,for,each,operator,which,strategy,to,use,such,as,hash,join,versus,sort,merge,join,what,data,exchange,method,to,use,local,pipe,forward,shuffle,broadcast,what,exchange,mode,to,use,pipelined,batch,where,to,cache,intermediate,results,etc,the,optimization,happens,in,multiple,phases,ol,li,create,optimizer,dag,implementation,of,the,program,tt,optimizer,node,tt,representations,of,the,pacts,assign,parallelism,and,compute,size,estimates,li,li,compute,interesting,properties,and,auxiliary,structures,li,li,enumerate,plan,alternatives,this,cannot,be,done,in,the,same,step,as,the,interesting,property,computation,as,opposed,to,the,database,approaches,because,we,support,plans,that,are,not,trees,li,ol,param,program,the,program,to,be,translated,param,post,passer,the,function,to,be,used,for,post,passing,the,optimizer,s,plan,and,setting,the,data,type,specific,serialization,routines,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;private,optimized,plan,compile,plan,program,optimizer,post,pass,post,passer,throws,compiler,exception,if,program,null,post,passer,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,beginning,compilation,of,program,program,get,job,name,final,execution,mode,default,data,exchange,mode,program,get,execution,config,get,execution,mode,final,int,default,parallelism,program,get,default,parallelism,0,program,get,default,parallelism,this,default,parallelism,log,debug,using,a,default,parallelism,of,default,parallelism,log,debug,using,default,data,exchange,mode,default,data,exchange,mode,graph,creating,visitor,graph,creator,new,graph,creating,visitor,default,parallelism,default,data,exchange,mode,program,accept,graph,creator,optimizer,node,root,node,if,graph,creator,get,sinks,size,1,root,node,graph,creator,get,sinks,get,0,else,if,graph,creator,get,sinks,size,1,iterator,data,sink,node,iter,graph,creator,get,sinks,iterator,root,node,iter,next,while,iter,has,next,root,node,new,sink,joiner,root,node,iter,next,else,throw,new,compiler,exception,bug,the,optimizer,plan,representation,has,no,sinks,root,node,accept,new,id,and,estimates,visitor,this,statistics,branches,visitor,branching,visitor,new,branches,visitor,root,node,accept,branching,visitor,interesting,property,visitor,props,visitor,new,interesting,property,visitor,this,cost,estimator,root,node,accept,props,visitor,if,root,node,get,open,branches,null,root,node,get,open,branches,size,0,throw,new,compiler,exception,bug,logic,for,branching,plans,non,tree,plans,has,an,error,and,does,not,track,the,re,joining,of,branches,correctly,list,plan,node,best,plan,root,node,get,alternative,plans,this,cost,estimator,if,best,plan,size,1,throw,new,compiler,exception,error,in,compiler,more,than,one,best,plan,was,created,plan,node,best,plan,root,best,plan,get,0,list,sink,plan,node,best,plan,sinks,new,array,list,sink,plan,node,4,if,best,plan,root,instanceof,sink,plan,node,best,plan,sinks,add,sink,plan,node,best,plan,root,else,if,best,plan,root,instanceof,sink,joiner,plan,node,sink,joiner,plan,node,best,plan,root,get,data,sinks,best,plan,sinks,optimized,plan,plan,new,plan,finalizer,create,final,plan,best,plan,sinks,program,get,job,name,program,plan,accept,new,binary,union,replacer,post,passer,post,pass,plan,return,plan
Optimizer -> private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException;1444404795;Translates the given program to an OptimizedPlan. The optimized plan describes for each operator_which strategy to use (such as hash join versus sort-merge join), what data exchange method to use_(local pipe forward, shuffle, broadcast), what exchange mode to use (pipelined, batch),_where to cache intermediate results, etc,__The optimization happens in multiple phases:_<ol>_<li>Create optimizer dag implementation of the program.__<tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li>_<li>Compute interesting properties and auxiliary structures.</li>_<li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as_opposed to the Database approaches), because we support plans that are not trees.</li>_</ol>__@param program The program to be translated._@param postPasser The function to be used for post passing the optimizer's plan and setting the_data type specific serialization routines._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException {_		if (program == null || postPasser == null) {_			throw new NullPointerException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Beginning compilation of program '" + program.getJobName() + '\'')__		}__		final ExecutionMode defaultDataExchangeMode = program.getExecutionConfig().getExecutionMode()___		final int defaultParallelism = program.getDefaultParallelism() > 0 ?_			program.getDefaultParallelism() : this.defaultParallelism___		_		LOG.debug("Using a default parallelism of {}",  defaultParallelism)__		LOG.debug("Using default data exchange mode {}", defaultDataExchangeMode)___		_		_		_		_		_		_		_		__		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(defaultParallelism, defaultDataExchangeMode)__		program.accept(graphCreator)___		_		_		_		OptimizerNode rootNode__		if (graphCreator.getSinks().size() == 1) {_			rootNode = graphCreator.getSinks().get(0)__		}_		else if (graphCreator.getSinks().size() > 1) {_			Iterator<DataSinkNode> iter = graphCreator.getSinks().iterator()__			rootNode = iter.next()___			while (iter.hasNext()) {_				rootNode = new SinkJoiner(rootNode, iter.next())__			}_		}_		else {_			throw new CompilerException("Bug: The optimizer plan representation has no sinks.")__		}__		_		_		rootNode.accept(new IdAndEstimatesVisitor(this.statistics))___		_		_		_		BranchesVisitor branchingVisitor = new BranchesVisitor()__		rootNode.accept(branchingVisitor)___		_		InterestingPropertyVisitor propsVisitor = new InterestingPropertyVisitor(this.costEstimator)__		rootNode.accept(propsVisitor)__		_		_		if (rootNode.getOpenBranches() != null && rootNode.getOpenBranches().size() > 0) {_			throw new CompilerException("Bug: Logic for branching plans (non-tree plans) has an error, and does not " +_					"track the re-joining of branches correctly.")__		}__		_		List<PlanNode> bestPlan = rootNode.getAlternativePlans(this.costEstimator)___		if (bestPlan.size() != 1) {_			throw new CompilerException("Error in compiler: more than one best plan was created!")__		}__		_		_		PlanNode bestPlanRoot = bestPlan.get(0)__		List<SinkPlanNode> bestPlanSinks = new ArrayList<SinkPlanNode>(4)___		if (bestPlanRoot instanceof SinkPlanNode) {_			bestPlanSinks.add((SinkPlanNode) bestPlanRoot)__		} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {_			((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks)__		}__		_		OptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program)__		_		plan.accept(new BinaryUnionReplacer())__		_		_		postPasser.postPass(plan)__		_		return plan__	};translates,the,given,program,to,an,optimized,plan,the,optimized,plan,describes,for,each,operator,which,strategy,to,use,such,as,hash,join,versus,sort,merge,join,what,data,exchange,method,to,use,local,pipe,forward,shuffle,broadcast,what,exchange,mode,to,use,pipelined,batch,where,to,cache,intermediate,results,etc,the,optimization,happens,in,multiple,phases,ol,li,create,optimizer,dag,implementation,of,the,program,tt,optimizer,node,tt,representations,of,the,pacts,assign,parallelism,and,compute,size,estimates,li,li,compute,interesting,properties,and,auxiliary,structures,li,li,enumerate,plan,alternatives,this,cannot,be,done,in,the,same,step,as,the,interesting,property,computation,as,opposed,to,the,database,approaches,because,we,support,plans,that,are,not,trees,li,ol,param,program,the,program,to,be,translated,param,post,passer,the,function,to,be,used,for,post,passing,the,optimizer,s,plan,and,setting,the,data,type,specific,serialization,routines,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;private,optimized,plan,compile,plan,program,optimizer,post,pass,post,passer,throws,compiler,exception,if,program,null,post,passer,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,beginning,compilation,of,program,program,get,job,name,final,execution,mode,default,data,exchange,mode,program,get,execution,config,get,execution,mode,final,int,default,parallelism,program,get,default,parallelism,0,program,get,default,parallelism,this,default,parallelism,log,debug,using,a,default,parallelism,of,default,parallelism,log,debug,using,default,data,exchange,mode,default,data,exchange,mode,graph,creating,visitor,graph,creator,new,graph,creating,visitor,default,parallelism,default,data,exchange,mode,program,accept,graph,creator,optimizer,node,root,node,if,graph,creator,get,sinks,size,1,root,node,graph,creator,get,sinks,get,0,else,if,graph,creator,get,sinks,size,1,iterator,data,sink,node,iter,graph,creator,get,sinks,iterator,root,node,iter,next,while,iter,has,next,root,node,new,sink,joiner,root,node,iter,next,else,throw,new,compiler,exception,bug,the,optimizer,plan,representation,has,no,sinks,root,node,accept,new,id,and,estimates,visitor,this,statistics,branches,visitor,branching,visitor,new,branches,visitor,root,node,accept,branching,visitor,interesting,property,visitor,props,visitor,new,interesting,property,visitor,this,cost,estimator,root,node,accept,props,visitor,if,root,node,get,open,branches,null,root,node,get,open,branches,size,0,throw,new,compiler,exception,bug,logic,for,branching,plans,non,tree,plans,has,an,error,and,does,not,track,the,re,joining,of,branches,correctly,list,plan,node,best,plan,root,node,get,alternative,plans,this,cost,estimator,if,best,plan,size,1,throw,new,compiler,exception,error,in,compiler,more,than,one,best,plan,was,created,plan,node,best,plan,root,best,plan,get,0,list,sink,plan,node,best,plan,sinks,new,array,list,sink,plan,node,4,if,best,plan,root,instanceof,sink,plan,node,best,plan,sinks,add,sink,plan,node,best,plan,root,else,if,best,plan,root,instanceof,sink,joiner,plan,node,sink,joiner,plan,node,best,plan,root,get,data,sinks,best,plan,sinks,optimized,plan,plan,new,plan,finalizer,create,final,plan,best,plan,sinks,program,get,job,name,program,plan,accept,new,binary,union,replacer,post,passer,post,pass,plan,return,plan
Optimizer -> private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException;1450712612;Translates the given program to an OptimizedPlan. The optimized plan describes for each operator_which strategy to use (such as hash join versus sort-merge join), what data exchange method to use_(local pipe forward, shuffle, broadcast), what exchange mode to use (pipelined, batch),_where to cache intermediate results, etc,__The optimization happens in multiple phases:_<ol>_<li>Create optimizer dag implementation of the program.__<tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li>_<li>Compute interesting properties and auxiliary structures.</li>_<li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as_opposed to the Database approaches), because we support plans that are not trees.</li>_</ol>__@param program The program to be translated._@param postPasser The function to be used for post passing the optimizer's plan and setting the_data type specific serialization routines._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException {_		if (program == null || postPasser == null) {_			throw new NullPointerException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Beginning compilation of program '" + program.getJobName() + '\'')__		}__		final ExecutionMode defaultDataExchangeMode = program.getExecutionConfig().getExecutionMode()___		final int defaultParallelism = program.getDefaultParallelism() > 0 ?_			program.getDefaultParallelism() : this.defaultParallelism___		_		LOG.debug("Using a default parallelism of {}",  defaultParallelism)__		LOG.debug("Using default data exchange mode {}", defaultDataExchangeMode)___		_		_		_		_		_		_		_		__		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(defaultParallelism, defaultDataExchangeMode)__		program.accept(graphCreator)___		_		_		_		OptimizerNode rootNode__		if (graphCreator.getSinks().size() == 1) {_			rootNode = graphCreator.getSinks().get(0)__		}_		else if (graphCreator.getSinks().size() > 1) {_			Iterator<DataSinkNode> iter = graphCreator.getSinks().iterator()__			rootNode = iter.next()___			while (iter.hasNext()) {_				rootNode = new SinkJoiner(rootNode, iter.next())__			}_		}_		else {_			throw new CompilerException("Bug: The optimizer plan representation has no sinks.")__		}__		_		_		rootNode.accept(new IdAndEstimatesVisitor(this.statistics))___		_		_		_		BranchesVisitor branchingVisitor = new BranchesVisitor()__		rootNode.accept(branchingVisitor)___		_		InterestingPropertyVisitor propsVisitor = new InterestingPropertyVisitor(this.costEstimator)__		rootNode.accept(propsVisitor)__		_		_		if (rootNode.getOpenBranches() != null && rootNode.getOpenBranches().size() > 0) {_			throw new CompilerException("Bug: Logic for branching plans (non-tree plans) has an error, and does not " +_					"track the re-joining of branches correctly.")__		}__		_		List<PlanNode> bestPlan = rootNode.getAlternativePlans(this.costEstimator)___		if (bestPlan.size() != 1) {_			throw new CompilerException("Error in compiler: more than one best plan was created!")__		}__		_		_		PlanNode bestPlanRoot = bestPlan.get(0)__		List<SinkPlanNode> bestPlanSinks = new ArrayList<SinkPlanNode>(4)___		if (bestPlanRoot instanceof SinkPlanNode) {_			bestPlanSinks.add((SinkPlanNode) bestPlanRoot)__		} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {_			((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks)__		}__		_		OptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program)__		_		plan.accept(new BinaryUnionReplacer())___		plan.accept(new RangePartitionRewriter(plan))___		_		postPasser.postPass(plan)__		_		return plan__	};translates,the,given,program,to,an,optimized,plan,the,optimized,plan,describes,for,each,operator,which,strategy,to,use,such,as,hash,join,versus,sort,merge,join,what,data,exchange,method,to,use,local,pipe,forward,shuffle,broadcast,what,exchange,mode,to,use,pipelined,batch,where,to,cache,intermediate,results,etc,the,optimization,happens,in,multiple,phases,ol,li,create,optimizer,dag,implementation,of,the,program,tt,optimizer,node,tt,representations,of,the,pacts,assign,parallelism,and,compute,size,estimates,li,li,compute,interesting,properties,and,auxiliary,structures,li,li,enumerate,plan,alternatives,this,cannot,be,done,in,the,same,step,as,the,interesting,property,computation,as,opposed,to,the,database,approaches,because,we,support,plans,that,are,not,trees,li,ol,param,program,the,program,to,be,translated,param,post,passer,the,function,to,be,used,for,post,passing,the,optimizer,s,plan,and,setting,the,data,type,specific,serialization,routines,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;private,optimized,plan,compile,plan,program,optimizer,post,pass,post,passer,throws,compiler,exception,if,program,null,post,passer,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,beginning,compilation,of,program,program,get,job,name,final,execution,mode,default,data,exchange,mode,program,get,execution,config,get,execution,mode,final,int,default,parallelism,program,get,default,parallelism,0,program,get,default,parallelism,this,default,parallelism,log,debug,using,a,default,parallelism,of,default,parallelism,log,debug,using,default,data,exchange,mode,default,data,exchange,mode,graph,creating,visitor,graph,creator,new,graph,creating,visitor,default,parallelism,default,data,exchange,mode,program,accept,graph,creator,optimizer,node,root,node,if,graph,creator,get,sinks,size,1,root,node,graph,creator,get,sinks,get,0,else,if,graph,creator,get,sinks,size,1,iterator,data,sink,node,iter,graph,creator,get,sinks,iterator,root,node,iter,next,while,iter,has,next,root,node,new,sink,joiner,root,node,iter,next,else,throw,new,compiler,exception,bug,the,optimizer,plan,representation,has,no,sinks,root,node,accept,new,id,and,estimates,visitor,this,statistics,branches,visitor,branching,visitor,new,branches,visitor,root,node,accept,branching,visitor,interesting,property,visitor,props,visitor,new,interesting,property,visitor,this,cost,estimator,root,node,accept,props,visitor,if,root,node,get,open,branches,null,root,node,get,open,branches,size,0,throw,new,compiler,exception,bug,logic,for,branching,plans,non,tree,plans,has,an,error,and,does,not,track,the,re,joining,of,branches,correctly,list,plan,node,best,plan,root,node,get,alternative,plans,this,cost,estimator,if,best,plan,size,1,throw,new,compiler,exception,error,in,compiler,more,than,one,best,plan,was,created,plan,node,best,plan,root,best,plan,get,0,list,sink,plan,node,best,plan,sinks,new,array,list,sink,plan,node,4,if,best,plan,root,instanceof,sink,plan,node,best,plan,sinks,add,sink,plan,node,best,plan,root,else,if,best,plan,root,instanceof,sink,joiner,plan,node,sink,joiner,plan,node,best,plan,root,get,data,sinks,best,plan,sinks,optimized,plan,plan,new,plan,finalizer,create,final,plan,best,plan,sinks,program,get,job,name,program,plan,accept,new,binary,union,replacer,plan,accept,new,range,partition,rewriter,plan,post,passer,post,pass,plan,return,plan
Optimizer -> private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException;1460472696;Translates the given program to an OptimizedPlan. The optimized plan describes for each operator_which strategy to use (such as hash join versus sort-merge join), what data exchange method to use_(local pipe forward, shuffle, broadcast), what exchange mode to use (pipelined, batch),_where to cache intermediate results, etc,__The optimization happens in multiple phases:_<ol>_<li>Create optimizer dag implementation of the program.__<tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li>_<li>Compute interesting properties and auxiliary structures.</li>_<li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as_opposed to the Database approaches), because we support plans that are not trees.</li>_</ol>__@param program The program to be translated._@param postPasser The function to be used for post passing the optimizer's plan and setting the_data type specific serialization routines._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException {_		if (program == null || postPasser == null) {_			throw new NullPointerException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Beginning compilation of program '" + program.getJobName() + '\'')__		}__		final ExecutionMode defaultDataExchangeMode = program.getExecutionConfig().getExecutionMode()___		final int defaultParallelism = program.getDefaultParallelism() > 0 ?_			program.getDefaultParallelism() : this.defaultParallelism___		_		LOG.debug("Using a default parallelism of {}",  defaultParallelism)__		LOG.debug("Using default data exchange mode {}", defaultDataExchangeMode)___		_		_		_		_		_		_		_		__		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(defaultParallelism, defaultDataExchangeMode)__		program.accept(graphCreator)___		_		_		_		OptimizerNode rootNode__		if (graphCreator.getSinks().size() == 1) {_			rootNode = graphCreator.getSinks().get(0)__		}_		else if (graphCreator.getSinks().size() > 1) {_			Iterator<DataSinkNode> iter = graphCreator.getSinks().iterator()__			rootNode = iter.next()___			while (iter.hasNext()) {_				rootNode = new SinkJoiner(rootNode, iter.next())__			}_		}_		else {_			throw new CompilerException("Bug: The optimizer plan representation has no sinks.")__		}__		_		_		rootNode.accept(new IdAndEstimatesVisitor(this.statistics))___		_		_		_		BranchesVisitor branchingVisitor = new BranchesVisitor()__		rootNode.accept(branchingVisitor)___		_		InterestingPropertyVisitor propsVisitor = new InterestingPropertyVisitor(this.costEstimator)__		rootNode.accept(propsVisitor)__		_		_		if (rootNode.getOpenBranches() != null && rootNode.getOpenBranches().size() > 0) {_			throw new CompilerException("Bug: Logic for branching plans (non-tree plans) has an error, and does not " +_					"track the re-joining of branches correctly.")__		}__		_		List<PlanNode> bestPlan = rootNode.getAlternativePlans(this.costEstimator)___		if (bestPlan.size() != 1) {_			throw new CompilerException("Error in compiler: more than one best plan was created!")__		}__		_		_		PlanNode bestPlanRoot = bestPlan.get(0)__		List<SinkPlanNode> bestPlanSinks = new ArrayList<SinkPlanNode>(4)___		if (bestPlanRoot instanceof SinkPlanNode) {_			bestPlanSinks.add((SinkPlanNode) bestPlanRoot)__		} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {_			((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks)__		}__		_		OptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program)__		_		plan.accept(new BinaryUnionReplacer())___		plan.accept(new RangePartitionRewriter(plan))___		_		postPasser.postPass(plan)__		_		return plan__	};translates,the,given,program,to,an,optimized,plan,the,optimized,plan,describes,for,each,operator,which,strategy,to,use,such,as,hash,join,versus,sort,merge,join,what,data,exchange,method,to,use,local,pipe,forward,shuffle,broadcast,what,exchange,mode,to,use,pipelined,batch,where,to,cache,intermediate,results,etc,the,optimization,happens,in,multiple,phases,ol,li,create,optimizer,dag,implementation,of,the,program,tt,optimizer,node,tt,representations,of,the,pacts,assign,parallelism,and,compute,size,estimates,li,li,compute,interesting,properties,and,auxiliary,structures,li,li,enumerate,plan,alternatives,this,cannot,be,done,in,the,same,step,as,the,interesting,property,computation,as,opposed,to,the,database,approaches,because,we,support,plans,that,are,not,trees,li,ol,param,program,the,program,to,be,translated,param,post,passer,the,function,to,be,used,for,post,passing,the,optimizer,s,plan,and,setting,the,data,type,specific,serialization,routines,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;private,optimized,plan,compile,plan,program,optimizer,post,pass,post,passer,throws,compiler,exception,if,program,null,post,passer,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,beginning,compilation,of,program,program,get,job,name,final,execution,mode,default,data,exchange,mode,program,get,execution,config,get,execution,mode,final,int,default,parallelism,program,get,default,parallelism,0,program,get,default,parallelism,this,default,parallelism,log,debug,using,a,default,parallelism,of,default,parallelism,log,debug,using,default,data,exchange,mode,default,data,exchange,mode,graph,creating,visitor,graph,creator,new,graph,creating,visitor,default,parallelism,default,data,exchange,mode,program,accept,graph,creator,optimizer,node,root,node,if,graph,creator,get,sinks,size,1,root,node,graph,creator,get,sinks,get,0,else,if,graph,creator,get,sinks,size,1,iterator,data,sink,node,iter,graph,creator,get,sinks,iterator,root,node,iter,next,while,iter,has,next,root,node,new,sink,joiner,root,node,iter,next,else,throw,new,compiler,exception,bug,the,optimizer,plan,representation,has,no,sinks,root,node,accept,new,id,and,estimates,visitor,this,statistics,branches,visitor,branching,visitor,new,branches,visitor,root,node,accept,branching,visitor,interesting,property,visitor,props,visitor,new,interesting,property,visitor,this,cost,estimator,root,node,accept,props,visitor,if,root,node,get,open,branches,null,root,node,get,open,branches,size,0,throw,new,compiler,exception,bug,logic,for,branching,plans,non,tree,plans,has,an,error,and,does,not,track,the,re,joining,of,branches,correctly,list,plan,node,best,plan,root,node,get,alternative,plans,this,cost,estimator,if,best,plan,size,1,throw,new,compiler,exception,error,in,compiler,more,than,one,best,plan,was,created,plan,node,best,plan,root,best,plan,get,0,list,sink,plan,node,best,plan,sinks,new,array,list,sink,plan,node,4,if,best,plan,root,instanceof,sink,plan,node,best,plan,sinks,add,sink,plan,node,best,plan,root,else,if,best,plan,root,instanceof,sink,joiner,plan,node,sink,joiner,plan,node,best,plan,root,get,data,sinks,best,plan,sinks,optimized,plan,plan,new,plan,finalizer,create,final,plan,best,plan,sinks,program,get,job,name,program,plan,accept,new,binary,union,replacer,plan,accept,new,range,partition,rewriter,plan,post,passer,post,pass,plan,return,plan
Optimizer -> private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException;1517324056;Translates the given program to an OptimizedPlan. The optimized plan describes for each operator_which strategy to use (such as hash join versus sort-merge join), what data exchange method to use_(local pipe forward, shuffle, broadcast), what exchange mode to use (pipelined, batch),_where to cache intermediate results, etc,__The optimization happens in multiple phases:_<ol>_<li>Create optimizer dag implementation of the program.__<tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li>_<li>Compute interesting properties and auxiliary structures.</li>_<li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as_opposed to the Database approaches), because we support plans that are not trees.</li>_</ol>__@param program The program to be translated._@param postPasser The function to be used for post passing the optimizer's plan and setting the_data type specific serialization routines._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException {_		if (program == null || postPasser == null) {_			throw new NullPointerException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Beginning compilation of program '" + program.getJobName() + '\'')__		}__		final ExecutionMode defaultDataExchangeMode = program.getExecutionConfig().getExecutionMode()___		final int defaultParallelism = program.getDefaultParallelism() > 0 ?_			program.getDefaultParallelism() : this.defaultParallelism___		_		LOG.debug("Using a default parallelism of {}",  defaultParallelism)__		LOG.debug("Using default data exchange mode {}", defaultDataExchangeMode)___		_		_		_		_		_		_		_		__		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(defaultParallelism, defaultDataExchangeMode)__		program.accept(graphCreator)___		_		_		_		OptimizerNode rootNode__		if (graphCreator.getSinks().size() == 1) {_			rootNode = graphCreator.getSinks().get(0)__		}_		else if (graphCreator.getSinks().size() > 1) {_			Iterator<DataSinkNode> iter = graphCreator.getSinks().iterator()__			rootNode = iter.next()___			while (iter.hasNext()) {_				rootNode = new SinkJoiner(rootNode, iter.next())__			}_		}_		else {_			throw new CompilerException("Bug: The optimizer plan representation has no sinks.")__		}__		_		_		rootNode.accept(new IdAndEstimatesVisitor(this.statistics))___		_		_		_		BranchesVisitor branchingVisitor = new BranchesVisitor()__		rootNode.accept(branchingVisitor)___		_		InterestingPropertyVisitor propsVisitor = new InterestingPropertyVisitor(this.costEstimator)__		rootNode.accept(propsVisitor)__		_		_		if (rootNode.getOpenBranches() != null && rootNode.getOpenBranches().size() > 0) {_			throw new CompilerException("Bug: Logic for branching plans (non-tree plans) has an error, and does not " +_					"track the re-joining of branches correctly.")__		}__		_		List<PlanNode> bestPlan = rootNode.getAlternativePlans(this.costEstimator)___		if (bestPlan.size() != 1) {_			throw new CompilerException("Error in compiler: more than one best plan was created!")__		}__		_		_		PlanNode bestPlanRoot = bestPlan.get(0)__		List<SinkPlanNode> bestPlanSinks = new ArrayList<SinkPlanNode>(4)___		if (bestPlanRoot instanceof SinkPlanNode) {_			bestPlanSinks.add((SinkPlanNode) bestPlanRoot)__		} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {_			((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks)__		}__		_		OptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program)__		_		plan.accept(new BinaryUnionReplacer())___		plan.accept(new RangePartitionRewriter(plan))___		_		postPasser.postPass(plan)__		_		return plan__	};translates,the,given,program,to,an,optimized,plan,the,optimized,plan,describes,for,each,operator,which,strategy,to,use,such,as,hash,join,versus,sort,merge,join,what,data,exchange,method,to,use,local,pipe,forward,shuffle,broadcast,what,exchange,mode,to,use,pipelined,batch,where,to,cache,intermediate,results,etc,the,optimization,happens,in,multiple,phases,ol,li,create,optimizer,dag,implementation,of,the,program,tt,optimizer,node,tt,representations,of,the,pacts,assign,parallelism,and,compute,size,estimates,li,li,compute,interesting,properties,and,auxiliary,structures,li,li,enumerate,plan,alternatives,this,cannot,be,done,in,the,same,step,as,the,interesting,property,computation,as,opposed,to,the,database,approaches,because,we,support,plans,that,are,not,trees,li,ol,param,program,the,program,to,be,translated,param,post,passer,the,function,to,be,used,for,post,passing,the,optimizer,s,plan,and,setting,the,data,type,specific,serialization,routines,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;private,optimized,plan,compile,plan,program,optimizer,post,pass,post,passer,throws,compiler,exception,if,program,null,post,passer,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,beginning,compilation,of,program,program,get,job,name,final,execution,mode,default,data,exchange,mode,program,get,execution,config,get,execution,mode,final,int,default,parallelism,program,get,default,parallelism,0,program,get,default,parallelism,this,default,parallelism,log,debug,using,a,default,parallelism,of,default,parallelism,log,debug,using,default,data,exchange,mode,default,data,exchange,mode,graph,creating,visitor,graph,creator,new,graph,creating,visitor,default,parallelism,default,data,exchange,mode,program,accept,graph,creator,optimizer,node,root,node,if,graph,creator,get,sinks,size,1,root,node,graph,creator,get,sinks,get,0,else,if,graph,creator,get,sinks,size,1,iterator,data,sink,node,iter,graph,creator,get,sinks,iterator,root,node,iter,next,while,iter,has,next,root,node,new,sink,joiner,root,node,iter,next,else,throw,new,compiler,exception,bug,the,optimizer,plan,representation,has,no,sinks,root,node,accept,new,id,and,estimates,visitor,this,statistics,branches,visitor,branching,visitor,new,branches,visitor,root,node,accept,branching,visitor,interesting,property,visitor,props,visitor,new,interesting,property,visitor,this,cost,estimator,root,node,accept,props,visitor,if,root,node,get,open,branches,null,root,node,get,open,branches,size,0,throw,new,compiler,exception,bug,logic,for,branching,plans,non,tree,plans,has,an,error,and,does,not,track,the,re,joining,of,branches,correctly,list,plan,node,best,plan,root,node,get,alternative,plans,this,cost,estimator,if,best,plan,size,1,throw,new,compiler,exception,error,in,compiler,more,than,one,best,plan,was,created,plan,node,best,plan,root,best,plan,get,0,list,sink,plan,node,best,plan,sinks,new,array,list,sink,plan,node,4,if,best,plan,root,instanceof,sink,plan,node,best,plan,sinks,add,sink,plan,node,best,plan,root,else,if,best,plan,root,instanceof,sink,joiner,plan,node,sink,joiner,plan,node,best,plan,root,get,data,sinks,best,plan,sinks,optimized,plan,plan,new,plan,finalizer,create,final,plan,best,plan,sinks,program,get,job,name,program,plan,accept,new,binary,union,replacer,plan,accept,new,range,partition,rewriter,plan,post,passer,post,pass,plan,return,plan
Optimizer -> private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException;1522323145;Translates the given program to an OptimizedPlan. The optimized plan describes for each operator_which strategy to use (such as hash join versus sort-merge join), what data exchange method to use_(local pipe forward, shuffle, broadcast), what exchange mode to use (pipelined, batch),_where to cache intermediate results, etc,__The optimization happens in multiple phases:_<ol>_<li>Create optimizer dag implementation of the program.__<tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li>_<li>Compute interesting properties and auxiliary structures.</li>_<li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as_opposed to the Database approaches), because we support plans that are not trees.</li>_</ol>__@param program The program to be translated._@param postPasser The function to be used for post passing the optimizer's plan and setting the_data type specific serialization routines._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;private OptimizedPlan compile(Plan program, OptimizerPostPass postPasser) throws CompilerException {_		if (program == null || postPasser == null) {_			throw new NullPointerException()__		}_		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Beginning compilation of program '" + program.getJobName() + '\'')__		}__		final ExecutionMode defaultDataExchangeMode = program.getExecutionConfig().getExecutionMode()___		final int defaultParallelism = program.getDefaultParallelism() > 0 ?_			program.getDefaultParallelism() : this.defaultParallelism___		_		LOG.debug("Using a default parallelism of {}",  defaultParallelism)__		LOG.debug("Using default data exchange mode {}", defaultDataExchangeMode)___		_		_		_		_		_		_		_		__		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(defaultParallelism, defaultDataExchangeMode)__		program.accept(graphCreator)___		_		_		_		OptimizerNode rootNode__		if (graphCreator.getSinks().size() == 1) {_			rootNode = graphCreator.getSinks().get(0)__		}_		else if (graphCreator.getSinks().size() > 1) {_			Iterator<DataSinkNode> iter = graphCreator.getSinks().iterator()__			rootNode = iter.next()___			while (iter.hasNext()) {_				rootNode = new SinkJoiner(rootNode, iter.next())__			}_		}_		else {_			throw new CompilerException("Bug: The optimizer plan representation has no sinks.")__		}__		_		_		rootNode.accept(new IdAndEstimatesVisitor(this.statistics))___		_		_		UnionParallelismAndForwardEnforcer unionEnforcer = new UnionParallelismAndForwardEnforcer()__		rootNode.accept(unionEnforcer)___		_		_		_		BranchesVisitor branchingVisitor = new BranchesVisitor()__		rootNode.accept(branchingVisitor)___		_		InterestingPropertyVisitor propsVisitor = new InterestingPropertyVisitor(this.costEstimator)__		rootNode.accept(propsVisitor)__		_		_		if (rootNode.getOpenBranches() != null && rootNode.getOpenBranches().size() > 0) {_			throw new CompilerException("Bug: Logic for branching plans (non-tree plans) has an error, and does not " +_					"track the re-joining of branches correctly.")__		}__		_		List<PlanNode> bestPlan = rootNode.getAlternativePlans(this.costEstimator)___		if (bestPlan.size() != 1) {_			throw new CompilerException("Error in compiler: more than one best plan was created!")__		}__		_		_		PlanNode bestPlanRoot = bestPlan.get(0)__		List<SinkPlanNode> bestPlanSinks = new ArrayList<SinkPlanNode>(4)___		if (bestPlanRoot instanceof SinkPlanNode) {_			bestPlanSinks.add((SinkPlanNode) bestPlanRoot)__		} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {_			((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks)__		}__		_		OptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program)__		_		plan.accept(new BinaryUnionReplacer())___		plan.accept(new RangePartitionRewriter(plan))___		_		postPasser.postPass(plan)__		_		return plan__	};translates,the,given,program,to,an,optimized,plan,the,optimized,plan,describes,for,each,operator,which,strategy,to,use,such,as,hash,join,versus,sort,merge,join,what,data,exchange,method,to,use,local,pipe,forward,shuffle,broadcast,what,exchange,mode,to,use,pipelined,batch,where,to,cache,intermediate,results,etc,the,optimization,happens,in,multiple,phases,ol,li,create,optimizer,dag,implementation,of,the,program,tt,optimizer,node,tt,representations,of,the,pacts,assign,parallelism,and,compute,size,estimates,li,li,compute,interesting,properties,and,auxiliary,structures,li,li,enumerate,plan,alternatives,this,cannot,be,done,in,the,same,step,as,the,interesting,property,computation,as,opposed,to,the,database,approaches,because,we,support,plans,that,are,not,trees,li,ol,param,program,the,program,to,be,translated,param,post,passer,the,function,to,be,used,for,post,passing,the,optimizer,s,plan,and,setting,the,data,type,specific,serialization,routines,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;private,optimized,plan,compile,plan,program,optimizer,post,pass,post,passer,throws,compiler,exception,if,program,null,post,passer,null,throw,new,null,pointer,exception,if,log,is,debug,enabled,log,debug,beginning,compilation,of,program,program,get,job,name,final,execution,mode,default,data,exchange,mode,program,get,execution,config,get,execution,mode,final,int,default,parallelism,program,get,default,parallelism,0,program,get,default,parallelism,this,default,parallelism,log,debug,using,a,default,parallelism,of,default,parallelism,log,debug,using,default,data,exchange,mode,default,data,exchange,mode,graph,creating,visitor,graph,creator,new,graph,creating,visitor,default,parallelism,default,data,exchange,mode,program,accept,graph,creator,optimizer,node,root,node,if,graph,creator,get,sinks,size,1,root,node,graph,creator,get,sinks,get,0,else,if,graph,creator,get,sinks,size,1,iterator,data,sink,node,iter,graph,creator,get,sinks,iterator,root,node,iter,next,while,iter,has,next,root,node,new,sink,joiner,root,node,iter,next,else,throw,new,compiler,exception,bug,the,optimizer,plan,representation,has,no,sinks,root,node,accept,new,id,and,estimates,visitor,this,statistics,union,parallelism,and,forward,enforcer,union,enforcer,new,union,parallelism,and,forward,enforcer,root,node,accept,union,enforcer,branches,visitor,branching,visitor,new,branches,visitor,root,node,accept,branching,visitor,interesting,property,visitor,props,visitor,new,interesting,property,visitor,this,cost,estimator,root,node,accept,props,visitor,if,root,node,get,open,branches,null,root,node,get,open,branches,size,0,throw,new,compiler,exception,bug,logic,for,branching,plans,non,tree,plans,has,an,error,and,does,not,track,the,re,joining,of,branches,correctly,list,plan,node,best,plan,root,node,get,alternative,plans,this,cost,estimator,if,best,plan,size,1,throw,new,compiler,exception,error,in,compiler,more,than,one,best,plan,was,created,plan,node,best,plan,root,best,plan,get,0,list,sink,plan,node,best,plan,sinks,new,array,list,sink,plan,node,4,if,best,plan,root,instanceof,sink,plan,node,best,plan,sinks,add,sink,plan,node,best,plan,root,else,if,best,plan,root,instanceof,sink,joiner,plan,node,sink,joiner,plan,node,best,plan,root,get,data,sinks,best,plan,sinks,optimized,plan,plan,new,plan,finalizer,create,final,plan,best,plan,sinks,program,get,job,name,program,plan,accept,new,binary,union,replacer,plan,accept,new,range,partition,rewriter,plan,post,passer,post,pass,plan,return,plan
Optimizer -> public Optimizer(DataStatistics stats);1426843274;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__@param stats_The statistics to be used to determine the input properties.;public Optimizer(DataStatistics stats) {_		this(stats, new DefaultCostEstimator())__	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,param,stats,the,statistics,to,be,used,to,determine,the,input,properties;public,optimizer,data,statistics,stats,this,stats,new,default,cost,estimator
Optimizer -> public Optimizer(DataStatistics stats);1427097830;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__@param stats_The statistics to be used to determine the input properties.;public Optimizer(DataStatistics stats) {_		this(stats, new DefaultCostEstimator())__	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,param,stats,the,statistics,to,be,used,to,determine,the,input,properties;public,optimizer,data,statistics,stats,this,stats,new,default,cost,estimator
Optimizer -> public Optimizer(DataStatistics stats);1427097836;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__@param stats_The statistics to be used to determine the input properties.;public Optimizer(DataStatistics stats) {_		this(stats, new DefaultCostEstimator())__	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,param,stats,the,statistics,to,be,used,to,determine,the,input,properties;public,optimizer,data,statistics,stats,this,stats,new,default,cost,estimator
Optimizer -> public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config);1427784999;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param stats_The statistics to be used to determine the input properties._@param estimator_The <tt>CostEstimator</tt> to use to cost the individual operations.;public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config) {_		this.statistics = stats__		this.costEstimator = estimator___		_		_		this.defaultParallelism = config.getInteger(_				ConfigConstants.DEFAULT_PARALLELISM_KEY_OLD,_				ConfigConstants.DEFAULT_PARALLELISM)__		_		this.defaultParallelism = config.getInteger(_				ConfigConstants.DEFAULT_PARALLELISM_KEY,_				this.defaultParallelism)___		if (defaultParallelism < 1) {_			LOG.warn("Config value " + defaultParallelism + " for option "_					+ ConfigConstants.DEFAULT_PARALLELISM + " is invalid. Ignoring and using a value of 1.")__			this.defaultParallelism = 1__		}_	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,stats,the,statistics,to,be,used,to,determine,the,input,properties,param,estimator,the,tt,cost,estimator,tt,to,use,to,cost,the,individual,operations;public,optimizer,data,statistics,stats,cost,estimator,estimator,configuration,config,this,statistics,stats,this,cost,estimator,estimator,this,default,parallelism,config,get,integer,config,constants,config,constants,this,default,parallelism,config,get,integer,config,constants,this,default,parallelism,if,default,parallelism,1,log,warn,config,value,default,parallelism,for,option,config,constants,is,invalid,ignoring,and,using,a,value,of,1,this,default,parallelism,1
Optimizer -> public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config);1431981454;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param stats_The statistics to be used to determine the input properties._@param estimator_The <tt>CostEstimator</tt> to use to cost the individual operations.;public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config) {_		this.statistics = stats__		this.costEstimator = estimator___		_		_		this.defaultParallelism = config.getInteger(_				ConfigConstants.DEFAULT_PARALLELISM_KEY_OLD,_				ConfigConstants.DEFAULT_PARALLELISM)__		_		this.defaultParallelism = config.getInteger(_				ConfigConstants.DEFAULT_PARALLELISM_KEY,_				this.defaultParallelism)___		if (defaultParallelism < 1) {_			LOG.warn("Config value " + defaultParallelism + " for option "_					+ ConfigConstants.DEFAULT_PARALLELISM + " is invalid. Ignoring and using a value of 1.")__			this.defaultParallelism = 1__		}_	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,stats,the,statistics,to,be,used,to,determine,the,input,properties,param,estimator,the,tt,cost,estimator,tt,to,use,to,cost,the,individual,operations;public,optimizer,data,statistics,stats,cost,estimator,estimator,configuration,config,this,statistics,stats,this,cost,estimator,estimator,this,default,parallelism,config,get,integer,config,constants,config,constants,this,default,parallelism,config,get,integer,config,constants,this,default,parallelism,if,default,parallelism,1,log,warn,config,value,default,parallelism,for,option,config,constants,is,invalid,ignoring,and,using,a,value,of,1,this,default,parallelism,1
Optimizer -> public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config);1436966346;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param stats_The statistics to be used to determine the input properties._@param estimator_The <tt>CostEstimator</tt> to use to cost the individual operations.;public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config) {_		this.statistics = stats__		this.costEstimator = estimator___		_		_		this.defaultParallelism = config.getInteger(_				ConfigConstants.DEFAULT_PARALLELISM_KEY_OLD,_				ConfigConstants.DEFAULT_PARALLELISM)__		_		this.defaultParallelism = config.getInteger(_				ConfigConstants.DEFAULT_PARALLELISM_KEY,_				this.defaultParallelism)___		if (defaultParallelism < 1) {_			LOG.warn("Config value " + defaultParallelism + " for option "_					+ ConfigConstants.DEFAULT_PARALLELISM + " is invalid. Ignoring and using a value of 1.")__			this.defaultParallelism = 1__		}_	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,stats,the,statistics,to,be,used,to,determine,the,input,properties,param,estimator,the,tt,cost,estimator,tt,to,use,to,cost,the,individual,operations;public,optimizer,data,statistics,stats,cost,estimator,estimator,configuration,config,this,statistics,stats,this,cost,estimator,estimator,this,default,parallelism,config,get,integer,config,constants,config,constants,this,default,parallelism,config,get,integer,config,constants,this,default,parallelism,if,default,parallelism,1,log,warn,config,value,default,parallelism,for,option,config,constants,is,invalid,ignoring,and,using,a,value,of,1,this,default,parallelism,1
Optimizer -> public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config);1444404795;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param stats_The statistics to be used to determine the input properties._@param estimator_The <tt>CostEstimator</tt> to use to cost the individual operations.;public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config) {_		this.statistics = stats__		this.costEstimator = estimator___		_		this.defaultParallelism = config.getInteger(_				ConfigConstants.DEFAULT_PARALLELISM_KEY,_				ConfigConstants.DEFAULT_PARALLELISM)___		if (defaultParallelism < 1) {_			LOG.warn("Config value " + defaultParallelism + " for option "_					+ ConfigConstants.DEFAULT_PARALLELISM + " is invalid. Ignoring and using a value of 1.")__			this.defaultParallelism = 1__		}_	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,stats,the,statistics,to,be,used,to,determine,the,input,properties,param,estimator,the,tt,cost,estimator,tt,to,use,to,cost,the,individual,operations;public,optimizer,data,statistics,stats,cost,estimator,estimator,configuration,config,this,statistics,stats,this,cost,estimator,estimator,this,default,parallelism,config,get,integer,config,constants,config,constants,if,default,parallelism,1,log,warn,config,value,default,parallelism,for,option,config,constants,is,invalid,ignoring,and,using,a,value,of,1,this,default,parallelism,1
Optimizer -> public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config);1450712612;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param stats_The statistics to be used to determine the input properties._@param estimator_The <tt>CostEstimator</tt> to use to cost the individual operations.;public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config) {_		this.statistics = stats__		this.costEstimator = estimator___		_		this.defaultParallelism = config.getInteger(_				ConfigConstants.DEFAULT_PARALLELISM_KEY,_				ConfigConstants.DEFAULT_PARALLELISM)___		if (defaultParallelism < 1) {_			LOG.warn("Config value " + defaultParallelism + " for option "_					+ ConfigConstants.DEFAULT_PARALLELISM + " is invalid. Ignoring and using a value of 1.")__			this.defaultParallelism = 1__		}_	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,stats,the,statistics,to,be,used,to,determine,the,input,properties,param,estimator,the,tt,cost,estimator,tt,to,use,to,cost,the,individual,operations;public,optimizer,data,statistics,stats,cost,estimator,estimator,configuration,config,this,statistics,stats,this,cost,estimator,estimator,this,default,parallelism,config,get,integer,config,constants,config,constants,if,default,parallelism,1,log,warn,config,value,default,parallelism,for,option,config,constants,is,invalid,ignoring,and,using,a,value,of,1,this,default,parallelism,1
Optimizer -> public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config);1460472696;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param stats_The statistics to be used to determine the input properties._@param estimator_The <tt>CostEstimator</tt> to use to cost the individual operations.;public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config) {_		this.statistics = stats__		this.costEstimator = estimator___		_		this.defaultParallelism = config.getInteger(_				ConfigConstants.DEFAULT_PARALLELISM_KEY,_				ConfigConstants.DEFAULT_PARALLELISM)___		if (defaultParallelism < 1) {_			LOG.warn("Config value " + defaultParallelism + " for option "_					+ ConfigConstants.DEFAULT_PARALLELISM + " is invalid. Ignoring and using a value of 1.")__			this.defaultParallelism = 1__		}_	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,stats,the,statistics,to,be,used,to,determine,the,input,properties,param,estimator,the,tt,cost,estimator,tt,to,use,to,cost,the,individual,operations;public,optimizer,data,statistics,stats,cost,estimator,estimator,configuration,config,this,statistics,stats,this,cost,estimator,estimator,this,default,parallelism,config,get,integer,config,constants,config,constants,if,default,parallelism,1,log,warn,config,value,default,parallelism,for,option,config,constants,is,invalid,ignoring,and,using,a,value,of,1,this,default,parallelism,1
Optimizer -> public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config);1517324056;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param stats_The statistics to be used to determine the input properties._@param estimator_The <tt>CostEstimator</tt> to use to cost the individual operations.;public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config) {_		this.statistics = stats__		this.costEstimator = estimator___		_		this.defaultParallelism = config.getInteger(CoreOptions.DEFAULT_PARALLELISM)___		if (defaultParallelism < 1) {_			this.defaultParallelism = CoreOptions.DEFAULT_PARALLELISM.defaultValue()__			LOG.warn("Config value {} for option {} is invalid. Ignoring and using a value of {}.",_				defaultParallelism,_				CoreOptions.DEFAULT_PARALLELISM.key(),_				defaultParallelism)__		}_	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,stats,the,statistics,to,be,used,to,determine,the,input,properties,param,estimator,the,tt,cost,estimator,tt,to,use,to,cost,the,individual,operations;public,optimizer,data,statistics,stats,cost,estimator,estimator,configuration,config,this,statistics,stats,this,cost,estimator,estimator,this,default,parallelism,config,get,integer,core,options,if,default,parallelism,1,this,default,parallelism,core,options,default,value,log,warn,config,value,for,option,is,invalid,ignoring,and,using,a,value,of,default,parallelism,core,options,key,default,parallelism
Optimizer -> public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config);1522323145;Creates a new optimizer instance that uses the statistics object to determine properties about the input._Given those statistics, the optimizer can make better choices for the execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param stats_The statistics to be used to determine the input properties._@param estimator_The <tt>CostEstimator</tt> to use to cost the individual operations.;public Optimizer(DataStatistics stats, CostEstimator estimator, Configuration config) {_		this.statistics = stats__		this.costEstimator = estimator___		_		this.defaultParallelism = config.getInteger(CoreOptions.DEFAULT_PARALLELISM)___		if (defaultParallelism < 1) {_			this.defaultParallelism = CoreOptions.DEFAULT_PARALLELISM.defaultValue()__			LOG.warn("Config value {} for option {} is invalid. Ignoring and using a value of {}.",_				defaultParallelism,_				CoreOptions.DEFAULT_PARALLELISM.key(),_				defaultParallelism)__		}_	};creates,a,new,optimizer,instance,that,uses,the,statistics,object,to,determine,properties,about,the,input,given,those,statistics,the,optimizer,can,make,better,choices,for,the,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,stats,the,statistics,to,be,used,to,determine,the,input,properties,param,estimator,the,tt,cost,estimator,tt,to,use,to,cost,the,individual,operations;public,optimizer,data,statistics,stats,cost,estimator,estimator,configuration,config,this,statistics,stats,this,cost,estimator,estimator,this,default,parallelism,config,get,integer,core,options,if,default,parallelism,1,this,default,parallelism,core,options,default,value,log,warn,config,value,for,option,is,invalid,ignoring,and,using,a,value,of,default,parallelism,core,options,key,default,parallelism
Optimizer -> public Optimizer(CostEstimator estimator);1426843274;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param estimator The cost estimator to use to cost the individual operations.;public Optimizer(CostEstimator estimator) {_		this(null, estimator)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,estimator,the,cost,estimator,to,use,to,cost,the,individual,operations;public,optimizer,cost,estimator,estimator,this,null,estimator
Optimizer -> public Optimizer(CostEstimator estimator);1427097830;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param estimator The cost estimator to use to cost the individual operations.;public Optimizer(CostEstimator estimator) {_		this(null, estimator)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,estimator,the,cost,estimator,to,use,to,cost,the,individual,operations;public,optimizer,cost,estimator,estimator,this,null,estimator
Optimizer -> public Optimizer(CostEstimator estimator);1427097836;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param estimator The cost estimator to use to cost the individual operations.;public Optimizer(CostEstimator estimator) {_		this(null, estimator)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,estimator,the,cost,estimator,to,use,to,cost,the,individual,operations;public,optimizer,cost,estimator,estimator,this,null,estimator
Optimizer -> public Optimizer(Configuration config);1427784999;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.;public Optimizer(Configuration config) {_		this(null, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies;public,optimizer,configuration,config,this,null,new,default,cost,estimator,config
Optimizer -> public Optimizer(Configuration config);1431981454;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.;public Optimizer(Configuration config) {_		this(null, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies;public,optimizer,configuration,config,this,null,new,default,cost,estimator,config
Optimizer -> public Optimizer(Configuration config);1436966346;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.;public Optimizer(Configuration config) {_		this(null, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies;public,optimizer,configuration,config,this,null,new,default,cost,estimator,config
Optimizer -> public Optimizer(Configuration config);1444404795;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.;public Optimizer(Configuration config) {_		this(null, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies;public,optimizer,configuration,config,this,null,new,default,cost,estimator,config
Optimizer -> public Optimizer(Configuration config);1450712612;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.;public Optimizer(Configuration config) {_		this(null, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies;public,optimizer,configuration,config,this,null,new,default,cost,estimator,config
Optimizer -> public Optimizer(Configuration config);1460472696;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.;public Optimizer(Configuration config) {_		this(null, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies;public,optimizer,configuration,config,this,null,new,default,cost,estimator,config
Optimizer -> public Optimizer(Configuration config);1517324056;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.;public Optimizer(Configuration config) {_		this(null, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies;public,optimizer,configuration,config,this,null,new,default,cost,estimator,config
Optimizer -> public Optimizer(Configuration config);1522323145;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.;public Optimizer(Configuration config) {_		this(null, new DefaultCostEstimator(), config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies;public,optimizer,configuration,config,this,null,new,default,cost,estimator,config
Optimizer -> public Optimizer();1426843274;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.;public Optimizer() {_		this(null, new DefaultCostEstimator())__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies;public,optimizer,this,null,new,default,cost,estimator
Optimizer -> public Optimizer();1427097830;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.;public Optimizer() {_		this(null, new DefaultCostEstimator())__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies;public,optimizer,this,null,new,default,cost,estimator
Optimizer -> public Optimizer();1427097836;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.;public Optimizer() {_		this(null, new DefaultCostEstimator())__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies;public,optimizer,this,null,new,default,cost,estimator
Optimizer -> public static List<DataSinkNode> createPreOptimizedPlan(Plan program);1426843274;This function performs only the first step to the compilation process - the creation of the optimizer_representation of the plan. No estimations or enumerations of alternatives are done here.__@param program The plan to generate the optimizer representation for._@return The optimizer representation of the plan, as a collection of all data sinks_from the plan can be traversed.;public static List<DataSinkNode> createPreOptimizedPlan(Plan program) {_		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(1, null)__		program.accept(graphCreator)__		return graphCreator.getSinks()__	};this,function,performs,only,the,first,step,to,the,compilation,process,the,creation,of,the,optimizer,representation,of,the,plan,no,estimations,or,enumerations,of,alternatives,are,done,here,param,program,the,plan,to,generate,the,optimizer,representation,for,return,the,optimizer,representation,of,the,plan,as,a,collection,of,all,data,sinks,from,the,plan,can,be,traversed;public,static,list,data,sink,node,create,pre,optimized,plan,plan,program,graph,creating,visitor,graph,creator,new,graph,creating,visitor,1,null,program,accept,graph,creator,return,graph,creator,get,sinks
Optimizer -> public static List<DataSinkNode> createPreOptimizedPlan(Plan program);1427097830;This function performs only the first step to the compilation process - the creation of the optimizer_representation of the plan. No estimations or enumerations of alternatives are done here.__@param program The plan to generate the optimizer representation for._@return The optimizer representation of the plan, as a collection of all data sinks_from the plan can be traversed.;public static List<DataSinkNode> createPreOptimizedPlan(Plan program) {_		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(1, null)__		program.accept(graphCreator)__		return graphCreator.getSinks()__	};this,function,performs,only,the,first,step,to,the,compilation,process,the,creation,of,the,optimizer,representation,of,the,plan,no,estimations,or,enumerations,of,alternatives,are,done,here,param,program,the,plan,to,generate,the,optimizer,representation,for,return,the,optimizer,representation,of,the,plan,as,a,collection,of,all,data,sinks,from,the,plan,can,be,traversed;public,static,list,data,sink,node,create,pre,optimized,plan,plan,program,graph,creating,visitor,graph,creator,new,graph,creating,visitor,1,null,program,accept,graph,creator,return,graph,creator,get,sinks
Optimizer -> public static List<DataSinkNode> createPreOptimizedPlan(Plan program);1427097836;This function performs only the first step to the compilation process - the creation of the optimizer_representation of the plan. No estimations or enumerations of alternatives are done here.__@param program The plan to generate the optimizer representation for._@return The optimizer representation of the plan, as a collection of all data sinks_from the plan can be traversed.;public static List<DataSinkNode> createPreOptimizedPlan(Plan program) {_		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(1, null)__		program.accept(graphCreator)__		return graphCreator.getSinks()__	};this,function,performs,only,the,first,step,to,the,compilation,process,the,creation,of,the,optimizer,representation,of,the,plan,no,estimations,or,enumerations,of,alternatives,are,done,here,param,program,the,plan,to,generate,the,optimizer,representation,for,return,the,optimizer,representation,of,the,plan,as,a,collection,of,all,data,sinks,from,the,plan,can,be,traversed;public,static,list,data,sink,node,create,pre,optimized,plan,plan,program,graph,creating,visitor,graph,creator,new,graph,creating,visitor,1,null,program,accept,graph,creator,return,graph,creator,get,sinks
Optimizer -> public static List<DataSinkNode> createPreOptimizedPlan(Plan program);1427784999;This function performs only the first step to the compilation process - the creation of the optimizer_representation of the plan. No estimations or enumerations of alternatives are done here.__@param program The plan to generate the optimizer representation for._@return The optimizer representation of the plan, as a collection of all data sinks_from the plan can be traversed.;public static List<DataSinkNode> createPreOptimizedPlan(Plan program) {_		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(1, null)__		program.accept(graphCreator)__		return graphCreator.getSinks()__	};this,function,performs,only,the,first,step,to,the,compilation,process,the,creation,of,the,optimizer,representation,of,the,plan,no,estimations,or,enumerations,of,alternatives,are,done,here,param,program,the,plan,to,generate,the,optimizer,representation,for,return,the,optimizer,representation,of,the,plan,as,a,collection,of,all,data,sinks,from,the,plan,can,be,traversed;public,static,list,data,sink,node,create,pre,optimized,plan,plan,program,graph,creating,visitor,graph,creator,new,graph,creating,visitor,1,null,program,accept,graph,creator,return,graph,creator,get,sinks
Optimizer -> public static List<DataSinkNode> createPreOptimizedPlan(Plan program);1431981454;This function performs only the first step to the compilation process - the creation of the optimizer_representation of the plan. No estimations or enumerations of alternatives are done here.__@param program The plan to generate the optimizer representation for._@return The optimizer representation of the plan, as a collection of all data sinks_from the plan can be traversed.;public static List<DataSinkNode> createPreOptimizedPlan(Plan program) {_		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(1, null)__		program.accept(graphCreator)__		return graphCreator.getSinks()__	};this,function,performs,only,the,first,step,to,the,compilation,process,the,creation,of,the,optimizer,representation,of,the,plan,no,estimations,or,enumerations,of,alternatives,are,done,here,param,program,the,plan,to,generate,the,optimizer,representation,for,return,the,optimizer,representation,of,the,plan,as,a,collection,of,all,data,sinks,from,the,plan,can,be,traversed;public,static,list,data,sink,node,create,pre,optimized,plan,plan,program,graph,creating,visitor,graph,creator,new,graph,creating,visitor,1,null,program,accept,graph,creator,return,graph,creator,get,sinks
Optimizer -> public static List<DataSinkNode> createPreOptimizedPlan(Plan program);1436966346;This function performs only the first step to the compilation process - the creation of the optimizer_representation of the plan. No estimations or enumerations of alternatives are done here.__@param program The plan to generate the optimizer representation for._@return The optimizer representation of the plan, as a collection of all data sinks_from the plan can be traversed.;public static List<DataSinkNode> createPreOptimizedPlan(Plan program) {_		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(1, null)__		program.accept(graphCreator)__		return graphCreator.getSinks()__	};this,function,performs,only,the,first,step,to,the,compilation,process,the,creation,of,the,optimizer,representation,of,the,plan,no,estimations,or,enumerations,of,alternatives,are,done,here,param,program,the,plan,to,generate,the,optimizer,representation,for,return,the,optimizer,representation,of,the,plan,as,a,collection,of,all,data,sinks,from,the,plan,can,be,traversed;public,static,list,data,sink,node,create,pre,optimized,plan,plan,program,graph,creating,visitor,graph,creator,new,graph,creating,visitor,1,null,program,accept,graph,creator,return,graph,creator,get,sinks
Optimizer -> public static List<DataSinkNode> createPreOptimizedPlan(Plan program);1444404795;This function performs only the first step to the compilation process - the creation of the optimizer_representation of the plan. No estimations or enumerations of alternatives are done here.__@param program The plan to generate the optimizer representation for._@return The optimizer representation of the plan, as a collection of all data sinks_from the plan can be traversed.;public static List<DataSinkNode> createPreOptimizedPlan(Plan program) {_		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(1, null)__		program.accept(graphCreator)__		return graphCreator.getSinks()__	};this,function,performs,only,the,first,step,to,the,compilation,process,the,creation,of,the,optimizer,representation,of,the,plan,no,estimations,or,enumerations,of,alternatives,are,done,here,param,program,the,plan,to,generate,the,optimizer,representation,for,return,the,optimizer,representation,of,the,plan,as,a,collection,of,all,data,sinks,from,the,plan,can,be,traversed;public,static,list,data,sink,node,create,pre,optimized,plan,plan,program,graph,creating,visitor,graph,creator,new,graph,creating,visitor,1,null,program,accept,graph,creator,return,graph,creator,get,sinks
Optimizer -> public static List<DataSinkNode> createPreOptimizedPlan(Plan program);1450712612;This function performs only the first step to the compilation process - the creation of the optimizer_representation of the plan. No estimations or enumerations of alternatives are done here.__@param program The plan to generate the optimizer representation for._@return The optimizer representation of the plan, as a collection of all data sinks_from the plan can be traversed.;public static List<DataSinkNode> createPreOptimizedPlan(Plan program) {_		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(1, null)__		program.accept(graphCreator)__		return graphCreator.getSinks()__	};this,function,performs,only,the,first,step,to,the,compilation,process,the,creation,of,the,optimizer,representation,of,the,plan,no,estimations,or,enumerations,of,alternatives,are,done,here,param,program,the,plan,to,generate,the,optimizer,representation,for,return,the,optimizer,representation,of,the,plan,as,a,collection,of,all,data,sinks,from,the,plan,can,be,traversed;public,static,list,data,sink,node,create,pre,optimized,plan,plan,program,graph,creating,visitor,graph,creator,new,graph,creating,visitor,1,null,program,accept,graph,creator,return,graph,creator,get,sinks
Optimizer -> public static List<DataSinkNode> createPreOptimizedPlan(Plan program);1460472696;This function performs only the first step to the compilation process - the creation of the optimizer_representation of the plan. No estimations or enumerations of alternatives are done here.__@param program The plan to generate the optimizer representation for._@return The optimizer representation of the plan, as a collection of all data sinks_from the plan can be traversed.;public static List<DataSinkNode> createPreOptimizedPlan(Plan program) {_		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(1, null)__		program.accept(graphCreator)__		return graphCreator.getSinks()__	};this,function,performs,only,the,first,step,to,the,compilation,process,the,creation,of,the,optimizer,representation,of,the,plan,no,estimations,or,enumerations,of,alternatives,are,done,here,param,program,the,plan,to,generate,the,optimizer,representation,for,return,the,optimizer,representation,of,the,plan,as,a,collection,of,all,data,sinks,from,the,plan,can,be,traversed;public,static,list,data,sink,node,create,pre,optimized,plan,plan,program,graph,creating,visitor,graph,creator,new,graph,creating,visitor,1,null,program,accept,graph,creator,return,graph,creator,get,sinks
Optimizer -> public static List<DataSinkNode> createPreOptimizedPlan(Plan program);1517324056;This function performs only the first step to the compilation process - the creation of the optimizer_representation of the plan. No estimations or enumerations of alternatives are done here.__@param program The plan to generate the optimizer representation for._@return The optimizer representation of the plan, as a collection of all data sinks_from the plan can be traversed.;public static List<DataSinkNode> createPreOptimizedPlan(Plan program) {_		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(1, null)__		program.accept(graphCreator)__		return graphCreator.getSinks()__	};this,function,performs,only,the,first,step,to,the,compilation,process,the,creation,of,the,optimizer,representation,of,the,plan,no,estimations,or,enumerations,of,alternatives,are,done,here,param,program,the,plan,to,generate,the,optimizer,representation,for,return,the,optimizer,representation,of,the,plan,as,a,collection,of,all,data,sinks,from,the,plan,can,be,traversed;public,static,list,data,sink,node,create,pre,optimized,plan,plan,program,graph,creating,visitor,graph,creator,new,graph,creating,visitor,1,null,program,accept,graph,creator,return,graph,creator,get,sinks
Optimizer -> public static List<DataSinkNode> createPreOptimizedPlan(Plan program);1522323145;This function performs only the first step to the compilation process - the creation of the optimizer_representation of the plan. No estimations or enumerations of alternatives are done here.__@param program The plan to generate the optimizer representation for._@return The optimizer representation of the plan, as a collection of all data sinks_from the plan can be traversed.;public static List<DataSinkNode> createPreOptimizedPlan(Plan program) {_		GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(1, null)__		program.accept(graphCreator)__		return graphCreator.getSinks()__	};this,function,performs,only,the,first,step,to,the,compilation,process,the,creation,of,the,optimizer,representation,of,the,plan,no,estimations,or,enumerations,of,alternatives,are,done,here,param,program,the,plan,to,generate,the,optimizer,representation,for,return,the,optimizer,representation,of,the,plan,as,a,collection,of,all,data,sinks,from,the,plan,can,be,traversed;public,static,list,data,sink,node,create,pre,optimized,plan,plan,program,graph,creating,visitor,graph,creator,new,graph,creating,visitor,1,null,program,accept,graph,creator,return,graph,creator,get,sinks
Optimizer -> public OptimizedPlan compile(Plan program) throws CompilerException;1426843274;Translates the given program to an OptimizedPlan, where all nodes have their local strategy assigned_and all channels have a shipping strategy assigned.__For more details on the optimization phase, see the comments for_{@link #compile(org.apache.flink.api.common.Plan, org.apache.flink.optimizer.postpass.OptimizerPostPass)}.__@param program The program to be translated._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;public OptimizedPlan compile(Plan program) throws CompilerException {_		final OptimizerPostPass postPasser = getPostPassFromPlan(program)__		return compile(program, postPasser)__	};translates,the,given,program,to,an,optimized,plan,where,all,nodes,have,their,local,strategy,assigned,and,all,channels,have,a,shipping,strategy,assigned,for,more,details,on,the,optimization,phase,see,the,comments,for,link,compile,org,apache,flink,api,common,plan,org,apache,flink,optimizer,postpass,optimizer,post,pass,param,program,the,program,to,be,translated,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;public,optimized,plan,compile,plan,program,throws,compiler,exception,final,optimizer,post,pass,post,passer,get,post,pass,from,plan,program,return,compile,program,post,passer
Optimizer -> public OptimizedPlan compile(Plan program) throws CompilerException;1427097830;Translates the given program to an OptimizedPlan, where all nodes have their local strategy assigned_and all channels have a shipping strategy assigned.__For more details on the optimization phase, see the comments for_{@link #compile(org.apache.flink.api.common.Plan, org.apache.flink.optimizer.postpass.OptimizerPostPass)}.__@param program The program to be translated._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;public OptimizedPlan compile(Plan program) throws CompilerException {_		final OptimizerPostPass postPasser = getPostPassFromPlan(program)__		return compile(program, postPasser)__	};translates,the,given,program,to,an,optimized,plan,where,all,nodes,have,their,local,strategy,assigned,and,all,channels,have,a,shipping,strategy,assigned,for,more,details,on,the,optimization,phase,see,the,comments,for,link,compile,org,apache,flink,api,common,plan,org,apache,flink,optimizer,postpass,optimizer,post,pass,param,program,the,program,to,be,translated,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;public,optimized,plan,compile,plan,program,throws,compiler,exception,final,optimizer,post,pass,post,passer,get,post,pass,from,plan,program,return,compile,program,post,passer
Optimizer -> public OptimizedPlan compile(Plan program) throws CompilerException;1427097836;Translates the given program to an OptimizedPlan, where all nodes have their local strategy assigned_and all channels have a shipping strategy assigned.__For more details on the optimization phase, see the comments for_{@link #compile(org.apache.flink.api.common.Plan, org.apache.flink.optimizer.postpass.OptimizerPostPass)}.__@param program The program to be translated._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;public OptimizedPlan compile(Plan program) throws CompilerException {_		final OptimizerPostPass postPasser = getPostPassFromPlan(program)__		return compile(program, postPasser)__	};translates,the,given,program,to,an,optimized,plan,where,all,nodes,have,their,local,strategy,assigned,and,all,channels,have,a,shipping,strategy,assigned,for,more,details,on,the,optimization,phase,see,the,comments,for,link,compile,org,apache,flink,api,common,plan,org,apache,flink,optimizer,postpass,optimizer,post,pass,param,program,the,program,to,be,translated,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;public,optimized,plan,compile,plan,program,throws,compiler,exception,final,optimizer,post,pass,post,passer,get,post,pass,from,plan,program,return,compile,program,post,passer
Optimizer -> public OptimizedPlan compile(Plan program) throws CompilerException;1427784999;Translates the given program to an OptimizedPlan, where all nodes have their local strategy assigned_and all channels have a shipping strategy assigned.__For more details on the optimization phase, see the comments for_{@link #compile(org.apache.flink.api.common.Plan, org.apache.flink.optimizer.postpass.OptimizerPostPass)}.__@param program The program to be translated._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;public OptimizedPlan compile(Plan program) throws CompilerException {_		final OptimizerPostPass postPasser = getPostPassFromPlan(program)__		return compile(program, postPasser)__	};translates,the,given,program,to,an,optimized,plan,where,all,nodes,have,their,local,strategy,assigned,and,all,channels,have,a,shipping,strategy,assigned,for,more,details,on,the,optimization,phase,see,the,comments,for,link,compile,org,apache,flink,api,common,plan,org,apache,flink,optimizer,postpass,optimizer,post,pass,param,program,the,program,to,be,translated,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;public,optimized,plan,compile,plan,program,throws,compiler,exception,final,optimizer,post,pass,post,passer,get,post,pass,from,plan,program,return,compile,program,post,passer
Optimizer -> public OptimizedPlan compile(Plan program) throws CompilerException;1431981454;Translates the given program to an OptimizedPlan, where all nodes have their local strategy assigned_and all channels have a shipping strategy assigned.__For more details on the optimization phase, see the comments for_{@link #compile(org.apache.flink.api.common.Plan, org.apache.flink.optimizer.postpass.OptimizerPostPass)}.__@param program The program to be translated._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;public OptimizedPlan compile(Plan program) throws CompilerException {_		final OptimizerPostPass postPasser = getPostPassFromPlan(program)__		return compile(program, postPasser)__	};translates,the,given,program,to,an,optimized,plan,where,all,nodes,have,their,local,strategy,assigned,and,all,channels,have,a,shipping,strategy,assigned,for,more,details,on,the,optimization,phase,see,the,comments,for,link,compile,org,apache,flink,api,common,plan,org,apache,flink,optimizer,postpass,optimizer,post,pass,param,program,the,program,to,be,translated,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;public,optimized,plan,compile,plan,program,throws,compiler,exception,final,optimizer,post,pass,post,passer,get,post,pass,from,plan,program,return,compile,program,post,passer
Optimizer -> public OptimizedPlan compile(Plan program) throws CompilerException;1436966346;Translates the given program to an OptimizedPlan, where all nodes have their local strategy assigned_and all channels have a shipping strategy assigned.__For more details on the optimization phase, see the comments for_{@link #compile(org.apache.flink.api.common.Plan, org.apache.flink.optimizer.postpass.OptimizerPostPass)}.__@param program The program to be translated._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;public OptimizedPlan compile(Plan program) throws CompilerException {_		final OptimizerPostPass postPasser = getPostPassFromPlan(program)__		return compile(program, postPasser)__	};translates,the,given,program,to,an,optimized,plan,where,all,nodes,have,their,local,strategy,assigned,and,all,channels,have,a,shipping,strategy,assigned,for,more,details,on,the,optimization,phase,see,the,comments,for,link,compile,org,apache,flink,api,common,plan,org,apache,flink,optimizer,postpass,optimizer,post,pass,param,program,the,program,to,be,translated,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;public,optimized,plan,compile,plan,program,throws,compiler,exception,final,optimizer,post,pass,post,passer,get,post,pass,from,plan,program,return,compile,program,post,passer
Optimizer -> public OptimizedPlan compile(Plan program) throws CompilerException;1444404795;Translates the given program to an OptimizedPlan, where all nodes have their local strategy assigned_and all channels have a shipping strategy assigned.__For more details on the optimization phase, see the comments for_{@link #compile(org.apache.flink.api.common.Plan, org.apache.flink.optimizer.postpass.OptimizerPostPass)}.__@param program The program to be translated._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;public OptimizedPlan compile(Plan program) throws CompilerException {_		final OptimizerPostPass postPasser = getPostPassFromPlan(program)__		return compile(program, postPasser)__	};translates,the,given,program,to,an,optimized,plan,where,all,nodes,have,their,local,strategy,assigned,and,all,channels,have,a,shipping,strategy,assigned,for,more,details,on,the,optimization,phase,see,the,comments,for,link,compile,org,apache,flink,api,common,plan,org,apache,flink,optimizer,postpass,optimizer,post,pass,param,program,the,program,to,be,translated,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;public,optimized,plan,compile,plan,program,throws,compiler,exception,final,optimizer,post,pass,post,passer,get,post,pass,from,plan,program,return,compile,program,post,passer
Optimizer -> public OptimizedPlan compile(Plan program) throws CompilerException;1450712612;Translates the given program to an OptimizedPlan, where all nodes have their local strategy assigned_and all channels have a shipping strategy assigned.__For more details on the optimization phase, see the comments for_{@link #compile(org.apache.flink.api.common.Plan, org.apache.flink.optimizer.postpass.OptimizerPostPass)}.__@param program The program to be translated._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;public OptimizedPlan compile(Plan program) throws CompilerException {_		final OptimizerPostPass postPasser = getPostPassFromPlan(program)__		return compile(program, postPasser)__	};translates,the,given,program,to,an,optimized,plan,where,all,nodes,have,their,local,strategy,assigned,and,all,channels,have,a,shipping,strategy,assigned,for,more,details,on,the,optimization,phase,see,the,comments,for,link,compile,org,apache,flink,api,common,plan,org,apache,flink,optimizer,postpass,optimizer,post,pass,param,program,the,program,to,be,translated,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;public,optimized,plan,compile,plan,program,throws,compiler,exception,final,optimizer,post,pass,post,passer,get,post,pass,from,plan,program,return,compile,program,post,passer
Optimizer -> public OptimizedPlan compile(Plan program) throws CompilerException;1460472696;Translates the given program to an OptimizedPlan, where all nodes have their local strategy assigned_and all channels have a shipping strategy assigned.__For more details on the optimization phase, see the comments for_{@link #compile(org.apache.flink.api.common.Plan, org.apache.flink.optimizer.postpass.OptimizerPostPass)}.__@param program The program to be translated._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;public OptimizedPlan compile(Plan program) throws CompilerException {_		final OptimizerPostPass postPasser = getPostPassFromPlan(program)__		return compile(program, postPasser)__	};translates,the,given,program,to,an,optimized,plan,where,all,nodes,have,their,local,strategy,assigned,and,all,channels,have,a,shipping,strategy,assigned,for,more,details,on,the,optimization,phase,see,the,comments,for,link,compile,org,apache,flink,api,common,plan,org,apache,flink,optimizer,postpass,optimizer,post,pass,param,program,the,program,to,be,translated,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;public,optimized,plan,compile,plan,program,throws,compiler,exception,final,optimizer,post,pass,post,passer,get,post,pass,from,plan,program,return,compile,program,post,passer
Optimizer -> public OptimizedPlan compile(Plan program) throws CompilerException;1517324056;Translates the given program to an OptimizedPlan, where all nodes have their local strategy assigned_and all channels have a shipping strategy assigned.__For more details on the optimization phase, see the comments for_{@link #compile(org.apache.flink.api.common.Plan, org.apache.flink.optimizer.postpass.OptimizerPostPass)}.__@param program The program to be translated._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;public OptimizedPlan compile(Plan program) throws CompilerException {_		final OptimizerPostPass postPasser = getPostPassFromPlan(program)__		return compile(program, postPasser)__	};translates,the,given,program,to,an,optimized,plan,where,all,nodes,have,their,local,strategy,assigned,and,all,channels,have,a,shipping,strategy,assigned,for,more,details,on,the,optimization,phase,see,the,comments,for,link,compile,org,apache,flink,api,common,plan,org,apache,flink,optimizer,postpass,optimizer,post,pass,param,program,the,program,to,be,translated,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;public,optimized,plan,compile,plan,program,throws,compiler,exception,final,optimizer,post,pass,post,passer,get,post,pass,from,plan,program,return,compile,program,post,passer
Optimizer -> public OptimizedPlan compile(Plan program) throws CompilerException;1522323145;Translates the given program to an OptimizedPlan, where all nodes have their local strategy assigned_and all channels have a shipping strategy assigned.__For more details on the optimization phase, see the comments for_{@link #compile(org.apache.flink.api.common.Plan, org.apache.flink.optimizer.postpass.OptimizerPostPass)}.__@param program The program to be translated._@return The optimized plan.__@throws CompilerException_Thrown, if the plan is invalid or the optimizer encountered an inconsistent_situation during the compilation process.;public OptimizedPlan compile(Plan program) throws CompilerException {_		final OptimizerPostPass postPasser = getPostPassFromPlan(program)__		return compile(program, postPasser)__	};translates,the,given,program,to,an,optimized,plan,where,all,nodes,have,their,local,strategy,assigned,and,all,channels,have,a,shipping,strategy,assigned,for,more,details,on,the,optimization,phase,see,the,comments,for,link,compile,org,apache,flink,api,common,plan,org,apache,flink,optimizer,postpass,optimizer,post,pass,param,program,the,program,to,be,translated,return,the,optimized,plan,throws,compiler,exception,thrown,if,the,plan,is,invalid,or,the,optimizer,encountered,an,inconsistent,situation,during,the,compilation,process;public,optimized,plan,compile,plan,program,throws,compiler,exception,final,optimizer,post,pass,post,passer,get,post,pass,from,plan,program,return,compile,program,post,passer
Optimizer -> public Optimizer(CostEstimator estimator, Configuration config);1427784999;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param estimator The cost estimator to use to cost the individual operations.;public Optimizer(CostEstimator estimator, Configuration config) {_		this(null, estimator, config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,estimator,the,cost,estimator,to,use,to,cost,the,individual,operations;public,optimizer,cost,estimator,estimator,configuration,config,this,null,estimator,config
Optimizer -> public Optimizer(CostEstimator estimator, Configuration config);1431981454;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param estimator The cost estimator to use to cost the individual operations.;public Optimizer(CostEstimator estimator, Configuration config) {_		this(null, estimator, config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,estimator,the,cost,estimator,to,use,to,cost,the,individual,operations;public,optimizer,cost,estimator,estimator,configuration,config,this,null,estimator,config
Optimizer -> public Optimizer(CostEstimator estimator, Configuration config);1436966346;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param estimator The cost estimator to use to cost the individual operations.;public Optimizer(CostEstimator estimator, Configuration config) {_		this(null, estimator, config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,estimator,the,cost,estimator,to,use,to,cost,the,individual,operations;public,optimizer,cost,estimator,estimator,configuration,config,this,null,estimator,config
Optimizer -> public Optimizer(CostEstimator estimator, Configuration config);1444404795;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param estimator The cost estimator to use to cost the individual operations.;public Optimizer(CostEstimator estimator, Configuration config) {_		this(null, estimator, config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,estimator,the,cost,estimator,to,use,to,cost,the,individual,operations;public,optimizer,cost,estimator,estimator,configuration,config,this,null,estimator,config
Optimizer -> public Optimizer(CostEstimator estimator, Configuration config);1450712612;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param estimator The cost estimator to use to cost the individual operations.;public Optimizer(CostEstimator estimator, Configuration config) {_		this(null, estimator, config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,estimator,the,cost,estimator,to,use,to,cost,the,individual,operations;public,optimizer,cost,estimator,estimator,configuration,config,this,null,estimator,config
Optimizer -> public Optimizer(CostEstimator estimator, Configuration config);1460472696;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param estimator The cost estimator to use to cost the individual operations.;public Optimizer(CostEstimator estimator, Configuration config) {_		this(null, estimator, config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,estimator,the,cost,estimator,to,use,to,cost,the,individual,operations;public,optimizer,cost,estimator,estimator,configuration,config,this,null,estimator,config
Optimizer -> public Optimizer(CostEstimator estimator, Configuration config);1517324056;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param estimator The cost estimator to use to cost the individual operations.;public Optimizer(CostEstimator estimator, Configuration config) {_		this(null, estimator, config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,estimator,the,cost,estimator,to,use,to,cost,the,individual,operations;public,optimizer,cost,estimator,estimator,configuration,config,this,null,estimator,config
Optimizer -> public Optimizer(CostEstimator estimator, Configuration config);1522323145;Creates a new optimizer instance. The optimizer has no access to statistics about the_inputs and can hence not determine any properties. It will perform all optimization with_unknown sizes and hence use only the heuristic cost functions, which result in the selection_of the most robust execution strategies.__The optimizer uses the given cost estimator to compute the costs of the individual operations.__@param estimator The cost estimator to use to cost the individual operations.;public Optimizer(CostEstimator estimator, Configuration config) {_		this(null, estimator, config)__	};creates,a,new,optimizer,instance,the,optimizer,has,no,access,to,statistics,about,the,inputs,and,can,hence,not,determine,any,properties,it,will,perform,all,optimization,with,unknown,sizes,and,hence,use,only,the,heuristic,cost,functions,which,result,in,the,selection,of,the,most,robust,execution,strategies,the,optimizer,uses,the,given,cost,estimator,to,compute,the,costs,of,the,individual,operations,param,estimator,the,cost,estimator,to,use,to,cost,the,individual,operations;public,optimizer,cost,estimator,estimator,configuration,config,this,null,estimator,config
