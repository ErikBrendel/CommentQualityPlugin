commented;modifiers;parameterAmount;loc;comment;code
false;public;1;11;;@Override public boolean preVisit(PlanNode visitable) {     if (this.seenBefore.add(visitable)) {         if (visitable instanceof IterationPlanNode) {             ((IterationPlanNode) visitable).acceptForStepFunction(this).         }         return true.     } else {         return false.     } }
false;public;1;51;;@Override public void postVisit(PlanNode visitable) {     if (visitable instanceof BinaryUnionPlanNode) {         final BinaryUnionPlanNode unionNode = (BinaryUnionPlanNode) visitable.         final Channel in1 = unionNode.getInput1().         final Channel in2 = unionNode.getInput2().         if (!unionNode.unionsStaticAndDynamicPath()) {             // both on static path, or both on dynamic path. we can collapse them             NAryUnionPlanNode newUnionNode.             List<Channel> inputs = new ArrayList<Channel>().             collect(in1, inputs).             collect(in2, inputs).             newUnionNode = new NAryUnionPlanNode(unionNode.getOptimizerNode(), inputs, unionNode.getGlobalProperties(), unionNode.getCumulativeCosts()).             newUnionNode.setParallelism(unionNode.getParallelism()).             for (Channel c : inputs) {                 c.setTarget(newUnionNode).             }             for (Channel channel : unionNode.getOutgoingChannels()) {                 channel.swapUnionNodes(newUnionNode).                 newUnionNode.addOutgoingChannel(channel).             }         } else {             // make sure that the first input is the cached (static) and the second input is the dynamic             if (in1.isOnDynamicPath()) {                 BinaryUnionPlanNode newUnionNode = new BinaryUnionPlanNode(unionNode).                 in1.setTarget(newUnionNode).                 in2.setTarget(newUnionNode).                 for (Channel channel : unionNode.getOutgoingChannels()) {                     channel.swapUnionNodes(newUnionNode).                     newUnionNode.addOutgoingChannel(channel).                 }             }         }     } }
false;public;2;16;;public void collect(Channel in, List<Channel> inputs) {     if (in.getSource() instanceof NAryUnionPlanNode) {         // sanity check         if (in.getShipStrategy() != ShipStrategyType.FORWARD) {             throw new CompilerException("Bug: Plan generation for Unions picked a ship strategy between binary plan operators.").         }         if (!(in.getLocalStrategy() == null || in.getLocalStrategy() == LocalStrategy.NONE)) {             throw new CompilerException("Bug: Plan generation for Unions picked a local strategy between binary plan operators.").         }         inputs.addAll(((NAryUnionPlanNode) in.getSource()).getListOfInputs()).     } else {         // is not a collapsed union node, so we take the channel directly         inputs.add(in).     } }
