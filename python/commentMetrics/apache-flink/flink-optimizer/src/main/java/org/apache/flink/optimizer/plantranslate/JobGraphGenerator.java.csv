# id;timestamp;commentText;codeText;commentWords;codeWords
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1426843274;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated frmo the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		this.vertices = new HashMap<PlanNode, AbstractJobVertex>()__		this.chainedTasks = new HashMap<PlanNode, TaskInChain>()__		this.chainedTasksInSequence = new ArrayList<TaskInChain>()__		this.auxVertices = new ArrayList<AbstractJobVertex>()__		this.iterations = new HashMap<IterationPlanNode, IterationDescriptor>()__		this.iterationStack = new ArrayList<IterationPlanNode>()__		_		this.sharingGroup = new SlotSharingGroup()__		_		_		program.accept(this)__		_		_		if (this.currentIteration != null) {_			throw new CompilerException("The graph translation ended prematurely, leaving an unclosed iteration.")__		}_		_		_		for (IterationDescriptor iteration : this.iterations.values()) {_			if (iteration.getIterationNode() instanceof BulkIterationPlanNode) {_				finalizeBulkIteration(iteration)__			} else if (iteration.getIterationNode() instanceof WorksetIterationPlanNode) {_				finalizeWorksetIteration(iteration)__			} else {_				throw new CompilerException()__			}_		}_		_		_		_		for (TaskInChain tic : this.chainedTasksInSequence) {_			TaskConfig t = new TaskConfig(tic.getContainingVertex().getConfiguration())__			t.addChainedTask(tic.getChainedTask(), tic.getTaskConfig(), tic.getTaskName())__		}_		_		_		JobGraph graph = new JobGraph(program.getJobName())__		graph.setNumberOfExecutionRetries(program.getOriginalPactPlan().getNumberOfExecutionRetries())__		graph.setAllowQueuedScheduling(false)__		_		_		for (AbstractJobVertex vertex : this.vertices.values()) {_			graph.addVertex(vertex)__		}_		_		for (AbstractJobVertex vertex : this.auxVertices) {_			graph.addVertex(vertex)__			vertex.setSlotSharingGroup(sharingGroup)__		}_		_		_		for (Entry<String, DistributedCacheEntry> e : program.getOriginalPactPlan().getCachedFiles()) {_			DistributedCache.writeFileInfoToConfig(e.getKey(), e.getValue(), graph.getJobConfiguration())__		}__		try {_			InstantiationUtil.writeObjectToConfig(_					program.getOriginalPactPlan().getExecutionConfig(),_					graph.getJobConfiguration(),_					ExecutionConfig.CONFIG_KEY)__		} catch (IOException e) {_			throw new RuntimeException("Config object could not be written to Job Configuration: " + e)__		}__		_		this.vertices = null__		this.chainedTasks = null__		this.chainedTasksInSequence = null__		this.auxVertices = null__		this.iterations = null__		this.iterationStack = null__		_		_		return graph__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,frmo,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,this,vertices,new,hash,map,plan,node,abstract,job,vertex,this,chained,tasks,new,hash,map,plan,node,task,in,chain,this,chained,tasks,in,sequence,new,array,list,task,in,chain,this,aux,vertices,new,array,list,abstract,job,vertex,this,iterations,new,hash,map,iteration,plan,node,iteration,descriptor,this,iteration,stack,new,array,list,iteration,plan,node,this,sharing,group,new,slot,sharing,group,program,accept,this,if,this,current,iteration,null,throw,new,compiler,exception,the,graph,translation,ended,prematurely,leaving,an,unclosed,iteration,for,iteration,descriptor,iteration,this,iterations,values,if,iteration,get,iteration,node,instanceof,bulk,iteration,plan,node,finalize,bulk,iteration,iteration,else,if,iteration,get,iteration,node,instanceof,workset,iteration,plan,node,finalize,workset,iteration,iteration,else,throw,new,compiler,exception,for,task,in,chain,tic,this,chained,tasks,in,sequence,task,config,t,new,task,config,tic,get,containing,vertex,get,configuration,t,add,chained,task,tic,get,chained,task,tic,get,task,config,tic,get,task,name,job,graph,graph,new,job,graph,program,get,job,name,graph,set,number,of,execution,retries,program,get,original,pact,plan,get,number,of,execution,retries,graph,set,allow,queued,scheduling,false,for,abstract,job,vertex,vertex,this,vertices,values,graph,add,vertex,vertex,for,abstract,job,vertex,vertex,this,aux,vertices,graph,add,vertex,vertex,vertex,set,slot,sharing,group,sharing,group,for,entry,string,distributed,cache,entry,e,program,get,original,pact,plan,get,cached,files,distributed,cache,write,file,info,to,config,e,get,key,e,get,value,graph,get,job,configuration,try,instantiation,util,write,object,to,config,program,get,original,pact,plan,get,execution,config,graph,get,job,configuration,execution,config,catch,ioexception,e,throw,new,runtime,exception,config,object,could,not,be,written,to,job,configuration,e,this,vertices,null,this,chained,tasks,null,this,chained,tasks,in,sequence,null,this,aux,vertices,null,this,iterations,null,this,iteration,stack,null,return,graph
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1427097830;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated frmo the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		this.vertices = new HashMap<PlanNode, AbstractJobVertex>()__		this.chainedTasks = new HashMap<PlanNode, TaskInChain>()__		this.chainedTasksInSequence = new ArrayList<TaskInChain>()__		this.auxVertices = new ArrayList<AbstractJobVertex>()__		this.iterations = new HashMap<IterationPlanNode, IterationDescriptor>()__		this.iterationStack = new ArrayList<IterationPlanNode>()__		_		this.sharingGroup = new SlotSharingGroup()__		_		_		program.accept(this)__		_		_		if (this.currentIteration != null) {_			throw new CompilerException("The graph translation ended prematurely, leaving an unclosed iteration.")__		}_		_		_		for (IterationDescriptor iteration : this.iterations.values()) {_			if (iteration.getIterationNode() instanceof BulkIterationPlanNode) {_				finalizeBulkIteration(iteration)__			} else if (iteration.getIterationNode() instanceof WorksetIterationPlanNode) {_				finalizeWorksetIteration(iteration)__			} else {_				throw new CompilerException()__			}_		}_		_		_		_		for (TaskInChain tic : this.chainedTasksInSequence) {_			TaskConfig t = new TaskConfig(tic.getContainingVertex().getConfiguration())__			t.addChainedTask(tic.getChainedTask(), tic.getTaskConfig(), tic.getTaskName())__		}_		_		_		JobGraph graph = new JobGraph(program.getJobName())__		graph.setNumberOfExecutionRetries(program.getOriginalPactPlan().getNumberOfExecutionRetries())__		graph.setAllowQueuedScheduling(false)__		_		_		for (AbstractJobVertex vertex : this.vertices.values()) {_			graph.addVertex(vertex)__		}_		_		for (AbstractJobVertex vertex : this.auxVertices) {_			graph.addVertex(vertex)__			vertex.setSlotSharingGroup(sharingGroup)__		}_		_		_		for (Entry<String, DistributedCacheEntry> e : program.getOriginalPactPlan().getCachedFiles()) {_			DistributedCache.writeFileInfoToConfig(e.getKey(), e.getValue(), graph.getJobConfiguration())__		}__		try {_			InstantiationUtil.writeObjectToConfig(_					program.getOriginalPactPlan().getExecutionConfig(),_					graph.getJobConfiguration(),_					ExecutionConfig.CONFIG_KEY)__		} catch (IOException e) {_			throw new RuntimeException("Config object could not be written to Job Configuration: " + e)__		}__		_		this.vertices = null__		this.chainedTasks = null__		this.chainedTasksInSequence = null__		this.auxVertices = null__		this.iterations = null__		this.iterationStack = null__		_		_		return graph__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,frmo,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,this,vertices,new,hash,map,plan,node,abstract,job,vertex,this,chained,tasks,new,hash,map,plan,node,task,in,chain,this,chained,tasks,in,sequence,new,array,list,task,in,chain,this,aux,vertices,new,array,list,abstract,job,vertex,this,iterations,new,hash,map,iteration,plan,node,iteration,descriptor,this,iteration,stack,new,array,list,iteration,plan,node,this,sharing,group,new,slot,sharing,group,program,accept,this,if,this,current,iteration,null,throw,new,compiler,exception,the,graph,translation,ended,prematurely,leaving,an,unclosed,iteration,for,iteration,descriptor,iteration,this,iterations,values,if,iteration,get,iteration,node,instanceof,bulk,iteration,plan,node,finalize,bulk,iteration,iteration,else,if,iteration,get,iteration,node,instanceof,workset,iteration,plan,node,finalize,workset,iteration,iteration,else,throw,new,compiler,exception,for,task,in,chain,tic,this,chained,tasks,in,sequence,task,config,t,new,task,config,tic,get,containing,vertex,get,configuration,t,add,chained,task,tic,get,chained,task,tic,get,task,config,tic,get,task,name,job,graph,graph,new,job,graph,program,get,job,name,graph,set,number,of,execution,retries,program,get,original,pact,plan,get,number,of,execution,retries,graph,set,allow,queued,scheduling,false,for,abstract,job,vertex,vertex,this,vertices,values,graph,add,vertex,vertex,for,abstract,job,vertex,vertex,this,aux,vertices,graph,add,vertex,vertex,vertex,set,slot,sharing,group,sharing,group,for,entry,string,distributed,cache,entry,e,program,get,original,pact,plan,get,cached,files,distributed,cache,write,file,info,to,config,e,get,key,e,get,value,graph,get,job,configuration,try,instantiation,util,write,object,to,config,program,get,original,pact,plan,get,execution,config,graph,get,job,configuration,execution,config,catch,ioexception,e,throw,new,runtime,exception,config,object,could,not,be,written,to,job,configuration,e,this,vertices,null,this,chained,tasks,null,this,chained,tasks,in,sequence,null,this,aux,vertices,null,this,iterations,null,this,iteration,stack,null,return,graph
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1430859396;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated frmo the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		this.vertices = new HashMap<PlanNode, AbstractJobVertex>()__		this.chainedTasks = new HashMap<PlanNode, TaskInChain>()__		this.chainedTasksInSequence = new ArrayList<TaskInChain>()__		this.auxVertices = new ArrayList<AbstractJobVertex>()__		this.iterations = new HashMap<IterationPlanNode, IterationDescriptor>()__		this.iterationStack = new ArrayList<IterationPlanNode>()__		_		this.sharingGroup = new SlotSharingGroup()__		_		_		program.accept(this)__		_		_		if (this.currentIteration != null) {_			throw new CompilerException("The graph translation ended prematurely, leaving an unclosed iteration.")__		}_		_		_		for (IterationDescriptor iteration : this.iterations.values()) {_			if (iteration.getIterationNode() instanceof BulkIterationPlanNode) {_				finalizeBulkIteration(iteration)__			} else if (iteration.getIterationNode() instanceof WorksetIterationPlanNode) {_				finalizeWorksetIteration(iteration)__			} else {_				throw new CompilerException()__			}_		}_		_		_		_		for (TaskInChain tic : this.chainedTasksInSequence) {_			TaskConfig t = new TaskConfig(tic.getContainingVertex().getConfiguration())__			t.addChainedTask(tic.getChainedTask(), tic.getTaskConfig(), tic.getTaskName())__		}_		_		_		JobGraph graph = new JobGraph(program.getJobName())__		graph.setNumberOfExecutionRetries(program.getOriginalPactPlan().getNumberOfExecutionRetries())__		graph.setAllowQueuedScheduling(false)__		_		_		for (AbstractJobVertex vertex : this.vertices.values()) {_			graph.addVertex(vertex)__		}_		_		for (AbstractJobVertex vertex : this.auxVertices) {_			graph.addVertex(vertex)__			vertex.setSlotSharingGroup(sharingGroup)__		}_		_		_		for (Entry<String, DistributedCacheEntry> e : program.getOriginalPactPlan().getCachedFiles()) {_			DistributedCache.writeFileInfoToConfig(e.getKey(), e.getValue(), graph.getJobConfiguration())__		}__		try {_			InstantiationUtil.writeObjectToConfig(_					program.getOriginalPactPlan().getExecutionConfig(),_					graph.getJobConfiguration(),_					ExecutionConfig.CONFIG_KEY)__		} catch (IOException e) {_			throw new RuntimeException("Config object could not be written to Job Configuration: " + e)__		}__		_		this.vertices = null__		this.chainedTasks = null__		this.chainedTasksInSequence = null__		this.auxVertices = null__		this.iterations = null__		this.iterationStack = null__		_		_		return graph__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,frmo,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,this,vertices,new,hash,map,plan,node,abstract,job,vertex,this,chained,tasks,new,hash,map,plan,node,task,in,chain,this,chained,tasks,in,sequence,new,array,list,task,in,chain,this,aux,vertices,new,array,list,abstract,job,vertex,this,iterations,new,hash,map,iteration,plan,node,iteration,descriptor,this,iteration,stack,new,array,list,iteration,plan,node,this,sharing,group,new,slot,sharing,group,program,accept,this,if,this,current,iteration,null,throw,new,compiler,exception,the,graph,translation,ended,prematurely,leaving,an,unclosed,iteration,for,iteration,descriptor,iteration,this,iterations,values,if,iteration,get,iteration,node,instanceof,bulk,iteration,plan,node,finalize,bulk,iteration,iteration,else,if,iteration,get,iteration,node,instanceof,workset,iteration,plan,node,finalize,workset,iteration,iteration,else,throw,new,compiler,exception,for,task,in,chain,tic,this,chained,tasks,in,sequence,task,config,t,new,task,config,tic,get,containing,vertex,get,configuration,t,add,chained,task,tic,get,chained,task,tic,get,task,config,tic,get,task,name,job,graph,graph,new,job,graph,program,get,job,name,graph,set,number,of,execution,retries,program,get,original,pact,plan,get,number,of,execution,retries,graph,set,allow,queued,scheduling,false,for,abstract,job,vertex,vertex,this,vertices,values,graph,add,vertex,vertex,for,abstract,job,vertex,vertex,this,aux,vertices,graph,add,vertex,vertex,vertex,set,slot,sharing,group,sharing,group,for,entry,string,distributed,cache,entry,e,program,get,original,pact,plan,get,cached,files,distributed,cache,write,file,info,to,config,e,get,key,e,get,value,graph,get,job,configuration,try,instantiation,util,write,object,to,config,program,get,original,pact,plan,get,execution,config,graph,get,job,configuration,execution,config,catch,ioexception,e,throw,new,runtime,exception,config,object,could,not,be,written,to,job,configuration,e,this,vertices,null,this,chained,tasks,null,this,chained,tasks,in,sequence,null,this,aux,vertices,null,this,iterations,null,this,iteration,stack,null,return,graph
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1434467925;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated frmo the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		this.vertices = new HashMap<PlanNode, JobVertex>()__		this.chainedTasks = new HashMap<PlanNode, TaskInChain>()__		this.chainedTasksInSequence = new ArrayList<TaskInChain>()__		this.auxVertices = new ArrayList<JobVertex>()__		this.iterations = new HashMap<IterationPlanNode, IterationDescriptor>()__		this.iterationStack = new ArrayList<IterationPlanNode>()__		_		this.sharingGroup = new SlotSharingGroup()__		_		_		program.accept(this)__		_		_		if (this.currentIteration != null) {_			throw new CompilerException("The graph translation ended prematurely, leaving an unclosed iteration.")__		}_		_		_		for (IterationDescriptor iteration : this.iterations.values()) {_			if (iteration.getIterationNode() instanceof BulkIterationPlanNode) {_				finalizeBulkIteration(iteration)__			} else if (iteration.getIterationNode() instanceof WorksetIterationPlanNode) {_				finalizeWorksetIteration(iteration)__			} else {_				throw new CompilerException()__			}_		}_		_		_		_		for (TaskInChain tic : this.chainedTasksInSequence) {_			TaskConfig t = new TaskConfig(tic.getContainingVertex().getConfiguration())__			t.addChainedTask(tic.getChainedTask(), tic.getTaskConfig(), tic.getTaskName())__		}_		_		_		JobGraph graph = new JobGraph(program.getJobName())__		graph.setNumberOfExecutionRetries(program.getOriginalPactPlan().getNumberOfExecutionRetries())__		graph.setAllowQueuedScheduling(false)__		_		_		for (JobVertex vertex : this.vertices.values()) {_			graph.addVertex(vertex)__		}_		_		for (JobVertex vertex : this.auxVertices) {_			graph.addVertex(vertex)__			vertex.setSlotSharingGroup(sharingGroup)__		}_		_		_		for (Entry<String, DistributedCacheEntry> e : program.getOriginalPactPlan().getCachedFiles()) {_			DistributedCache.writeFileInfoToConfig(e.getKey(), e.getValue(), graph.getJobConfiguration())__		}__		try {_			InstantiationUtil.writeObjectToConfig(_					program.getOriginalPactPlan().getExecutionConfig(),_					graph.getJobConfiguration(),_					ExecutionConfig.CONFIG_KEY)__		} catch (IOException e) {_			throw new RuntimeException("Config object could not be written to Job Configuration: " + e)__		}__		_		this.vertices = null__		this.chainedTasks = null__		this.chainedTasksInSequence = null__		this.auxVertices = null__		this.iterations = null__		this.iterationStack = null__		_		_		return graph__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,frmo,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,this,vertices,new,hash,map,plan,node,job,vertex,this,chained,tasks,new,hash,map,plan,node,task,in,chain,this,chained,tasks,in,sequence,new,array,list,task,in,chain,this,aux,vertices,new,array,list,job,vertex,this,iterations,new,hash,map,iteration,plan,node,iteration,descriptor,this,iteration,stack,new,array,list,iteration,plan,node,this,sharing,group,new,slot,sharing,group,program,accept,this,if,this,current,iteration,null,throw,new,compiler,exception,the,graph,translation,ended,prematurely,leaving,an,unclosed,iteration,for,iteration,descriptor,iteration,this,iterations,values,if,iteration,get,iteration,node,instanceof,bulk,iteration,plan,node,finalize,bulk,iteration,iteration,else,if,iteration,get,iteration,node,instanceof,workset,iteration,plan,node,finalize,workset,iteration,iteration,else,throw,new,compiler,exception,for,task,in,chain,tic,this,chained,tasks,in,sequence,task,config,t,new,task,config,tic,get,containing,vertex,get,configuration,t,add,chained,task,tic,get,chained,task,tic,get,task,config,tic,get,task,name,job,graph,graph,new,job,graph,program,get,job,name,graph,set,number,of,execution,retries,program,get,original,pact,plan,get,number,of,execution,retries,graph,set,allow,queued,scheduling,false,for,job,vertex,vertex,this,vertices,values,graph,add,vertex,vertex,for,job,vertex,vertex,this,aux,vertices,graph,add,vertex,vertex,vertex,set,slot,sharing,group,sharing,group,for,entry,string,distributed,cache,entry,e,program,get,original,pact,plan,get,cached,files,distributed,cache,write,file,info,to,config,e,get,key,e,get,value,graph,get,job,configuration,try,instantiation,util,write,object,to,config,program,get,original,pact,plan,get,execution,config,graph,get,job,configuration,execution,config,catch,ioexception,e,throw,new,runtime,exception,config,object,could,not,be,written,to,job,configuration,e,this,vertices,null,this,chained,tasks,null,this,chained,tasks,in,sequence,null,this,aux,vertices,null,this,iterations,null,this,iteration,stack,null,return,graph
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1434490608;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated frmo the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		this.vertices = new HashMap<PlanNode, JobVertex>()__		this.chainedTasks = new HashMap<PlanNode, TaskInChain>()__		this.chainedTasksInSequence = new ArrayList<TaskInChain>()__		this.auxVertices = new ArrayList<JobVertex>()__		this.iterations = new HashMap<IterationPlanNode, IterationDescriptor>()__		this.iterationStack = new ArrayList<IterationPlanNode>()__		_		this.sharingGroup = new SlotSharingGroup()__		_		_		program.accept(this)__		_		_		if (this.currentIteration != null) {_			throw new CompilerException("The graph translation ended prematurely, leaving an unclosed iteration.")__		}_		_		_		for (IterationDescriptor iteration : this.iterations.values()) {_			if (iteration.getIterationNode() instanceof BulkIterationPlanNode) {_				finalizeBulkIteration(iteration)__			} else if (iteration.getIterationNode() instanceof WorksetIterationPlanNode) {_				finalizeWorksetIteration(iteration)__			} else {_				throw new CompilerException()__			}_		}_		_		_		_		for (TaskInChain tic : this.chainedTasksInSequence) {_			TaskConfig t = new TaskConfig(tic.getContainingVertex().getConfiguration())__			t.addChainedTask(tic.getChainedTask(), tic.getTaskConfig(), tic.getTaskName())__		}_		_		_		JobGraph graph = new JobGraph(program.getJobName())__		graph.setNumberOfExecutionRetries(program.getOriginalPactPlan().getNumberOfExecutionRetries())__		graph.setAllowQueuedScheduling(false)__		_		_		for (JobVertex vertex : this.vertices.values()) {_			graph.addVertex(vertex)__		}_		_		for (JobVertex vertex : this.auxVertices) {_			graph.addVertex(vertex)__			vertex.setSlotSharingGroup(sharingGroup)__		}_		_		_		for (Entry<String, DistributedCacheEntry> e : program.getOriginalPactPlan().getCachedFiles()) {_			DistributedCache.writeFileInfoToConfig(e.getKey(), e.getValue(), graph.getJobConfiguration())__		}__		try {_			InstantiationUtil.writeObjectToConfig(_					program.getOriginalPactPlan().getExecutionConfig(),_					graph.getJobConfiguration(),_					ExecutionConfig.CONFIG_KEY)__		} catch (IOException e) {_			throw new RuntimeException("Config object could not be written to Job Configuration: " + e)__		}__		_		this.vertices = null__		this.chainedTasks = null__		this.chainedTasksInSequence = null__		this.auxVertices = null__		this.iterations = null__		this.iterationStack = null__		_		_		return graph__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,frmo,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,this,vertices,new,hash,map,plan,node,job,vertex,this,chained,tasks,new,hash,map,plan,node,task,in,chain,this,chained,tasks,in,sequence,new,array,list,task,in,chain,this,aux,vertices,new,array,list,job,vertex,this,iterations,new,hash,map,iteration,plan,node,iteration,descriptor,this,iteration,stack,new,array,list,iteration,plan,node,this,sharing,group,new,slot,sharing,group,program,accept,this,if,this,current,iteration,null,throw,new,compiler,exception,the,graph,translation,ended,prematurely,leaving,an,unclosed,iteration,for,iteration,descriptor,iteration,this,iterations,values,if,iteration,get,iteration,node,instanceof,bulk,iteration,plan,node,finalize,bulk,iteration,iteration,else,if,iteration,get,iteration,node,instanceof,workset,iteration,plan,node,finalize,workset,iteration,iteration,else,throw,new,compiler,exception,for,task,in,chain,tic,this,chained,tasks,in,sequence,task,config,t,new,task,config,tic,get,containing,vertex,get,configuration,t,add,chained,task,tic,get,chained,task,tic,get,task,config,tic,get,task,name,job,graph,graph,new,job,graph,program,get,job,name,graph,set,number,of,execution,retries,program,get,original,pact,plan,get,number,of,execution,retries,graph,set,allow,queued,scheduling,false,for,job,vertex,vertex,this,vertices,values,graph,add,vertex,vertex,for,job,vertex,vertex,this,aux,vertices,graph,add,vertex,vertex,vertex,set,slot,sharing,group,sharing,group,for,entry,string,distributed,cache,entry,e,program,get,original,pact,plan,get,cached,files,distributed,cache,write,file,info,to,config,e,get,key,e,get,value,graph,get,job,configuration,try,instantiation,util,write,object,to,config,program,get,original,pact,plan,get,execution,config,graph,get,job,configuration,execution,config,catch,ioexception,e,throw,new,runtime,exception,config,object,could,not,be,written,to,job,configuration,e,this,vertices,null,this,chained,tasks,null,this,chained,tasks,in,sequence,null,this,aux,vertices,null,this,iterations,null,this,iteration,stack,null,return,graph
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1437494294;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated frmo the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		this.vertices = new HashMap<PlanNode, JobVertex>()__		this.chainedTasks = new HashMap<PlanNode, TaskInChain>()__		this.chainedTasksInSequence = new ArrayList<TaskInChain>()__		this.auxVertices = new ArrayList<JobVertex>()__		this.iterations = new HashMap<IterationPlanNode, IterationDescriptor>()__		this.iterationStack = new ArrayList<IterationPlanNode>()__		_		this.sharingGroup = new SlotSharingGroup()__		_		_		program.accept(this)__		_		_		if (this.currentIteration != null) {_			throw new CompilerException("The graph translation ended prematurely, leaving an unclosed iteration.")__		}_		_		_		for (IterationDescriptor iteration : this.iterations.values()) {_			if (iteration.getIterationNode() instanceof BulkIterationPlanNode) {_				finalizeBulkIteration(iteration)__			} else if (iteration.getIterationNode() instanceof WorksetIterationPlanNode) {_				finalizeWorksetIteration(iteration)__			} else {_				throw new CompilerException()__			}_		}_		_		_		_		for (TaskInChain tic : this.chainedTasksInSequence) {_			TaskConfig t = new TaskConfig(tic.getContainingVertex().getConfiguration())__			t.addChainedTask(tic.getChainedTask(), tic.getTaskConfig(), tic.getTaskName())__		}_		_		_		JobGraph graph = new JobGraph(program.getJobName())__		graph.setNumberOfExecutionRetries(program.getOriginalPactPlan().getNumberOfExecutionRetries())__		graph.setAllowQueuedScheduling(false)__		_		_		for (JobVertex vertex : this.vertices.values()) {_			graph.addVertex(vertex)__		}_		_		for (JobVertex vertex : this.auxVertices) {_			graph.addVertex(vertex)__			vertex.setSlotSharingGroup(sharingGroup)__		}_		_		_		for (Entry<String, DistributedCacheEntry> e : program.getOriginalPactPlan().getCachedFiles()) {_			DistributedCache.writeFileInfoToConfig(e.getKey(), e.getValue(), graph.getJobConfiguration())__		}__		try {_			InstantiationUtil.writeObjectToConfig(_					program.getOriginalPactPlan().getExecutionConfig(),_					graph.getJobConfiguration(),_					ExecutionConfig.CONFIG_KEY)__		} catch (IOException e) {_			throw new RuntimeException("Config object could not be written to Job Configuration: " + e)__		}__		String jsonPlan = new PlanJSONDumpGenerator().getOptimizerPlanAsJSON(program)__		graph.setJsonPlan(jsonPlan)___		_		this.vertices = null__		this.chainedTasks = null__		this.chainedTasksInSequence = null__		this.auxVertices = null__		this.iterations = null__		this.iterationStack = null__		_		_		return graph__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,frmo,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,this,vertices,new,hash,map,plan,node,job,vertex,this,chained,tasks,new,hash,map,plan,node,task,in,chain,this,chained,tasks,in,sequence,new,array,list,task,in,chain,this,aux,vertices,new,array,list,job,vertex,this,iterations,new,hash,map,iteration,plan,node,iteration,descriptor,this,iteration,stack,new,array,list,iteration,plan,node,this,sharing,group,new,slot,sharing,group,program,accept,this,if,this,current,iteration,null,throw,new,compiler,exception,the,graph,translation,ended,prematurely,leaving,an,unclosed,iteration,for,iteration,descriptor,iteration,this,iterations,values,if,iteration,get,iteration,node,instanceof,bulk,iteration,plan,node,finalize,bulk,iteration,iteration,else,if,iteration,get,iteration,node,instanceof,workset,iteration,plan,node,finalize,workset,iteration,iteration,else,throw,new,compiler,exception,for,task,in,chain,tic,this,chained,tasks,in,sequence,task,config,t,new,task,config,tic,get,containing,vertex,get,configuration,t,add,chained,task,tic,get,chained,task,tic,get,task,config,tic,get,task,name,job,graph,graph,new,job,graph,program,get,job,name,graph,set,number,of,execution,retries,program,get,original,pact,plan,get,number,of,execution,retries,graph,set,allow,queued,scheduling,false,for,job,vertex,vertex,this,vertices,values,graph,add,vertex,vertex,for,job,vertex,vertex,this,aux,vertices,graph,add,vertex,vertex,vertex,set,slot,sharing,group,sharing,group,for,entry,string,distributed,cache,entry,e,program,get,original,pact,plan,get,cached,files,distributed,cache,write,file,info,to,config,e,get,key,e,get,value,graph,get,job,configuration,try,instantiation,util,write,object,to,config,program,get,original,pact,plan,get,execution,config,graph,get,job,configuration,execution,config,catch,ioexception,e,throw,new,runtime,exception,config,object,could,not,be,written,to,job,configuration,e,string,json,plan,new,plan,jsondump,generator,get,optimizer,plan,as,json,program,graph,set,json,plan,json,plan,this,vertices,null,this,chained,tasks,null,this,chained,tasks,in,sequence,null,this,aux,vertices,null,this,iterations,null,this,iteration,stack,null,return,graph
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1438872996;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated frmo the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		this.vertices = new HashMap<PlanNode, JobVertex>()__		this.chainedTasks = new HashMap<PlanNode, TaskInChain>()__		this.chainedTasksInSequence = new ArrayList<TaskInChain>()__		this.auxVertices = new ArrayList<JobVertex>()__		this.iterations = new HashMap<IterationPlanNode, IterationDescriptor>()__		this.iterationStack = new ArrayList<IterationPlanNode>()__		_		this.sharingGroup = new SlotSharingGroup()__		_		_		program.accept(this)__		_		_		if (this.currentIteration != null) {_			throw new CompilerException("The graph translation ended prematurely, leaving an unclosed iteration.")__		}_		_		_		for (IterationDescriptor iteration : this.iterations.values()) {_			if (iteration.getIterationNode() instanceof BulkIterationPlanNode) {_				finalizeBulkIteration(iteration)__			} else if (iteration.getIterationNode() instanceof WorksetIterationPlanNode) {_				finalizeWorksetIteration(iteration)__			} else {_				throw new CompilerException()__			}_		}_		_		_		_		for (TaskInChain tic : this.chainedTasksInSequence) {_			TaskConfig t = new TaskConfig(tic.getContainingVertex().getConfiguration())__			t.addChainedTask(tic.getChainedTask(), tic.getTaskConfig(), tic.getTaskName())__		}_		_		_		JobGraph graph = new JobGraph(program.getJobName())__		graph.setNumberOfExecutionRetries(program.getOriginalPactPlan().getNumberOfExecutionRetries())__		graph.setAllowQueuedScheduling(false)__		_		_		for (JobVertex vertex : this.vertices.values()) {_			graph.addVertex(vertex)__		}_		_		for (JobVertex vertex : this.auxVertices) {_			graph.addVertex(vertex)__			vertex.setSlotSharingGroup(sharingGroup)__		}_		_		_		for (Entry<String, DistributedCacheEntry> e : program.getOriginalPactPlan().getCachedFiles()) {_			DistributedCache.writeFileInfoToConfig(e.getKey(), e.getValue(), graph.getJobConfiguration())__		}__		try {_			InstantiationUtil.writeObjectToConfig(_					program.getOriginalPactPlan().getExecutionConfig(),_					graph.getJobConfiguration(),_					ExecutionConfig.CONFIG_KEY)__		} catch (IOException e) {_			throw new RuntimeException("Config object could not be written to Job Configuration: " + e)__		}__		String jsonPlan = new PlanJSONDumpGenerator().getOptimizerPlanAsJSON(program)__		graph.setJsonPlan(jsonPlan)___		_		this.vertices = null__		this.chainedTasks = null__		this.chainedTasksInSequence = null__		this.auxVertices = null__		this.iterations = null__		this.iterationStack = null__		_		_		return graph__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,frmo,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,this,vertices,new,hash,map,plan,node,job,vertex,this,chained,tasks,new,hash,map,plan,node,task,in,chain,this,chained,tasks,in,sequence,new,array,list,task,in,chain,this,aux,vertices,new,array,list,job,vertex,this,iterations,new,hash,map,iteration,plan,node,iteration,descriptor,this,iteration,stack,new,array,list,iteration,plan,node,this,sharing,group,new,slot,sharing,group,program,accept,this,if,this,current,iteration,null,throw,new,compiler,exception,the,graph,translation,ended,prematurely,leaving,an,unclosed,iteration,for,iteration,descriptor,iteration,this,iterations,values,if,iteration,get,iteration,node,instanceof,bulk,iteration,plan,node,finalize,bulk,iteration,iteration,else,if,iteration,get,iteration,node,instanceof,workset,iteration,plan,node,finalize,workset,iteration,iteration,else,throw,new,compiler,exception,for,task,in,chain,tic,this,chained,tasks,in,sequence,task,config,t,new,task,config,tic,get,containing,vertex,get,configuration,t,add,chained,task,tic,get,chained,task,tic,get,task,config,tic,get,task,name,job,graph,graph,new,job,graph,program,get,job,name,graph,set,number,of,execution,retries,program,get,original,pact,plan,get,number,of,execution,retries,graph,set,allow,queued,scheduling,false,for,job,vertex,vertex,this,vertices,values,graph,add,vertex,vertex,for,job,vertex,vertex,this,aux,vertices,graph,add,vertex,vertex,vertex,set,slot,sharing,group,sharing,group,for,entry,string,distributed,cache,entry,e,program,get,original,pact,plan,get,cached,files,distributed,cache,write,file,info,to,config,e,get,key,e,get,value,graph,get,job,configuration,try,instantiation,util,write,object,to,config,program,get,original,pact,plan,get,execution,config,graph,get,job,configuration,execution,config,catch,ioexception,e,throw,new,runtime,exception,config,object,could,not,be,written,to,job,configuration,e,string,json,plan,new,plan,jsondump,generator,get,optimizer,plan,as,json,program,graph,set,json,plan,json,plan,this,vertices,null,this,chained,tasks,null,this,chained,tasks,in,sequence,null,this,aux,vertices,null,this,iterations,null,this,iteration,stack,null,return,graph
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1440151741;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated frmo the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		this.vertices = new HashMap<PlanNode, JobVertex>()__		this.chainedTasks = new HashMap<PlanNode, TaskInChain>()__		this.chainedTasksInSequence = new ArrayList<TaskInChain>()__		this.auxVertices = new ArrayList<JobVertex>()__		this.iterations = new HashMap<IterationPlanNode, IterationDescriptor>()__		this.iterationStack = new ArrayList<IterationPlanNode>()__		_		this.sharingGroup = new SlotSharingGroup()__		_		_		program.accept(this)__		_		_		if (this.currentIteration != null) {_			throw new CompilerException("The graph translation ended prematurely, leaving an unclosed iteration.")__		}_		_		_		for (IterationDescriptor iteration : this.iterations.values()) {_			if (iteration.getIterationNode() instanceof BulkIterationPlanNode) {_				finalizeBulkIteration(iteration)__			} else if (iteration.getIterationNode() instanceof WorksetIterationPlanNode) {_				finalizeWorksetIteration(iteration)__			} else {_				throw new CompilerException()__			}_		}_		_		_		_		for (TaskInChain tic : this.chainedTasksInSequence) {_			TaskConfig t = new TaskConfig(tic.getContainingVertex().getConfiguration())__			t.addChainedTask(tic.getChainedTask(), tic.getTaskConfig(), tic.getTaskName())__		}_		_		_		JobGraph graph = new JobGraph(program.getJobName())__		graph.setNumberOfExecutionRetries(program.getOriginalPactPlan().getNumberOfExecutionRetries())__		graph.setAllowQueuedScheduling(false)__		_		_		for (JobVertex vertex : this.vertices.values()) {_			graph.addVertex(vertex)__		}_		_		for (JobVertex vertex : this.auxVertices) {_			graph.addVertex(vertex)__			vertex.setSlotSharingGroup(sharingGroup)__		}_		_		_		for (Entry<String, DistributedCacheEntry> e : program.getOriginalPactPlan().getCachedFiles()) {_			DistributedCache.writeFileInfoToConfig(e.getKey(), e.getValue(), graph.getJobConfiguration())__		}__		try {_			InstantiationUtil.writeObjectToConfig(_					program.getOriginalPactPlan().getExecutionConfig(),_					graph.getJobConfiguration(),_					ExecutionConfig.CONFIG_KEY)__		} catch (IOException e) {_			throw new RuntimeException("Config object could not be written to Job Configuration: " + e)__		}__		String jsonPlan = new PlanJSONDumpGenerator().getOptimizerPlanAsJSON(program)__		graph.setJsonPlan(jsonPlan)___		_		this.vertices = null__		this.chainedTasks = null__		this.chainedTasksInSequence = null__		this.auxVertices = null__		this.iterations = null__		this.iterationStack = null__		_		_		return graph__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,frmo,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,this,vertices,new,hash,map,plan,node,job,vertex,this,chained,tasks,new,hash,map,plan,node,task,in,chain,this,chained,tasks,in,sequence,new,array,list,task,in,chain,this,aux,vertices,new,array,list,job,vertex,this,iterations,new,hash,map,iteration,plan,node,iteration,descriptor,this,iteration,stack,new,array,list,iteration,plan,node,this,sharing,group,new,slot,sharing,group,program,accept,this,if,this,current,iteration,null,throw,new,compiler,exception,the,graph,translation,ended,prematurely,leaving,an,unclosed,iteration,for,iteration,descriptor,iteration,this,iterations,values,if,iteration,get,iteration,node,instanceof,bulk,iteration,plan,node,finalize,bulk,iteration,iteration,else,if,iteration,get,iteration,node,instanceof,workset,iteration,plan,node,finalize,workset,iteration,iteration,else,throw,new,compiler,exception,for,task,in,chain,tic,this,chained,tasks,in,sequence,task,config,t,new,task,config,tic,get,containing,vertex,get,configuration,t,add,chained,task,tic,get,chained,task,tic,get,task,config,tic,get,task,name,job,graph,graph,new,job,graph,program,get,job,name,graph,set,number,of,execution,retries,program,get,original,pact,plan,get,number,of,execution,retries,graph,set,allow,queued,scheduling,false,for,job,vertex,vertex,this,vertices,values,graph,add,vertex,vertex,for,job,vertex,vertex,this,aux,vertices,graph,add,vertex,vertex,vertex,set,slot,sharing,group,sharing,group,for,entry,string,distributed,cache,entry,e,program,get,original,pact,plan,get,cached,files,distributed,cache,write,file,info,to,config,e,get,key,e,get,value,graph,get,job,configuration,try,instantiation,util,write,object,to,config,program,get,original,pact,plan,get,execution,config,graph,get,job,configuration,execution,config,catch,ioexception,e,throw,new,runtime,exception,config,object,could,not,be,written,to,job,configuration,e,string,json,plan,new,plan,jsondump,generator,get,optimizer,plan,as,json,program,graph,set,json,plan,json,plan,this,vertices,null,this,chained,tasks,null,this,chained,tasks,in,sequence,null,this,aux,vertices,null,this,iterations,null,this,iteration,stack,null,return,graph
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1442492509;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated frmo the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		this.vertices = new HashMap<PlanNode, JobVertex>()__		this.chainedTasks = new HashMap<PlanNode, TaskInChain>()__		this.chainedTasksInSequence = new ArrayList<TaskInChain>()__		this.auxVertices = new ArrayList<JobVertex>()__		this.iterations = new HashMap<IterationPlanNode, IterationDescriptor>()__		this.iterationStack = new ArrayList<IterationPlanNode>()__		_		this.sharingGroup = new SlotSharingGroup()__		_		_		program.accept(this)__		_		_		if (this.currentIteration != null) {_			throw new CompilerException("The graph translation ended prematurely, leaving an unclosed iteration.")__		}_		_		_		for (IterationDescriptor iteration : this.iterations.values()) {_			if (iteration.getIterationNode() instanceof BulkIterationPlanNode) {_				finalizeBulkIteration(iteration)__			} else if (iteration.getIterationNode() instanceof WorksetIterationPlanNode) {_				finalizeWorksetIteration(iteration)__			} else {_				throw new CompilerException()__			}_		}_		_		_		_		for (TaskInChain tic : this.chainedTasksInSequence) {_			TaskConfig t = new TaskConfig(tic.getContainingVertex().getConfiguration())__			t.addChainedTask(tic.getChainedTask(), tic.getTaskConfig(), tic.getTaskName())__		}_		_		_		_		attachOperatorNamesAndDescriptions()___		_		_		_		JobGraph graph = new JobGraph(program.getJobName())__		graph.setNumberOfExecutionRetries(program.getOriginalPactPlan().getNumberOfExecutionRetries())__		graph.setAllowQueuedScheduling(false)___		_		for (JobVertex vertex : this.vertices.values()) {_			graph.addVertex(vertex)__		}__		for (JobVertex vertex : this.auxVertices) {_			graph.addVertex(vertex)__			vertex.setSlotSharingGroup(sharingGroup)__		}__		_		for (Entry<String, DistributedCacheEntry> e : program.getOriginalPactPlan().getCachedFiles()) {_			DistributedCache.writeFileInfoToConfig(e.getKey(), e.getValue(), graph.getJobConfiguration())__		}__		try {_			InstantiationUtil.writeObjectToConfig(_					program.getOriginalPactPlan().getExecutionConfig(),_					graph.getJobConfiguration(),_					ExecutionConfig.CONFIG_KEY)__		} catch (IOException e) {_			throw new RuntimeException("Config object could not be written to Job Configuration: " + e)__		}__		_		this.vertices = null__		this.chainedTasks = null__		this.chainedTasksInSequence = null__		this.auxVertices = null__		this.iterations = null__		this.iterationStack = null__		_		_		return graph__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,frmo,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,this,vertices,new,hash,map,plan,node,job,vertex,this,chained,tasks,new,hash,map,plan,node,task,in,chain,this,chained,tasks,in,sequence,new,array,list,task,in,chain,this,aux,vertices,new,array,list,job,vertex,this,iterations,new,hash,map,iteration,plan,node,iteration,descriptor,this,iteration,stack,new,array,list,iteration,plan,node,this,sharing,group,new,slot,sharing,group,program,accept,this,if,this,current,iteration,null,throw,new,compiler,exception,the,graph,translation,ended,prematurely,leaving,an,unclosed,iteration,for,iteration,descriptor,iteration,this,iterations,values,if,iteration,get,iteration,node,instanceof,bulk,iteration,plan,node,finalize,bulk,iteration,iteration,else,if,iteration,get,iteration,node,instanceof,workset,iteration,plan,node,finalize,workset,iteration,iteration,else,throw,new,compiler,exception,for,task,in,chain,tic,this,chained,tasks,in,sequence,task,config,t,new,task,config,tic,get,containing,vertex,get,configuration,t,add,chained,task,tic,get,chained,task,tic,get,task,config,tic,get,task,name,attach,operator,names,and,descriptions,job,graph,graph,new,job,graph,program,get,job,name,graph,set,number,of,execution,retries,program,get,original,pact,plan,get,number,of,execution,retries,graph,set,allow,queued,scheduling,false,for,job,vertex,vertex,this,vertices,values,graph,add,vertex,vertex,for,job,vertex,vertex,this,aux,vertices,graph,add,vertex,vertex,vertex,set,slot,sharing,group,sharing,group,for,entry,string,distributed,cache,entry,e,program,get,original,pact,plan,get,cached,files,distributed,cache,write,file,info,to,config,e,get,key,e,get,value,graph,get,job,configuration,try,instantiation,util,write,object,to,config,program,get,original,pact,plan,get,execution,config,graph,get,job,configuration,execution,config,catch,ioexception,e,throw,new,runtime,exception,config,object,could,not,be,written,to,job,configuration,e,this,vertices,null,this,chained,tasks,null,this,chained,tasks,in,sequence,null,this,aux,vertices,null,this,iterations,null,this,iteration,stack,null,return,graph
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1442944546;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1444144446;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1444215406;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1445427423;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1448400254;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1450712612;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1455548285;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1457737669;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1459526979;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1463155298;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1466529056;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1469630409;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1477046030;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1487548883;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1487616195;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1489060856;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1489149057;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1489671807;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1509447226;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1511814440;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1511890763;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1518451382;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1522323145;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1525420604;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1529583969;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> public JobGraph compileJobGraph(OptimizedPlan program);1547644408;Translates a {@link org.apache.flink.optimizer.plan.OptimizedPlan} into a_{@link org.apache.flink.runtime.jobgraph.JobGraph}.__@param program Optimized plan that is translated into a JobGraph._@return JobGraph generated from the plan.;public JobGraph compileJobGraph(OptimizedPlan program) {_		return compileJobGraph(program, null)__	};translates,a,link,org,apache,flink,optimizer,plan,optimized,plan,into,a,link,org,apache,flink,runtime,jobgraph,job,graph,param,program,optimized,plan,that,is,translated,into,a,job,graph,return,job,graph,generated,from,the,plan;public,job,graph,compile,job,graph,optimized,plan,program,return,compile,job,graph,program,null
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1434467925;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@param channel_@param inputNumber_@param sourceVertex_@param sourceConfig_@param targetVertex_@param targetConfig_@param isBroadcast_@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,param,channel,param,input,number,param,source,vertex,param,source,config,param,target,vertex,param,target,config,param,is,broadcast,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1434490608;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@param channel_@param inputNumber_@param sourceVertex_@param sourceConfig_@param targetVertex_@param targetConfig_@param isBroadcast_@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,param,channel,param,input,number,param,source,vertex,param,source,config,param,target,vertex,param,target,config,param,is,broadcast,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1437494294;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@param channel_@param inputNumber_@param sourceVertex_@param sourceConfig_@param targetVertex_@param targetConfig_@param isBroadcast_@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,param,channel,param,input,number,param,source,vertex,param,source,config,param,target,vertex,param,target,config,param,is,broadcast,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1438872996;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@param channel_@param inputNumber_@param sourceVertex_@param sourceConfig_@param targetVertex_@param targetConfig_@param isBroadcast_@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,param,channel,param,input,number,param,source,vertex,param,source,config,param,target,vertex,param,target,config,param,is,broadcast,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1440151741;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@param channel_@param inputNumber_@param sourceVertex_@param sourceConfig_@param targetVertex_@param targetConfig_@param isBroadcast_@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,param,channel,param,input,number,param,source,vertex,param,source,config,param,target,vertex,param,target,config,param,is,broadcast,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1442492509;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1442944546;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1444144446;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1444215406;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1445427423;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1448400254;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1450712612;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1455548285;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1457737669;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1459526979;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1463155298;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1466529056;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1469630409;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1477046030;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1487548883;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1487616195;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1489060856;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1489149057;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1489671807;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1509447226;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1511814440;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1511890763;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1518451382;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1522323145;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1525420604;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1529583969;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final JobVertex sourceVertex, final TaskConfig sourceConfig, 			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1547644408;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final JobVertex sourceVertex, final TaskConfig sourceConfig,_			final JobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		JobEdge edge = targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution.")__			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		_		_		_		String shipStrategy = JsonMapper.getShipStrategyString(channel.getShipStrategy())__		if (channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {_			shipStrategy += " on " + (channel.getShipStrategySortOrder() == null ?_					channel.getShipStrategyKeys().toString() :_					Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString())__		}_		_		String localStrategy__		if (channel.getLocalStrategy() == null || channel.getLocalStrategy() == LocalStrategy.NONE) {_			localStrategy = null__		}_		else {_			localStrategy = JsonMapper.getLocalStrategyString(channel.getLocalStrategy())__			if (localStrategy != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {_				localStrategy += " on " + (channel.getLocalStrategySortOrder() == null ?_						channel.getLocalStrategyKeys().toString() :_						Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString())__			}_		}_		_		String caching = channel.getTempMode() == TempMode.NONE ? null : channel.getTempMode().toString()___		edge.setShipStrategyName(shipStrategy)__		edge.setPreProcessingOperationName(localStrategy)__		edge.setOperatorLevelCachingDescription(caching)__		_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,job,vertex,source,vertex,final,task,config,source,config,final,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,job,edge,edge,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,string,ship,strategy,json,mapper,get,ship,strategy,string,channel,get,ship,strategy,if,channel,get,ship,strategy,keys,null,channel,get,ship,strategy,keys,size,0,ship,strategy,on,channel,get,ship,strategy,sort,order,null,channel,get,ship,strategy,keys,to,string,utils,create,ordering,channel,get,ship,strategy,keys,channel,get,ship,strategy,sort,order,to,string,string,local,strategy,if,channel,get,local,strategy,null,channel,get,local,strategy,local,strategy,none,local,strategy,null,else,local,strategy,json,mapper,get,local,strategy,string,channel,get,local,strategy,if,local,strategy,null,channel,get,local,strategy,keys,null,channel,get,local,strategy,keys,size,0,local,strategy,on,channel,get,local,strategy,sort,order,null,channel,get,local,strategy,keys,to,string,utils,create,ordering,channel,get,local,strategy,keys,channel,get,local,strategy,sort,order,to,string,string,caching,channel,get,temp,mode,temp,mode,none,null,channel,get,temp,mode,to,string,edge,set,ship,strategy,name,ship,strategy,edge,set,pre,processing,operation,name,local,strategy,edge,set,operator,level,caching,description,caching,return,distribution,pattern
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1426843274;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					AbstractJobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final AbstractJobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					AbstractJobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if(containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName+" -> "+chainedTask.getTaskName())__					} else {_						container.setName("CHAIN "+containerTaskName+" -> "+chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				AbstractJobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				if (head != null) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,abstract,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,abstract,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,abstract,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,abstract,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,head,null,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,nephele,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1427097830;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					AbstractJobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final AbstractJobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					AbstractJobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if(containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName+" -> "+chainedTask.getTaskName())__					} else {_						container.setName("CHAIN "+containerTaskName+" -> "+chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				AbstractJobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				if (head != null) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,abstract,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,abstract,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,abstract,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,abstract,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,head,null,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,nephele,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1430859396;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					AbstractJobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final AbstractJobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					AbstractJobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if(containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName+" -> "+chainedTask.getTaskName())__					} else {_						container.setName("CHAIN "+containerTaskName+" -> "+chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				AbstractJobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				if (head != null) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,abstract,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,abstract,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,abstract,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,abstract,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,head,null,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,nephele,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1434467925;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if(containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName+" -> "+chainedTask.getTaskName())__					} else {_						container.setName("CHAIN "+containerTaskName+" -> "+chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				if (head != null) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,head,null,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,nephele,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1434490608;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if(containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName+" -> "+chainedTask.getTaskName())__					} else {_						container.setName("CHAIN "+containerTaskName+" -> "+chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,nephele,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1437494294;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if(containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName+" -> "+chainedTask.getTaskName())__					} else {_						container.setName("CHAIN "+containerTaskName+" -> "+chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,nephele,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1438872996;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if(containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName+" -> "+chainedTask.getTaskName())__					} else {_						container.setName("CHAIN "+containerTaskName+" -> "+chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,nephele,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1440151741;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if(containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName+" -> "+chainedTask.getTaskName())__					} else {_						container.setName("CHAIN "+containerTaskName+" -> "+chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,nephele,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1442492509;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1442944546;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1444144446;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1444215406;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1445427423;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1448400254;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1450712612;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1455548285;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1457737669;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1459526979;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1463155298;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1466529056;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1469630409;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1477046030;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1487548883;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1487616195;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1489060856;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1489149057;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}_					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1489671807;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}__					_					container.setResources(container.getMinResources().merge(node.getMinResources()),_							container.getPreferredResources().merge(node.getPreferredResources()))__					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,container,set,resources,container,get,min,resources,merge,node,get,min,resources,container,get,preferred,resources,merge,node,get,preferred,resources,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1509447226;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}__					_					container.setResources(container.getMinResources().merge(node.getMinResources()),_							container.getPreferredResources().merge(node.getPreferredResources()))__					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,container,set,resources,container,get,min,resources,merge,node,get,min,resources,container,get,preferred,resources,merge,node,get,preferred,resources,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1511814440;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}__					_					container.setResources(container.getMinResources().merge(node.getMinResources()),_							container.getPreferredResources().merge(node.getPreferredResources()))__					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,container,set,resources,container,get,min,resources,merge,node,get,min,resources,container,get,preferred,resources,merge,node,get,preferred,resources,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1511890763;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}__					_					container.setResources(container.getMinResources().merge(node.getMinResources()),_							container.getPreferredResources().merge(node.getPreferredResources()))__					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,container,set,resources,container,get,min,resources,merge,node,get,min,resources,container,get,preferred,resources,merge,node,get,preferred,resources,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1518451382;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}__					_					container.setResources(container.getMinResources().merge(node.getMinResources()),_							container.getPreferredResources().merge(node.getPreferredResources()))__					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,container,set,resources,container,get,min,resources,merge,node,get,min,resources,container,get,preferred,resources,merge,node,get,preferred,resources,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1522323145;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}__					_					container.setResources(container.getMinResources().merge(node.getMinResources()),_							container.getPreferredResources().merge(node.getPreferredResources()))__					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,container,set,resources,container,get,min,resources,merge,node,get,min,resources,container,get,preferred,resources,merge,node,get,preferred,resources,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1525420604;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}__					_					container.setResources(container.getMinResources().merge(node.getMinResources()),_							container.getPreferredResources().merge(node.getPreferredResources()))__					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,container,set,resources,container,get,min,resources,merge,node,get,min,resources,container,get,preferred,resources,merge,node,get,preferred,resources,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1529583969;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}__					_					container.setResources(container.getMinResources().merge(node.getMinResources()),_							container.getPreferredResources().merge(node.getPreferredResources()))__					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,container,set,resources,container,get,min,resources,merge,node,get,min,resources,container,get,preferred,resources,merge,node,get,preferred,resources,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> @Override 	public void postVisit(PlanNode node);1547644408;This method implements the post-visit during the depth-first traversal. When the post visit happens,_all of the descendants have been processed, so this method connects all of the current node's_predecessors to the current node.__@param node_The node currently processed during the post-visit._@see org.apache.flink.util.Visitor#postVisit(org.apache.flink.util.Visitable) t;@Override_	public void postVisit(PlanNode node) {_		try {_			_			_			_			_			_			if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode || node instanceof SolutionSetPlanNode) {_				return__			}_			_			_			if (node instanceof IterationPlanNode) {_				_				if (node.isOnDynamicPath()) {_					throw new CompilerException("Nested Iterations are not possible at the moment!")__				}_				_				_				_				if (this.currentIteration != null) {_					this.iterationStack.add(this.currentIteration)__				}_				_				this.currentIteration = (IterationPlanNode) node__				this.currentIteration.acceptForStepFunction(this)__				_				_				if (this.iterationStack.isEmpty()) {_					this.currentIteration = null__				} else {_					this.currentIteration = this.iterationStack.remove(this.iterationStack.size() - 1)__				}_				_				_				_				if (node instanceof WorksetIterationPlanNode) {_					_					WorksetIterationPlanNode wsNode = (WorksetIterationPlanNode) node__					JobVertex headVertex = this.iterations.get(wsNode).getHeadTask()__					TaskConfig headConfig = new TaskConfig(headVertex.getConfiguration())__					int inputIndex = headConfig.getDriverStrategy().getNumInputs()__					headConfig.setIterationHeadSolutionSetInputIndex(inputIndex)__					translateChannel(wsNode.getInitialSolutionSetInput(), inputIndex, headVertex, headConfig, false)__				}_				_				return__			}_			_			final JobVertex targetVertex = this.vertices.get(node)__			_			_			_			_			_			_			_			_			_			if (targetVertex == null) {_				_				_				final TaskInChain chainedTask__				if ((chainedTask = this.chainedTasks.get(node)) != null) {_					_					final Iterator<Channel> inConns = node.getInputs().iterator()__					if (!inConns.hasNext()) {_						throw new CompilerException("Bug: Found chained task with no input.")__					}_					final Channel inConn = inConns.next()__					_					if (inConns.hasNext()) {_						throw new CompilerException("Bug: Found a chained task with more than one input!")__					}_					if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {_						throw new CompilerException("Bug: Found a chained task with an input local strategy.")__					}_					if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {_						throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.")__					}_	_					JobVertex container = chainedTask.getContainingVertex()__					_					if (container == null) {_						final PlanNode sourceNode = inConn.getSource()__						container = this.vertices.get(sourceNode)__						if (container == null) {_							_							container = this.chainedTasks.get(sourceNode).getContainingVertex()__							if (container == null) {_								throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.")__							}_						} else {_							_							new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD)__						}_						chainedTask.setContainingVertex(container)__					}_					_					_					chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(), 0)__					_					_					String containerTaskName = container.getName()__					if (containerTaskName.startsWith("CHAIN ")) {_						container.setName(containerTaskName + " -> " + chainedTask.getTaskName())__					} else {_						container.setName("CHAIN " + containerTaskName + " -> " + chainedTask.getTaskName())__					}__					_					container.setResources(container.getMinResources().merge(node.getMinResources()),_							container.getPreferredResources().merge(node.getPreferredResources()))__					_					this.chainedTasksInSequence.add(chainedTask)__					return__				}_				else if (node instanceof BulkPartialSolutionPlanNode ||_						node instanceof WorksetPlanNode)_				{_					_					return__				} else {_					throw new CompilerException("Bug: Unrecognized merged task vertex.")__				}_			}_			_			_			_			_			if (this.currentIteration != null) {_				JobVertex head = this.iterations.get(this.currentIteration).getHeadTask()__				_				_				if (node.isOnDynamicPath()) {_					targetVertex.setStrictlyCoLocatedWith(head)__				}_			}_			_			_			_			final TaskConfig targetVertexConfig = new TaskConfig(targetVertex.getConfiguration())__						_			_			_			final Iterator<Channel> inConns__			if (node instanceof BulkPartialSolutionPlanNode) {_				inConns = ((BulkPartialSolutionPlanNode) node).getContainingIterationNode().getInputs().iterator()__				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__			} else if (node instanceof WorksetPlanNode) {_				WorksetPlanNode wspn = (WorksetPlanNode) node__				_				inConns = Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator()__				_				_				_				targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0)__				targetVertexConfig.setIterationHeadSolutionSetInputIndex(1)__			} else {_				inConns = node.getInputs().iterator()__			}_			if (!inConns.hasNext()) {_				throw new CompilerException("Bug: Found a non-source task with no input.")__			}_			_			int inputIndex = 0__			while (inConns.hasNext()) {_				Channel input = inConns.next()__				inputIndex += translateChannel(input, inputIndex, targetVertex, targetVertexConfig, false)__			}_			_			int broadcastInputIndex = 0__			for (NamedChannel broadcastInput: node.getBroadcastInputs()) {_				int broadcastInputIndexDelta = translateChannel(broadcastInput, broadcastInputIndex, targetVertex, targetVertexConfig, true)__				targetVertexConfig.setBroadcastInputName(broadcastInput.getName(), broadcastInputIndex)__				targetVertexConfig.setBroadcastInputSerializer(broadcastInput.getSerializer(), broadcastInputIndex)__				broadcastInputIndex += broadcastInputIndexDelta__			}_		} catch (Exception e) {_			throw new CompilerException(_				"An error occurred while translating the optimized plan to a JobGraph: " + e.getMessage(), e)__		}_	};this,method,implements,the,post,visit,during,the,depth,first,traversal,when,the,post,visit,happens,all,of,the,descendants,have,been,processed,so,this,method,connects,all,of,the,current,node,s,predecessors,to,the,current,node,param,node,the,node,currently,processed,during,the,post,visit,see,org,apache,flink,util,visitor,post,visit,org,apache,flink,util,visitable,t;override,public,void,post,visit,plan,node,node,try,if,node,instanceof,source,plan,node,node,instanceof,nary,union,plan,node,node,instanceof,solution,set,plan,node,return,if,node,instanceof,iteration,plan,node,if,node,is,on,dynamic,path,throw,new,compiler,exception,nested,iterations,are,not,possible,at,the,moment,if,this,current,iteration,null,this,iteration,stack,add,this,current,iteration,this,current,iteration,iteration,plan,node,node,this,current,iteration,accept,for,step,function,this,if,this,iteration,stack,is,empty,this,current,iteration,null,else,this,current,iteration,this,iteration,stack,remove,this,iteration,stack,size,1,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,ws,node,workset,iteration,plan,node,node,job,vertex,head,vertex,this,iterations,get,ws,node,get,head,task,task,config,head,config,new,task,config,head,vertex,get,configuration,int,input,index,head,config,get,driver,strategy,get,num,inputs,head,config,set,iteration,head,solution,set,input,index,input,index,translate,channel,ws,node,get,initial,solution,set,input,input,index,head,vertex,head,config,false,return,final,job,vertex,target,vertex,this,vertices,get,node,if,target,vertex,null,final,task,in,chain,chained,task,if,chained,task,this,chained,tasks,get,node,null,final,iterator,channel,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,chained,task,with,no,input,final,channel,in,conn,in,conns,next,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,chained,task,with,more,than,one,input,if,in,conn,get,local,strategy,null,in,conn,get,local,strategy,local,strategy,none,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,local,strategy,if,in,conn,get,ship,strategy,null,in,conn,get,ship,strategy,ship,strategy,type,forward,throw,new,compiler,exception,bug,found,a,chained,task,with,an,input,ship,strategy,other,than,forward,job,vertex,container,chained,task,get,containing,vertex,if,container,null,final,plan,node,source,node,in,conn,get,source,container,this,vertices,get,source,node,if,container,null,container,this,chained,tasks,get,source,node,get,containing,vertex,if,container,null,throw,new,illegal,state,exception,bug,chained,task,predecessor,has,not,been,assigned,its,containing,vertex,else,new,task,config,container,get,configuration,add,output,ship,strategy,ship,strategy,type,forward,chained,task,set,containing,vertex,container,chained,task,get,task,config,set,input,serializer,in,conn,get,serializer,0,string,container,task,name,container,get,name,if,container,task,name,starts,with,chain,container,set,name,container,task,name,chained,task,get,task,name,else,container,set,name,chain,container,task,name,chained,task,get,task,name,container,set,resources,container,get,min,resources,merge,node,get,min,resources,container,get,preferred,resources,merge,node,get,preferred,resources,this,chained,tasks,in,sequence,add,chained,task,return,else,if,node,instanceof,bulk,partial,solution,plan,node,node,instanceof,workset,plan,node,return,else,throw,new,compiler,exception,bug,unrecognized,merged,task,vertex,if,this,current,iteration,null,job,vertex,head,this,iterations,get,this,current,iteration,get,head,task,if,node,is,on,dynamic,path,target,vertex,set,strictly,co,located,with,head,final,task,config,target,vertex,config,new,task,config,target,vertex,get,configuration,final,iterator,channel,in,conns,if,node,instanceof,bulk,partial,solution,plan,node,in,conns,bulk,partial,solution,plan,node,node,get,containing,iteration,node,get,inputs,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,else,if,node,instanceof,workset,plan,node,workset,plan,node,wspn,workset,plan,node,node,in,conns,collections,singleton,wspn,get,containing,iteration,node,get,input2,iterator,target,vertex,config,set,iteration,head,partial,solution,or,workset,input,index,0,target,vertex,config,set,iteration,head,solution,set,input,index,1,else,in,conns,node,get,inputs,iterator,if,in,conns,has,next,throw,new,compiler,exception,bug,found,a,non,source,task,with,no,input,int,input,index,0,while,in,conns,has,next,channel,input,in,conns,next,input,index,translate,channel,input,input,index,target,vertex,target,vertex,config,false,int,broadcast,input,index,0,for,named,channel,broadcast,input,node,get,broadcast,inputs,int,broadcast,input,index,delta,translate,channel,broadcast,input,broadcast,input,index,target,vertex,target,vertex,config,true,target,vertex,config,set,broadcast,input,name,broadcast,input,get,name,broadcast,input,index,target,vertex,config,set,broadcast,input,serializer,broadcast,input,get,serializer,broadcast,input,index,broadcast,input,index,broadcast,input,index,delta,catch,exception,e,throw,new,compiler,exception,an,error,occurred,while,translating,the,optimized,plan,to,a,job,graph,e,get,message,e
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final AbstractJobVertex sourceVertex, final TaskConfig sourceConfig, 			final AbstractJobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1426843274;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@param channel_@param inputNumber_@param sourceVertex_@param sourceConfig_@param targetVertex_@param targetConfig_@param isBroadcast_@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final AbstractJobVertex sourceVertex, final TaskConfig sourceConfig,_			final AbstractJobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,param,channel,param,input,number,param,source,vertex,param,source,config,param,target,vertex,param,target,config,param,is,broadcast,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,abstract,job,vertex,source,vertex,final,task,config,source,config,final,abstract,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final AbstractJobVertex sourceVertex, final TaskConfig sourceConfig, 			final AbstractJobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1427097830;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@param channel_@param inputNumber_@param sourceVertex_@param sourceConfig_@param targetVertex_@param targetConfig_@param isBroadcast_@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final AbstractJobVertex sourceVertex, final TaskConfig sourceConfig,_			final AbstractJobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,param,channel,param,input,number,param,source,vertex,param,source,config,param,target,vertex,param,target,config,param,is,broadcast,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,abstract,job,vertex,source,vertex,final,task,config,source,config,final,abstract,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,return,distribution,pattern
JobGraphGenerator -> private DistributionPattern connectJobVertices(Channel channel, int inputNumber, 			final AbstractJobVertex sourceVertex, final TaskConfig sourceConfig, 			final AbstractJobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast) 	throws CompilerException;1430859396;NOTE: The channel for global and local strategies are different if we connect a union. The global strategy_channel is then the channel into the union node, the local strategy channel the one from the union to the_actual target operator.__@param channel_@param inputNumber_@param sourceVertex_@param sourceConfig_@param targetVertex_@param targetConfig_@param isBroadcast_@throws CompilerException;private DistributionPattern connectJobVertices(Channel channel, int inputNumber,_			final AbstractJobVertex sourceVertex, final TaskConfig sourceConfig,_			final AbstractJobVertex targetVertex, final TaskConfig targetConfig, boolean isBroadcast)_	throws CompilerException_	{_		_		final DistributionPattern distributionPattern___		switch (channel.getShipStrategy()) {_			case FORWARD:_				distributionPattern = DistributionPattern.POINTWISE__				break__			case PARTITION_RANDOM:_			case BROADCAST:_			case PARTITION_HASH:_			case PARTITION_CUSTOM:_			case PARTITION_RANGE:_			case PARTITION_FORCED_REBALANCE:_				distributionPattern = DistributionPattern.ALL_TO_ALL__				break__			default:_				throw new RuntimeException("Unknown runtime ship strategy: " + channel.getShipStrategy())__		}__		final ResultPartitionType resultType___		switch (channel.getDataExchangeMode()) {__			case PIPELINED:_				resultType = ResultPartitionType.PIPELINED__				break___			case BATCH:_				_				_				_				resultType = channel.getSource().isOnDynamicPath()_						? ResultPartitionType.PIPELINED_						: ResultPartitionType.BLOCKING__				break___			case PIPELINE_WITH_BATCH_FALLBACK:_				throw new UnsupportedOperationException("Data exchange mode " +_						channel.getDataExchangeMode() + " currently not supported.")___			default:_				throw new UnsupportedOperationException("Unknown data exchange mode.")___		}__		targetVertex.connectNewDataSetAsInput(sourceVertex, distributionPattern, resultType)___		_		final int outputIndex = sourceConfig.getNumOutputs()__		sourceConfig.addOutputShipStrategy(channel.getShipStrategy())__		if (outputIndex == 0) {_			sourceConfig.setOutputSerializer(channel.getSerializer())__		}_		if (channel.getShipStrategyComparator() != null) {_			sourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex)__		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {_			_			final DataDistribution dataDistribution = channel.getDataDistribution()__			if (dataDistribution != null) {_				sourceConfig.setOutputDataDistribution(dataDistribution, outputIndex)__			} else {_				throw new RuntimeException("Range partitioning requires data distribution")__				_			}_		}_		_		if (channel.getShipStrategy() == ShipStrategyType.PARTITION_CUSTOM) {_			if (channel.getPartitioner() != null) {_				sourceConfig.setOutputPartitioner(channel.getPartitioner(), outputIndex)__			} else {_				throw new CompilerException("The ship strategy was set to custom partitioning, but no partitioner was set.")__			}_		}_		_		_		if (isBroadcast) {_			targetConfig.addBroadcastInputToGroup(inputNumber)__		} else {_			targetConfig.addInputToGroup(inputNumber)__		}_		return distributionPattern__	};note,the,channel,for,global,and,local,strategies,are,different,if,we,connect,a,union,the,global,strategy,channel,is,then,the,channel,into,the,union,node,the,local,strategy,channel,the,one,from,the,union,to,the,actual,target,operator,param,channel,param,input,number,param,source,vertex,param,source,config,param,target,vertex,param,target,config,param,is,broadcast,throws,compiler,exception;private,distribution,pattern,connect,job,vertices,channel,channel,int,input,number,final,abstract,job,vertex,source,vertex,final,task,config,source,config,final,abstract,job,vertex,target,vertex,final,task,config,target,config,boolean,is,broadcast,throws,compiler,exception,final,distribution,pattern,distribution,pattern,switch,channel,get,ship,strategy,case,forward,distribution,pattern,distribution,pattern,pointwise,break,case,case,broadcast,case,case,case,case,distribution,pattern,distribution,pattern,break,default,throw,new,runtime,exception,unknown,runtime,ship,strategy,channel,get,ship,strategy,final,result,partition,type,result,type,switch,channel,get,data,exchange,mode,case,pipelined,result,type,result,partition,type,pipelined,break,case,batch,result,type,channel,get,source,is,on,dynamic,path,result,partition,type,pipelined,result,partition,type,blocking,break,case,throw,new,unsupported,operation,exception,data,exchange,mode,channel,get,data,exchange,mode,currently,not,supported,default,throw,new,unsupported,operation,exception,unknown,data,exchange,mode,target,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,type,final,int,output,index,source,config,get,num,outputs,source,config,add,output,ship,strategy,channel,get,ship,strategy,if,output,index,0,source,config,set,output,serializer,channel,get,serializer,if,channel,get,ship,strategy,comparator,null,source,config,set,output,comparator,channel,get,ship,strategy,comparator,output,index,if,channel,get,ship,strategy,ship,strategy,type,final,data,distribution,data,distribution,channel,get,data,distribution,if,data,distribution,null,source,config,set,output,data,distribution,data,distribution,output,index,else,throw,new,runtime,exception,range,partitioning,requires,data,distribution,if,channel,get,ship,strategy,ship,strategy,type,if,channel,get,partitioner,null,source,config,set,output,partitioner,channel,get,partitioner,output,index,else,throw,new,compiler,exception,the,ship,strategy,was,set,to,custom,partitioning,but,no,partitioner,was,set,if,is,broadcast,target,config,add,broadcast,input,to,group,input,number,else,target,config,add,input,to,group,input,number,return,distribution,pattern
JobGraphGenerator -> public JobGraphGenerator();1426843274;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1427097830;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1430859396;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1434467925;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1434490608;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1437494294;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1438872996;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1440151741;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1442492509;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1442944546;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1444144446;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1444215406;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1445427423;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1448400254;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1450712612;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1455548285;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1457737669;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1459526979;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1463155298;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants
JobGraphGenerator -> public JobGraphGenerator();1466529056;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1469630409;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1477046030;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1487548883;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1487616195;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1489060856;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1489149057;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1489671807;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1509447226;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1511814440;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1511890763;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = ConfigConstants.DEFAULT_SPILLING_MAX_FAN__		this.defaultSortSpillingThreshold = ConfigConstants.DEFAULT_SORT_SPILLING_THRESHOLD__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,config,constants,this,default,sort,spilling,threshold,config,constants,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1518451382;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = AlgorithmOptions.SPILLING_MAX_FAN.defaultValue()__		this.defaultSortSpillingThreshold = AlgorithmOptions.SORT_SPILLING_THRESHOLD.defaultValue()__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,algorithm,options,default,value,this,default,sort,spilling,threshold,algorithm,options,default,value,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1522323145;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = AlgorithmOptions.SPILLING_MAX_FAN.defaultValue()__		this.defaultSortSpillingThreshold = AlgorithmOptions.SORT_SPILLING_THRESHOLD.defaultValue()__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,algorithm,options,default,value,this,default,sort,spilling,threshold,algorithm,options,default,value,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1525420604;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = AlgorithmOptions.SPILLING_MAX_FAN.defaultValue()__		this.defaultSortSpillingThreshold = AlgorithmOptions.SORT_SPILLING_THRESHOLD.defaultValue()__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,algorithm,options,default,value,this,default,sort,spilling,threshold,algorithm,options,default,value,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1529583969;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = AlgorithmOptions.SPILLING_MAX_FAN.defaultValue()__		this.defaultSortSpillingThreshold = AlgorithmOptions.SORT_SPILLING_THRESHOLD.defaultValue()__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,algorithm,options,default,value,this,default,sort,spilling,threshold,algorithm,options,default,value,this,use,large,record,handler,config,constants
JobGraphGenerator -> public JobGraphGenerator();1547644408;Creates a new job graph generator that uses the default values for its resource configuration.;public JobGraphGenerator() {_		this.defaultMaxFan = AlgorithmOptions.SPILLING_MAX_FAN.defaultValue()__		this.defaultSortSpillingThreshold = AlgorithmOptions.SORT_SPILLING_THRESHOLD.defaultValue()__		this.useLargeRecordHandler = ConfigConstants.DEFAULT_USE_LARGE_RECORD_HANDLER__	};creates,a,new,job,graph,generator,that,uses,the,default,values,for,its,resource,configuration;public,job,graph,generator,this,default,max,fan,algorithm,options,default,value,this,default,sort,spilling,threshold,algorithm,options,default,value,this,use,large,record,handler,config,constants
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1426843274;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final AbstractJobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different degree of parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different degree of parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different degree of parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					AbstractJobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(MatchDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, degree-of-parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,abstract,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,degree,of,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,degree,of,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,degree,of,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,abstract,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,match,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,degree,of,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1427097830;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final AbstractJobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					AbstractJobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(MatchDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,abstract,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,abstract,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,match,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1430859396;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final AbstractJobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					AbstractJobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(MatchDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,abstract,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,abstract,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,match,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1434467925;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(MatchDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,match,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1434490608;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(MatchDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,match,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1437494294;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(MatchDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,match,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1438872996;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1440151741;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1442492509;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1442944546;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1444144446;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1444215406;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1445427423;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1448400254;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1450712612;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1455548285;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1457737669;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1459526979;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1463155298;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1466529056;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1469630409;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1477046030;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1487548883;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1487616195;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1489060856;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1489149057;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			vertex.setMaxParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,max,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1489671807;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			vertex.setMaxParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,max,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1509447226;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			vertex.setMaxParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,max,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1511814440;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			vertex.setMaxParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,max,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1511890763;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			vertex.setMaxParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,max,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1518451382;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			vertex.setMaxParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,max,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1522323145;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			vertex.setMaxParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,max,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1525420604;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			vertex.setMaxParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,max,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1529583969;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			vertex.setMaxParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,max,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
JobGraphGenerator -> @Override 	public boolean preVisit(PlanNode node);1547644408;This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and_sets local strategy.__@param node_The node that is currently processed._@return True, if the visitor should descend to the node's children, false if not._@see org.apache.flink.util.Visitor#preVisit(org.apache.flink.util.Visitable);@Override_	public boolean preVisit(PlanNode node) {_		_		if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {_			_			return false__		}__		_		final JobVertex vertex__		try {_			if (node instanceof SinkPlanNode) {_				vertex = createDataSinkVertex((SinkPlanNode) node)__			}_			else if (node instanceof SourcePlanNode) {_				vertex = createDataSourceVertex((SourcePlanNode) node)__			}_			else if (node instanceof BulkIterationPlanNode) {_				BulkIterationPlanNode iterationNode = (BulkIterationPlanNode) node__				_				_				_				_				_				_				_				PlanNode root = iterationNode.getRootOfStepFunction()__				if (root.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("Error: The final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof WorksetIterationPlanNode) {_				WorksetIterationPlanNode iterationNode = (WorksetIterationPlanNode) node___				_				PlanNode nextWorkSet = iterationNode.getNextWorkSetPlanNode()__				PlanNode solutionSetDelta  = iterationNode.getSolutionSetDeltaPlanNode()__				_				if (nextWorkSet.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				if (solutionSetDelta.getParallelism() != node.getParallelism())_				{_					throw new CompilerException("It is currently not supported that the final operator of the step " +_							"function has a different parallelism than the iteration operator itself.")__				}_				_				IterationDescriptor descr = new IterationDescriptor(iterationNode, this.iterationIdEnumerator++)__				this.iterations.put(iterationNode, descr)__				vertex = null__			}_			else if (node instanceof SingleInputPlanNode) {_				vertex = createSingleInputVertex((SingleInputPlanNode) node)__			}_			else if (node instanceof DualInputPlanNode) {_				vertex = createDualInputVertex((DualInputPlanNode) node)__			}_			else if (node instanceof NAryUnionPlanNode) {_				_				vertex = null__			}_			else if (node instanceof BulkPartialSolutionPlanNode) {_				_				vertex = createBulkIterationHead((BulkPartialSolutionPlanNode) node)__			}_			else if (node instanceof SolutionSetPlanNode) {_				_				_				_				_				for (Channel c : node.getOutgoingChannels()) {_					DualInputPlanNode target = (DualInputPlanNode) c.getTarget()__					JobVertex accessingVertex = this.vertices.get(target)__					TaskConfig conf = new TaskConfig(accessingVertex.getConfiguration())__					int inputNum = c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1__					_					_					if (inputNum == -1) {_						throw new CompilerException()__					}_					_					_					if (conf.getDriver().equals(JoinDriver.class)) {_						conf.setDriver(inputNum == 0 ? JoinWithSolutionSetFirstDriver.class : JoinWithSolutionSetSecondDriver.class)__					}_					else if (conf.getDriver().equals(CoGroupDriver.class)) {_						conf.setDriver(inputNum == 0 ? CoGroupWithSolutionSetFirstDriver.class : CoGroupWithSolutionSetSecondDriver.class)__					}_					else {_						throw new CompilerException("Found join with solution set using incompatible operator (only Join/CoGroup are valid).")__					}_				}_				_				_				this.chainedTasks.put(node, ALREADY_VISITED_PLACEHOLDER)__				_				vertex = null__			}_			else if (node instanceof WorksetPlanNode) {_				_				vertex = createWorksetIterationHead((WorksetPlanNode) node)__			}_			else {_				throw new CompilerException("Unrecognized node type: " + node.getClass().getName())__			}_		}_		catch (Exception e) {_			throw new CompilerException("Error translating node '" + node + "': " + e.getMessage(), e)__		}_		_		_		if (vertex != null) {_			_			int pd = node.getParallelism()__			vertex.setParallelism(pd)__			vertex.setMaxParallelism(pd)__			_			vertex.setSlotSharingGroup(sharingGroup)__			_			_			if (this.currentIteration != null) {_				_				PlanNode iterationNode = (PlanNode) this.currentIteration__				if (iterationNode.getParallelism() < pd) {_					throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, parallelism than the iteration operator.")__				}__				_				IterationDescriptor descr = this.iterations.get(this.currentIteration)__				new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId())__			}_	_			_			this.vertices.put(node, vertex)__		}__		_		return true__	};this,methods,implements,the,pre,visiting,during,a,depth,first,traversal,it,create,the,job,vertex,and,sets,local,strategy,param,node,the,node,that,is,currently,processed,return,true,if,the,visitor,should,descend,to,the,node,s,children,false,if,not,see,org,apache,flink,util,visitor,pre,visit,org,apache,flink,util,visitable;override,public,boolean,pre,visit,plan,node,node,if,this,vertices,contains,key,node,this,chained,tasks,contains,key,node,this,iterations,contains,key,node,return,false,final,job,vertex,vertex,try,if,node,instanceof,sink,plan,node,vertex,create,data,sink,vertex,sink,plan,node,node,else,if,node,instanceof,source,plan,node,vertex,create,data,source,vertex,source,plan,node,node,else,if,node,instanceof,bulk,iteration,plan,node,bulk,iteration,plan,node,iteration,node,bulk,iteration,plan,node,node,plan,node,root,iteration,node,get,root,of,step,function,if,root,get,parallelism,node,get,parallelism,throw,new,compiler,exception,error,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,workset,iteration,plan,node,workset,iteration,plan,node,iteration,node,workset,iteration,plan,node,node,plan,node,next,work,set,iteration,node,get,next,work,set,plan,node,plan,node,solution,set,delta,iteration,node,get,solution,set,delta,plan,node,if,next,work,set,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,if,solution,set,delta,get,parallelism,node,get,parallelism,throw,new,compiler,exception,it,is,currently,not,supported,that,the,final,operator,of,the,step,function,has,a,different,parallelism,than,the,iteration,operator,itself,iteration,descriptor,descr,new,iteration,descriptor,iteration,node,this,iteration,id,enumerator,this,iterations,put,iteration,node,descr,vertex,null,else,if,node,instanceof,single,input,plan,node,vertex,create,single,input,vertex,single,input,plan,node,node,else,if,node,instanceof,dual,input,plan,node,vertex,create,dual,input,vertex,dual,input,plan,node,node,else,if,node,instanceof,nary,union,plan,node,vertex,null,else,if,node,instanceof,bulk,partial,solution,plan,node,vertex,create,bulk,iteration,head,bulk,partial,solution,plan,node,node,else,if,node,instanceof,solution,set,plan,node,for,channel,c,node,get,outgoing,channels,dual,input,plan,node,target,dual,input,plan,node,c,get,target,job,vertex,accessing,vertex,this,vertices,get,target,task,config,conf,new,task,config,accessing,vertex,get,configuration,int,input,num,c,target,get,input1,0,c,target,get,input2,1,1,if,input,num,1,throw,new,compiler,exception,if,conf,get,driver,equals,join,driver,class,conf,set,driver,input,num,0,join,with,solution,set,first,driver,class,join,with,solution,set,second,driver,class,else,if,conf,get,driver,equals,co,group,driver,class,conf,set,driver,input,num,0,co,group,with,solution,set,first,driver,class,co,group,with,solution,set,second,driver,class,else,throw,new,compiler,exception,found,join,with,solution,set,using,incompatible,operator,only,join,co,group,are,valid,this,chained,tasks,put,node,vertex,null,else,if,node,instanceof,workset,plan,node,vertex,create,workset,iteration,head,workset,plan,node,node,else,throw,new,compiler,exception,unrecognized,node,type,node,get,class,get,name,catch,exception,e,throw,new,compiler,exception,error,translating,node,node,e,get,message,e,if,vertex,null,int,pd,node,get,parallelism,vertex,set,parallelism,pd,vertex,set,max,parallelism,pd,vertex,set,slot,sharing,group,sharing,group,if,this,current,iteration,null,plan,node,iteration,node,plan,node,this,current,iteration,if,iteration,node,get,parallelism,pd,throw,new,compiler,exception,error,all,functions,that,are,part,of,an,iteration,must,have,the,same,or,a,lower,parallelism,than,the,iteration,operator,iteration,descriptor,descr,this,iterations,get,this,current,iteration,new,task,config,vertex,get,configuration,set,iteration,id,descr,get,id,this,vertices,put,node,vertex,return,true
