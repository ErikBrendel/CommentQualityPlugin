commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;// -------------------------------------------------------------------------------------------- public BulkIterationNode getIterationNode() {     if (this.template instanceof BulkIterationNode) {         return (BulkIterationNode) this.template.     } else {         throw new RuntimeException().     } }
false;public;0;3;;public BulkPartialSolutionPlanNode getPartialSolutionPlanNode() {     return this.partialSolutionPlanNode. }
false;public;0;3;;public PlanNode getRootOfStepFunction() {     return this.rootOfStepFunction. }
false;public;0;3;;public PlanNode getRootOfTerminationCriterion() {     return this.rootOfTerminationCriterion. }
false;public;0;3;;// -------------------------------------------------------------------------------------------- public TypeSerializerFactory<?> getSerializerForIterationChannel() {     return serializerForIterationChannel. }
false;public;1;3;;public void setSerializerForIterationChannel(TypeSerializerFactory<?> serializerForIterationChannel) {     this.serializerForIterationChannel = serializerForIterationChannel. }
false;public;1;12;;public void setCosts(Costs nodeCosts) {     // add the costs from the step function     nodeCosts.addCosts(this.rootOfStepFunction.getCumulativeCosts()).     // the costs are divided at branches, so we can simply add them up     if (rootOfTerminationCriterion != null) {         nodeCosts.addCosts(this.rootOfTerminationCriterion.getCumulativeCosts()).     }     super.setCosts(nodeCosts). }
false;public;0;3;;public int getMemoryConsumerWeight() {     return 1. }
false;public;1;19;;@Override public SourceAndDamReport hasDamOnPathDownTo(PlanNode source) {     if (source == this) {         return FOUND_SOURCE.     }     SourceAndDamReport fromOutside = super.hasDamOnPathDownTo(source).     if (fromOutside == FOUND_SOURCE_AND_DAM) {         return FOUND_SOURCE_AND_DAM.     } else if (fromOutside == FOUND_SOURCE) {         // we always have a dam in the back channel         return FOUND_SOURCE_AND_DAM.     } else {         // check the step function for dams         return this.rootOfStepFunction.hasDamOnPathDownTo(source).     } }
false;public;1;8;;@Override public void acceptForStepFunction(Visitor<PlanNode> visitor) {     this.rootOfStepFunction.accept(visitor).     if (this.rootOfTerminationCriterion != null) {         this.rootOfTerminationCriterion.accept(visitor).     } }
false;private;0;24;;private void mergeBranchPlanMaps() {     for (OptimizerNode.UnclosedBranchDescriptor desc : template.getOpenBranches()) {         OptimizerNode brancher = desc.getBranchingNode().         if (branchPlan == null) {             branchPlan = new HashMap<OptimizerNode, PlanNode>(6).         }         if (!branchPlan.containsKey(brancher)) {             PlanNode selectedCandidate = null.             if (rootOfStepFunction.branchPlan != null) {                 selectedCandidate = rootOfStepFunction.branchPlan.get(brancher).             }             if (selectedCandidate == null) {                 throw new CompilerException("Candidates for a node with open branches are missing information about the selected candidate ").             }             this.branchPlan.put(brancher, selectedCandidate).         }     } }
