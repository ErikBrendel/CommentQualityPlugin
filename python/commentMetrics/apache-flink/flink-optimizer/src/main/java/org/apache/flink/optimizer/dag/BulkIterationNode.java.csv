commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// -------------------------------------------------------------------------------------------- public BulkIterationBase<?> getIterationContract() {     return (BulkIterationBase<?>) getOperator(). }
true;public;0;3;/**  * Gets the partialSolution from this BulkIterationNode.  *  * @return The partialSolution.  */ ;/**  * Gets the partialSolution from this BulkIterationNode.  *  * @return The partialSolution.  */ public BulkPartialSolutionNode getPartialSolution() {     return partialSolution. }
true;public;1;3;/**  * Sets the partialSolution for this BulkIterationNode.  *  * @param partialSolution The partialSolution to set.  */ ;/**  * Sets the partialSolution for this BulkIterationNode.  *  * @param partialSolution The partialSolution to set.  */ public void setPartialSolution(BulkPartialSolutionNode partialSolution) {     this.partialSolution = partialSolution. }
true;public;0;3;/**  * Gets the nextPartialSolution from this BulkIterationNode.  *  * @return The nextPartialSolution.  */ ;/**  * Gets the nextPartialSolution from this BulkIterationNode.  *  * @return The nextPartialSolution.  */ public OptimizerNode getNextPartialSolution() {     return nextPartialSolution. }
true;public;2;43;/**  * Sets the nextPartialSolution for this BulkIterationNode.  *  * @param nextPartialSolution The nextPartialSolution to set.  */ ;/**  * Sets the nextPartialSolution for this BulkIterationNode.  *  * @param nextPartialSolution The nextPartialSolution to set.  */ public void setNextPartialSolution(OptimizerNode nextPartialSolution, OptimizerNode terminationCriterion) {     // or if the step function has any operator at all     if (nextPartialSolution.getParallelism() != getParallelism() || nextPartialSolution == partialSolution || nextPartialSolution instanceof BinaryUnionNode) {         // add a no-op to the root to express the re-partitioning         NoOpNode noop = new NoOpNode().         noop.setParallelism(getParallelism()).         DagConnection noOpConn = new DagConnection(nextPartialSolution, noop, ExecutionMode.PIPELINED).         noop.setIncomingConnection(noOpConn).         nextPartialSolution.addOutgoingConnection(noOpConn).         nextPartialSolution = noop.     }     this.nextPartialSolution = nextPartialSolution.     this.terminationCriterion = terminationCriterion.     if (terminationCriterion == null) {         this.singleRoot = nextPartialSolution.         this.rootConnection = new DagConnection(nextPartialSolution, ExecutionMode.PIPELINED).     } else {         // we have a termination criterion         SingleRootJoiner singleRootJoiner = new SingleRootJoiner().         this.rootConnection = new DagConnection(nextPartialSolution, singleRootJoiner, ExecutionMode.PIPELINED).         this.terminationCriterionRootConnection = new DagConnection(terminationCriterion, singleRootJoiner, ExecutionMode.PIPELINED).         singleRootJoiner.setInputs(this.rootConnection, this.terminationCriterionRootConnection).         this.singleRoot = singleRootJoiner.         // add connection to terminationCriterion for interesting properties visitor         terminationCriterion.addOutgoingConnection(terminationCriterionRootConnection).     }     nextPartialSolution.addOutgoingConnection(rootConnection). }
false;public;0;3;;public int getCostWeight() {     return this.costWeight. }
false;public;0;3;;public OptimizerNode getSingleRootOfStepFunction() {     return this.singleRoot. }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public String getOperatorName() {     return "Bulk Iteration". }
false;public;0;4;;@Override public SemanticProperties getSemanticProperties() {     return new EmptySemanticProperties(). }
false;protected;0;1;;protected void readStubAnnotations() { }
false;protected;1;5;;@Override protected void computeOperatorSpecificDefaultEstimates(DataStatistics statistics) {     this.estimatedOutputSize = getPredecessorNode().getEstimatedOutputSize().     this.estimatedNumRecords = getPredecessorNode().getEstimatedNumRecords(). }
false;protected;0;3;;// -------------------------------------------------------------------------------------------- // Properties and Optimization // -------------------------------------------------------------------------------------------- protected List<OperatorDescriptorSingle> getPossibleProperties() {     return Collections.<OperatorDescriptorSingle>singletonList(new NoOpDescriptor()). }
false;public;1;41;;@Override public void computeInterestingPropertiesForInputs(CostEstimator estimator) {     final InterestingProperties intProps = getInterestingProperties().clone().     if (this.terminationCriterion != null) {         // first propagate through termination Criterion. since it has no successors, it has no         // interesting properties         this.terminationCriterionRootConnection.setInterestingProperties(new InterestingProperties()).         this.terminationCriterion.accept(new InterestingPropertyVisitor(estimator)).     }     // we need to make 2 interesting property passes, because the root of the step function needs also     // the interesting properties as generated by the partial solution     // give our own interesting properties (as generated by the iterations successors) to the step function and     // make the first pass     this.rootConnection.setInterestingProperties(intProps).     this.nextPartialSolution.accept(new InterestingPropertyVisitor(estimator)).     // take the interesting properties of the partial solution and add them to the root interesting properties     InterestingProperties partialSolutionIntProps = this.partialSolution.getInterestingProperties().     intProps.getGlobalProperties().addAll(partialSolutionIntProps.getGlobalProperties()).     intProps.getLocalProperties().addAll(partialSolutionIntProps.getLocalProperties()).     // clear all interesting properties to prepare the second traversal     // this clears only the path down from the next partial solution. The paths down     // from the termination criterion (before they meet the paths down from the next partial solution)     // remain unaffected by this step     this.rootConnection.clearInterestingProperties().     this.nextPartialSolution.accept(InterestingPropertiesClearer.INSTANCE).     // 2nd pass     this.rootConnection.setInterestingProperties(intProps).     this.nextPartialSolution.accept(new InterestingPropertyVisitor(estimator)).     // now add the interesting properties of the partial solution to the input     final InterestingProperties inProps = this.partialSolution.getInterestingProperties().clone().     inProps.addGlobalProperties(new RequestedGlobalProperties()).     inProps.addLocalProperties(new RequestedLocalProperties()).     this.inConn.setInterestingProperties(inProps). }
false;public;0;7;;@Override public void clearInterestingProperties() {     super.clearInterestingProperties().     this.singleRoot.accept(InterestingPropertiesClearer.INSTANCE).     this.rootConnection.clearInterestingProperties(). }
false;public;0;13;;@Override public void computeUnclosedBranchStack() {     if (this.openBranches != null) {         return.     }     // the resulting branches are those of the step function     // because the BulkPartialSolution takes the input's branches     addClosedBranches(getSingleRootOfStepFunction().closedBranchingNodes).     List<UnclosedBranchDescriptor> result = getSingleRootOfStepFunction().openBranches.     this.openBranches = (result == null || result.isEmpty()) ? Collections.<UnclosedBranchDescriptor>emptyList() : result. }
false;protected;7;110;;@SuppressWarnings("unchecked") @Override protected void instantiateCandidate(OperatorDescriptorSingle dps, Channel in, List<Set<? extends NamedChannel>> broadcastPlanChannels, List<PlanNode> target, CostEstimator estimator, RequestedGlobalProperties globPropsReq, RequestedLocalProperties locPropsReq) {     // NOTES ON THE ENUMERATION OF THE STEP FUNCTION PLANS:     // Whenever we instantiate the iteration, we enumerate new candidates for the step function.     // That way, we make sure we have an appropriate plan for each candidate for the initial partial solution,     // we have a fitting candidate for the step function (often, work is pushed out of the step function).     // Among the candidates of the step function, we keep only those that meet the requested properties of the     // current candidate initial partial solution. That makes sure these properties exist at the beginning of     // the successive iteration.     // 1) Because we enumerate multiple times, we may need to clean the cached plans     // before starting another enumeration     this.nextPartialSolution.accept(PlanCacheCleaner.INSTANCE).     if (this.terminationCriterion != null) {         this.terminationCriterion.accept(PlanCacheCleaner.INSTANCE).     }     // 2) Give the partial solution the properties of the current candidate for the initial partial solution     this.partialSolution.setCandidateProperties(in.getGlobalProperties(), in.getLocalProperties(), in).     final BulkPartialSolutionPlanNode pspn = this.partialSolution.getCurrentPartialSolutionPlanNode().     // 3) Get the alternative plans     List<PlanNode> candidates = this.nextPartialSolution.getAlternativePlans(estimator).     // 4) Make sure that the beginning of the step function does not assume properties that     // are not also produced by the end of the step function.     {         List<PlanNode> newCandidates = new ArrayList<PlanNode>().         for (Iterator<PlanNode> planDeleter = candidates.iterator(). planDeleter.hasNext(). ) {             PlanNode candidate = planDeleter.next().             GlobalProperties atEndGlobal = candidate.getGlobalProperties().             LocalProperties atEndLocal = candidate.getLocalProperties().             FeedbackPropertiesMeetRequirementsReport report = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobal, atEndLocal).             if (report == FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION) {             // depends only through broadcast variable on the partial solution             } else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {                 // attach a no-op node through which we create the properties of the original input                 Channel toNoOp = new Channel(candidate).                 globPropsReq.parameterizeChannel(toNoOp, false, rootConnection.getDataExchangeMode(), false).                 locPropsReq.parameterizeChannel(toNoOp).                 NoOpUnaryUdfOp noOpUnaryUdfOp = new NoOpUnaryUdfOp<>().                 noOpUnaryUdfOp.setInput(candidate.getProgramOperator()).                 UnaryOperatorNode rebuildPropertiesNode = new UnaryOperatorNode("Rebuild Partial Solution Properties", noOpUnaryUdfOp, true).                 rebuildPropertiesNode.setParallelism(candidate.getParallelism()).                 SingleInputPlanNode rebuildPropertiesPlanNode = new SingleInputPlanNode(rebuildPropertiesNode, "Rebuild Partial Solution Properties", toNoOp, DriverStrategy.UNARY_NO_OP).                 rebuildPropertiesPlanNode.initProperties(toNoOp.getGlobalProperties(), toNoOp.getLocalProperties()).                 estimator.costOperator(rebuildPropertiesPlanNode).                 GlobalProperties atEndGlobalModified = rebuildPropertiesPlanNode.getGlobalProperties().                 LocalProperties atEndLocalModified = rebuildPropertiesPlanNode.getLocalProperties().                 if (!(atEndGlobalModified.equals(atEndGlobal) && atEndLocalModified.equals(atEndLocal))) {                     FeedbackPropertiesMeetRequirementsReport report2 = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobalModified, atEndLocalModified).                     if (report2 != FeedbackPropertiesMeetRequirementsReport.NOT_MET) {                         newCandidates.add(rebuildPropertiesPlanNode).                     }                 }                 planDeleter.remove().             }         }         candidates.addAll(newCandidates).     }     if (candidates.isEmpty()) {         return.     }     // 5) Create a candidate for the Iteration Node for every remaining plan of the step function.     if (terminationCriterion == null) {         for (PlanNode candidate : candidates) {             BulkIterationPlanNode node = new BulkIterationPlanNode(this, this.getOperator().getName(), in, pspn, candidate).             GlobalProperties gProps = candidate.getGlobalProperties().clone().             LocalProperties lProps = candidate.getLocalProperties().clone().             node.initProperties(gProps, lProps).             target.add(node).         }     } else if (candidates.size() > 0) {         List<PlanNode> terminationCriterionCandidates = this.terminationCriterion.getAlternativePlans(estimator).         SingleRootJoiner singleRoot = (SingleRootJoiner) this.singleRoot.         for (PlanNode candidate : candidates) {             for (PlanNode terminationCandidate : terminationCriterionCandidates) {                 if (singleRoot.areBranchCompatible(candidate, terminationCandidate)) {                     BulkIterationPlanNode node = new BulkIterationPlanNode(this, "BulkIteration (" + this.getOperator().getName() + ")", in, pspn, candidate, terminationCandidate).                     GlobalProperties gProps = candidate.getGlobalProperties().clone().                     LocalProperties lProps = candidate.getLocalProperties().clone().                     node.initProperties(gProps, lProps).                     target.add(node).                 }             }         }     } }
false;public;1;3;;// -------------------------------------------------------------------------------------------- // Iteration Specific Traversals // -------------------------------------------------------------------------------------------- public void acceptForStepFunction(Visitor<OptimizerNode> visitor) {     this.singleRoot.accept(visitor). }
