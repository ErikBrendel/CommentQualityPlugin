commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Gets the operator for this CoGroup node.  *  * @return The CoGroup operator.  */ ;// -------------------------------------------------------------------------------------------- /**  * Gets the operator for this CoGroup node.  *  * @return The CoGroup operator.  */ @Override public CoGroupOperatorBase<?, ?, ?, ?> getOperator() {     return (CoGroupOperatorBase<?, ?, ?, ?>) super.getOperator(). }
false;public;0;4;;@Override public String getOperatorName() {     return "CoGroup". }
false;protected;0;4;;@Override protected List<OperatorDescriptorDual> getPossibleProperties() {     return this.dataProperties. }
false;public;1;11;;public void makeCoGroupWithSolutionSet(int solutionsetInputIndex) {     OperatorDescriptorDual op.     if (solutionsetInputIndex == 0) {         op = new CoGroupWithSolutionSetFirstDescriptor(keys1, keys2).     } else if (solutionsetInputIndex == 1) {         op = new CoGroupWithSolutionSetSecondDescriptor(keys1, keys2).     } else {         throw new IllegalArgumentException().     }     this.dataProperties = Collections.<OperatorDescriptorDual>singletonList(op). }
false;protected;0;34;;@Override protected SemanticProperties getSemanticPropertiesForLocalPropertyFiltering() {     // Local properties for CoGroup may only be preserved on key fields.     DualInputSemanticProperties origProps = ((DualInputOperator<?, ?, ?, ?>) getOperator()).getSemanticProperties().     DualInputSemanticProperties filteredProps = new DualInputSemanticProperties().     FieldSet readSet1 = origProps.getReadFields(0).     FieldSet readSet2 = origProps.getReadFields(1).     if (readSet1 != null) {         filteredProps.addReadFields(0, readSet1).     }     if (readSet2 != null) {         filteredProps.addReadFields(1, readSet2).     }     // preserve only key fields (first input)     for (int f : this.keys1) {         FieldSet targets = origProps.getForwardingTargetFields(0, f).         for (int t : targets) {             filteredProps.addForwardedField(0, f, t).         }     }     // preserve only key fields (second input)     for (int f : this.keys2) {         FieldSet targets = origProps.getForwardingTargetFields(1, f).         for (int t : targets) {             filteredProps.addForwardedField(1, f, t).         }     }     return filteredProps. }
false;protected;1;4;;@Override protected void computeOperatorSpecificDefaultEstimates(DataStatistics statistics) { // for CoGroup, we currently make no reasonable default estimates }
false;private;1;22;;private List<OperatorDescriptorDual> initializeDataProperties(Partitioner<?> customPartitioner) {     Ordering groupOrder1 = null.     Ordering groupOrder2 = null.     CoGroupOperatorBase<?, ?, ?, ?> cgc = getOperator().     groupOrder1 = cgc.getGroupOrderForInputOne().     groupOrder2 = cgc.getGroupOrderForInputTwo().     if (groupOrder1 != null && groupOrder1.getNumberOfFields() == 0) {         groupOrder1 = null.     }     if (groupOrder2 != null && groupOrder2.getNumberOfFields() == 0) {         groupOrder2 = null.     }     CoGroupDescriptor descr = new CoGroupDescriptor(this.keys1, this.keys2, groupOrder1, groupOrder2).     if (customPartitioner != null) {         descr.setCustomPartitioner(customPartitioner).     }     return Collections.<OperatorDescriptorDual>singletonList(descr). }
