commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;// -------------------------------------------------------------------------------------------- protected void copyEstimates(OptimizerNode node) {     this.estimatedNumRecords = node.estimatedNumRecords.     this.estimatedOutputSize = node.estimatedOutputSize. }
false;public,abstract;0;1;;public abstract IterationNode getIterationNode().
false;public;0;3;;// -------------------------------------------------------------------------------------------- public boolean isOnDynamicPath() {     return true. }
false;public;1;4;;public void identifyDynamicPath(int costWeight) {     this.onDynamicPath = true.     this.costWeight = costWeight. }
false;public;0;4;;@Override public List<DagConnection> getIncomingConnections() {     return Collections.emptyList(). }
false;public;2;2;;@Override public void setInput(Map<Operator<?>, OptimizerNode> contractToNode, ExecutionMode dataExchangeMode) { }
false;protected;1;4;;@Override protected void computeOperatorSpecificDefaultEstimates(DataStatistics statistics) { // we do nothing here, because the estimates can only be copied from the iteration input }
false;public;1;4;;@Override public void computeInterestingPropertiesForInputs(CostEstimator estimator) { // no children, so nothing to compute }
false;public;1;8;;@Override public List<PlanNode> getAlternativePlans(CostEstimator estimator) {     if (this.cachedPlans != null) {         return this.cachedPlans.     } else {         throw new IllegalStateException().     } }
false;public;0;4;;@Override public SemanticProperties getSemanticProperties() {     return new EmptySemanticProperties(). }
false;protected;0;2;;@Override protected void readStubAnnotations() { }
false;public;1;6;;@Override public void accept(Visitor<OptimizerNode> visitor) {     if (visitor.preVisit(this)) {         visitor.postVisit(this).     } }
