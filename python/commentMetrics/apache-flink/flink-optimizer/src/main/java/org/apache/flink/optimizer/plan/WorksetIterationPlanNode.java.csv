commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;// -------------------------------------------------------------------------------------------- public WorksetIterationNode getIterationNode() {     if (this.template instanceof WorksetIterationNode) {         return (WorksetIterationNode) this.template.     } else {         throw new RuntimeException().     } }
false;public;0;3;;public SolutionSetPlanNode getSolutionSetPlanNode() {     return this.solutionSetPlanNode. }
false;public;0;3;;public WorksetPlanNode getWorksetPlanNode() {     return this.worksetPlanNode. }
false;public;0;3;;public PlanNode getSolutionSetDeltaPlanNode() {     return this.solutionSetDeltaPlanNode. }
false;public;0;3;;public PlanNode getNextWorkSetPlanNode() {     return this.nextWorkSetPlanNode. }
false;public;0;3;;public Channel getInitialSolutionSetInput() {     return getInput1(). }
false;public;0;3;;public Channel getInitialWorksetInput() {     return getInput2(). }
false;public;1;3;;public void setImmediateSolutionSetUpdate(boolean immediateUpdate) {     this.immediateSolutionSetUpdate = immediateUpdate. }
false;public;0;3;;public boolean isImmediateSolutionSetUpdate() {     return this.immediateSolutionSetUpdate. }
false;public;0;3;;public FieldList getSolutionSetKeyFields() {     return getIterationNode().getSolutionSetKeyFields(). }
false;public;0;3;;// -------------------------------------------------------------------------------------------- public TypeSerializerFactory<?> getWorksetSerializer() {     return worksetSerializer. }
false;public;1;3;;public void setWorksetSerializer(TypeSerializerFactory<?> worksetSerializer) {     this.worksetSerializer = worksetSerializer. }
false;public;0;3;;public TypeSerializerFactory<?> getSolutionSetSerializer() {     return solutionSetSerializer. }
false;public;1;3;;public void setSolutionSetSerializer(TypeSerializerFactory<?> solutionSetSerializer) {     this.solutionSetSerializer = solutionSetSerializer. }
false;public;0;3;;public TypeComparatorFactory<?> getSolutionSetComparator() {     return solutionSetComparator. }
false;public;1;3;;public void setSolutionSetComparator(TypeComparatorFactory<?> solutionSetComparator) {     this.solutionSetComparator = solutionSetComparator. }
false;public;1;7;;// -------------------------------------------------------------------------------------------- public void setCosts(Costs nodeCosts) {     // add the costs from the step function     nodeCosts.addCosts(this.solutionSetDeltaPlanNode.getCumulativeCostsShare()).     nodeCosts.addCosts(this.nextWorkSetPlanNode.getCumulativeCostsShare()).     super.setCosts(nodeCosts). }
false;public;0;4;;public int getMemoryConsumerWeight() {     // solution set index and workset back channel     return 2. }
false;public;1;26;;@Override public SourceAndDamReport hasDamOnPathDownTo(PlanNode source) {     if (source == this) {         return FOUND_SOURCE.     }     SourceAndDamReport fromOutside = super.hasDamOnPathDownTo(source).     if (fromOutside == FOUND_SOURCE_AND_DAM) {         return FOUND_SOURCE_AND_DAM.     } else if (fromOutside == FOUND_SOURCE) {         // we always have a dam in the solution set index         return FOUND_SOURCE_AND_DAM.     } else {         SourceAndDamReport fromNextWorkset = nextWorkSetPlanNode.hasDamOnPathDownTo(source).         if (fromNextWorkset == FOUND_SOURCE_AND_DAM) {             return FOUND_SOURCE_AND_DAM.         } else if (fromNextWorkset == FOUND_SOURCE) {             return FOUND_SOURCE_AND_DAM.         } else {             return this.solutionSetDeltaPlanNode.hasDamOnPathDownTo(source).         }     } }
false;public;1;5;;@Override public void acceptForStepFunction(Visitor<PlanNode> visitor) {     this.solutionSetDeltaPlanNode.accept(visitor).     this.nextWorkSetPlanNode.accept(visitor). }
true;protected;2;2;/**  * Merging can only take place after the solutionSetDelta and nextWorkset PlanNode has been set,  * because they can contain also some of the branching nodes.  */ ;/**  * Merging can only take place after the solutionSetDelta and nextWorkset PlanNode has been set,  * because they can contain also some of the branching nodes.  */ @Override protected void mergeBranchPlanMaps(Map<OptimizerNode, PlanNode> branchPlan1, Map<OptimizerNode, PlanNode> branchPlan2) { }
false;protected;0;43;;protected void mergeBranchPlanMaps() {     Map<OptimizerNode, PlanNode> branchPlan1 = input1.getSource().branchPlan.     Map<OptimizerNode, PlanNode> branchPlan2 = input2.getSource().branchPlan.     // merge the branchPlan maps according the template's uncloseBranchesStack     if (this.template.hasUnclosedBranches()) {         if (this.branchPlan == null) {             this.branchPlan = new HashMap<OptimizerNode, PlanNode>(8).         }         for (OptimizerNode.UnclosedBranchDescriptor uc : this.template.getOpenBranches()) {             OptimizerNode brancher = uc.getBranchingNode().             PlanNode selectedCandidate = null.             if (branchPlan1 != null) {                 // predecessor 1 has branching children, see if it got the branch we are looking for                 selectedCandidate = branchPlan1.get(brancher).             }             if (selectedCandidate == null && branchPlan2 != null) {                 // predecessor 2 has branching children, see if it got the branch we are looking for                 selectedCandidate = branchPlan2.get(brancher).             }             if (selectedCandidate == null && getSolutionSetDeltaPlanNode() != null && getSolutionSetDeltaPlanNode().branchPlan != null) {                 selectedCandidate = getSolutionSetDeltaPlanNode().branchPlan.get(brancher).             }             if (selectedCandidate == null && getNextWorkSetPlanNode() != null && getNextWorkSetPlanNode().branchPlan != null) {                 selectedCandidate = getNextWorkSetPlanNode().branchPlan.get(brancher).             }             if (selectedCandidate == null) {                 throw new CompilerException("Candidates for a node with open branches are missing information about the selected candidate ").             }             this.branchPlan.put(brancher, selectedCandidate).         }     } }
false;public;0;3;;// -------------------------------------------------------------------------------------------- public TypeSerializerFactory<?> getSerializerForIterationChannel() {     return serializerForIterationChannel. }
false;public;1;3;;public void setSerializerForIterationChannel(TypeSerializerFactory<?> serializerForIterationChannel) {     this.serializerForIterationChannel = serializerForIterationChannel. }
