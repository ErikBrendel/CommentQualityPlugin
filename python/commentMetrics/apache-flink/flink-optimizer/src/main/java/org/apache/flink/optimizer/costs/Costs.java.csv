commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the network cost.  *  * @return The network cost, in bytes to be transferred.  */ ;// -------------------------------------------------------------------------------------------- /**  * Gets the network cost.  *  * @return The network cost, in bytes to be transferred.  */ public double getNetworkCost() {     return networkCost. }
true;public;1;7;/**  * Sets the network cost for this Costs object.  *  * @param bytes  *        The network cost to set, in bytes to be transferred.  */ ;/**  * Sets the network cost for this Costs object.  *  * @param bytes  *        The network cost to set, in bytes to be transferred.  */ public void setNetworkCost(double bytes) {     if (bytes == UNKNOWN || bytes >= 0) {         this.networkCost = bytes.     } else {         throw new IllegalArgumentException().     } }
true;public;1;3;/**  * Adds the costs for network to the current network costs  * for this Costs object.  *  * @param bytes The network cost to add, in bytes to be transferred.  */ ;/**  * Adds the costs for network to the current network costs  * for this Costs object.  *  * @param bytes The network cost to add, in bytes to be transferred.  */ public void addNetworkCost(double bytes) {     this.networkCost = (this.networkCost < 0 || bytes < 0) ? UNKNOWN : this.networkCost + bytes. }
true;public;0;3;/**  * Gets the costs for disk.  *  * @return The disk cost, in bytes to be written and read.  */ ;/**  * Gets the costs for disk.  *  * @return The disk cost, in bytes to be written and read.  */ public double getDiskCost() {     return diskCost. }
true;public;1;7;/**  * Sets the costs for disk for this Costs object.  *  * @param bytes The disk cost to set, in bytes to be written and read.  */ ;/**  * Sets the costs for disk for this Costs object.  *  * @param bytes The disk cost to set, in bytes to be written and read.  */ public void setDiskCost(double bytes) {     if (bytes == UNKNOWN || bytes >= 0) {         this.diskCost = bytes.     } else {         throw new IllegalArgumentException().     } }
true;public;1;4;/**  * Adds the costs for disk to the current disk costs  * for this Costs object.  *  * @param bytes The disk cost to add, in bytes to be written and read.  */ ;/**  * Adds the costs for disk to the current disk costs  * for this Costs object.  *  * @param bytes The disk cost to add, in bytes to be written and read.  */ public void addDiskCost(double bytes) {     this.diskCost = (this.diskCost < 0 || bytes < 0) ? UNKNOWN : this.diskCost + bytes. }
true;public;0;3;/**  * Gets the cost for the CPU.  *  * @return The CPU Cost.  */ ;/**  * Gets the cost for the CPU.  *  * @return The CPU Cost.  */ public double getCpuCost() {     return this.cpuCost. }
true;public;1;7;/**  * Sets the cost for the CPU.  *  * @param cost The CPU Cost.  */ ;/**  * Sets the cost for the CPU.  *  * @param cost The CPU Cost.  */ public void setCpuCost(double cost) {     if (cost == UNKNOWN || cost >= 0) {         this.cpuCost = cost.     } else {         throw new IllegalArgumentException().     } }
true;public;1;4;/**  * Adds the given CPU cost to the current CPU cost for this Costs object.  *  * @param cost The CPU cost to add.  */ ;/**  * Adds the given CPU cost to the current CPU cost for this Costs object.  *  * @param cost The CPU cost to add.  */ public void addCpuCost(double cost) {     this.cpuCost = (this.cpuCost < 0 || cost < 0) ? UNKNOWN : this.cpuCost + cost. }
true;public;0;3;/**  * Gets the heuristic network cost.  *  * @return The heuristic network cost, in bytes to be transferred.  */ ;// -------------------------------------------------------------------------------------------- /**  * Gets the heuristic network cost.  *  * @return The heuristic network cost, in bytes to be transferred.  */ public double getHeuristicNetworkCost() {     return this.heuristicNetworkCost. }
true;public;1;6;/**  * Sets the heuristic network cost for this Costs object.  *  * @param cost The heuristic network cost to set, in bytes to be transferred.  */ ;/**  * Sets the heuristic network cost for this Costs object.  *  * @param cost The heuristic network cost to set, in bytes to be transferred.  */ public void setHeuristicNetworkCost(double cost) {     if (cost <= 0) {         throw new IllegalArgumentException("Heuristic costs must be positive.").     }     this.heuristicNetworkCost = cost. }
true;public;1;10;/**  * Adds the heuristic costs for network to the current heuristic network costs  * for this Costs object.  *  * @param cost The heuristic network cost to add.  */ ;/**  * Adds the heuristic costs for network to the current heuristic network costs  * for this Costs object.  *  * @param cost The heuristic network cost to add.  */ public void addHeuristicNetworkCost(double cost) {     if (cost <= 0) {         throw new IllegalArgumentException("Heuristic costs must be positive.").     }     this.heuristicNetworkCost += cost.     // check for overflow     if (this.heuristicNetworkCost < 0) {         this.heuristicNetworkCost = Double.MAX_VALUE.     } }
true;public;0;3;/**  * Gets the heuristic costs for disk.  *  * @return The heuristic disk cost.  */ ;/**  * Gets the heuristic costs for disk.  *  * @return The heuristic disk cost.  */ public double getHeuristicDiskCost() {     return this.heuristicDiskCost. }
true;public;1;6;/**  * Sets the heuristic costs for disk for this Costs object.  *  * @param cost The heuristic disk cost to set.  */ ;/**  * Sets the heuristic costs for disk for this Costs object.  *  * @param cost The heuristic disk cost to set.  */ public void setHeuristicDiskCost(double cost) {     if (cost <= 0) {         throw new IllegalArgumentException("Heuristic costs must be positive.").     }     this.heuristicDiskCost = cost. }
true;public;1;10;/**  * Adds the heuristic costs for disk to the current heuristic disk costs  * for this Costs object.  *  * @param cost The heuristic disk cost to add.  */ ;/**  * Adds the heuristic costs for disk to the current heuristic disk costs  * for this Costs object.  *  * @param cost The heuristic disk cost to add.  */ public void addHeuristicDiskCost(double cost) {     if (cost <= 0) {         throw new IllegalArgumentException("Heuristic costs must be positive.").     }     this.heuristicDiskCost += cost.     // check for overflow     if (this.heuristicDiskCost < 0) {         this.heuristicDiskCost = Double.MAX_VALUE.     } }
true;public;0;3;/**  * Gets the heuristic cost for the CPU.  *  * @return The heuristic CPU Cost.  */ ;/**  * Gets the heuristic cost for the CPU.  *  * @return The heuristic CPU Cost.  */ public double getHeuristicCpuCost() {     return this.heuristicCpuCost. }
true;public;1;6;/**  * Sets the heuristic cost for the CPU.  *  * @param cost The heuristic CPU Cost.  */ ;/**  * Sets the heuristic cost for the CPU.  *  * @param cost The heuristic CPU Cost.  */ public void setHeuristicCpuCost(double cost) {     if (cost <= 0) {         throw new IllegalArgumentException("Heuristic costs must be positive.").     }     this.heuristicCpuCost = cost. }
true;public;1;10;/**  * Adds the given heuristic CPU cost to the current heuristic CPU cost for this Costs object.  *  * @param cost The heuristic CPU cost to add.  */ ;/**  * Adds the given heuristic CPU cost to the current heuristic CPU cost for this Costs object.  *  * @param cost The heuristic CPU cost to add.  */ public void addHeuristicCpuCost(double cost) {     if (cost <= 0) {         throw new IllegalArgumentException("Heuristic costs must be positive.").     }     this.heuristicCpuCost += cost.     // check for overflow     if (this.heuristicCpuCost < 0) {         this.heuristicCpuCost = Double.MAX_VALUE.     } }
true;public;1;26;/**  * Adds the given costs to these costs. If for one of the different cost components (network, disk),  * the costs are unknown, the resulting costs will be unknown.  *  * @param other The costs to add.  */ ;// -------------------------------------------------------------------------------------------- /**  * Adds the given costs to these costs. If for one of the different cost components (network, disk),  * the costs are unknown, the resulting costs will be unknown.  *  * @param other The costs to add.  */ public void addCosts(Costs other) {     // ---------- quantifiable costs ----------     if (this.networkCost == UNKNOWN || other.networkCost == UNKNOWN) {         this.networkCost = UNKNOWN.     } else {         this.networkCost += other.networkCost.     }     if (this.diskCost == UNKNOWN || other.diskCost == UNKNOWN) {         this.diskCost = UNKNOWN.     } else {         this.diskCost += other.diskCost.     }     if (this.cpuCost == UNKNOWN || other.cpuCost == UNKNOWN) {         this.cpuCost = UNKNOWN.     } else {         this.cpuCost += other.cpuCost.     }     // ---------- heuristic costs ----------     this.heuristicNetworkCost += other.heuristicNetworkCost.     this.heuristicDiskCost += other.heuristicDiskCost.     this.heuristicCpuCost += other.heuristicCpuCost. }
true;public;1;35;/**  * Subtracts the given costs from these costs. If the given costs are unknown, then these costs are remain unchanged.  *  * @param other The costs to subtract.  */ ;/**  * Subtracts the given costs from these costs. If the given costs are unknown, then these costs are remain unchanged.  *  * @param other The costs to subtract.  */ public void subtractCosts(Costs other) {     if (this.networkCost != UNKNOWN && other.networkCost != UNKNOWN) {         this.networkCost -= other.networkCost.         if (this.networkCost < 0) {             throw new IllegalArgumentException("Cannot subtract more cost then there is.").         }     }     if (this.diskCost != UNKNOWN && other.diskCost != UNKNOWN) {         this.diskCost -= other.diskCost.         if (this.diskCost < 0) {             throw new IllegalArgumentException("Cannot subtract more cost then there is.").         }     }     if (this.cpuCost != UNKNOWN && other.cpuCost != UNKNOWN) {         this.cpuCost -= other.cpuCost.         if (this.cpuCost < 0) {             throw new IllegalArgumentException("Cannot subtract more cost then there is.").         }     }     // ---------- relative costs ----------     this.heuristicNetworkCost -= other.heuristicNetworkCost.     if (this.heuristicNetworkCost < 0) {         throw new IllegalArgumentException("Cannot subtract more cost then there is.").     }     this.heuristicDiskCost -= other.heuristicDiskCost.     if (this.heuristicDiskCost < 0) {         throw new IllegalArgumentException("Cannot subtract more cost then there is.").     }     this.heuristicCpuCost -= other.heuristicCpuCost.     if (this.heuristicCpuCost < 0) {         throw new IllegalArgumentException("Cannot subtract more cost then there is.").     } }
false;public;1;8;;public void multiplyWith(int factor) {     this.networkCost = this.networkCost < 0 ? -1 : this.networkCost * factor.     this.diskCost = this.diskCost < 0 ? -1 : this.diskCost * factor.     this.cpuCost = this.cpuCost < 0 ? -1 : this.cpuCost * factor.     this.heuristicNetworkCost = this.heuristicNetworkCost < 0 ? -1 : this.heuristicNetworkCost * factor.     this.heuristicDiskCost = this.heuristicDiskCost < 0 ? -1 : this.heuristicDiskCost * factor.     this.heuristicCpuCost = this.heuristicCpuCost < 0 ? -1 : this.heuristicCpuCost * factor. }
false;public;1;8;;public void divideBy(int factor) {     this.networkCost = this.networkCost < 0 ? -1 : this.networkCost / factor.     this.diskCost = this.diskCost < 0 ? -1 : this.diskCost / factor.     this.cpuCost = this.cpuCost < 0 ? -1 : this.cpuCost / factor.     this.heuristicNetworkCost = this.heuristicNetworkCost < 0 ? -1 : this.heuristicNetworkCost / factor.     this.heuristicDiskCost = this.heuristicDiskCost < 0 ? -1 : this.heuristicDiskCost / factor.     this.heuristicCpuCost = this.heuristicCpuCost < 0 ? -1 : this.heuristicCpuCost / factor. }
true;public;1;35;/**  * The order of comparison is: network first, then disk, then CPU. The comparison here happens each time  * primarily after the heuristic costs, then after the quantifiable costs.  *  * @see java.lang.Comparable#compareTo(java.lang.Object)  */ ;// -------------------------------------------------------------------------------------------- /**  * The order of comparison is: network first, then disk, then CPU. The comparison here happens each time  * primarily after the heuristic costs, then after the quantifiable costs.  *  * @see java.lang.Comparable#compareTo(java.lang.Object)  */ @Override public int compareTo(Costs o) {     // check the network cost. if we have actual costs on both, use them, otherwise use the heuristic costs.     if (this.networkCost != UNKNOWN && o.networkCost != UNKNOWN) {         if (this.networkCost != o.networkCost) {             return this.networkCost < o.networkCost ? -1 : 1.         }     } else if (this.heuristicNetworkCost < o.heuristicNetworkCost) {         return -1.     } else if (this.heuristicNetworkCost > o.heuristicNetworkCost) {         return 1.     }     // next, check the disk cost. again, if we have actual costs on both, use them, otherwise use the heuristic costs.     if (this.diskCost != UNKNOWN && o.diskCost != UNKNOWN) {         if (this.diskCost != o.diskCost) {             return this.diskCost < o.diskCost ? -1 : 1.         }     } else if (this.heuristicDiskCost < o.heuristicDiskCost) {         return -1.     } else if (this.heuristicDiskCost > o.heuristicDiskCost) {         return 1.     }     // next, check the CPU cost. again, if we have actual costs on both, use them, otherwise use the heuristic costs.     if (this.cpuCost != UNKNOWN && o.cpuCost != UNKNOWN) {         return this.cpuCost < o.cpuCost ? -1 : this.cpuCost > o.cpuCost ? 1 : 0.     } else if (this.heuristicCpuCost < o.heuristicCpuCost) {         return -1.     } else if (this.heuristicCpuCost > o.heuristicCpuCost) {         return 1.     } else {         return 0.     } }
false;public;0;19;;@Override public int hashCode() {     final int prime = 31.     int result = 1.     long cpuCostBits = Double.doubleToLongBits(cpuCost).     long heuristicCpuCostBits = Double.doubleToLongBits(heuristicCpuCost).     long heuristicNetworkCostBits = Double.doubleToLongBits(heuristicNetworkCost).     long heuristicDiskCostBits = Double.doubleToLongBits(heuristicDiskCost).     long networkCostBits = Double.doubleToLongBits(networkCost).     long diskCostBits = Double.doubleToLongBits(diskCost).     result = prime * result + (int) (cpuCostBits ^ (cpuCostBits >>> 32)).     result = prime * result + (int) (heuristicCpuCostBits ^ (heuristicCpuCostBits >>> 32)).     result = prime * result + (int) (heuristicNetworkCostBits ^ (heuristicNetworkCostBits >>> 32)).     result = prime * result + (int) (heuristicDiskCostBits ^ (heuristicDiskCostBits >>> 32)).     result = prime * result + (int) (networkCostBits ^ (networkCostBits >>> 32)).     result = prime * result + (int) (diskCostBits ^ (diskCostBits >>> 32)).     return result. }
false;public;1;14;;@Override public boolean equals(Object obj) {     if (obj.getClass() == getClass()) {         final Costs other = (Costs) obj.         return this.networkCost == other.networkCost & this.diskCost == other.diskCost & this.cpuCost == other.cpuCost & this.heuristicNetworkCost == other.heuristicNetworkCost & this.heuristicDiskCost == other.heuristicDiskCost & this.heuristicCpuCost == other.heuristicCpuCost.     } else {         return false.     } }
false;public;0;6;;@Override public String toString() {     return "Costs [networkCost=" + networkCost + ", diskCost=" + diskCost + ", cpuCost=" + cpuCost + ", heuristicNetworkCost=" + heuristicNetworkCost + ", heuristicDiskCost=" + heuristicDiskCost + ", heuristicCpuCost=" + heuristicCpuCost + "]". }
false;public;0;8;;@Override public Costs clone() {     try {         return (Costs) super.clone().     } catch (CloneNotSupportedException e) {         // should never happen         throw new RuntimeException(e).     } }
