commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Gets the contract object for this data source node.  *  * @return The contract.  */ ;/**  * Gets the contract object for this data source node.  *  * @return The contract.  */ @Override public GenericDataSourceBase<?, ?> getOperator() {     return (GenericDataSourceBase<?, ?>) super.getOperator(). }
false;public;0;4;;@Override public String getOperatorName() {     return "Data Source". }
false;public;1;7;;@Override public void setParallelism(int parallelism) {     // if unsplittable, parallelism remains at 1     if (!this.sequentialInput) {         super.setParallelism(parallelism).     } }
false;public;0;4;;@Override public List<DagConnection> getIncomingConnections() {     return Collections.<DagConnection>emptyList(). }
false;public;2;2;;@Override public void setInput(Map<Operator<?>, OptimizerNode> contractToNode, ExecutionMode defaultDataExchangeMode) { }
false;protected;1;59;;@Override protected void computeOperatorSpecificDefaultEstimates(DataStatistics statistics) {     // see, if we have a statistics object that can tell us a bit about the file     if (statistics != null) {         // instantiate the input format, as this is needed by the statistics         InputFormat<?, ?> format.         String inFormatDescription = "<unknown>".         try {             format = getOperator().getFormatWrapper().getUserCodeObject().             Configuration config = getOperator().getParameters().             format.configure(config).         } catch (Throwable t) {             if (Optimizer.LOG.isWarnEnabled()) {                 Optimizer.LOG.warn("Could not instantiate InputFormat to obtain statistics." + " Limited statistics will be available.", t).             }             return.         }         try {             inFormatDescription = format.toString().         } catch (Throwable t) {         // we can ignore this error, as it only prevents us to use a cosmetic string         }         // first of all, get the statistics from the cache         final String statisticsKey = getOperator().getStatisticsKey().         final BaseStatistics cachedStatistics = statistics.getBaseStatistics(statisticsKey).         BaseStatistics bs = null.         try {             bs = format.getStatistics(cachedStatistics).         } catch (Throwable t) {             if (Optimizer.LOG.isWarnEnabled()) {                 Optimizer.LOG.warn("Error obtaining statistics from input format: " + t.getMessage(), t).             }         }         if (bs != null) {             final long len = bs.getTotalInputSize().             if (len == BaseStatistics.SIZE_UNKNOWN) {                 if (Optimizer.LOG.isInfoEnabled()) {                     Optimizer.LOG.info("Compiler could not determine the size of input '" + inFormatDescription + "'. Using default estimates.").                 }             } else if (len >= 0) {                 this.estimatedOutputSize = len.             }             final long card = bs.getNumberOfRecords().             if (card != BaseStatistics.NUM_RECORDS_UNKNOWN) {                 this.estimatedNumRecords = card.             }         }     } }
false;public;1;4;;@Override public void computeInterestingPropertiesForInputs(CostEstimator estimator) { // no children, so nothing to compute }
false;public;0;5;;@Override public void computeUnclosedBranchStack() {     // because there are no inputs, there are no unclosed branches.     this.openBranches = Collections.emptyList(). }
false;public;1;37;;@Override public List<PlanNode> getAlternativePlans(CostEstimator estimator) {     if (this.cachedPlans != null) {         return this.cachedPlans.     }     SourcePlanNode candidate = new SourcePlanNode(this, "DataSource (" + this.getOperator().getName() + ")", this.gprops, this.lprops).     if (!replicatedInput) {         candidate.updatePropertiesWithUniqueSets(getUniqueFields()).         final Costs costs = new Costs().         if (FileInputFormat.class.isAssignableFrom(getOperator().getFormatWrapper().getUserCodeClass()) && this.estimatedOutputSize >= 0) {             estimator.addFileInputCost(this.estimatedOutputSize, costs).         }         candidate.setCosts(costs).     } else {         // replicated input         final Costs costs = new Costs().         InputFormat<?, ?> inputFormat = ((ReplicatingInputFormat<?, ?>) getOperator().getFormatWrapper().getUserCodeObject()).getReplicatedInputFormat().         if (FileInputFormat.class.isAssignableFrom(inputFormat.getClass()) && this.estimatedOutputSize >= 0) {             estimator.addFileInputCost(this.estimatedOutputSize * this.getParallelism(), costs).         }         candidate.setCosts(costs).     }     // since there is only a single plan for the data-source, return a list with that element only     List<PlanNode> plans = new ArrayList<PlanNode>(1).     plans.add(candidate).     this.cachedPlans = plans.     return plans. }
false;public;0;4;;@Override public SemanticProperties getSemanticProperties() {     return new EmptySemanticProperties(). }
false;public;1;6;;@Override public void accept(Visitor<OptimizerNode> visitor) {     if (visitor.preVisit(this)) {         visitor.postVisit(this).     } }
false;private;1;52;;private void setDataPropertiesFromSplitProperties(SplitDataProperties splitProps) {     // set global properties     int[] partitionKeys = splitProps.getSplitPartitionKeys().     Partitioner<?> partitioner = splitProps.getSplitPartitioner().     if (partitionKeys != null && partitioner != null) {         this.gprops.setCustomPartitioned(new FieldList(partitionKeys), partitioner).     } else if (partitionKeys != null) {         this.gprops.setAnyPartitioning(new FieldList(partitionKeys)).     }     // set local properties     int[] groupingKeys = splitProps.getSplitGroupKeys().     Ordering ordering = splitProps.getSplitOrder().     // adapt split grouping and sorting     if (ordering != null) {         // sorting falls back to grouping because a source can read multiple,         // randomly assigned splits         groupingKeys = ordering.getFieldPositions().     }     if (groupingKeys != null && partitionKeys != null) {         // check if grouping is also valid across splits, i.e., whether grouping keys are         // valid superset of partition keys         boolean allFieldsIncluded = true.         for (int i : partitionKeys) {             boolean fieldIncluded = false.             for (int j : groupingKeys) {                 if (i == j) {                     fieldIncluded = true.                     break.                 }             }             if (!fieldIncluded) {                 allFieldsIncluded = false.                 break.             }         }         if (allFieldsIncluded) {             this.lprops = LocalProperties.forGrouping(new FieldList(groupingKeys)).         } else {             this.lprops = new LocalProperties().         }     } else {         this.lprops = new LocalProperties().     } }
