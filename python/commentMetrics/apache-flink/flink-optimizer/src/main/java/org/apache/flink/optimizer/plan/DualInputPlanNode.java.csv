commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;// -------------------------------------------------------------------------------------------- public TwoInputNode getTwoInputNode() {     if (this.template instanceof TwoInputNode) {         return (TwoInputNode) this.template.     } else {         throw new RuntimeException().     } }
false;public;0;3;;public FieldList getKeysForInput1() {     return this.keys1. }
false;public;0;3;;public FieldList getKeysForInput2() {     return this.keys2. }
false;public;0;3;;public boolean[] getSortOrders() {     return this.sortOrders. }
false;public;0;3;;public TypeComparatorFactory<?> getComparator1() {     return this.comparator1. }
false;public;0;3;;public TypeComparatorFactory<?> getComparator2() {     return this.comparator2. }
false;public;1;3;;public void setComparator1(TypeComparatorFactory<?> comparator) {     this.comparator1 = comparator. }
false;public;1;3;;public void setComparator2(TypeComparatorFactory<?> comparator) {     this.comparator2 = comparator. }
false;public;0;3;;public TypePairComparatorFactory<?, ?> getPairComparator() {     return this.pairComparator. }
false;public;1;3;;public void setPairComparator(TypePairComparatorFactory<?, ?> comparator) {     this.pairComparator = comparator. }
true;public;0;3;/**  * Gets the first input channel to this node.  *  * @return The first input channel to this node.  */ ;/**  * Gets the first input channel to this node.  *  * @return The first input channel to this node.  */ public Channel getInput1() {     return this.input1. }
true;public;0;3;/**  * Gets the second input channel to this node.  *  * @return The second input channel to this node.  */ ;/**  * Gets the second input channel to this node.  *  * @return The second input channel to this node.  */ public Channel getInput2() {     return this.input2. }
false;public;1;13;;// -------------------------------------------------------------------------------------------- @Override public void accept(Visitor<PlanNode> visitor) {     if (visitor.preVisit(this)) {         this.input1.getSource().accept(visitor).         this.input2.getSource().accept(visitor).         for (Channel broadcastInput : getBroadcastInputs()) {             broadcastInput.getSource().accept(visitor).         }         visitor.postVisit(this).     } }
false;public;0;17;;@Override public Iterable<PlanNode> getPredecessors() {     if (getBroadcastInputs() == null || getBroadcastInputs().isEmpty()) {         return Arrays.asList(this.input1.getSource(), this.input2.getSource()).     } else {         List<PlanNode> preds = new ArrayList<PlanNode>().         preds.add(input1.getSource()).         preds.add(input2.getSource()).         for (Channel c : getBroadcastInputs()) {             preds.add(c.getSource()).         }         return preds.     } }
false;public;0;4;;@Override public Iterable<Channel> getInputs() {     return Arrays.asList(this.input1, this.input2). }
false;public;1;47;;@Override public SourceAndDamReport hasDamOnPathDownTo(PlanNode source) {     if (source == this) {         return FOUND_SOURCE.     }     // check first input     SourceAndDamReport res1 = this.input1.getSource().hasDamOnPathDownTo(source).     if (res1 == FOUND_SOURCE_AND_DAM) {         return FOUND_SOURCE_AND_DAM.     } else if (res1 == FOUND_SOURCE) {         if (this.input1.getLocalStrategy().dams() || this.input1.getTempMode().breaksPipeline() || getDriverStrategy().firstDam() == DamBehavior.FULL_DAM) {             return FOUND_SOURCE_AND_DAM.         } else {             return FOUND_SOURCE.         }     } else {         SourceAndDamReport res2 = this.input2.getSource().hasDamOnPathDownTo(source).         if (res2 == FOUND_SOURCE_AND_DAM) {             return FOUND_SOURCE_AND_DAM.         } else if (res2 == FOUND_SOURCE) {             if (this.input2.getLocalStrategy().dams() || this.input2.getTempMode().breaksPipeline() || getDriverStrategy().secondDam() == DamBehavior.FULL_DAM) {                 return FOUND_SOURCE_AND_DAM.             } else {                 return FOUND_SOURCE.             }         } else {             for (NamedChannel nc : getBroadcastInputs()) {                 SourceAndDamReport bcRes = nc.getSource().hasDamOnPathDownTo(source).                 if (bcRes != NOT_FOUND) {                     // broadcast inputs are always dams                     return FOUND_SOURCE_AND_DAM.                 }             }             return NOT_FOUND.         }     } }
