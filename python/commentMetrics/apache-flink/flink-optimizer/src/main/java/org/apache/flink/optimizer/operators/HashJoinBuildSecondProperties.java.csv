commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public DriverStrategy getStrategy() {     return DriverStrategy.HYBRIDHASH_BUILD_SECOND. }
false;protected;0;6;;@Override protected List<LocalPropertiesPair> createPossibleLocalProperties() {     // all properties are possible     return Collections.singletonList(new LocalPropertiesPair(new RequestedLocalProperties(), new RequestedLocalProperties())). }
false;public;4;6;;@Override public boolean areCoFulfilled(RequestedLocalProperties requested1, RequestedLocalProperties requested2, LocalProperties produced1, LocalProperties produced2) {     return true. }
false;public;3;18;;@Override public DualInputPlanNode instantiate(Channel in1, Channel in2, TwoInputNode node) {     DriverStrategy strategy.     if (!in2.isOnDynamicPath() && in1.isOnDynamicPath()) {         // sanity check that the first input is cached and remove that cache         if (!in2.getTempMode().isCached()) {             throw new CompilerException("No cache at point where static and dynamic parts meet.").         }         in2.setTempMode(in2.getTempMode().makeNonCached()).         strategy = DriverStrategy.HYBRIDHASH_BUILD_SECOND_CACHED.     } else {         strategy = DriverStrategy.HYBRIDHASH_BUILD_SECOND.     }     return new DualInputPlanNode(node, "Join (" + node.getOperator().getName() + ")", in1, in2, strategy, this.keys1, this.keys2). }
false;public;2;4;;@Override public LocalProperties computeLocalProperties(LocalProperties in1, LocalProperties in2) {     return new LocalProperties(). }
