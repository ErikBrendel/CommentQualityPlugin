commented;modifiers;parameterAmount;loc;comment;code
false;private;1;38;;private List<OperatorDescriptorSingle> initPossibleProperties(Partitioner<?> customPartitioner) {     // see if an internal hint dictates the strategy to use     final Configuration conf = getOperator().getParameters().     final String localStrategy = conf.getString(Optimizer.HINT_LOCAL_STRATEGY, null).     final boolean useCombiner.     if (localStrategy != null) {         if (Optimizer.HINT_LOCAL_STRATEGY_SORT.equals(localStrategy)) {             useCombiner = false.         } else if (Optimizer.HINT_LOCAL_STRATEGY_COMBINING_SORT.equals(localStrategy)) {             if (!isCombineable()) {                 Optimizer.LOG.warn("Strategy hint for GroupReduce '" + getOperator().getName() + "' requires combinable reduce, but user function is not marked combinable.").             }             useCombiner = true.         } else {             throw new CompilerException("Invalid local strategy hint for match contract: " + localStrategy).         }     } else {         useCombiner = isCombineable().     }     // check if we can work with a grouping (simple reducer), or if we need ordering because of a group order     Ordering groupOrder = null.     if (getOperator() != null) {         groupOrder = getOperator().getGroupOrder().         if (groupOrder != null && groupOrder.getNumberOfFields() == 0) {             groupOrder = null.         }     }     OperatorDescriptorSingle props = useCombiner ? (this.keys == null ? new AllGroupWithPartialPreGroupProperties() : new GroupReduceWithCombineProperties(this.keys, groupOrder, customPartitioner)) : (this.keys == null ? new AllGroupReduceProperties() : new GroupReduceProperties(this.keys, groupOrder, customPartitioner)).     return Collections.singletonList(props). }
true;public;0;4;/**  * Gets the operator represented by this optimizer node.  *  * @return The operator represented by this optimizer node.  */ ;// ------------------------------------------------------------------------ /**  * Gets the operator represented by this optimizer node.  *  * @return The operator represented by this optimizer node.  */ @Override public GroupReduceOperatorBase<?, ?, ?> getOperator() {     return (GroupReduceOperatorBase<?, ?, ?>) super.getOperator(). }
true;public;0;3;/**  * Checks, whether a combiner function has been given for the function encapsulated  * by this reduce contract.  *  * @return True, if a combiner has been given, false otherwise.  */ ;/**  * Checks, whether a combiner function has been given for the function encapsulated  * by this reduce contract.  *  * @return True, if a combiner has been given, false otherwise.  */ public boolean isCombineable() {     return getOperator().isCombinable(). }
false;public;0;4;;@Override public String getOperatorName() {     return this.operatorName. }
false;protected;0;4;;@Override protected List<OperatorDescriptorSingle> getPossibleProperties() {     return this.possibleProperties. }
false;protected;0;21;;@Override protected SemanticProperties getSemanticPropertiesForLocalPropertyFiltering() {     // Local properties for GroupReduce may only be preserved on key fields.     SingleInputSemanticProperties origProps = getOperator().getSemanticProperties().     SingleInputSemanticProperties filteredProps = new SingleInputSemanticProperties().     FieldSet readSet = origProps.getReadFields(0).     if (readSet != null) {         filteredProps.addReadFields(readSet).     }     // only add forward field information for key fields     if (this.keys != null) {         for (int f : this.keys) {             FieldSet targets = origProps.getForwardingTargetFields(0, f).             for (int t : targets) {                 filteredProps.addForwardedField(f, t).             }         }     }     return filteredProps. }
false;protected;1;4;;// -------------------------------------------------------------------------------------------- // Estimates // -------------------------------------------------------------------------------------------- @Override protected void computeOperatorSpecificDefaultEstimates(DataStatistics statistics) { // no real estimates possible for a reducer. }
false;public;0;10;;public GroupReduceNode getCombinerUtilityNode() {     if (this.combinerUtilityNode == null) {         this.combinerUtilityNode = new GroupReduceNode(this).         // we conservatively assume the combiner returns the same data size as it consumes         this.combinerUtilityNode.estimatedOutputSize = getPredecessorNode().getEstimatedOutputSize().         this.combinerUtilityNode.estimatedNumRecords = getPredecessorNode().getEstimatedNumRecords().     }     return this.combinerUtilityNode. }
