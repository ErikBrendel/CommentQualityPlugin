commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;// -------------------------------------------------------------------------------------------- public void setCosts(Costs nodeCosts) {     // the plan enumeration logic works as for regular two-input-operators, which is important     // because of the branch handling logic. it does pick redistributing network channels     // between the sink and the sink joiner, because sinks joiner has a different parallelism than the sink.     // we discard any cost and simply use the sum of the costs from the two children.     Costs totalCosts = getInput1().getSource().getCumulativeCosts().clone().     totalCosts.addCosts(getInput2().getSource().getCumulativeCosts()).     super.setCosts(totalCosts). }
false;public;1;20;;// -------------------------------------------------------------------------------------------- public void getDataSinks(List<SinkPlanNode> sinks) {     final PlanNode in1 = this.input1.getSource().     final PlanNode in2 = this.input2.getSource().     if (in1 instanceof SinkPlanNode) {         sinks.add((SinkPlanNode) in1).     } else if (in1 instanceof SinkJoinerPlanNode) {         ((SinkJoinerPlanNode) in1).getDataSinks(sinks).     } else {         throw new CompilerException("Illegal child node for a sink joiner utility node: Neither Sink nor Sink Joiner").     }     if (in2 instanceof SinkPlanNode) {         sinks.add((SinkPlanNode) in2).     } else if (in2 instanceof SinkJoinerPlanNode) {         ((SinkJoinerPlanNode) in2).getDataSinks(sinks).     } else {         throw new CompilerException("Illegal child node for a sink joiner utility node: Neither Sink nor Sink Joiner").     } }
