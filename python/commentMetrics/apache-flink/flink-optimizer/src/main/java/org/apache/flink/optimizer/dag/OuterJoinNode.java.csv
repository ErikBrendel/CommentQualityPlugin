commented;modifiers;parameterAmount;loc;comment;code
false;private;0;31;;private List<OperatorDescriptorDual> getDataProperties() {     OuterJoinOperatorBase<?, ?, ?, ?> operator = getOperator().     OuterJoinType type = operator.getOuterJoinType().     JoinHint joinHint = operator.getJoinHint().     joinHint = joinHint == null ? JoinHint.OPTIMIZER_CHOOSES : joinHint.     List<OperatorDescriptorDual> list.     switch(type) {         case LEFT:             list = createLeftOuterJoinDescriptors(joinHint).             break.         case RIGHT:             list = createRightOuterJoinDescriptors(joinHint).             break.         case FULL:             list = createFullOuterJoinDescriptors(joinHint).             break.         default:             throw new CompilerException("Unknown outer join type: " + type).     }     Partitioner<?> customPartitioner = operator.getCustomPartitioner().     if (customPartitioner != null) {         for (OperatorDescriptorDual desc : list) {             ((AbstractJoinDescriptor) desc).setCustomPartitioner(customPartitioner).         }     }     return list. }
false;private;1;26;;private List<OperatorDescriptorDual> createLeftOuterJoinDescriptors(JoinHint hint) {     List<OperatorDescriptorDual> list = new ArrayList<>().     switch(hint) {         case OPTIMIZER_CHOOSES:             list.add(new SortMergeLeftOuterJoinDescriptor(this.keys1, this.keys2, true)).             list.add(new HashLeftOuterJoinBuildSecondDescriptor(this.keys1, this.keys2, true, true)).             break.         case REPARTITION_SORT_MERGE:             list.add(new SortMergeLeftOuterJoinDescriptor(this.keys1, this.keys2, false)).             break.         case REPARTITION_HASH_SECOND:             list.add(new HashLeftOuterJoinBuildSecondDescriptor(this.keys1, this.keys2, false, true)).             break.         case BROADCAST_HASH_SECOND:             list.add(new HashLeftOuterJoinBuildSecondDescriptor(this.keys1, this.keys2, true, false)).             break.         case REPARTITION_HASH_FIRST:             list.add(new HashLeftOuterJoinBuildFirstDescriptor(this.keys1, this.keys2, false, true)).             break.         case BROADCAST_HASH_FIRST:         default:             throw new CompilerException("Invalid join hint: " + hint + " for left outer join").     }     return list. }
false;private;1;26;;private List<OperatorDescriptorDual> createRightOuterJoinDescriptors(JoinHint hint) {     List<OperatorDescriptorDual> list = new ArrayList<>().     switch(hint) {         case OPTIMIZER_CHOOSES:             list.add(new SortMergeRightOuterJoinDescriptor(this.keys1, this.keys2, true)).             list.add(new HashRightOuterJoinBuildFirstDescriptor(this.keys1, this.keys2, true, true)).             break.         case REPARTITION_SORT_MERGE:             list.add(new SortMergeRightOuterJoinDescriptor(this.keys1, this.keys2, false)).             break.         case REPARTITION_HASH_FIRST:             list.add(new HashRightOuterJoinBuildFirstDescriptor(this.keys1, this.keys2, false, true)).             break.         case BROADCAST_HASH_FIRST:             list.add(new HashRightOuterJoinBuildFirstDescriptor(this.keys1, this.keys2, true, false)).             break.         case REPARTITION_HASH_SECOND:             list.add(new HashRightOuterJoinBuildSecondDescriptor(this.keys1, this.keys2, false, true)).             break.         case BROADCAST_HASH_SECOND:         default:             throw new CompilerException("Invalid join hint: " + hint + " for right outer join").     }     return list. }
false;private;1;23;;private List<OperatorDescriptorDual> createFullOuterJoinDescriptors(JoinHint hint) {     List<OperatorDescriptorDual> list = new ArrayList<>().     switch(hint) {         case OPTIMIZER_CHOOSES:             list.add(new SortMergeFullOuterJoinDescriptor(this.keys1, this.keys2)).             break.         case REPARTITION_SORT_MERGE:             list.add(new SortMergeFullOuterJoinDescriptor(this.keys1, this.keys2)).             break.         case REPARTITION_HASH_FIRST:             list.add(new HashFullOuterJoinBuildFirstDescriptor(this.keys1, this.keys2)).             break.         case REPARTITION_HASH_SECOND:             list.add(new HashFullOuterJoinBuildSecondDescriptor(this.keys1, this.keys2)).             break.         case BROADCAST_HASH_FIRST:         case BROADCAST_HASH_SECOND:         default:             throw new CompilerException("Invalid join hint: " + hint + " for full outer join").     }     return list. }
false;public;0;4;;@Override public OuterJoinOperatorBase<?, ?, ?, ?> getOperator() {     return (OuterJoinOperatorBase<?, ?, ?, ?>) super.getOperator(). }
false;protected;0;4;;@Override protected List<OperatorDescriptorDual> getPossibleProperties() {     return dataProperties. }
false;public;0;4;;@Override public String getOperatorName() {     return "Outer Join". }
false;protected;1;21;;@Override protected void computeOperatorSpecificDefaultEstimates(DataStatistics statistics) {     long card1 = getFirstPredecessorNode().getEstimatedNumRecords().     long card2 = getSecondPredecessorNode().getEstimatedNumRecords().     if (card1 < 0 || card2 < 0) {         this.estimatedNumRecords = -1.     } else {         this.estimatedNumRecords = Math.max(card1, card2).     }     if (this.estimatedNumRecords >= 0) {         float width1 = getFirstPredecessorNode().getEstimatedAvgWidthPerOutputRecord().         float width2 = getSecondPredecessorNode().getEstimatedAvgWidthPerOutputRecord().         float width = (width1 <= 0 || width2 <= 0) ? -1 : width1 + width2.         if (width > 0) {             this.estimatedOutputSize = (long) (width * this.estimatedNumRecords).         }     } }
