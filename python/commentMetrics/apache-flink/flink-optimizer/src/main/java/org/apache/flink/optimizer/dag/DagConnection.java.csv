commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the source of the connection.  *  * @return The source Node.  */ ;/**  * Gets the source of the connection.  *  * @return The source Node.  */ public OptimizerNode getSource() {     return this.source. }
true;public;0;3;/**  * Gets the target of the connection.  *  * @return The target node.  */ ;/**  * Gets the target of the connection.  *  * @return The target node.  */ public OptimizerNode getTarget() {     return this.target. }
true;public;0;3;/**  * Gets the shipping strategy for this connection.  *  * @return The connection's shipping strategy.  */ ;/**  * Gets the shipping strategy for this connection.  *  * @return The connection's shipping strategy.  */ public ShipStrategyType getShipStrategy() {     return this.shipStrategy. }
true;public;1;3;/**  * Sets the shipping strategy for this connection.  *  * @param strategy  *        The shipping strategy to be applied to this connection.  */ ;/**  * Sets the shipping strategy for this connection.  *  * @param strategy  *        The shipping strategy to be applied to this connection.  */ public void setShipStrategy(ShipStrategyType strategy) {     this.shipStrategy = strategy. }
true;public;0;6;/**  * Gets the data exchange mode to use for this connection.  *  * @return The data exchange mode to use for this connection.  */ ;/**  * Gets the data exchange mode to use for this connection.  *  * @return The data exchange mode to use for this connection.  */ public ExecutionMode getDataExchangeMode() {     if (dataExchangeMode == null) {         throw new IllegalStateException("This connection does not have the data exchange mode set").     }     return dataExchangeMode. }
true;public;0;3;/**  * Marks that this connection should do a decoupled data exchange (such as batched)  * rather then pipeline data. Connections are marked as pipeline breakers to avoid  * deadlock situations.  */ ;/**  * Marks that this connection should do a decoupled data exchange (such as batched)  * rather then pipeline data. Connections are marked as pipeline breakers to avoid  * deadlock situations.  */ public void markBreaksPipeline() {     this.breakPipeline = true. }
true;public;0;3;/**  * Checks whether this connection is marked to break the pipeline.  *  * @return True, if this connection is marked to break the pipeline, false otherwise.  */ ;/**  * Checks whether this connection is marked to break the pipeline.  *  * @return True, if this connection is marked to break the pipeline, false otherwise.  */ public boolean isBreakingPipeline() {     return this.breakPipeline. }
true;public;0;3;/**  * Gets the interesting properties object for this pact connection.  * If the interesting properties for this connections have not yet been set,  * this method returns null.  *  * @return The collection of all interesting properties, or null, if they have not yet been set.  */ ;/**  * Gets the interesting properties object for this pact connection.  * If the interesting properties for this connections have not yet been set,  * this method returns null.  *  * @return The collection of all interesting properties, or null, if they have not yet been set.  */ public InterestingProperties getInterestingProperties() {     return this.interestingProps. }
true;public;1;7;/**  * Sets the interesting properties for this pact connection.  *  * @param props The interesting properties.  */ ;/**  * Sets the interesting properties for this pact connection.  *  * @param props The interesting properties.  */ public void setInterestingProperties(InterestingProperties props) {     if (this.interestingProps == null) {         this.interestingProps = props.     } else {         throw new IllegalStateException("Interesting Properties have already been set.").     } }
false;public;0;3;;public void clearInterestingProperties() {     this.interestingProps = null. }
false;public;0;8;;public void initMaxDepth() {     if (this.maxDepth == -1) {         this.maxDepth = this.source.getMaxDepth() + 1.     } else {         throw new IllegalStateException("Maximum path depth has already been initialized.").     } }
false;public;0;7;;public int getMaxDepth() {     if (this.maxDepth != -1) {         return this.maxDepth.     } else {         throw new IllegalStateException("Maximum path depth has not been initialized.").     } }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // Estimates // -------------------------------------------------------------------------------------------- @Override public long getEstimatedOutputSize() {     return this.source.getEstimatedOutputSize(). }
false;public;0;4;;@Override public long getEstimatedNumRecords() {     return this.source.getEstimatedNumRecords(). }
false;public;0;4;;@Override public float getEstimatedAvgWidthPerOutputRecord() {     return this.source.getEstimatedAvgWidthPerOutputRecord(). }
false;public;0;3;;// -------------------------------------------------------------------------------------------- public TempMode getMaterializationMode() {     return this.materializationMode. }
false;public;1;3;;public void setMaterializationMode(TempMode materializationMode) {     this.materializationMode = materializationMode. }
false;public;0;3;;public boolean isOnDynamicPath() {     return this.source.isOnDynamicPath(). }
false;public;0;3;;public int getCostWeight() {     return this.source.getCostWeight(). }
false;public;0;28;;// -------------------------------------------------------------------------------------------- public String toString() {     StringBuilder buf = new StringBuilder(50).     buf.append("Connection: ").     if (this.source == null) {         buf.append("null").     } else {         buf.append(this.source.getOperator().getName()).         buf.append('(').append(this.source.getOperatorName()).append(')').     }     buf.append(" -> ").     if (this.shipStrategy != null) {         buf.append('[').         buf.append(this.shipStrategy.name()).         buf.append(']').append(' ').     }     if (this.target == null) {         buf.append("null").     } else {         buf.append(this.target.getOperator().getName()).         buf.append('(').append(this.target.getOperatorName()).append(')').     }     return buf.toString(). }
