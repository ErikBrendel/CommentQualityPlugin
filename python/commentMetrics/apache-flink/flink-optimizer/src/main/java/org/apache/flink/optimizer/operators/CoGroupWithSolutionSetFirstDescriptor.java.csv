commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;6;;@Override protected List<LocalPropertiesPair> createPossibleLocalProperties() {     RequestedLocalProperties none = new RequestedLocalProperties().     RequestedLocalProperties sort = new RequestedLocalProperties(Utils.createOrdering(this.keys2)).     return Collections.singletonList(new LocalPropertiesPair(none, sort)). }
false;public;3;14;;@Override public DualInputPlanNode instantiate(Channel in1, Channel in2, TwoInputNode node) {     boolean[] inputOrders = in2.getLocalProperties().getOrdering() == null ? null : in2.getLocalProperties().getOrdering().getFieldSortDirections().     if (inputOrders == null || inputOrders.length < this.keys2.size()) {         throw new CompilerException("BUG: The input strategy does not sufficiently describe the sort orders for a CoGroup operator.").     } else if (inputOrders.length > this.keys2.size()) {         boolean[] tmp = new boolean[this.keys2.size()].         System.arraycopy(inputOrders, 0, tmp, 0, tmp.length).         inputOrders = tmp.     }     return new DualInputPlanNode(node, "CoGroup (" + node.getOperator().getName() + ")", in1, in2, DriverStrategy.CO_GROUP, this.keys1, this.keys2, inputOrders). }
false;public;4;6;;@Override public boolean areCoFulfilled(RequestedLocalProperties requested1, RequestedLocalProperties requested2, LocalProperties produced1, LocalProperties produced2) {     return true. }
false;public;2;4;;@Override public LocalProperties computeLocalProperties(LocalProperties in1, LocalProperties in2) {     return in2. }
