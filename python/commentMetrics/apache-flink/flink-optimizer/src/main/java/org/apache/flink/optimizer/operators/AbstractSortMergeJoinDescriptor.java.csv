commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;6;;@Override protected List<LocalPropertiesPair> createPossibleLocalProperties() {     RequestedLocalProperties sort1 = new RequestedLocalProperties(Utils.createOrdering(this.keys1)).     RequestedLocalProperties sort2 = new RequestedLocalProperties(Utils.createOrdering(this.keys2)).     return Collections.singletonList(new LocalPropertiesPair(sort1, sort2)). }
false;public;4;6;;@Override public boolean areCoFulfilled(RequestedLocalProperties requested1, RequestedLocalProperties requested2, LocalProperties produced1, LocalProperties produced2) {     int numRelevantFields = this.keys1.size().     return checkSameOrdering(produced1, produced2, numRelevantFields). }
false;public;3;15;;@Override public DualInputPlanNode instantiate(Channel in1, Channel in2, TwoInputNode node) {     boolean[] inputOrders = in1.getLocalProperties().getOrdering().getFieldSortDirections().     if (inputOrders == null || inputOrders.length < this.keys1.size()) {         throw new CompilerException("BUG: The input strategy does not sufficiently describe the sort orders for a merge operator.").     } else if (inputOrders.length > this.keys1.size()) {         boolean[] tmp = new boolean[this.keys1.size()].         System.arraycopy(inputOrders, 0, tmp, 0, tmp.length).         inputOrders = tmp.     }     String nodeName = String.format("%s (%s)", getNodeName(), node.getOperator().getName()).     return new DualInputPlanNode(node, nodeName, in1, in2, getStrategy(), this.keys1, this.keys2, inputOrders). }
false;public;2;5;;@Override public LocalProperties computeLocalProperties(LocalProperties in1, LocalProperties in2) {     LocalProperties comb = LocalProperties.combine(in1, in2).     return comb.clearUniqueFieldSets(). }
false;protected,abstract;0;1;;protected abstract String getNodeName().
