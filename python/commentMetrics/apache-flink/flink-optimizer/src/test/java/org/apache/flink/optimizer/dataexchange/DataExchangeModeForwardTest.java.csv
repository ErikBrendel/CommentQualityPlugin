commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Test public void testPipelinedForced() {     // PIPELINED_FORCED should result in pipelining all the way     verifySimpleForwardPlan(ExecutionMode.PIPELINED_FORCED, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED). }
false;public;0;8;;@Test public void testPipelined() {     // PIPELINED should result in pipelining all the way     verifySimpleForwardPlan(ExecutionMode.PIPELINED, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED). }
false;public;0;8;;@Test public void testBatch() {     // BATCH should result in batching the shuffle all the way     verifySimpleForwardPlan(ExecutionMode.BATCH, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED, DataExchangeMode.PIPELINED, DataExchangeMode.BATCH, DataExchangeMode.PIPELINED). }
false;public;0;8;;@Test public void testBatchForced() {     // BATCH_FORCED should result in batching all the way     verifySimpleForwardPlan(ExecutionMode.BATCH_FORCED, DataExchangeMode.BATCH, DataExchangeMode.BATCH, DataExchangeMode.BATCH, DataExchangeMode.PIPELINED, DataExchangeMode.BATCH, DataExchangeMode.BATCH). }
false;public;1;4;;@Override public boolean filter(Integer value) {     return false. }
false;public;1;4;;@Override public Integer map(String value) {     return 0. }
false;private;7;52;;private void verifySimpleForwardPlan(ExecutionMode execMode, DataExchangeMode toMap, DataExchangeMode toFilter, DataExchangeMode toKeyExtractor, DataExchangeMode toCombiner, DataExchangeMode toReduce, DataExchangeMode toSink) {     try {         ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().         env.getConfig().setExecutionMode(execMode).         DataSet<String> dataSet = env.readTextFile("/never/accessed").         dataSet.map(new MapFunction<String, Integer>() {              @Override             public Integer map(String value) {                 return 0.             }         }).filter(new FilterFunction<Integer>() {              @Override             public boolean filter(Integer value) {                 return false.             }         }).groupBy(new IdentityKeyExtractor<Integer>()).reduceGroup(new Top1GroupReducer<Integer>()).output(new DiscardingOutputFormat<Integer>()).         OptimizedPlan optPlan = compileNoStats(env.createProgramPlan()).         SinkPlanNode sinkNode = optPlan.getDataSinks().iterator().next().         SingleInputPlanNode reduceNode = (SingleInputPlanNode) sinkNode.getPredecessor().         SingleInputPlanNode combineNode = (SingleInputPlanNode) reduceNode.getPredecessor().         SingleInputPlanNode keyExtractorNode = (SingleInputPlanNode) combineNode.getPredecessor().         SingleInputPlanNode filterNode = (SingleInputPlanNode) keyExtractorNode.getPredecessor().         SingleInputPlanNode mapNode = (SingleInputPlanNode) filterNode.getPredecessor().         assertEquals(toMap, mapNode.getInput().getDataExchangeMode()).         assertEquals(toFilter, filterNode.getInput().getDataExchangeMode()).         assertEquals(toKeyExtractor, keyExtractorNode.getInput().getDataExchangeMode()).         assertEquals(toCombiner, combineNode.getInput().getDataExchangeMode()).         assertEquals(toReduce, reduceNode.getInput().getDataExchangeMode()).         assertEquals(toSink, sinkNode.getInput().getDataExchangeMode()).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
