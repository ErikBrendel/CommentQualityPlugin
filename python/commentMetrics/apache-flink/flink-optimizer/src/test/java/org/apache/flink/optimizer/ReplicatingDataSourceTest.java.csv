# id;timestamp;commentText;codeText;commentWords;codeWords
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInput();1426843274;Tests join program with replicated data source.;@Test_	public void checkJoinWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setDegreeOfParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source;test,public,void,check,join,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,degree,of,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInput();1427097830;Tests join program with replicated data source.;@Test_	public void checkJoinWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source;test,public,void,check,join,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInput();1427312339;Tests join program with replicated data source.;@Test_	public void checkJoinWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source;test,public,void,check,join,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInput();1427784999;Tests join program with replicated data source.;@Test_	public void checkJoinWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source;test,public,void,check,join,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInput();1430859707;Tests join program with replicated data source.;@Test_	public void checkJoinWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source;test,public,void,check,join,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInput();1447879320;Tests join program with replicated data source.;@Test_	public void checkJoinWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source;test,public,void,check,join,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInput();1449526184;Tests join program with replicated data source.;@Test_	public void checkJoinWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		Plan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source;test,public,void,check,join,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,write,as,text,some,newpath,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFilter();1426843274;Tests join program with replicated data source behind filter.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFilter() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setDegreeOfParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,filter;test,public,void,check,join,with,replicated,source,input,behind,filter,execution,environment,env,execution,environment,create,local,environment,env,set,degree,of,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFilter();1427097830;Tests join program with replicated data source behind filter.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFilter() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,filter;test,public,void,check,join,with,replicated,source,input,behind,filter,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFilter();1427312339;Tests join program with replicated data source behind filter.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFilter() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,filter;test,public,void,check,join,with,replicated,source,input,behind,filter,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFilter();1427784999;Tests join program with replicated data source behind filter.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFilter() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,filter;test,public,void,check,join,with,replicated,source,input,behind,filter,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFilter();1430859707;Tests join program with replicated data source behind filter.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFilter() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,filter;test,public,void,check,join,with,replicated,source,input,behind,filter,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFilter();1447879320;Tests join program with replicated data source behind filter.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFilter() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,filter;test,public,void,check,join,with,replicated,source,input,behind,filter,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFilter();1449526184;Tests join program with replicated data source behind filter.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFilter() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		Plan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,filter;test,public,void,check,join,with,replicated,source,input,behind,filter,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,join,source2,where,equal,to,write,as,text,some,newpath,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindRebalance();1426843274;Tests compiler fail for join program with replicated data source behind rebalance.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindRebalance() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setDegreeOfParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.rebalance()_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,rebalance;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,rebalance,execution,environment,env,execution,environment,create,local,environment,env,set,degree,of,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,rebalance,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindRebalance();1427097830;Tests compiler fail for join program with replicated data source behind rebalance.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindRebalance() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.rebalance()_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,rebalance;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,rebalance,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,rebalance,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindRebalance();1427312339;Tests compiler fail for join program with replicated data source behind rebalance.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindRebalance() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.rebalance()_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,rebalance;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,rebalance,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,rebalance,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindRebalance();1427784999;Tests compiler fail for join program with replicated data source behind rebalance.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindRebalance() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.rebalance()_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,rebalance;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,rebalance,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,rebalance,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindRebalance();1430859707;Tests compiler fail for join program with replicated data source behind rebalance.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindRebalance() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.rebalance()_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,rebalance;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,rebalance,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,rebalance,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindRebalance();1447879320;Tests compiler fail for join program with replicated data source behind rebalance.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindRebalance() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.rebalance()_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,rebalance;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,rebalance,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,rebalance,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindRebalance();1449526184;Tests compiler fail for join program with replicated data source behind rebalance.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindRebalance() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.rebalance()_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		Plan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,rebalance;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,rebalance,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,rebalance,join,source2,where,equal,to,write,as,text,some,newpath,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInputBehindMap();1426843274;Tests cross program with replicated data source behind map and filter.;@Test_	public void checkCrossWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setDegreeOfParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.filter(new NoFilter())_				.cross(source2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source,behind,map,and,filter;test,public,void,check,cross,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,degree,of,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,filter,new,no,filter,cross,source2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInputBehindMap();1427097830;Tests cross program with replicated data source behind map and filter.;@Test_	public void checkCrossWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.filter(new NoFilter())_				.cross(source2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source,behind,map,and,filter;test,public,void,check,cross,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,filter,new,no,filter,cross,source2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInputBehindMap();1427312339;Tests cross program with replicated data source behind map and filter.;@Test_	public void checkCrossWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.filter(new NoFilter())_				.cross(source2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source,behind,map,and,filter;test,public,void,check,cross,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,filter,new,no,filter,cross,source2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInputBehindMap();1427784999;Tests cross program with replicated data source behind map and filter.;@Test_	public void checkCrossWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.filter(new NoFilter())_				.cross(source2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source,behind,map,and,filter;test,public,void,check,cross,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,filter,new,no,filter,cross,source2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInputBehindMap();1430859707;Tests cross program with replicated data source behind map and filter.;@Test_	public void checkCrossWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.filter(new NoFilter())_				.cross(source2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source,behind,map,and,filter;test,public,void,check,cross,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,filter,new,no,filter,cross,source2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInputBehindMap();1447879320;Tests cross program with replicated data source behind map and filter.;@Test_	public void checkCrossWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.filter(new NoFilter())_				.cross(source2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source,behind,map,and,filter;test,public,void,check,cross,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,filter,new,no,filter,cross,source2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInputBehindMap();1449526184;Tests cross program with replicated data source behind map and filter.;@Test_	public void checkCrossWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.filter(new NoFilter())_				.cross(source2)_				.writeAsText("/some/newpath")___		Plan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source,behind,map,and,filter;test,public,void,check,cross,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,filter,new,no,filter,cross,source2,write,as,text,some,newpath,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMultiMaps();1426843274;Tests join program with replicated data source behind multiple map ops.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMultiMaps() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setDegreeOfParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.mapPartition(new IdPMap())_				.flatMap(new IdFlatMap())_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,multiple,map,ops;test,public,void,check,join,with,replicated,source,input,behind,multi,maps,execution,environment,env,execution,environment,create,local,environment,env,set,degree,of,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,map,partition,new,id,pmap,flat,map,new,id,flat,map,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMultiMaps();1427097830;Tests join program with replicated data source behind multiple map ops.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMultiMaps() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.mapPartition(new IdPMap())_				.flatMap(new IdFlatMap())_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,multiple,map,ops;test,public,void,check,join,with,replicated,source,input,behind,multi,maps,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,map,partition,new,id,pmap,flat,map,new,id,flat,map,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMultiMaps();1427312339;Tests join program with replicated data source behind multiple map ops.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMultiMaps() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.mapPartition(new IdPMap())_				.flatMap(new IdFlatMap())_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,multiple,map,ops;test,public,void,check,join,with,replicated,source,input,behind,multi,maps,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,map,partition,new,id,pmap,flat,map,new,id,flat,map,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMultiMaps();1427784999;Tests join program with replicated data source behind multiple map ops.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMultiMaps() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.mapPartition(new IdPMap())_				.flatMap(new IdFlatMap())_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,multiple,map,ops;test,public,void,check,join,with,replicated,source,input,behind,multi,maps,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,map,partition,new,id,pmap,flat,map,new,id,flat,map,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMultiMaps();1430859707;Tests join program with replicated data source behind multiple map ops.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMultiMaps() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.mapPartition(new IdPMap())_				.flatMap(new IdFlatMap())_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,multiple,map,ops;test,public,void,check,join,with,replicated,source,input,behind,multi,maps,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,map,partition,new,id,pmap,flat,map,new,id,flat,map,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMultiMaps();1447879320;Tests join program with replicated data source behind multiple map ops.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMultiMaps() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.mapPartition(new IdPMap())_				.flatMap(new IdFlatMap())_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,multiple,map,ops;test,public,void,check,join,with,replicated,source,input,behind,multi,maps,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,map,partition,new,id,pmap,flat,map,new,id,flat,map,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMultiMaps();1449526184;Tests join program with replicated data source behind multiple map ops.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMultiMaps() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.filter(new NoFilter())_				.mapPartition(new IdPMap())_				.flatMap(new IdFlatMap())_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		Plan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,multiple,map,ops;test,public,void,check,join,with,replicated,source,input,behind,multi,maps,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,filter,new,no,filter,map,partition,new,id,pmap,flat,map,new,id,flat,map,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputChangingparallelism();1427097830;Tests compiler fail for join program with replicated data source and changing parallelism.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputChangingparallelism() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*").setParallelism(DEFAULT_PARALLELISM+2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,and,changing,parallelism;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,changingparallelism,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,set,parallelism,2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputChangingparallelism();1427312339;Tests compiler fail for join program with replicated data source and changing parallelism.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputChangingparallelism() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*").setParallelism(DEFAULT_PARALLELISM+2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,and,changing,parallelism;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,changingparallelism,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,set,parallelism,2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputChangingparallelism();1427784999;Tests compiler fail for join program with replicated data source and changing parallelism.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputChangingparallelism() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*").setParallelism(DEFAULT_PARALLELISM+2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,and,changing,parallelism;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,changingparallelism,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,set,parallelism,2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputChangingparallelism();1430859707;Tests compiler fail for join program with replicated data source and changing parallelism.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputChangingparallelism() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*").setParallelism(DEFAULT_PARALLELISM+2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,and,changing,parallelism;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,changingparallelism,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,set,parallelism,2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputChangingparallelism();1447879320;Tests compiler fail for join program with replicated data source and changing parallelism.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputChangingparallelism() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*").setParallelism(DEFAULT_PARALLELISM+2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,and,changing,parallelism;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,changingparallelism,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,set,parallelism,2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputChangingparallelism();1449526184;Tests compiler fail for join program with replicated data source and changing parallelism.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputChangingparallelism() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.join(source2).where("*").equalTo("*").setParallelism(DEFAULT_PARALLELISM+2)_				.writeAsText("/some/newpath")___		Plan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,and,changing,parallelism;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,changingparallelism,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,join,source2,where,equal,to,set,parallelism,2,write,as,text,some,newpath,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFlatMap();1426843274;Tests join program with replicated data source behind flatMap.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFlatMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setDegreeOfParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.flatMap(new IdFlatMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,flat,map;test,public,void,check,join,with,replicated,source,input,behind,flat,map,execution,environment,env,execution,environment,create,local,environment,env,set,degree,of,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,flat,map,new,id,flat,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFlatMap();1427097830;Tests join program with replicated data source behind flatMap.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFlatMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.flatMap(new IdFlatMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,flat,map;test,public,void,check,join,with,replicated,source,input,behind,flat,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,flat,map,new,id,flat,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFlatMap();1427312339;Tests join program with replicated data source behind flatMap.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFlatMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.flatMap(new IdFlatMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,flat,map;test,public,void,check,join,with,replicated,source,input,behind,flat,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,flat,map,new,id,flat,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFlatMap();1427784999;Tests join program with replicated data source behind flatMap.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFlatMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.flatMap(new IdFlatMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,flat,map;test,public,void,check,join,with,replicated,source,input,behind,flat,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,flat,map,new,id,flat,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFlatMap();1430859707;Tests join program with replicated data source behind flatMap.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFlatMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.flatMap(new IdFlatMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,flat,map;test,public,void,check,join,with,replicated,source,input,behind,flat,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,flat,map,new,id,flat,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFlatMap();1447879320;Tests join program with replicated data source behind flatMap.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFlatMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.flatMap(new IdFlatMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,flat,map;test,public,void,check,join,with,replicated,source,input,behind,flat,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,flat,map,new,id,flat,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindFlatMap();1449526184;Tests join program with replicated data source behind flatMap.;@Test_	public void checkJoinWithReplicatedSourceInputBehindFlatMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.flatMap(new IdFlatMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		Plan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,flat,map;test,public,void,check,join,with,replicated,source,input,behind,flat,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,flat,map,new,id,flat,map,join,source2,where,equal,to,write,as,text,some,newpath,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindMapChangingparallelism();1427097830;Tests compiler fail for join program with replicated data source behind map and changing parallelism.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindMapChangingparallelism() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap()).setParallelism(DEFAULT_PARALLELISM+1)_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,map,and,changing,parallelism;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,map,changingparallelism,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,set,parallelism,1,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindMapChangingparallelism();1427312339;Tests compiler fail for join program with replicated data source behind map and changing parallelism.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindMapChangingparallelism() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap()).setParallelism(DEFAULT_PARALLELISM+1)_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,map,and,changing,parallelism;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,map,changingparallelism,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,set,parallelism,1,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindMapChangingparallelism();1427784999;Tests compiler fail for join program with replicated data source behind map and changing parallelism.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindMapChangingparallelism() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap()).setParallelism(DEFAULT_PARALLELISM+1)_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,map,and,changing,parallelism;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,map,changingparallelism,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,set,parallelism,1,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindMapChangingparallelism();1430859707;Tests compiler fail for join program with replicated data source behind map and changing parallelism.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindMapChangingparallelism() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap()).setParallelism(DEFAULT_PARALLELISM+1)_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,map,and,changing,parallelism;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,map,changingparallelism,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,set,parallelism,1,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindMapChangingparallelism();1447879320;Tests compiler fail for join program with replicated data source behind map and changing parallelism.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindMapChangingparallelism() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap()).setParallelism(DEFAULT_PARALLELISM+1)_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,map,and,changing,parallelism;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,map,changingparallelism,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,set,parallelism,1,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindMapChangingparallelism();1449526184;Tests compiler fail for join program with replicated data source behind map and changing parallelism.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindMapChangingparallelism() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap()).setParallelism(DEFAULT_PARALLELISM+1)_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		Plan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,map,and,changing,parallelism;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,map,changingparallelism,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,set,parallelism,1,join,source2,where,equal,to,write,as,text,some,newpath,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMap();1426843274;Tests join program with replicated data source behind map.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setDegreeOfParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map;test,public,void,check,join,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,degree,of,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMap();1427097830;Tests join program with replicated data source behind map.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map;test,public,void,check,join,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMap();1427312339;Tests join program with replicated data source behind map.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map;test,public,void,check,join,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMap();1427784999;Tests join program with replicated data source behind map.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map;test,public,void,check,join,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMap();1430859707;Tests join program with replicated data source behind map.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map;test,public,void,check,join,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMap();1447879320;Tests join program with replicated data source behind map.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map;test,public,void,check,join,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMap();1449526184;Tests join program with replicated data source behind map.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMap() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.map(new IdMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		Plan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map;test,public,void,check,join,with,replicated,source,input,behind,map,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,new,id,map,join,source2,where,equal,to,write,as,text,some,newpath,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindReduce();1426843274;Tests compiler fail for join program with replicated data source behind reduce.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindReduce() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setDegreeOfParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.reduce(new LastReduce())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,reduce;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,reduce,execution,environment,env,execution,environment,create,local,environment,env,set,degree,of,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,reduce,new,last,reduce,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindReduce();1427097830;Tests compiler fail for join program with replicated data source behind reduce.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindReduce() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.reduce(new LastReduce())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,reduce;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,reduce,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,reduce,new,last,reduce,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindReduce();1427312339;Tests compiler fail for join program with replicated data source behind reduce.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindReduce() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.reduce(new LastReduce())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,reduce;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,reduce,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,reduce,new,last,reduce,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindReduce();1427784999;Tests compiler fail for join program with replicated data source behind reduce.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindReduce() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.reduce(new LastReduce())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,reduce;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,reduce,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,reduce,new,last,reduce,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindReduce();1430859707;Tests compiler fail for join program with replicated data source behind reduce.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindReduce() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.reduce(new LastReduce())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,reduce;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,reduce,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,reduce,new,last,reduce,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindReduce();1447879320;Tests compiler fail for join program with replicated data source behind reduce.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindReduce() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.reduce(new LastReduce())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,reduce;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,reduce,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,reduce,new,last,reduce,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test(expected = CompilerException.class) 	public void checkJoinWithReplicatedSourceInputBehindReduce();1449526184;Tests compiler fail for join program with replicated data source behind reduce.;@Test(expected = CompilerException.class)_	public void checkJoinWithReplicatedSourceInputBehindReduce() {_		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.reduce(new LastReduce())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		Plan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)__	};tests,compiler,fail,for,join,program,with,replicated,data,source,behind,reduce;test,expected,compiler,exception,class,public,void,check,join,with,replicated,source,input,behind,reduce,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,reduce,new,last,reduce,join,source2,where,equal,to,write,as,text,some,newpath,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMapPartition();1426843274;Tests join program with replicated data source behind map partition.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMapPartition() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setDegreeOfParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.mapPartition(new IdPMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map,partition;test,public,void,check,join,with,replicated,source,input,behind,map,partition,execution,environment,env,execution,environment,create,local,environment,env,set,degree,of,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,partition,new,id,pmap,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMapPartition();1427097830;Tests join program with replicated data source behind map partition.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMapPartition() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.mapPartition(new IdPMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map,partition;test,public,void,check,join,with,replicated,source,input,behind,map,partition,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,partition,new,id,pmap,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMapPartition();1427312339;Tests join program with replicated data source behind map partition.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMapPartition() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.mapPartition(new IdPMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map,partition;test,public,void,check,join,with,replicated,source,input,behind,map,partition,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,partition,new,id,pmap,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMapPartition();1427784999;Tests join program with replicated data source behind map partition.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMapPartition() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.mapPartition(new IdPMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map,partition;test,public,void,check,join,with,replicated,source,input,behind,map,partition,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,partition,new,id,pmap,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMapPartition();1430859707;Tests join program with replicated data source behind map partition.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMapPartition() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.mapPartition(new IdPMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map,partition;test,public,void,check,join,with,replicated,source,input,behind,map,partition,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,partition,new,id,pmap,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMapPartition();1447879320;Tests join program with replicated data source behind map partition.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMapPartition() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.mapPartition(new IdPMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map,partition;test,public,void,check,join,with,replicated,source,input,behind,map,partition,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,partition,new,id,pmap,join,source2,where,equal,to,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkJoinWithReplicatedSourceInputBehindMapPartition();1449526184;Tests join program with replicated data source behind map partition.;@Test_	public void checkJoinWithReplicatedSourceInputBehindMapPartition() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.mapPartition(new IdPMap())_				.join(source2).where("*").equalTo("*")_				.writeAsText("/some/newpath")___		Plan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType joinIn1 = joinNode.getInput1().getShipStrategy()__		ShipStrategyType joinIn2 = joinNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, joinIn2)__	};tests,join,program,with,replicated,data,source,behind,map,partition;test,public,void,check,join,with,replicated,source,input,behind,map,partition,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,map,partition,new,id,pmap,join,source2,where,equal,to,write,as,text,some,newpath,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,join,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,join,in1,join,node,get,input1,get,ship,strategy,ship,strategy,type,join,in2,join,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,join,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInput();1426843274;Tests cross program with replicated data source.;@Test_	public void checkCrossWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setDegreeOfParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.cross(source2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source;test,public,void,check,cross,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,degree,of,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,cross,source2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInput();1427097830;Tests cross program with replicated data source.;@Test_	public void checkCrossWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), String.class))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.cross(source2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source;test,public,void,check,cross,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,string,class,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,cross,source2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInput();1427312339;Tests cross program with replicated data source.;@Test_	public void checkCrossWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.cross(source2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source;test,public,void,check,cross,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,cross,source2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInput();1427784999;Tests cross program with replicated data source.;@Test_	public void checkCrossWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.cross(source2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source;test,public,void,check,cross,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,cross,source2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInput();1430859707;Tests cross program with replicated data source.;@Test_	public void checkCrossWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new CsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.cross(source2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source;test,public,void,check,cross,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,cross,source2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInput();1447879320;Tests cross program with replicated data source.;@Test_	public void checkCrossWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.cross(source2)_				.writeAsText("/some/newpath")___		JavaPlan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source;test,public,void,check,cross,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,cross,source2,write,as,text,some,newpath,java,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
ReplicatingDataSourceTest -> @Test 	public void checkCrossWithReplicatedSourceInput();1449526184;Tests cross program with replicated data source.;@Test_	public void checkCrossWithReplicatedSourceInput() {__		ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		TupleTypeInfo<Tuple1<String>> typeInfo = TupleTypeInfo.getBasicTupleTypeInfo(String.class)__		ReplicatingInputFormat<Tuple1<String>, FileInputSplit> rif =_				new ReplicatingInputFormat<Tuple1<String>, FileInputSplit>(new TupleCsvInputFormat<Tuple1<String>>(new Path("/some/path"), typeInfo))___		DataSet<Tuple1<String>> source1 = env.createInput(rif, new TupleTypeInfo<Tuple1<String>>(BasicTypeInfo.STRING_TYPE_INFO))__		DataSet<Tuple1<String>> source2 = env.readCsvFile("/some/otherpath").types(String.class)___		DataSink<Tuple2<Tuple1<String>, Tuple1<String>>> out = source1_				.cross(source2)_				.writeAsText("/some/newpath")___		Plan plan = env.createProgramPlan()___		_		OptimizedPlan oPlan = compileNoStats(plan)___		_		_		SinkPlanNode sinkNode = oPlan.getDataSinks().iterator().next()__		DualInputPlanNode crossNode = (DualInputPlanNode) sinkNode.getPredecessor()___		ShipStrategyType crossIn1 = crossNode.getInput1().getShipStrategy()__		ShipStrategyType crossIn2 = crossNode.getInput2().getShipStrategy()___		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn1)__		Assert.assertEquals("Invalid ship strategy for an operator.", ShipStrategyType.FORWARD, crossIn2)__	};tests,cross,program,with,replicated,data,source;test,public,void,check,cross,with,replicated,source,input,execution,environment,env,execution,environment,create,local,environment,env,set,parallelism,tuple,type,info,tuple1,string,type,info,tuple,type,info,get,basic,tuple,type,info,string,class,replicating,input,format,tuple1,string,file,input,split,rif,new,replicating,input,format,tuple1,string,file,input,split,new,tuple,csv,input,format,tuple1,string,new,path,some,path,type,info,data,set,tuple1,string,source1,env,create,input,rif,new,tuple,type,info,tuple1,string,basic,type,info,data,set,tuple1,string,source2,env,read,csv,file,some,otherpath,types,string,class,data,sink,tuple2,tuple1,string,tuple1,string,out,source1,cross,source2,write,as,text,some,newpath,plan,plan,env,create,program,plan,optimized,plan,o,plan,compile,no,stats,plan,sink,plan,node,sink,node,o,plan,get,data,sinks,iterator,next,dual,input,plan,node,cross,node,dual,input,plan,node,sink,node,get,predecessor,ship,strategy,type,cross,in1,cross,node,get,input1,get,ship,strategy,ship,strategy,type,cross,in2,cross,node,get,input2,get,ship,strategy,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in1,assert,assert,equals,invalid,ship,strategy,for,an,operator,ship,strategy,type,forward,cross,in2
