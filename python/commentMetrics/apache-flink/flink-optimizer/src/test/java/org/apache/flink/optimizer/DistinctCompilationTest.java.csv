commented;modifiers;parameterAmount;loc;comment;code
false;public;0;51;;@Test public void testDistinctPlain() {     try {         ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(8).         DataSet<Tuple2<String, Double>> data = env.readCsvFile("file:///will/never/be/read").types(String.class, Double.class).name("source").setParallelism(6).         data.distinct().name("reducer").output(new DiscardingOutputFormat<Tuple2<String, Double>>()).name("sink").         Plan p = env.createProgramPlan().         OptimizedPlan op = compileNoStats(p).         OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(op).         // get the original nodes         SourcePlanNode sourceNode = resolver.getNode("source").         SingleInputPlanNode reduceNode = resolver.getNode("reducer").         SinkPlanNode sinkNode = resolver.getNode("sink").         // get the combiner         SingleInputPlanNode combineNode = (SingleInputPlanNode) reduceNode.getInput().getSource().         // check wiring         assertEquals(sourceNode, combineNode.getInput().getSource()).         assertEquals(reduceNode, sinkNode.getInput().getSource()).         // check that both reduce and combiner have the same strategy         assertEquals(DriverStrategy.SORTED_REDUCE, reduceNode.getDriverStrategy()).         assertEquals(DriverStrategy.SORTED_PARTIAL_REDUCE, combineNode.getDriverStrategy()).         // check the keys         assertEquals(new FieldList(0, 1), reduceNode.getKeys(0)).         assertEquals(new FieldList(0, 1), combineNode.getKeys(0)).         assertEquals(new FieldList(0, 1), reduceNode.getInput().getLocalStrategyKeys()).         // check parallelism         assertEquals(6, sourceNode.getParallelism()).         assertEquals(6, combineNode.getParallelism()).         assertEquals(8, reduceNode.getParallelism()).         assertEquals(8, sinkNode.getParallelism()).     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail(e.getClass().getSimpleName() + " in test: " + e.getMessage()).     } }
false;public;0;50;;@Test public void testDistinctWithCombineHint() {     try {         ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(8).         DataSet<Tuple2<String, Double>> data = env.readCsvFile("file:///will/never/be/read").types(String.class, Double.class).name("source").setParallelism(6).         data.distinct().setCombineHint(CombineHint.HASH).name("reducer").output(new DiscardingOutputFormat<Tuple2<String, Double>>()).name("sink").         Plan p = env.createProgramPlan().         OptimizedPlan op = compileNoStats(p).         OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(op).         // get the original nodes         SourcePlanNode sourceNode = resolver.getNode("source").         SingleInputPlanNode reduceNode = resolver.getNode("reducer").         SinkPlanNode sinkNode = resolver.getNode("sink").         // get the combiner         SingleInputPlanNode combineNode = (SingleInputPlanNode) reduceNode.getInput().getSource().         // check wiring         assertEquals(sourceNode, combineNode.getInput().getSource()).         assertEquals(reduceNode, sinkNode.getInput().getSource()).         // check that both reduce and combiner have the same strategy         assertEquals(DriverStrategy.SORTED_REDUCE, reduceNode.getDriverStrategy()).         assertEquals(DriverStrategy.HASHED_PARTIAL_REDUCE, combineNode.getDriverStrategy()).         // check the keys         assertEquals(new FieldList(0, 1), reduceNode.getKeys(0)).         assertEquals(new FieldList(0, 1), combineNode.getKeys(0)).         assertEquals(new FieldList(0, 1), reduceNode.getInput().getLocalStrategyKeys()).         // check parallelism         assertEquals(6, sourceNode.getParallelism()).         assertEquals(6, combineNode.getParallelism()).         assertEquals(8, reduceNode.getParallelism()).         assertEquals(8, sinkNode.getParallelism()).     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail(e.getClass().getSimpleName() + " in test: " + e.getMessage()).     } }
false;public;1;1;;public String getKey(Tuple2<String, Double> value) {     return value.f0. }
false;public;0;60;;@Test public void testDistinctWithSelectorFunctionKey() {     try {         ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(8).         DataSet<Tuple2<String, Double>> data = env.readCsvFile("file:///will/never/be/read").types(String.class, Double.class).name("source").setParallelism(6).         data.distinct(new KeySelector<Tuple2<String, Double>, String>() {              public String getKey(Tuple2<String, Double> value) {                 return value.f0.             }         }).name("reducer").output(new DiscardingOutputFormat<Tuple2<String, Double>>()).name("sink").         Plan p = env.createProgramPlan().         OptimizedPlan op = compileNoStats(p).         OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(op).         // get the original nodes         SourcePlanNode sourceNode = resolver.getNode("source").         SingleInputPlanNode reduceNode = resolver.getNode("reducer").         SinkPlanNode sinkNode = resolver.getNode("sink").         // get the combiner         SingleInputPlanNode combineNode = (SingleInputPlanNode) reduceNode.getInput().getSource().         // get the key extractors and projectors         SingleInputPlanNode keyExtractor = (SingleInputPlanNode) combineNode.getInput().getSource().         SingleInputPlanNode keyProjector = (SingleInputPlanNode) sinkNode.getInput().getSource().         // check wiring         assertEquals(sourceNode, keyExtractor.getInput().getSource()).         assertEquals(keyProjector, sinkNode.getInput().getSource()).         // check that both reduce and combiner have the same strategy         assertEquals(DriverStrategy.SORTED_REDUCE, reduceNode.getDriverStrategy()).         assertEquals(DriverStrategy.SORTED_PARTIAL_REDUCE, combineNode.getDriverStrategy()).         // check the keys         assertEquals(new FieldList(0), reduceNode.getKeys(0)).         assertEquals(new FieldList(0), combineNode.getKeys(0)).         assertEquals(new FieldList(0), reduceNode.getInput().getLocalStrategyKeys()).         // check parallelism         assertEquals(6, sourceNode.getParallelism()).         assertEquals(6, keyExtractor.getParallelism()).         assertEquals(6, combineNode.getParallelism()).         assertEquals(8, reduceNode.getParallelism()).         assertEquals(8, keyProjector.getParallelism()).         assertEquals(8, sinkNode.getParallelism()).     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail(e.getClass().getSimpleName() + " in test: " + e.getMessage()).     } }
false;public;0;52;;@Test public void testDistinctWithFieldPositionKeyCombinable() {     try {         ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(8).         DataSet<Tuple2<String, Double>> data = env.readCsvFile("file:///will/never/be/read").types(String.class, Double.class).name("source").setParallelism(6).         DistinctOperator<Tuple2<String, Double>> reduced = data.distinct(1).name("reducer").         reduced.output(new DiscardingOutputFormat<Tuple2<String, Double>>()).name("sink").         Plan p = env.createProgramPlan().         OptimizedPlan op = compileNoStats(p).         OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(op).         // get the original nodes         SourcePlanNode sourceNode = resolver.getNode("source").         SingleInputPlanNode reduceNode = resolver.getNode("reducer").         SinkPlanNode sinkNode = resolver.getNode("sink").         // get the combiner         SingleInputPlanNode combineNode = (SingleInputPlanNode) reduceNode.getInput().getSource().         // check wiring         assertEquals(sourceNode, combineNode.getInput().getSource()).         assertEquals(reduceNode, sinkNode.getInput().getSource()).         // check that both reduce and combiner have the same strategy         assertEquals(DriverStrategy.SORTED_REDUCE, reduceNode.getDriverStrategy()).         assertEquals(DriverStrategy.SORTED_PARTIAL_REDUCE, combineNode.getDriverStrategy()).         // check the keys         assertEquals(new FieldList(1), reduceNode.getKeys(0)).         assertEquals(new FieldList(1), combineNode.getKeys(0)).         assertEquals(new FieldList(1), reduceNode.getInput().getLocalStrategyKeys()).         // check parallelism         assertEquals(6, sourceNode.getParallelism()).         assertEquals(6, combineNode.getParallelism()).         assertEquals(8, reduceNode.getParallelism()).         assertEquals(8, sinkNode.getParallelism()).     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail(e.getClass().getSimpleName() + " in test: " + e.getMessage()).     } }
