# id;timestamp;commentText;codeText;commentWords;codeWords
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithRangePartitioning() throws Exception;1479922544;Checks that a plan with consecutive UNIONs followed by PARTITION_RANGE is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 -> PartitionByRange -> Output_Src3 ----------------/__In the resulting plan, the range partitioning must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithRangePartitioning() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)___		union123.partitionByRange(1).output(new DiscardingOutputFormat<Tuple2<Long, Long>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode sink = resolver.getNode("out")___		_		assertEquals("Sink input should be range partitioned.",_			PartitioningProperty.RANGE_PARTITIONED, sink.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Sink input should be range partitioned on 1",_			new Ordering(1, null, Order.ASCENDING), sink.getInput().getGlobalProperties().getPartitioningOrdering())___		SingleInputPlanNode partitioner = (SingleInputPlanNode)sink.getInput().getSource()__		assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP)__		assertEquals("Partitioner input should be range partitioned.",_			PartitioningProperty.RANGE_PARTITIONED, partitioner.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Partitioner input should be range partitioned on 1",_			new Ordering(1, null, Order.ASCENDING), partitioner.getInput().getGlobalProperties().getPartitioningOrdering())__		assertEquals("Partitioner input channel should be forwarding",_			ShipStrategyType.FORWARD, partitioner.getInput().getShipStrategy())___		NAryUnionPlanNode union = (NAryUnionPlanNode)partitioner.getInput().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be force rebalanced",_				PartitioningProperty.RANGE_PARTITIONED, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be rebalancing",_				ShipStrategyType.FORWARD, c.getShipStrategy())__			_			SingleInputPlanNode partitionMap = (SingleInputPlanNode)c.getSource()__			assertEquals(DriverStrategy.MAP, partitionMap.getDriverStrategy())__			assertEquals(ShipStrategyType.PARTITION_CUSTOM, partitionMap.getInput().getShipStrategy())__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,partition,by,range,output,src3,in,the,resulting,plan,the,range,partitioning,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,range,partitioning,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,partition,by,range,1,output,new,discarding,output,format,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,sink,resolver,get,node,out,assert,equals,sink,input,should,be,range,partitioned,partitioning,property,sink,get,input,get,global,properties,get,partitioning,assert,equals,sink,input,should,be,range,partitioned,on,1,new,ordering,1,null,order,ascending,sink,get,input,get,global,properties,get,partitioning,ordering,single,input,plan,node,partitioner,single,input,plan,node,sink,get,input,get,source,assert,true,partitioner,get,driver,strategy,driver,strategy,assert,equals,partitioner,input,should,be,range,partitioned,partitioning,property,partitioner,get,input,get,global,properties,get,partitioning,assert,equals,partitioner,input,should,be,range,partitioned,on,1,new,ordering,1,null,order,ascending,partitioner,get,input,get,global,properties,get,partitioning,ordering,assert,equals,partitioner,input,channel,should,be,forwarding,ship,strategy,type,forward,partitioner,get,input,get,ship,strategy,nary,union,plan,node,union,nary,union,plan,node,partitioner,get,input,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,force,rebalanced,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,rebalancing,ship,strategy,type,forward,c,get,ship,strategy,single,input,plan,node,partition,map,single,input,plan,node,c,get,source,assert,equals,driver,strategy,map,partition,map,get,driver,strategy,assert,equals,ship,strategy,type,partition,map,get,input,get,ship,strategy
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithRangePartitioning() throws Exception;1484927904;Checks that a plan with consecutive UNIONs followed by PARTITION_RANGE is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 -> PartitionByRange -> Output_Src3 ----------------/__In the resulting plan, the range partitioning must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithRangePartitioning() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)___		union123.partitionByRange(1).output(new DiscardingOutputFormat<Tuple2<Long, Long>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode sink = resolver.getNode("out")___		_		assertEquals("Sink input should be range partitioned.",_			PartitioningProperty.RANGE_PARTITIONED, sink.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Sink input should be range partitioned on 1",_			new Ordering(1, null, Order.ASCENDING), sink.getInput().getGlobalProperties().getPartitioningOrdering())___		SingleInputPlanNode partitioner = (SingleInputPlanNode)sink.getInput().getSource()__		assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP)__		assertEquals("Partitioner input should be range partitioned.",_			PartitioningProperty.RANGE_PARTITIONED, partitioner.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Partitioner input should be range partitioned on 1",_			new Ordering(1, null, Order.ASCENDING), partitioner.getInput().getGlobalProperties().getPartitioningOrdering())__		assertEquals("Partitioner input channel should be forwarding",_			ShipStrategyType.FORWARD, partitioner.getInput().getShipStrategy())___		NAryUnionPlanNode union = (NAryUnionPlanNode)partitioner.getInput().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be range partitioned",_				PartitioningProperty.RANGE_PARTITIONED, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be forwarded",_				ShipStrategyType.FORWARD, c.getShipStrategy())__			_			SingleInputPlanNode partitionMap = (SingleInputPlanNode)c.getSource()__			assertEquals(DriverStrategy.MAP, partitionMap.getDriverStrategy())__			assertEquals(ShipStrategyType.PARTITION_CUSTOM, partitionMap.getInput().getShipStrategy())__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,partition,by,range,output,src3,in,the,resulting,plan,the,range,partitioning,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,range,partitioning,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,partition,by,range,1,output,new,discarding,output,format,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,sink,resolver,get,node,out,assert,equals,sink,input,should,be,range,partitioned,partitioning,property,sink,get,input,get,global,properties,get,partitioning,assert,equals,sink,input,should,be,range,partitioned,on,1,new,ordering,1,null,order,ascending,sink,get,input,get,global,properties,get,partitioning,ordering,single,input,plan,node,partitioner,single,input,plan,node,sink,get,input,get,source,assert,true,partitioner,get,driver,strategy,driver,strategy,assert,equals,partitioner,input,should,be,range,partitioned,partitioning,property,partitioner,get,input,get,global,properties,get,partitioning,assert,equals,partitioner,input,should,be,range,partitioned,on,1,new,ordering,1,null,order,ascending,partitioner,get,input,get,global,properties,get,partitioning,ordering,assert,equals,partitioner,input,channel,should,be,forwarding,ship,strategy,type,forward,partitioner,get,input,get,ship,strategy,nary,union,plan,node,union,nary,union,plan,node,partitioner,get,input,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,range,partitioned,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,forwarded,ship,strategy,type,forward,c,get,ship,strategy,single,input,plan,node,partition,map,single,input,plan,node,c,get,source,assert,equals,driver,strategy,map,partition,map,get,driver,strategy,assert,equals,ship,strategy,type,partition,map,get,input,get,ship,strategy
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithRangePartitioning() throws Exception;1516028607;Checks that a plan with consecutive UNIONs followed by PARTITION_RANGE is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 -> PartitionByRange -> Output_Src3 ----------------/__In the resulting plan, the range partitioning must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithRangePartitioning() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)___		union123.partitionByRange(1).output(new DiscardingOutputFormat<Tuple2<Long, Long>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode sink = resolver.getNode("out")___		_		assertEquals("Sink input should be range partitioned.",_			PartitioningProperty.RANGE_PARTITIONED, sink.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Sink input should be range partitioned on 1",_			new Ordering(1, null, Order.ASCENDING), sink.getInput().getGlobalProperties().getPartitioningOrdering())___		SingleInputPlanNode partitioner = (SingleInputPlanNode)sink.getInput().getSource()__		assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP)__		assertEquals("Partitioner input should be range partitioned.",_			PartitioningProperty.RANGE_PARTITIONED, partitioner.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Partitioner input should be range partitioned on 1",_			new Ordering(1, null, Order.ASCENDING), partitioner.getInput().getGlobalProperties().getPartitioningOrdering())__		assertEquals("Partitioner input channel should be forwarding",_			ShipStrategyType.FORWARD, partitioner.getInput().getShipStrategy())___		NAryUnionPlanNode union = (NAryUnionPlanNode)partitioner.getInput().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be range partitioned",_				PartitioningProperty.RANGE_PARTITIONED, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be forwarded",_				ShipStrategyType.FORWARD, c.getShipStrategy())__			_			SingleInputPlanNode partitionMap = (SingleInputPlanNode)c.getSource()__			assertEquals(DriverStrategy.MAP, partitionMap.getDriverStrategy())__			assertEquals(ShipStrategyType.PARTITION_CUSTOM, partitionMap.getInput().getShipStrategy())__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,partition,by,range,output,src3,in,the,resulting,plan,the,range,partitioning,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,range,partitioning,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,partition,by,range,1,output,new,discarding,output,format,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,sink,resolver,get,node,out,assert,equals,sink,input,should,be,range,partitioned,partitioning,property,sink,get,input,get,global,properties,get,partitioning,assert,equals,sink,input,should,be,range,partitioned,on,1,new,ordering,1,null,order,ascending,sink,get,input,get,global,properties,get,partitioning,ordering,single,input,plan,node,partitioner,single,input,plan,node,sink,get,input,get,source,assert,true,partitioner,get,driver,strategy,driver,strategy,assert,equals,partitioner,input,should,be,range,partitioned,partitioning,property,partitioner,get,input,get,global,properties,get,partitioning,assert,equals,partitioner,input,should,be,range,partitioned,on,1,new,ordering,1,null,order,ascending,partitioner,get,input,get,global,properties,get,partitioning,ordering,assert,equals,partitioner,input,channel,should,be,forwarding,ship,strategy,type,forward,partitioner,get,input,get,ship,strategy,nary,union,plan,node,union,nary,union,plan,node,partitioner,get,input,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,range,partitioned,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,forwarded,ship,strategy,type,forward,c,get,ship,strategy,single,input,plan,node,partition,map,single,input,plan,node,c,get,source,assert,equals,driver,strategy,map,partition,map,get,driver,strategy,assert,equals,ship,strategy,type,partition,map,get,input,get,ship,strategy
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithRangePartitioning() throws Exception;1522323145;Checks that a plan with consecutive UNIONs followed by PARTITION_RANGE is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 -> PartitionByRange -> Output_Src3 ----------------/__In the resulting plan, the range partitioning must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithRangePartitioning() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)___		union123.partitionByRange(1).output(new DiscardingOutputFormat<Tuple2<Long, Long>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode sink = resolver.getNode("out")___		_		assertEquals("Sink input should be range partitioned.",_			PartitioningProperty.RANGE_PARTITIONED, sink.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Sink input should be range partitioned on 1",_			new Ordering(1, null, Order.ASCENDING), sink.getInput().getGlobalProperties().getPartitioningOrdering())___		SingleInputPlanNode partitioner = (SingleInputPlanNode)sink.getInput().getSource()__		assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP)__		assertEquals("Partitioner input should be range partitioned.",_			PartitioningProperty.RANGE_PARTITIONED, partitioner.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Partitioner input should be range partitioned on 1",_			new Ordering(1, null, Order.ASCENDING), partitioner.getInput().getGlobalProperties().getPartitioningOrdering())__		assertEquals("Partitioner input channel should be forwarding",_			ShipStrategyType.FORWARD, partitioner.getInput().getShipStrategy())___		NAryUnionPlanNode union = (NAryUnionPlanNode)partitioner.getInput().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be range partitioned",_				PartitioningProperty.RANGE_PARTITIONED, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be forwarded",_				ShipStrategyType.FORWARD, c.getShipStrategy())__			_			SingleInputPlanNode partitionMap = (SingleInputPlanNode)c.getSource()__			assertEquals(DriverStrategy.MAP, partitionMap.getDriverStrategy())__			assertEquals(ShipStrategyType.PARTITION_CUSTOM, partitionMap.getInput().getShipStrategy())__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,partition,by,range,output,src3,in,the,resulting,plan,the,range,partitioning,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,range,partitioning,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,partition,by,range,1,output,new,discarding,output,format,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,sink,resolver,get,node,out,assert,equals,sink,input,should,be,range,partitioned,partitioning,property,sink,get,input,get,global,properties,get,partitioning,assert,equals,sink,input,should,be,range,partitioned,on,1,new,ordering,1,null,order,ascending,sink,get,input,get,global,properties,get,partitioning,ordering,single,input,plan,node,partitioner,single,input,plan,node,sink,get,input,get,source,assert,true,partitioner,get,driver,strategy,driver,strategy,assert,equals,partitioner,input,should,be,range,partitioned,partitioning,property,partitioner,get,input,get,global,properties,get,partitioning,assert,equals,partitioner,input,should,be,range,partitioned,on,1,new,ordering,1,null,order,ascending,partitioner,get,input,get,global,properties,get,partitioning,ordering,assert,equals,partitioner,input,channel,should,be,forwarding,ship,strategy,type,forward,partitioner,get,input,get,ship,strategy,nary,union,plan,node,union,nary,union,plan,node,partitioner,get,input,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,range,partitioned,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,forwarded,ship,strategy,type,forward,c,get,ship,strategy,single,input,plan,node,partition,map,single,input,plan,node,c,get,source,assert,equals,driver,strategy,map,partition,map,get,driver,strategy,assert,equals,ship,strategy,type,partition,map,get,input,get,ship,strategy
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithRebalance() throws Exception;1479922544;Checks that a plan with consecutive UNIONs followed by REBALANCE is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 -> Rebalance -> Output_Src3 ----------------/__In the resulting plan, the Rebalance (ShippingStrategy.PARTITION_FORCED_REBALANCE) must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithRebalance() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)___		union123.rebalance().output(new DiscardingOutputFormat<Tuple2<Long, Long>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode sink = resolver.getNode("out")___		_		assertEquals("Sink input should be force rebalanced.",_			PartitioningProperty.FORCED_REBALANCED, sink.getInput().getGlobalProperties().getPartitioning())___		SingleInputPlanNode partitioner = (SingleInputPlanNode)sink.getInput().getSource()__		assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP)__		assertEquals("Partitioner input should be force rebalanced.",_			PartitioningProperty.FORCED_REBALANCED, partitioner.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Partitioner input channel should be forwarding",_			ShipStrategyType.FORWARD, partitioner.getInput().getShipStrategy())___		NAryUnionPlanNode union = (NAryUnionPlanNode)partitioner.getInput().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be force rebalanced",_				PartitioningProperty.FORCED_REBALANCED, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be rebalancing",_				ShipStrategyType.PARTITION_FORCED_REBALANCE, c.getShipStrategy())__			assertTrue("Union input should be data source",_				c.getSource() instanceof SourcePlanNode)__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,rebalance,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,rebalance,output,src3,in,the,resulting,plan,the,rebalance,shipping,strategy,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,rebalance,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,rebalance,output,new,discarding,output,format,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,sink,resolver,get,node,out,assert,equals,sink,input,should,be,force,rebalanced,partitioning,property,sink,get,input,get,global,properties,get,partitioning,single,input,plan,node,partitioner,single,input,plan,node,sink,get,input,get,source,assert,true,partitioner,get,driver,strategy,driver,strategy,assert,equals,partitioner,input,should,be,force,rebalanced,partitioning,property,partitioner,get,input,get,global,properties,get,partitioning,assert,equals,partitioner,input,channel,should,be,forwarding,ship,strategy,type,forward,partitioner,get,input,get,ship,strategy,nary,union,plan,node,union,nary,union,plan,node,partitioner,get,input,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,force,rebalanced,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,rebalancing,ship,strategy,type,c,get,ship,strategy,assert,true,union,input,should,be,data,source,c,get,source,instanceof,source,plan,node
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithRebalance() throws Exception;1484927904;Checks that a plan with consecutive UNIONs followed by REBALANCE is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 -> Rebalance -> Output_Src3 ----------------/__In the resulting plan, the Rebalance (ShippingStrategy.PARTITION_FORCED_REBALANCE) must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithRebalance() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)___		union123.rebalance().output(new DiscardingOutputFormat<Tuple2<Long, Long>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode sink = resolver.getNode("out")___		_		assertEquals("Sink input should be force rebalanced.",_			PartitioningProperty.FORCED_REBALANCED, sink.getInput().getGlobalProperties().getPartitioning())___		SingleInputPlanNode partitioner = (SingleInputPlanNode)sink.getInput().getSource()__		assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP)__		assertEquals("Partitioner input should be force rebalanced.",_			PartitioningProperty.FORCED_REBALANCED, partitioner.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Partitioner input channel should be forwarding",_			ShipStrategyType.FORWARD, partitioner.getInput().getShipStrategy())___		NAryUnionPlanNode union = (NAryUnionPlanNode)partitioner.getInput().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be force rebalanced",_				PartitioningProperty.FORCED_REBALANCED, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be rebalancing",_				ShipStrategyType.PARTITION_FORCED_REBALANCE, c.getShipStrategy())__			assertTrue("Union input should be data source",_				c.getSource() instanceof SourcePlanNode)__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,rebalance,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,rebalance,output,src3,in,the,resulting,plan,the,rebalance,shipping,strategy,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,rebalance,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,rebalance,output,new,discarding,output,format,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,sink,resolver,get,node,out,assert,equals,sink,input,should,be,force,rebalanced,partitioning,property,sink,get,input,get,global,properties,get,partitioning,single,input,plan,node,partitioner,single,input,plan,node,sink,get,input,get,source,assert,true,partitioner,get,driver,strategy,driver,strategy,assert,equals,partitioner,input,should,be,force,rebalanced,partitioning,property,partitioner,get,input,get,global,properties,get,partitioning,assert,equals,partitioner,input,channel,should,be,forwarding,ship,strategy,type,forward,partitioner,get,input,get,ship,strategy,nary,union,plan,node,union,nary,union,plan,node,partitioner,get,input,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,force,rebalanced,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,rebalancing,ship,strategy,type,c,get,ship,strategy,assert,true,union,input,should,be,data,source,c,get,source,instanceof,source,plan,node
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithRebalance() throws Exception;1516028607;Checks that a plan with consecutive UNIONs followed by REBALANCE is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 -> Rebalance -> Output_Src3 ----------------/__In the resulting plan, the Rebalance (ShippingStrategy.PARTITION_FORCED_REBALANCE) must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithRebalance() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)___		union123.rebalance().output(new DiscardingOutputFormat<Tuple2<Long, Long>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode sink = resolver.getNode("out")___		_		assertEquals("Sink input should be force rebalanced.",_			PartitioningProperty.FORCED_REBALANCED, sink.getInput().getGlobalProperties().getPartitioning())___		SingleInputPlanNode partitioner = (SingleInputPlanNode)sink.getInput().getSource()__		assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP)__		assertEquals("Partitioner input should be force rebalanced.",_			PartitioningProperty.FORCED_REBALANCED, partitioner.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Partitioner input channel should be forwarding",_			ShipStrategyType.FORWARD, partitioner.getInput().getShipStrategy())___		NAryUnionPlanNode union = (NAryUnionPlanNode)partitioner.getInput().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be force rebalanced",_				PartitioningProperty.FORCED_REBALANCED, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be rebalancing",_				ShipStrategyType.PARTITION_FORCED_REBALANCE, c.getShipStrategy())__			assertTrue("Union input should be data source",_				c.getSource() instanceof SourcePlanNode)__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,rebalance,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,rebalance,output,src3,in,the,resulting,plan,the,rebalance,shipping,strategy,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,rebalance,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,rebalance,output,new,discarding,output,format,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,sink,resolver,get,node,out,assert,equals,sink,input,should,be,force,rebalanced,partitioning,property,sink,get,input,get,global,properties,get,partitioning,single,input,plan,node,partitioner,single,input,plan,node,sink,get,input,get,source,assert,true,partitioner,get,driver,strategy,driver,strategy,assert,equals,partitioner,input,should,be,force,rebalanced,partitioning,property,partitioner,get,input,get,global,properties,get,partitioning,assert,equals,partitioner,input,channel,should,be,forwarding,ship,strategy,type,forward,partitioner,get,input,get,ship,strategy,nary,union,plan,node,union,nary,union,plan,node,partitioner,get,input,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,force,rebalanced,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,rebalancing,ship,strategy,type,c,get,ship,strategy,assert,true,union,input,should,be,data,source,c,get,source,instanceof,source,plan,node
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithRebalance() throws Exception;1522323145;Checks that a plan with consecutive UNIONs followed by REBALANCE is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 -> Rebalance -> Output_Src3 ----------------/__In the resulting plan, the Rebalance (ShippingStrategy.PARTITION_FORCED_REBALANCE) must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithRebalance() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)___		union123.rebalance().output(new DiscardingOutputFormat<Tuple2<Long, Long>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode sink = resolver.getNode("out")___		_		assertEquals("Sink input should be force rebalanced.",_			PartitioningProperty.FORCED_REBALANCED, sink.getInput().getGlobalProperties().getPartitioning())___		SingleInputPlanNode partitioner = (SingleInputPlanNode)sink.getInput().getSource()__		assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP)__		assertEquals("Partitioner input should be force rebalanced.",_			PartitioningProperty.FORCED_REBALANCED, partitioner.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Partitioner input channel should be forwarding",_			ShipStrategyType.FORWARD, partitioner.getInput().getShipStrategy())___		NAryUnionPlanNode union = (NAryUnionPlanNode)partitioner.getInput().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be force rebalanced",_				PartitioningProperty.FORCED_REBALANCED, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be rebalancing",_				ShipStrategyType.PARTITION_FORCED_REBALANCE, c.getShipStrategy())__			assertTrue("Union input should be data source",_				c.getSource() instanceof SourcePlanNode)__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,rebalance,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,rebalance,output,src3,in,the,resulting,plan,the,rebalance,shipping,strategy,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,rebalance,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,rebalance,output,new,discarding,output,format,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,sink,resolver,get,node,out,assert,equals,sink,input,should,be,force,rebalanced,partitioning,property,sink,get,input,get,global,properties,get,partitioning,single,input,plan,node,partitioner,single,input,plan,node,sink,get,input,get,source,assert,true,partitioner,get,driver,strategy,driver,strategy,assert,equals,partitioner,input,should,be,force,rebalanced,partitioning,property,partitioner,get,input,get,global,properties,get,partitioning,assert,equals,partitioner,input,channel,should,be,forwarding,ship,strategy,type,forward,partitioner,get,input,get,ship,strategy,nary,union,plan,node,union,nary,union,plan,node,partitioner,get,input,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,force,rebalanced,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,rebalancing,ship,strategy,type,c,get,ship,strategy,assert,true,union,input,should,be,data,source,c,get,source,instanceof,source,plan,node
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithBroadcast() throws Exception;1484927904;Checks that a plan with consecutive UNIONs followed by broadcast-fwd JOIN is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 --> bc-fwd-Join -> Output_Src3 ----------------/             /__Src4 ----------------------------/__In the resulting plan, the broadcasting must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithBroadcast() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src4 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)__		union123.join(src4, JoinOperatorBase.JoinHint.BROADCAST_HASH_FIRST)_			.where(0).equalTo(0).name("join")_			.output(new DiscardingOutputFormat<Tuple2<Tuple2<Long, Long>, Tuple2<Long, Long>>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		DualInputPlanNode join = resolver.getNode("join")___		_		assertEquals("First join input should be fully replicated.",_			PartitioningProperty.FULL_REPLICATION, join.getInput1().getGlobalProperties().getPartitioning())___		NAryUnionPlanNode union = (NAryUnionPlanNode)join.getInput1().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be fully replicated",_				PartitioningProperty.FULL_REPLICATION, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be broadcasting",_				ShipStrategyType.BROADCAST, c.getShipStrategy())__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,broadcast,fwd,join,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,bc,fwd,join,output,src3,src4,in,the,resulting,plan,the,broadcasting,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,broadcast,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src4,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,join,src4,join,operator,base,join,hint,where,0,equal,to,0,name,join,output,new,discarding,output,format,tuple2,tuple2,long,long,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,dual,input,plan,node,join,resolver,get,node,join,assert,equals,first,join,input,should,be,fully,replicated,partitioning,property,join,get,input1,get,global,properties,get,partitioning,nary,union,plan,node,union,nary,union,plan,node,join,get,input1,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,fully,replicated,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,broadcasting,ship,strategy,type,broadcast,c,get,ship,strategy
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithBroadcast() throws Exception;1516028607;Checks that a plan with consecutive UNIONs followed by broadcast-fwd JOIN is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 --> bc-fwd-Join -> Output_Src3 ----------------/             /__Src4 ----------------------------/__In the resulting plan, the broadcasting must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithBroadcast() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src4 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)__		union123.join(src4, JoinOperatorBase.JoinHint.BROADCAST_HASH_FIRST)_			.where(0).equalTo(0).name("join")_			.output(new DiscardingOutputFormat<Tuple2<Tuple2<Long, Long>, Tuple2<Long, Long>>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		DualInputPlanNode join = resolver.getNode("join")___		_		assertEquals("First join input should be fully replicated.",_			PartitioningProperty.FULL_REPLICATION, join.getInput1().getGlobalProperties().getPartitioning())___		NAryUnionPlanNode union = (NAryUnionPlanNode)join.getInput1().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be fully replicated",_				PartitioningProperty.FULL_REPLICATION, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be broadcasting",_				ShipStrategyType.BROADCAST, c.getShipStrategy())__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,broadcast,fwd,join,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,bc,fwd,join,output,src3,src4,in,the,resulting,plan,the,broadcasting,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,broadcast,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src4,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,join,src4,join,operator,base,join,hint,where,0,equal,to,0,name,join,output,new,discarding,output,format,tuple2,tuple2,long,long,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,dual,input,plan,node,join,resolver,get,node,join,assert,equals,first,join,input,should,be,fully,replicated,partitioning,property,join,get,input1,get,global,properties,get,partitioning,nary,union,plan,node,union,nary,union,plan,node,join,get,input1,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,fully,replicated,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,broadcasting,ship,strategy,type,broadcast,c,get,ship,strategy
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithBroadcast() throws Exception;1522323145;Checks that a plan with consecutive UNIONs followed by broadcast-fwd JOIN is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 --> bc-fwd-Join -> Output_Src3 ----------------/             /__Src4 ----------------------------/__In the resulting plan, the broadcasting must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithBroadcast() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src4 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)__		union123.join(src4, JoinOperatorBase.JoinHint.BROADCAST_HASH_FIRST)_			.where(0).equalTo(0).name("join")_			.output(new DiscardingOutputFormat<Tuple2<Tuple2<Long, Long>, Tuple2<Long, Long>>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		DualInputPlanNode join = resolver.getNode("join")___		_		assertEquals("First join input should be fully replicated.",_			PartitioningProperty.FULL_REPLICATION, join.getInput1().getGlobalProperties().getPartitioning())___		NAryUnionPlanNode union = (NAryUnionPlanNode)join.getInput1().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be fully replicated",_				PartitioningProperty.FULL_REPLICATION, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be broadcasting",_				ShipStrategyType.BROADCAST, c.getShipStrategy())__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,broadcast,fwd,join,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,bc,fwd,join,output,src3,src4,in,the,resulting,plan,the,broadcasting,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,broadcast,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src4,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,join,src4,join,operator,base,join,hint,where,0,equal,to,0,name,join,output,new,discarding,output,format,tuple2,tuple2,long,long,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,dual,input,plan,node,join,resolver,get,node,join,assert,equals,first,join,input,should,be,fully,replicated,partitioning,property,join,get,input1,get,global,properties,get,partitioning,nary,union,plan,node,union,nary,union,plan,node,join,get,input1,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,fully,replicated,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,broadcasting,ship,strategy,type,broadcast,c,get,ship,strategy
UnionReplacementTest -> @Test 	public void testUnionWithTwoOutputs() throws Exception;1479922544;Test for FLINK-2662.__Checks that a plan with an union with two outputs is correctly translated._The program can be illustrated as follows:__Src1 ----------------\_>-> Union123 -> GroupBy(0) -> Sum -> Output_Src2 -\              /_>-> Union23--<_Src3 -/              \_>-> Union234 -> GroupBy(1) -> Sum -> Output_Src4 ----------------/__The fix for FLINK-2662 translates the union with two output (Union-23) into two separate_unions (Union-23_1 and Union-23_2) with one output each. Due to this change, the interesting_partitioning properties for GroupBy(0) and GroupBy(1) are pushed through Union-23_1 and_Union-23_2 and do not interfere with each other (which would be the case if Union-23 would_be a single operator with two outputs).;@Test_	public void testUnionWithTwoOutputs() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src4 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union23 = src2.union(src3)__		DataSet<Tuple2<Long, Long>> union123 = src1.union(union23)__		DataSet<Tuple2<Long, Long>> union234 = src4.union(union23)___		union123.groupBy(0).sum(1).name("1").output(new DiscardingOutputFormat<Tuple2<Long, Long>>())__		union234.groupBy(1).sum(0).name("2").output(new DiscardingOutputFormat<Tuple2<Long, Long>>())___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode groupRed1 = resolver.getNode("1")__		SingleInputPlanNode groupRed2 = resolver.getNode("2")___		_		assertTrue("Reduce input should be partitioned on 0.",_			groupRed1.getInput().getGlobalProperties().getPartitioningFields().isExactMatch(new FieldList(0)))__		assertTrue("Reduce input should be partitioned on 1.",_			groupRed2.getInput().getGlobalProperties().getPartitioningFields().isExactMatch(new FieldList(1)))___		_		assertTrue("Reduce input should be n-ary union with three inputs.",_			groupRed1.getInput().getSource() instanceof NAryUnionPlanNode &&_				((NAryUnionPlanNode) groupRed1.getInput().getSource()).getListOfInputs().size() == 3)__		assertTrue("Reduce input should be n-ary union with three inputs.",_			groupRed2.getInput().getSource() instanceof NAryUnionPlanNode &&_				((NAryUnionPlanNode) groupRed2.getInput().getSource()).getListOfInputs().size() == 3)___		_		assertTrue("Channel between union and group reduce should be forwarding",_			groupRed1.getInput().getShipStrategy().equals(ShipStrategyType.FORWARD))__		assertTrue("Channel between union and group reduce should be forwarding",_			groupRed2.getInput().getShipStrategy().equals(ShipStrategyType.FORWARD))___		_		List<Channel> union123In = ((NAryUnionPlanNode) groupRed1.getInput().getSource()).getListOfInputs()__		for(Channel i : union123In) {_			assertTrue("Union input channel should hash partition on 0",_				i.getShipStrategy().equals(ShipStrategyType.PARTITION_HASH) &&_					i.getShipStrategyKeys().isExactMatch(new FieldList(0)))__		}_		List<Channel> union234In = ((NAryUnionPlanNode) groupRed2.getInput().getSource()).getListOfInputs()__		for(Channel i : union234In) {_			assertTrue("Union input channel should hash partition on 0",_				i.getShipStrategy().equals(ShipStrategyType.PARTITION_HASH) &&_					i.getShipStrategyKeys().isExactMatch(new FieldList(1)))__		}__	};test,for,flink,2662,checks,that,a,plan,with,an,union,with,two,outputs,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union123,group,by,0,sum,output,src2,union23,src3,union234,group,by,1,sum,output,src4,the,fix,for,flink,2662,translates,the,union,with,two,output,union,23,into,two,separate,unions,union,and,union,with,one,output,each,due,to,this,change,the,interesting,partitioning,properties,for,group,by,0,and,group,by,1,are,pushed,through,union,and,union,and,do,not,interfere,with,each,other,which,would,be,the,case,if,union,23,would,be,a,single,operator,with,two,outputs;test,public,void,test,union,with,two,outputs,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src4,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union23,src2,union,src3,data,set,tuple2,long,long,union123,src1,union,union23,data,set,tuple2,long,long,union234,src4,union,union23,union123,group,by,0,sum,1,name,1,output,new,discarding,output,format,tuple2,long,long,union234,group,by,1,sum,0,name,2,output,new,discarding,output,format,tuple2,long,long,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,group,red1,resolver,get,node,1,single,input,plan,node,group,red2,resolver,get,node,2,assert,true,reduce,input,should,be,partitioned,on,0,group,red1,get,input,get,global,properties,get,partitioning,fields,is,exact,match,new,field,list,0,assert,true,reduce,input,should,be,partitioned,on,1,group,red2,get,input,get,global,properties,get,partitioning,fields,is,exact,match,new,field,list,1,assert,true,reduce,input,should,be,n,ary,union,with,three,inputs,group,red1,get,input,get,source,instanceof,nary,union,plan,node,nary,union,plan,node,group,red1,get,input,get,source,get,list,of,inputs,size,3,assert,true,reduce,input,should,be,n,ary,union,with,three,inputs,group,red2,get,input,get,source,instanceof,nary,union,plan,node,nary,union,plan,node,group,red2,get,input,get,source,get,list,of,inputs,size,3,assert,true,channel,between,union,and,group,reduce,should,be,forwarding,group,red1,get,input,get,ship,strategy,equals,ship,strategy,type,forward,assert,true,channel,between,union,and,group,reduce,should,be,forwarding,group,red2,get,input,get,ship,strategy,equals,ship,strategy,type,forward,list,channel,union123in,nary,union,plan,node,group,red1,get,input,get,source,get,list,of,inputs,for,channel,i,union123in,assert,true,union,input,channel,should,hash,partition,on,0,i,get,ship,strategy,equals,ship,strategy,type,i,get,ship,strategy,keys,is,exact,match,new,field,list,0,list,channel,union234in,nary,union,plan,node,group,red2,get,input,get,source,get,list,of,inputs,for,channel,i,union234in,assert,true,union,input,channel,should,hash,partition,on,0,i,get,ship,strategy,equals,ship,strategy,type,i,get,ship,strategy,keys,is,exact,match,new,field,list,1
UnionReplacementTest -> @Test 	public void testUnionWithTwoOutputs() throws Exception;1484927904;Test for FLINK-2662.__Checks that a plan with an union with two outputs is correctly translated._The program can be illustrated as follows:__Src1 ----------------\_>-> Union123 -> GroupBy(0) -> Sum -> Output_Src2 -\              /_>-> Union23--<_Src3 -/              \_>-> Union234 -> GroupBy(1) -> Sum -> Output_Src4 ----------------/__The fix for FLINK-2662 translates the union with two output (Union-23) into two separate_unions (Union-23_1 and Union-23_2) with one output each. Due to this change, the interesting_partitioning properties for GroupBy(0) and GroupBy(1) are pushed through Union-23_1 and_Union-23_2 and do not interfere with each other (which would be the case if Union-23 would_be a single operator with two outputs).;@Test_	public void testUnionWithTwoOutputs() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src4 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union23 = src2.union(src3)__		DataSet<Tuple2<Long, Long>> union123 = src1.union(union23)__		DataSet<Tuple2<Long, Long>> union234 = src4.union(union23)___		union123.groupBy(0).sum(1).name("1").output(new DiscardingOutputFormat<Tuple2<Long, Long>>())__		union234.groupBy(1).sum(0).name("2").output(new DiscardingOutputFormat<Tuple2<Long, Long>>())___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode groupRed1 = resolver.getNode("1")__		SingleInputPlanNode groupRed2 = resolver.getNode("2")___		_		assertTrue("Reduce input should be partitioned on 0.",_			groupRed1.getInput().getGlobalProperties().getPartitioningFields().isExactMatch(new FieldList(0)))__		assertTrue("Reduce input should be partitioned on 1.",_			groupRed2.getInput().getGlobalProperties().getPartitioningFields().isExactMatch(new FieldList(1)))___		_		assertTrue("Reduce input should be n-ary union with three inputs.",_			groupRed1.getInput().getSource() instanceof NAryUnionPlanNode &&_				((NAryUnionPlanNode) groupRed1.getInput().getSource()).getListOfInputs().size() == 3)__		assertTrue("Reduce input should be n-ary union with three inputs.",_			groupRed2.getInput().getSource() instanceof NAryUnionPlanNode &&_				((NAryUnionPlanNode) groupRed2.getInput().getSource()).getListOfInputs().size() == 3)___		_		assertTrue("Channel between union and group reduce should be forwarding",_			groupRed1.getInput().getShipStrategy().equals(ShipStrategyType.FORWARD))__		assertTrue("Channel between union and group reduce should be forwarding",_			groupRed2.getInput().getShipStrategy().equals(ShipStrategyType.FORWARD))___		_		List<Channel> union123In = ((NAryUnionPlanNode) groupRed1.getInput().getSource()).getListOfInputs()__		for(Channel i : union123In) {_			assertTrue("Union input channel should hash partition on 0",_				i.getShipStrategy().equals(ShipStrategyType.PARTITION_HASH) &&_					i.getShipStrategyKeys().isExactMatch(new FieldList(0)))__		}_		List<Channel> union234In = ((NAryUnionPlanNode) groupRed2.getInput().getSource()).getListOfInputs()__		for(Channel i : union234In) {_			assertTrue("Union input channel should hash partition on 0",_				i.getShipStrategy().equals(ShipStrategyType.PARTITION_HASH) &&_					i.getShipStrategyKeys().isExactMatch(new FieldList(1)))__		}__	};test,for,flink,2662,checks,that,a,plan,with,an,union,with,two,outputs,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union123,group,by,0,sum,output,src2,union23,src3,union234,group,by,1,sum,output,src4,the,fix,for,flink,2662,translates,the,union,with,two,output,union,23,into,two,separate,unions,union,and,union,with,one,output,each,due,to,this,change,the,interesting,partitioning,properties,for,group,by,0,and,group,by,1,are,pushed,through,union,and,union,and,do,not,interfere,with,each,other,which,would,be,the,case,if,union,23,would,be,a,single,operator,with,two,outputs;test,public,void,test,union,with,two,outputs,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src4,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union23,src2,union,src3,data,set,tuple2,long,long,union123,src1,union,union23,data,set,tuple2,long,long,union234,src4,union,union23,union123,group,by,0,sum,1,name,1,output,new,discarding,output,format,tuple2,long,long,union234,group,by,1,sum,0,name,2,output,new,discarding,output,format,tuple2,long,long,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,group,red1,resolver,get,node,1,single,input,plan,node,group,red2,resolver,get,node,2,assert,true,reduce,input,should,be,partitioned,on,0,group,red1,get,input,get,global,properties,get,partitioning,fields,is,exact,match,new,field,list,0,assert,true,reduce,input,should,be,partitioned,on,1,group,red2,get,input,get,global,properties,get,partitioning,fields,is,exact,match,new,field,list,1,assert,true,reduce,input,should,be,n,ary,union,with,three,inputs,group,red1,get,input,get,source,instanceof,nary,union,plan,node,nary,union,plan,node,group,red1,get,input,get,source,get,list,of,inputs,size,3,assert,true,reduce,input,should,be,n,ary,union,with,three,inputs,group,red2,get,input,get,source,instanceof,nary,union,plan,node,nary,union,plan,node,group,red2,get,input,get,source,get,list,of,inputs,size,3,assert,true,channel,between,union,and,group,reduce,should,be,forwarding,group,red1,get,input,get,ship,strategy,equals,ship,strategy,type,forward,assert,true,channel,between,union,and,group,reduce,should,be,forwarding,group,red2,get,input,get,ship,strategy,equals,ship,strategy,type,forward,list,channel,union123in,nary,union,plan,node,group,red1,get,input,get,source,get,list,of,inputs,for,channel,i,union123in,assert,true,union,input,channel,should,hash,partition,on,0,i,get,ship,strategy,equals,ship,strategy,type,i,get,ship,strategy,keys,is,exact,match,new,field,list,0,list,channel,union234in,nary,union,plan,node,group,red2,get,input,get,source,get,list,of,inputs,for,channel,i,union234in,assert,true,union,input,channel,should,hash,partition,on,0,i,get,ship,strategy,equals,ship,strategy,type,i,get,ship,strategy,keys,is,exact,match,new,field,list,1
UnionReplacementTest -> @Test 	public void testUnionWithTwoOutputs() throws Exception;1516028607;Test for FLINK-2662.__Checks that a plan with an union with two outputs is correctly translated._The program can be illustrated as follows:__Src1 ----------------\_>-> Union123 -> GroupBy(0) -> Sum -> Output_Src2 -\              /_>-> Union23--<_Src3 -/              \_>-> Union234 -> GroupBy(1) -> Sum -> Output_Src4 ----------------/__The fix for FLINK-2662 translates the union with two output (Union-23) into two separate_unions (Union-23_1 and Union-23_2) with one output each. Due to this change, the interesting_partitioning properties for GroupBy(0) and GroupBy(1) are pushed through Union-23_1 and_Union-23_2 and do not interfere with each other (which would be the case if Union-23 would_be a single operator with two outputs).;@Test_	public void testUnionWithTwoOutputs() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src4 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union23 = src2.union(src3)__		DataSet<Tuple2<Long, Long>> union123 = src1.union(union23)__		DataSet<Tuple2<Long, Long>> union234 = src4.union(union23)___		union123.groupBy(0).sum(1).name("1").output(new DiscardingOutputFormat<Tuple2<Long, Long>>())__		union234.groupBy(1).sum(0).name("2").output(new DiscardingOutputFormat<Tuple2<Long, Long>>())___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode groupRed1 = resolver.getNode("1")__		SingleInputPlanNode groupRed2 = resolver.getNode("2")___		_		assertTrue("Reduce input should be partitioned on 0.",_			groupRed1.getInput().getGlobalProperties().getPartitioningFields().isExactMatch(new FieldList(0)))__		assertTrue("Reduce input should be partitioned on 1.",_			groupRed2.getInput().getGlobalProperties().getPartitioningFields().isExactMatch(new FieldList(1)))___		_		assertTrue("Reduce input should be n-ary union with three inputs.",_			groupRed1.getInput().getSource() instanceof NAryUnionPlanNode &&_				((NAryUnionPlanNode) groupRed1.getInput().getSource()).getListOfInputs().size() == 3)__		assertTrue("Reduce input should be n-ary union with three inputs.",_			groupRed2.getInput().getSource() instanceof NAryUnionPlanNode &&_				((NAryUnionPlanNode) groupRed2.getInput().getSource()).getListOfInputs().size() == 3)___		_		assertTrue("Channel between union and group reduce should be forwarding",_			groupRed1.getInput().getShipStrategy().equals(ShipStrategyType.FORWARD))__		assertTrue("Channel between union and group reduce should be forwarding",_			groupRed2.getInput().getShipStrategy().equals(ShipStrategyType.FORWARD))___		_		List<Channel> union123In = ((NAryUnionPlanNode) groupRed1.getInput().getSource()).getListOfInputs()__		for(Channel i : union123In) {_			assertTrue("Union input channel should hash partition on 0",_				i.getShipStrategy().equals(ShipStrategyType.PARTITION_HASH) &&_					i.getShipStrategyKeys().isExactMatch(new FieldList(0)))__		}_		List<Channel> union234In = ((NAryUnionPlanNode) groupRed2.getInput().getSource()).getListOfInputs()__		for(Channel i : union234In) {_			assertTrue("Union input channel should hash partition on 0",_				i.getShipStrategy().equals(ShipStrategyType.PARTITION_HASH) &&_					i.getShipStrategyKeys().isExactMatch(new FieldList(1)))__		}__	};test,for,flink,2662,checks,that,a,plan,with,an,union,with,two,outputs,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union123,group,by,0,sum,output,src2,union23,src3,union234,group,by,1,sum,output,src4,the,fix,for,flink,2662,translates,the,union,with,two,output,union,23,into,two,separate,unions,union,and,union,with,one,output,each,due,to,this,change,the,interesting,partitioning,properties,for,group,by,0,and,group,by,1,are,pushed,through,union,and,union,and,do,not,interfere,with,each,other,which,would,be,the,case,if,union,23,would,be,a,single,operator,with,two,outputs;test,public,void,test,union,with,two,outputs,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src4,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union23,src2,union,src3,data,set,tuple2,long,long,union123,src1,union,union23,data,set,tuple2,long,long,union234,src4,union,union23,union123,group,by,0,sum,1,name,1,output,new,discarding,output,format,tuple2,long,long,union234,group,by,1,sum,0,name,2,output,new,discarding,output,format,tuple2,long,long,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,group,red1,resolver,get,node,1,single,input,plan,node,group,red2,resolver,get,node,2,assert,true,reduce,input,should,be,partitioned,on,0,group,red1,get,input,get,global,properties,get,partitioning,fields,is,exact,match,new,field,list,0,assert,true,reduce,input,should,be,partitioned,on,1,group,red2,get,input,get,global,properties,get,partitioning,fields,is,exact,match,new,field,list,1,assert,true,reduce,input,should,be,n,ary,union,with,three,inputs,group,red1,get,input,get,source,instanceof,nary,union,plan,node,nary,union,plan,node,group,red1,get,input,get,source,get,list,of,inputs,size,3,assert,true,reduce,input,should,be,n,ary,union,with,three,inputs,group,red2,get,input,get,source,instanceof,nary,union,plan,node,nary,union,plan,node,group,red2,get,input,get,source,get,list,of,inputs,size,3,assert,true,channel,between,union,and,group,reduce,should,be,forwarding,group,red1,get,input,get,ship,strategy,equals,ship,strategy,type,forward,assert,true,channel,between,union,and,group,reduce,should,be,forwarding,group,red2,get,input,get,ship,strategy,equals,ship,strategy,type,forward,list,channel,union123in,nary,union,plan,node,group,red1,get,input,get,source,get,list,of,inputs,for,channel,i,union123in,assert,true,union,input,channel,should,hash,partition,on,0,i,get,ship,strategy,equals,ship,strategy,type,i,get,ship,strategy,keys,is,exact,match,new,field,list,0,list,channel,union234in,nary,union,plan,node,group,red2,get,input,get,source,get,list,of,inputs,for,channel,i,union234in,assert,true,union,input,channel,should,hash,partition,on,0,i,get,ship,strategy,equals,ship,strategy,type,i,get,ship,strategy,keys,is,exact,match,new,field,list,1
UnionReplacementTest -> @Test 	public void testUnionWithTwoOutputs() throws Exception;1522323145;Test for FLINK-2662.__Checks that a plan with an union with two outputs is correctly translated._The program can be illustrated as follows:__Src1 ----------------\_>-> Union123 -> GroupBy(0) -> Sum -> Output_Src2 -\              /_>-> Union23--<_Src3 -/              \_>-> Union234 -> GroupBy(1) -> Sum -> Output_Src4 ----------------/__The fix for FLINK-2662 translates the union with two output (Union-23) into two separate_unions (Union-23_1 and Union-23_2) with one output each. Due to this change, the interesting_partitioning properties for GroupBy(0) and GroupBy(1) are pushed through Union-23_1 and_Union-23_2 and do not interfere with each other (which would be the case if Union-23 would_be a single operator with two outputs).;@Test_	public void testUnionWithTwoOutputs() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src4 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union23 = src2.union(src3)__		DataSet<Tuple2<Long, Long>> union123 = src1.union(union23)__		DataSet<Tuple2<Long, Long>> union234 = src4.union(union23)___		union123.groupBy(0).sum(1).name("1").output(new DiscardingOutputFormat<Tuple2<Long, Long>>())__		union234.groupBy(1).sum(0).name("2").output(new DiscardingOutputFormat<Tuple2<Long, Long>>())___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode groupRed1 = resolver.getNode("1")__		SingleInputPlanNode groupRed2 = resolver.getNode("2")___		_		assertTrue("Reduce input should be partitioned on 0.",_			groupRed1.getInput().getGlobalProperties().getPartitioningFields().isExactMatch(new FieldList(0)))__		assertTrue("Reduce input should be partitioned on 1.",_			groupRed2.getInput().getGlobalProperties().getPartitioningFields().isExactMatch(new FieldList(1)))___		_		assertTrue("Reduce input should be n-ary union with three inputs.",_			groupRed1.getInput().getSource() instanceof NAryUnionPlanNode &&_				((NAryUnionPlanNode) groupRed1.getInput().getSource()).getListOfInputs().size() == 3)__		assertTrue("Reduce input should be n-ary union with three inputs.",_			groupRed2.getInput().getSource() instanceof NAryUnionPlanNode &&_				((NAryUnionPlanNode) groupRed2.getInput().getSource()).getListOfInputs().size() == 3)___		_		assertTrue("Channel between union and group reduce should be forwarding",_			groupRed1.getInput().getShipStrategy().equals(ShipStrategyType.FORWARD))__		assertTrue("Channel between union and group reduce should be forwarding",_			groupRed2.getInput().getShipStrategy().equals(ShipStrategyType.FORWARD))___		_		List<Channel> union123In = ((NAryUnionPlanNode) groupRed1.getInput().getSource()).getListOfInputs()__		for(Channel i : union123In) {_			assertTrue("Union input channel should hash partition on 0",_				i.getShipStrategy().equals(ShipStrategyType.PARTITION_HASH) &&_					i.getShipStrategyKeys().isExactMatch(new FieldList(0)))__		}_		List<Channel> union234In = ((NAryUnionPlanNode) groupRed2.getInput().getSource()).getListOfInputs()__		for(Channel i : union234In) {_			assertTrue("Union input channel should hash partition on 0",_				i.getShipStrategy().equals(ShipStrategyType.PARTITION_HASH) &&_					i.getShipStrategyKeys().isExactMatch(new FieldList(1)))__		}__	};test,for,flink,2662,checks,that,a,plan,with,an,union,with,two,outputs,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union123,group,by,0,sum,output,src2,union23,src3,union234,group,by,1,sum,output,src4,the,fix,for,flink,2662,translates,the,union,with,two,output,union,23,into,two,separate,unions,union,and,union,with,one,output,each,due,to,this,change,the,interesting,partitioning,properties,for,group,by,0,and,group,by,1,are,pushed,through,union,and,union,and,do,not,interfere,with,each,other,which,would,be,the,case,if,union,23,would,be,a,single,operator,with,two,outputs;test,public,void,test,union,with,two,outputs,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src4,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union23,src2,union,src3,data,set,tuple2,long,long,union123,src1,union,union23,data,set,tuple2,long,long,union234,src4,union,union23,union123,group,by,0,sum,1,name,1,output,new,discarding,output,format,tuple2,long,long,union234,group,by,1,sum,0,name,2,output,new,discarding,output,format,tuple2,long,long,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,group,red1,resolver,get,node,1,single,input,plan,node,group,red2,resolver,get,node,2,assert,true,reduce,input,should,be,partitioned,on,0,group,red1,get,input,get,global,properties,get,partitioning,fields,is,exact,match,new,field,list,0,assert,true,reduce,input,should,be,partitioned,on,1,group,red2,get,input,get,global,properties,get,partitioning,fields,is,exact,match,new,field,list,1,assert,true,reduce,input,should,be,n,ary,union,with,three,inputs,group,red1,get,input,get,source,instanceof,nary,union,plan,node,nary,union,plan,node,group,red1,get,input,get,source,get,list,of,inputs,size,3,assert,true,reduce,input,should,be,n,ary,union,with,three,inputs,group,red2,get,input,get,source,instanceof,nary,union,plan,node,nary,union,plan,node,group,red2,get,input,get,source,get,list,of,inputs,size,3,assert,true,channel,between,union,and,group,reduce,should,be,forwarding,group,red1,get,input,get,ship,strategy,equals,ship,strategy,type,forward,assert,true,channel,between,union,and,group,reduce,should,be,forwarding,group,red2,get,input,get,ship,strategy,equals,ship,strategy,type,forward,list,channel,union123in,nary,union,plan,node,group,red1,get,input,get,source,get,list,of,inputs,for,channel,i,union123in,assert,true,union,input,channel,should,hash,partition,on,0,i,get,ship,strategy,equals,ship,strategy,type,i,get,ship,strategy,keys,is,exact,match,new,field,list,0,list,channel,union234in,nary,union,plan,node,group,red2,get,input,get,source,get,list,of,inputs,for,channel,i,union234in,assert,true,union,input,channel,should,hash,partition,on,0,i,get,ship,strategy,equals,ship,strategy,type,i,get,ship,strategy,keys,is,exact,match,new,field,list,1
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithHashPartitioning() throws Exception;1479922544;Checks that a plan with consecutive UNIONs followed by PartitionByHash is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 -> PartitionByHash -> Output_Src3 ----------------/__In the resulting plan, the hash partitioning (ShippingStrategy.PARTITION_HASH) must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithHashPartitioning() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)___		union123.partitionByHash(1).output(new DiscardingOutputFormat<Tuple2<Long, Long>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode sink = resolver.getNode("out")___		_		assertEquals("Sink input should be hash partitioned.",_			PartitioningProperty.HASH_PARTITIONED, sink.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Sink input should be hash partitioned on 1.",_			new FieldList(1), sink.getInput().getGlobalProperties().getPartitioningFields())___		SingleInputPlanNode partitioner = (SingleInputPlanNode)sink.getInput().getSource()__		assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP)__		assertEquals("Partitioner input should be hash partitioned.",_			PartitioningProperty.HASH_PARTITIONED, partitioner.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Partitioner input should be hash partitioned on 1.",_			new FieldList(1), partitioner.getInput().getGlobalProperties().getPartitioningFields())__		assertEquals("Partitioner input channel should be forwarding",_			ShipStrategyType.FORWARD, partitioner.getInput().getShipStrategy())___		NAryUnionPlanNode union = (NAryUnionPlanNode)partitioner.getInput().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be hash partitioned",_				PartitioningProperty.HASH_PARTITIONED, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be hash partitioning",_				ShipStrategyType.PARTITION_HASH, c.getShipStrategy())__			assertTrue("Union input should be data source",_				c.getSource() instanceof SourcePlanNode)__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,partition,by,hash,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,partition,by,hash,output,src3,in,the,resulting,plan,the,hash,partitioning,shipping,strategy,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,hash,partitioning,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,partition,by,hash,1,output,new,discarding,output,format,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,sink,resolver,get,node,out,assert,equals,sink,input,should,be,hash,partitioned,partitioning,property,sink,get,input,get,global,properties,get,partitioning,assert,equals,sink,input,should,be,hash,partitioned,on,1,new,field,list,1,sink,get,input,get,global,properties,get,partitioning,fields,single,input,plan,node,partitioner,single,input,plan,node,sink,get,input,get,source,assert,true,partitioner,get,driver,strategy,driver,strategy,assert,equals,partitioner,input,should,be,hash,partitioned,partitioning,property,partitioner,get,input,get,global,properties,get,partitioning,assert,equals,partitioner,input,should,be,hash,partitioned,on,1,new,field,list,1,partitioner,get,input,get,global,properties,get,partitioning,fields,assert,equals,partitioner,input,channel,should,be,forwarding,ship,strategy,type,forward,partitioner,get,input,get,ship,strategy,nary,union,plan,node,union,nary,union,plan,node,partitioner,get,input,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,hash,partitioned,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,hash,partitioning,ship,strategy,type,c,get,ship,strategy,assert,true,union,input,should,be,data,source,c,get,source,instanceof,source,plan,node
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithHashPartitioning() throws Exception;1484927904;Checks that a plan with consecutive UNIONs followed by PartitionByHash is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 -> PartitionByHash -> Output_Src3 ----------------/__In the resulting plan, the hash partitioning (ShippingStrategy.PARTITION_HASH) must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithHashPartitioning() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)___		union123.partitionByHash(1).output(new DiscardingOutputFormat<Tuple2<Long, Long>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode sink = resolver.getNode("out")___		_		assertEquals("Sink input should be hash partitioned.",_			PartitioningProperty.HASH_PARTITIONED, sink.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Sink input should be hash partitioned on 1.",_			new FieldList(1), sink.getInput().getGlobalProperties().getPartitioningFields())___		SingleInputPlanNode partitioner = (SingleInputPlanNode)sink.getInput().getSource()__		assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP)__		assertEquals("Partitioner input should be hash partitioned.",_			PartitioningProperty.HASH_PARTITIONED, partitioner.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Partitioner input should be hash partitioned on 1.",_			new FieldList(1), partitioner.getInput().getGlobalProperties().getPartitioningFields())__		assertEquals("Partitioner input channel should be forwarding",_			ShipStrategyType.FORWARD, partitioner.getInput().getShipStrategy())___		NAryUnionPlanNode union = (NAryUnionPlanNode)partitioner.getInput().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be hash partitioned",_				PartitioningProperty.HASH_PARTITIONED, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be hash partitioning",_				ShipStrategyType.PARTITION_HASH, c.getShipStrategy())__			assertTrue("Union input should be data source",_				c.getSource() instanceof SourcePlanNode)__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,partition,by,hash,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,partition,by,hash,output,src3,in,the,resulting,plan,the,hash,partitioning,shipping,strategy,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,hash,partitioning,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,partition,by,hash,1,output,new,discarding,output,format,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,sink,resolver,get,node,out,assert,equals,sink,input,should,be,hash,partitioned,partitioning,property,sink,get,input,get,global,properties,get,partitioning,assert,equals,sink,input,should,be,hash,partitioned,on,1,new,field,list,1,sink,get,input,get,global,properties,get,partitioning,fields,single,input,plan,node,partitioner,single,input,plan,node,sink,get,input,get,source,assert,true,partitioner,get,driver,strategy,driver,strategy,assert,equals,partitioner,input,should,be,hash,partitioned,partitioning,property,partitioner,get,input,get,global,properties,get,partitioning,assert,equals,partitioner,input,should,be,hash,partitioned,on,1,new,field,list,1,partitioner,get,input,get,global,properties,get,partitioning,fields,assert,equals,partitioner,input,channel,should,be,forwarding,ship,strategy,type,forward,partitioner,get,input,get,ship,strategy,nary,union,plan,node,union,nary,union,plan,node,partitioner,get,input,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,hash,partitioned,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,hash,partitioning,ship,strategy,type,c,get,ship,strategy,assert,true,union,input,should,be,data,source,c,get,source,instanceof,source,plan,node
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithHashPartitioning() throws Exception;1516028607;Checks that a plan with consecutive UNIONs followed by PartitionByHash is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 -> PartitionByHash -> Output_Src3 ----------------/__In the resulting plan, the hash partitioning (ShippingStrategy.PARTITION_HASH) must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithHashPartitioning() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)___		union123.partitionByHash(1).output(new DiscardingOutputFormat<Tuple2<Long, Long>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode sink = resolver.getNode("out")___		_		assertEquals("Sink input should be hash partitioned.",_			PartitioningProperty.HASH_PARTITIONED, sink.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Sink input should be hash partitioned on 1.",_			new FieldList(1), sink.getInput().getGlobalProperties().getPartitioningFields())___		SingleInputPlanNode partitioner = (SingleInputPlanNode)sink.getInput().getSource()__		assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP)__		assertEquals("Partitioner input should be hash partitioned.",_			PartitioningProperty.HASH_PARTITIONED, partitioner.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Partitioner input should be hash partitioned on 1.",_			new FieldList(1), partitioner.getInput().getGlobalProperties().getPartitioningFields())__		assertEquals("Partitioner input channel should be forwarding",_			ShipStrategyType.FORWARD, partitioner.getInput().getShipStrategy())___		NAryUnionPlanNode union = (NAryUnionPlanNode)partitioner.getInput().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be hash partitioned",_				PartitioningProperty.HASH_PARTITIONED, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be hash partitioning",_				ShipStrategyType.PARTITION_HASH, c.getShipStrategy())__			assertTrue("Union input should be data source",_				c.getSource() instanceof SourcePlanNode)__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,partition,by,hash,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,partition,by,hash,output,src3,in,the,resulting,plan,the,hash,partitioning,shipping,strategy,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,hash,partitioning,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,partition,by,hash,1,output,new,discarding,output,format,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,sink,resolver,get,node,out,assert,equals,sink,input,should,be,hash,partitioned,partitioning,property,sink,get,input,get,global,properties,get,partitioning,assert,equals,sink,input,should,be,hash,partitioned,on,1,new,field,list,1,sink,get,input,get,global,properties,get,partitioning,fields,single,input,plan,node,partitioner,single,input,plan,node,sink,get,input,get,source,assert,true,partitioner,get,driver,strategy,driver,strategy,assert,equals,partitioner,input,should,be,hash,partitioned,partitioning,property,partitioner,get,input,get,global,properties,get,partitioning,assert,equals,partitioner,input,should,be,hash,partitioned,on,1,new,field,list,1,partitioner,get,input,get,global,properties,get,partitioning,fields,assert,equals,partitioner,input,channel,should,be,forwarding,ship,strategy,type,forward,partitioner,get,input,get,ship,strategy,nary,union,plan,node,union,nary,union,plan,node,partitioner,get,input,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,hash,partitioned,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,hash,partitioning,ship,strategy,type,c,get,ship,strategy,assert,true,union,input,should,be,data,source,c,get,source,instanceof,source,plan,node
UnionReplacementTest -> @Test 	public void testConsecutiveUnionsWithHashPartitioning() throws Exception;1522323145;Checks that a plan with consecutive UNIONs followed by PartitionByHash is correctly translated.__The program can be illustrated as follows:__Src1 -\_>-> Union12--<_Src2 -/              \_>-> Union123 -> PartitionByHash -> Output_Src3 ----------------/__In the resulting plan, the hash partitioning (ShippingStrategy.PARTITION_HASH) must be_pushed to the inputs of the unions (Src1, Src2, Src3).;@Test_	public void testConsecutiveUnionsWithHashPartitioning() throws Exception {__		_		_		__		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(DEFAULT_PARALLELISM)___		DataSet<Tuple2<Long, Long>> src1 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src2 = env.fromElements(new Tuple2<>(0L, 0L))__		DataSet<Tuple2<Long, Long>> src3 = env.fromElements(new Tuple2<>(0L, 0L))___		DataSet<Tuple2<Long, Long>> union12 = src1.union(src2)__		DataSet<Tuple2<Long, Long>> union123 = union12.union(src3)___		union123.partitionByHash(1).output(new DiscardingOutputFormat<Tuple2<Long, Long>>()).name("out")___		_		_		__		OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan())___		OptimizerPlanNodeResolver resolver = getOptimizerPlanNodeResolver(optimizedPlan)___		SingleInputPlanNode sink = resolver.getNode("out")___		_		assertEquals("Sink input should be hash partitioned.",_			PartitioningProperty.HASH_PARTITIONED, sink.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Sink input should be hash partitioned on 1.",_			new FieldList(1), sink.getInput().getGlobalProperties().getPartitioningFields())___		SingleInputPlanNode partitioner = (SingleInputPlanNode)sink.getInput().getSource()__		assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP)__		assertEquals("Partitioner input should be hash partitioned.",_			PartitioningProperty.HASH_PARTITIONED, partitioner.getInput().getGlobalProperties().getPartitioning())__		assertEquals("Partitioner input should be hash partitioned on 1.",_			new FieldList(1), partitioner.getInput().getGlobalProperties().getPartitioningFields())__		assertEquals("Partitioner input channel should be forwarding",_			ShipStrategyType.FORWARD, partitioner.getInput().getShipStrategy())___		NAryUnionPlanNode union = (NAryUnionPlanNode)partitioner.getInput().getSource()__		_		for (Channel c : union.getInputs()) {_			assertEquals("Union input should be hash partitioned",_				PartitioningProperty.HASH_PARTITIONED, c.getGlobalProperties().getPartitioning())__			assertEquals("Union input channel should be hash partitioning",_				ShipStrategyType.PARTITION_HASH, c.getShipStrategy())__			assertTrue("Union input should be data source",_				c.getSource() instanceof SourcePlanNode)__		}_	};checks,that,a,plan,with,consecutive,unions,followed,by,partition,by,hash,is,correctly,translated,the,program,can,be,illustrated,as,follows,src1,union12,src2,union123,partition,by,hash,output,src3,in,the,resulting,plan,the,hash,partitioning,shipping,strategy,must,be,pushed,to,the,inputs,of,the,unions,src1,src2,src3;test,public,void,test,consecutive,unions,with,hash,partitioning,throws,exception,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,data,set,tuple2,long,long,src1,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src2,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,src3,env,from,elements,new,tuple2,0l,0l,data,set,tuple2,long,long,union12,src1,union,src2,data,set,tuple2,long,long,union123,union12,union,src3,union123,partition,by,hash,1,output,new,discarding,output,format,tuple2,long,long,name,out,optimized,plan,optimized,plan,compile,no,stats,env,create,program,plan,optimizer,plan,node,resolver,resolver,get,optimizer,plan,node,resolver,optimized,plan,single,input,plan,node,sink,resolver,get,node,out,assert,equals,sink,input,should,be,hash,partitioned,partitioning,property,sink,get,input,get,global,properties,get,partitioning,assert,equals,sink,input,should,be,hash,partitioned,on,1,new,field,list,1,sink,get,input,get,global,properties,get,partitioning,fields,single,input,plan,node,partitioner,single,input,plan,node,sink,get,input,get,source,assert,true,partitioner,get,driver,strategy,driver,strategy,assert,equals,partitioner,input,should,be,hash,partitioned,partitioning,property,partitioner,get,input,get,global,properties,get,partitioning,assert,equals,partitioner,input,should,be,hash,partitioned,on,1,new,field,list,1,partitioner,get,input,get,global,properties,get,partitioning,fields,assert,equals,partitioner,input,channel,should,be,forwarding,ship,strategy,type,forward,partitioner,get,input,get,ship,strategy,nary,union,plan,node,union,nary,union,plan,node,partitioner,get,input,get,source,for,channel,c,union,get,inputs,assert,equals,union,input,should,be,hash,partitioned,partitioning,property,c,get,global,properties,get,partitioning,assert,equals,union,input,channel,should,be,hash,partitioning,ship,strategy,type,c,get,ship,strategy,assert,true,union,input,should,be,data,source,c,get,source,instanceof,source,plan,node
