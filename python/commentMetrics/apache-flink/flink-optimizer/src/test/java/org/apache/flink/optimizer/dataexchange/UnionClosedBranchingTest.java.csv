commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;14;;@Parameterized.Parameters public static Collection<Object[]> params() {     Collection<Object[]> params = Arrays.asList(new Object[][] { { ExecutionMode.PIPELINED, BATCH, PIPELINED }, { ExecutionMode.PIPELINED_FORCED, PIPELINED, PIPELINED }, { ExecutionMode.BATCH, BATCH, PIPELINED }, { ExecutionMode.BATCH_FORCED, BATCH, BATCH } }).     // Make sure that changes to ExecutionMode are reflected in this test.     assertEquals(ExecutionMode.values().length, params.size()).     return params. }
false;public;0;88;;@Test public void testUnionClosedBranchingTest() throws Exception {     // -----------------------------------------------------------------------------------------     // Build test program     // -----------------------------------------------------------------------------------------     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.getConfig().setExecutionMode(executionMode).     env.setParallelism(4).     DataSet<Tuple1<Integer>> src1 = env.fromElements(new Tuple1<>(0), new Tuple1<>(1)).     DataSet<Tuple1<Integer>> src2 = env.fromElements(new Tuple1<>(0), new Tuple1<>(1)).     DataSet<Tuple1<Integer>> union = src1.union(src2).     DataSet<Tuple2<Integer, Integer>> join = union.join(union).where(0).equalTo(0).projectFirst(0).projectSecond(0).     join.output(new DiscardingOutputFormat<Tuple2<Integer, Integer>>()).     // -----------------------------------------------------------------------------------------     // Verify optimized plan     // -----------------------------------------------------------------------------------------     OptimizedPlan optimizedPlan = compileNoStats(env.createProgramPlan()).     SinkPlanNode sinkNode = optimizedPlan.getDataSinks().iterator().next().     DualInputPlanNode joinNode = (DualInputPlanNode) sinkNode.getPredecessor().     // Verify that the compiler correctly sets the expected data exchange modes.     for (Channel channel : joinNode.getInputs()) {         assertEquals("Unexpected data exchange mode between union and join node.", unionToJoin, channel.getDataExchangeMode()).         assertEquals("Unexpected ship strategy between union and join node.", unionToJoinStrategy, channel.getShipStrategy()).     }     for (SourcePlanNode src : optimizedPlan.getDataSources()) {         for (Channel channel : src.getOutgoingChannels()) {             assertEquals("Unexpected data exchange mode between source and union node.", sourceToUnion, channel.getDataExchangeMode()).             assertEquals("Unexpected ship strategy between source and union node.", sourceToUnionStrategy, channel.getShipStrategy()).         }     }     // -----------------------------------------------------------------------------------------     // Verify generated JobGraph     // -----------------------------------------------------------------------------------------     JobGraphGenerator jgg = new JobGraphGenerator().     JobGraph jobGraph = jgg.compileJobGraph(optimizedPlan).     List<JobVertex> vertices = jobGraph.getVerticesSortedTopologicallyFromSources().     // Sanity check for the test setup     assertEquals("Unexpected number of vertices created.", 4, vertices.size()).     // Verify all sources     JobVertex[] sources = new JobVertex[] { vertices.get(0), vertices.get(1) }.     for (JobVertex src : sources) {         // Sanity check         assertTrue("Unexpected vertex type. Test setup is broken.", src.isInputVertex()).         // The union is not translated to an extra union task, but the join uses a union         // input gate to read multiple inputs. The source create a single result per consumer.         assertEquals("Unexpected number of created results.", 2, src.getNumberOfProducedIntermediateDataSets()).         for (IntermediateDataSet dataSet : src.getProducedDataSets()) {             ResultPartitionType dsType = dataSet.getResultType().             // Ensure batch exchange unless PIPELINED_FORCE is enabled.             if (!executionMode.equals(ExecutionMode.PIPELINED_FORCED)) {                 assertTrue("Expected batch exchange, but result type is " + dsType + ".", dsType.isBlocking()).             } else {                 assertFalse("Expected non-batch exchange, but result type is " + dsType + ".", dsType.isBlocking()).             }         }     } }
