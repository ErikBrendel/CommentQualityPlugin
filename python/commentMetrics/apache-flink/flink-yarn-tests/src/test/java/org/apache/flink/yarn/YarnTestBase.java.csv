commented;modifiers;parameterAmount;loc;comment;code
false;public,static;3;17;;public static void populateYarnSecureConfigurations(Configuration conf, String principal, String keytab) {     conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION, "kerberos").     conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION, "true").     conf.set(YarnConfiguration.RM_KEYTAB, keytab).     conf.set(YarnConfiguration.RM_PRINCIPAL, principal).     conf.set(YarnConfiguration.NM_KEYTAB, keytab).     conf.set(YarnConfiguration.NM_PRINCIPAL, principal).     conf.set(YarnConfiguration.RM_WEBAPP_SPNEGO_USER_NAME_KEY, principal).     conf.set(YarnConfiguration.RM_WEBAPP_SPNEGO_KEYTAB_FILE_KEY, keytab).     conf.set(YarnConfiguration.NM_WEBAPP_SPNEGO_USER_NAME_KEY, principal).     conf.set(YarnConfiguration.NM_WEBAPP_SPNEGO_KEYTAB_FILE_KEY, keytab).     conf.set("hadoop.security.auth_to_local", "RULE:[1:$1] RULE:[2:$1]"). }
false;public;0;10;;@Before public void checkClusterEmpty() {     if (yarnClient == null) {         yarnClient = YarnClient.createYarnClient().         yarnClient.init(getYarnConfiguration()).         yarnClient.start().     }     flinkConfiguration = new org.apache.flink.configuration.Configuration(globalConfiguration). }
true;public;0;27;/**  * Sleep a bit between the tests (we are re-using the YARN cluster for the tests).  */ ;/**  * Sleep a bit between the tests (we are re-using the YARN cluster for the tests).  */ @After public void sleep() throws IOException, YarnException {     Deadline deadline = Deadline.now().plus(Duration.ofSeconds(10)).     boolean isAnyJobRunning = yarnClient.getApplications().stream().anyMatch(YarnTestBase::isApplicationRunning).     while (deadline.hasTimeLeft() && isAnyJobRunning) {         try {             Thread.sleep(500).         } catch (InterruptedException e) {             Assert.fail("Should not happen").         }         isAnyJobRunning = yarnClient.getApplications().stream().anyMatch(YarnTestBase::isApplicationRunning).     }     if (isAnyJobRunning) {         final List<String> runningApps = yarnClient.getApplications().stream().filter(YarnTestBase::isApplicationRunning).map(app -> "App " + app.getApplicationId() + " is in state " + app.getYarnApplicationState() + '.').collect(Collectors.toList()).         if (!runningApps.isEmpty()) {             Assert.fail("There is at least one application on the cluster that is not finished." + runningApps).         }     } }
false;private,static;1;6;;private static boolean isApplicationRunning(ApplicationReport app) {     final YarnApplicationState yarnApplicationState = app.getYarnApplicationState().     return yarnApplicationState != YarnApplicationState.FINISHED && app.getYarnApplicationState() != YarnApplicationState.KILLED && app.getYarnApplicationState() != YarnApplicationState.FAILED. }
false;protected;0;4;;@Nullable protected YarnClient getYarnClient() {     return yarnClient. }
false;protected,static;0;3;;protected static YarnConfiguration getYarnConfiguration() {     return YARN_CONFIGURATION. }
true;public,static;2;19;/**  * Locate a file or directory.  */ ;/**  * Locate a file or directory.  */ public static File findFile(String startAt, FilenameFilter fnf) {     File root = new File(startAt).     String[] files = root.list().     if (files == null) {         return null.     }     for (String file : files) {         File f = new File(startAt + File.separator + file).         if (f.isDirectory()) {             File r = findFile(f.getAbsolutePath(), fnf).             if (r != null) {                 return r.             }         } else if (fnf.accept(f.getParentFile(), f.getName())) {             return f.         }     }     return null. }
false;;1;12;;@Nonnull YarnClusterDescriptor createYarnClusterDescriptor(org.apache.flink.configuration.Configuration flinkConfiguration) {     final YarnClusterDescriptor yarnClusterDescriptor = new YarnClusterDescriptor(flinkConfiguration, YARN_CONFIGURATION, CliFrontend.getConfigurationDirectoryFromEnv(), yarnClient, true).     yarnClusterDescriptor.setLocalJarPath(new Path(flinkUberjar.toURI())).     yarnClusterDescriptor.addShipFiles(Collections.singletonList(flinkLibFolder)).     return yarnClusterDescriptor. }
false;public;2;4;;@Override public boolean accept(File dir, String name) {     return name.startsWith("flink-dist") && name.endsWith(".jar") && dir.toString().contains("/lib"). }
false;public;2;18;;@Override public boolean accept(File dir, String name) {     if (excludeInPath == null) {         for (String n : names) {             if (!name.contains(n)) {                 return false.             }         }         return true.     } else {         for (String n : names) {             if (!name.contains(n)) {                 return false.             }         }         return !dir.toString().contains(excludeInPath).     } }
false;public,static;1;10;;public static File writeYarnSiteConfigXML(Configuration yarnConf) throws IOException {     tmp.create().     File yarnSiteXML = new File(tmp.newFolder().getAbsolutePath() + "/yarn-site.xml").     try (FileWriter writer = new FileWriter(yarnSiteXML)) {         yarnConf.writeXml(writer).         writer.flush().     }     return yarnSiteXML. }
false;public;2;64;;@Override public boolean accept(File dir, String name) {     // scan each file for prohibited strings.     File f = new File(dir.getAbsolutePath() + "/" + name).     try {         BufferingScanner scanner = new BufferingScanner(new Scanner(f), 10).         while (scanner.hasNextLine()) {             final String lineFromFile = scanner.nextLine().             for (String aProhibited : prohibited) {                 if (lineFromFile.contains(aProhibited)) {                     boolean whitelistedFound = false.                     for (String white : whitelisted) {                         if (lineFromFile.contains(white)) {                             whitelistedFound = true.                             break.                         }                     }                     if (!whitelistedFound) {                         // logging in FATAL to see the actual message in TRAVIS tests.                         Marker fatal = MarkerFactory.getMarker("FATAL").                         LOG.error(fatal, "Prohibited String '{}' in line '{}'", aProhibited, lineFromFile).                         StringBuilder logExcerpt = new StringBuilder().                         logExcerpt.append(System.lineSeparator()).                         // include some previous lines in case of irregular formatting                         for (String previousLine : scanner.getPreviousLines()) {                             logExcerpt.append(previousLine).                             logExcerpt.append(System.lineSeparator()).                         }                         logExcerpt.append(lineFromFile).                         logExcerpt.append(System.lineSeparator()).                         // extract potential stack trace from log                         while (scanner.hasNextLine()) {                             String line = scanner.nextLine().                             logExcerpt.append(line).                             logExcerpt.append(System.lineSeparator()).                             if (line.isEmpty() || (!Character.isWhitespace(line.charAt(0)) && !line.startsWith("Caused by"))) {                                 // the cause has been printed, now add a few more lines in case of irregular formatting                                 for (int x = 0. x < 10 && scanner.hasNextLine(). x++) {                                     logExcerpt.append(scanner.nextLine()).                                     logExcerpt.append(System.lineSeparator()).                                 }                                 break.                             }                         }                         prohibitedExcerpts.add(logExcerpt.toString()).                         return true.                     }                 }             }         }     } catch (FileNotFoundException e) {         LOG.warn("Unable to locate file: " + e.getMessage() + " file: " + f.getAbsolutePath()).     }     return false. }
true;public,static;2;88;/**  * This method checks the written TaskManager and JobManager log files  * for exceptions.  *  * <p>WARN: Please make sure the tool doesn't find old logfiles from previous test runs.  * So always run "mvn clean" before running the tests here.  */ ;/**  * This method checks the written TaskManager and JobManager log files  * for exceptions.  *  * <p>WARN: Please make sure the tool doesn't find old logfiles from previous test runs.  * So always run "mvn clean" before running the tests here.  */ public static void ensureNoProhibitedStringInLogFiles(final String[] prohibited, final String[] whitelisted) {     File cwd = new File("target/" + YARN_CONFIGURATION.get(TEST_CLUSTER_NAME_KEY)).     Assert.assertTrue("Expecting directory " + cwd.getAbsolutePath() + " to exist", cwd.exists()).     Assert.assertTrue("Expecting directory " + cwd.getAbsolutePath() + " to be a directory", cwd.isDirectory()).     List<String> prohibitedExcerpts = new ArrayList<>().     File foundFile = findFile(cwd.getAbsolutePath(), new FilenameFilter() {          @Override         public boolean accept(File dir, String name) {             // scan each file for prohibited strings.             File f = new File(dir.getAbsolutePath() + "/" + name).             try {                 BufferingScanner scanner = new BufferingScanner(new Scanner(f), 10).                 while (scanner.hasNextLine()) {                     final String lineFromFile = scanner.nextLine().                     for (String aProhibited : prohibited) {                         if (lineFromFile.contains(aProhibited)) {                             boolean whitelistedFound = false.                             for (String white : whitelisted) {                                 if (lineFromFile.contains(white)) {                                     whitelistedFound = true.                                     break.                                 }                             }                             if (!whitelistedFound) {                                 // logging in FATAL to see the actual message in TRAVIS tests.                                 Marker fatal = MarkerFactory.getMarker("FATAL").                                 LOG.error(fatal, "Prohibited String '{}' in line '{}'", aProhibited, lineFromFile).                                 StringBuilder logExcerpt = new StringBuilder().                                 logExcerpt.append(System.lineSeparator()).                                 // include some previous lines in case of irregular formatting                                 for (String previousLine : scanner.getPreviousLines()) {                                     logExcerpt.append(previousLine).                                     logExcerpt.append(System.lineSeparator()).                                 }                                 logExcerpt.append(lineFromFile).                                 logExcerpt.append(System.lineSeparator()).                                 // extract potential stack trace from log                                 while (scanner.hasNextLine()) {                                     String line = scanner.nextLine().                                     logExcerpt.append(line).                                     logExcerpt.append(System.lineSeparator()).                                     if (line.isEmpty() || (!Character.isWhitespace(line.charAt(0)) && !line.startsWith("Caused by"))) {                                         // the cause has been printed, now add a few more lines in case of irregular formatting                                         for (int x = 0. x < 10 && scanner.hasNextLine(). x++) {                                             logExcerpt.append(scanner.nextLine()).                                             logExcerpt.append(System.lineSeparator()).                                         }                                         break.                                     }                                 }                                 prohibitedExcerpts.add(logExcerpt.toString()).                                 return true.                             }                         }                     }                 }             } catch (FileNotFoundException e) {                 LOG.warn("Unable to locate file: " + e.getMessage() + " file: " + f.getAbsolutePath()).             }             return false.         }     }).     if (foundFile != null) {         Scanner scanner = null.         try {             scanner = new Scanner(foundFile).         } catch (FileNotFoundException e) {             Assert.fail("Unable to locate file: " + e.getMessage() + " file: " + foundFile.getAbsolutePath()).         }         LOG.warn("Found a file with a prohibited string. Printing contents:").         while (scanner.hasNextLine()) {             LOG.warn("LINE: " + scanner.nextLine()).         }         Assert.fail("Found a file " + foundFile + " with a prohibited string (one of " + Arrays.toString(prohibited) + "). " + "Excerpts:" + System.lineSeparator() + prohibitedExcerpts).     } }
false;public;2;26;;@Override public boolean accept(File dir, String name) {     if (fileName != null && !name.equals(fileName)) {         return false.     }     File f = new File(dir.getAbsolutePath() + "/" + name).     LOG.info("Searching in {}", f.getAbsolutePath()).     try {         Set<String> foundSet = new HashSet<>(mustHave.length).         Scanner scanner = new Scanner(f).         while (scanner.hasNextLine()) {             final String lineFromFile = scanner.nextLine().             for (String str : mustHave) {                 if (lineFromFile.contains(str)) {                     foundSet.add(str).                 }             }             if (foundSet.containsAll(mustHaveList)) {                 return true.             }         }     } catch (FileNotFoundException e) {         LOG.warn("Unable to locate file: " + e.getMessage() + " file: " + f.getAbsolutePath()).     }     return false. }
false;public,static;2;44;;public static boolean verifyStringsInNamedLogFiles(final String[] mustHave, final String fileName) {     List<String> mustHaveList = Arrays.asList(mustHave).     File cwd = new File("target/" + YARN_CONFIGURATION.get(TEST_CLUSTER_NAME_KEY)).     if (!cwd.exists() || !cwd.isDirectory()) {         return false.     }     File foundFile = findFile(cwd.getAbsolutePath(), new FilenameFilter() {          @Override         public boolean accept(File dir, String name) {             if (fileName != null && !name.equals(fileName)) {                 return false.             }             File f = new File(dir.getAbsolutePath() + "/" + name).             LOG.info("Searching in {}", f.getAbsolutePath()).             try {                 Set<String> foundSet = new HashSet<>(mustHave.length).                 Scanner scanner = new Scanner(f).                 while (scanner.hasNextLine()) {                     final String lineFromFile = scanner.nextLine().                     for (String str : mustHave) {                         if (lineFromFile.contains(str)) {                             foundSet.add(str).                         }                     }                     if (foundSet.containsAll(mustHaveList)) {                         return true.                     }                 }             } catch (FileNotFoundException e) {                 LOG.warn("Unable to locate file: " + e.getMessage() + " file: " + f.getAbsolutePath()).             }             return false.         }     }).     if (foundFile != null) {         LOG.info("Found string {} in {}.", Arrays.toString(mustHave), foundFile.getAbsolutePath()).         return true.     } else {         return false.     } }
false;public,static;1;7;;public static void sleep(int time) {     try {         Thread.sleep(time).     } catch (InterruptedException e) {         LOG.warn("Interruped", e).     } }
false;public,static;0;9;;public static int getRunningContainers() {     int count = 0.     for (int nmId = 0. nmId < NUM_NODEMANAGERS. nmId++) {         NodeManager nm = yarnCluster.getNodeManager(nmId).         ConcurrentMap<ContainerId, Container> containers = nm.getNMContext().getContainers().         count += containers.size().     }     return count. }
false;public,static;3;3;;public static void startYARNSecureMode(YarnConfiguration conf, String principal, String keytab) {     start(conf, principal, keytab). }
false;public,static;1;3;;public static void startYARNWithConfig(YarnConfiguration conf) {     start(conf, null, null). }
false;private,static;3;83;;private static void start(YarnConfiguration conf, String principal, String keytab) {     // set the home directory to a temp directory. Flink on YARN is using the home dir to distribute the file     File homeDir = null.     try {         homeDir = tmp.newFolder().     } catch (IOException e) {         e.printStackTrace().         Assert.fail(e.getMessage()).     }     System.setProperty("user.home", homeDir.getAbsolutePath()).     String uberjarStartLoc = "..".     LOG.info("Trying to locate uberjar in {}", new File(uberjarStartLoc).getAbsolutePath()).     flinkUberjar = findFile(uberjarStartLoc, new RootDirFilenameFilter()).     Assert.assertNotNull("Flink uberjar not found", flinkUberjar).     String flinkDistRootDir = flinkUberjar.getParentFile().getParent().     // the uberjar is located in lib/     flinkLibFolder = flinkUberjar.getParentFile().     // the hadoop jar was copied into the target/shaded-hadoop directory during the build     flinkShadedHadoopDir = Paths.get("target/shaded-hadoop").toFile().     Assert.assertNotNull("Flink flinkLibFolder not found", flinkLibFolder).     Assert.assertTrue("lib folder not found", flinkLibFolder.exists()).     Assert.assertTrue("lib folder not found", flinkLibFolder.isDirectory()).     if (!flinkUberjar.exists()) {         Assert.fail("Unable to locate yarn-uberjar.jar").     }     try {         LOG.info("Starting up MiniYARNCluster").         if (yarnCluster == null) {             final String testName = conf.get(YarnTestBase.TEST_CLUSTER_NAME_KEY).             yarnCluster = new MiniYARNCluster(testName == null ? "YarnTest_" + UUID.randomUUID() : testName, NUM_NODEMANAGERS, 1, 1).             yarnCluster.init(conf).             yarnCluster.start().         }         Map<String, String> map = new HashMap<String, String>(System.getenv()).         File flinkConfDirPath = findFile(flinkDistRootDir, new ContainsName(new String[] { "flink-conf.yaml" })).         Assert.assertNotNull(flinkConfDirPath).         final String confDirPath = flinkConfDirPath.getParentFile().getAbsolutePath().         globalConfiguration = GlobalConfiguration.loadConfiguration(confDirPath).         // copy conf dir to test temporary workspace location         tempConfPathForSecureRun = tmp.newFolder("conf").         FileUtils.copyDirectory(new File(confDirPath), tempConfPathForSecureRun).         BootstrapTools.writeConfiguration(globalConfiguration, new File(tempConfPathForSecureRun, "flink-conf.yaml")).         String configDir = tempConfPathForSecureRun.getAbsolutePath().         LOG.info("Temporary Flink configuration directory to be used for secure test: {}", configDir).         Assert.assertNotNull(configDir).         map.put(ConfigConstants.ENV_FLINK_CONF_DIR, configDir).         File yarnConfFile = writeYarnSiteConfigXML(conf).         map.put("YARN_CONF_DIR", yarnConfFile.getParentFile().getAbsolutePath()).         // see YarnClusterDescriptor() for more infos         map.put("IN_TESTS", "yes we are in tests").         TestBaseUtils.setEnv(map).         Assert.assertTrue(yarnCluster.getServiceState() == Service.STATE.STARTED).         // wait for the nodeManagers to connect         while (!yarnCluster.waitForNodeManagersToConnect(500)) {             LOG.info("Waiting for Nodemanagers to connect").         }     } catch (Exception ex) {         ex.printStackTrace().         LOG.error("setup failure", ex).         Assert.fail().     } }
true;public,static;0;4;/**  * Default @BeforeClass impl. Overwrite this for passing a different configuration  */ ;/**  * Default @BeforeClass impl. Overwrite this for passing a different configuration  */ @BeforeClass public static void setup() throws Exception {     startYARNWithConfig(YARN_CONFIGURATION). }
true;protected;3;48;/**  * This method returns once the "startedAfterString" has been seen.  */ ;/**  * This method returns once the "startedAfterString" has been seen.  */ protected Runner startWithArgs(String[] args, String startedAfterString, RunTypes type) throws IOException {     LOG.info("Running with args {}", Arrays.toString(args)).     outContent = new ByteArrayOutputStream().     errContent = new ByteArrayOutputStream().     PipedOutputStream out = new PipedOutputStream().     PipedInputStream in = new PipedInputStream(out).     PrintStream stdinPrintStream = new PrintStream(out).     System.setOut(new PrintStream(outContent)).     System.setErr(new PrintStream(errContent)).     System.setIn(in).     final int startTimeoutSeconds = 60.     Runner runner = new Runner(args, flinkConfiguration, CliFrontend.getConfigurationDirectoryFromEnv(), type, 0, stdinPrintStream).     runner.setName("Frontend (CLI/YARN Client) runner thread (startWithArgs()).").     runner.start().     for (int second = 0. second < startTimeoutSeconds. second++) {         sleep(1000).         // check output for correct TaskManager startup.         if (outContent.toString().contains(startedAfterString) || errContent.toString().contains(startedAfterString)) {             LOG.info("Found expected output in redirected streams").             return runner.         }         // check if thread died         if (!runner.isAlive()) {             resetStreamsAndSendOutput().             if (runner.getRunnerError() != null) {                 throw new RuntimeException("Runner failed with exception.", runner.getRunnerError()).             }             Assert.fail("Runner thread died before the test was finished.").         }     }     resetStreamsAndSendOutput().     Assert.fail("During the timeout period of " + startTimeoutSeconds + " seconds the " + "expected string did not show up").     return null. }
false;protected;5;3;;protected void runWithArgs(String[] args, String terminateAfterString, String[] failOnStrings, RunTypes type, int returnCode) throws IOException {     runWithArgs(args, terminateAfterString, failOnStrings, type, returnCode, false). }
true;protected;6;96;/**  * The test has been passed once the "terminateAfterString" has been seen.  * @param args Command line arguments for the runner  * @param terminateAfterString the runner is searching the stdout and stderr for this string. as soon as it appears, the test has passed  * @param failOnPatterns The runner is searching stdout and stderr for the pattern (regexp) specified here. If one appears, the test has failed  * @param type Set the type of the runner  * @param expectedReturnValue Expected return code from the runner.  * @param checkLogForTerminateString  If true, the runner checks also the log4j logger for the terminate string  */ ;/**  * The test has been passed once the "terminateAfterString" has been seen.  * @param args Command line arguments for the runner  * @param terminateAfterString the runner is searching the stdout and stderr for this string. as soon as it appears, the test has passed  * @param failOnPatterns The runner is searching stdout and stderr for the pattern (regexp) specified here. If one appears, the test has failed  * @param type Set the type of the runner  * @param expectedReturnValue Expected return code from the runner.  * @param checkLogForTerminateString  If true, the runner checks also the log4j logger for the terminate string  */ protected void runWithArgs(String[] args, String terminateAfterString, String[] failOnPatterns, RunTypes type, int expectedReturnValue, boolean checkLogForTerminateString) throws IOException {     LOG.info("Running with args {}", Arrays.toString(args)).     outContent = new ByteArrayOutputStream().     errContent = new ByteArrayOutputStream().     PipedOutputStream out = new PipedOutputStream().     PipedInputStream in = new PipedInputStream(out).     PrintStream stdinPrintStream = new PrintStream(out).     System.setOut(new PrintStream(outContent)).     System.setErr(new PrintStream(errContent)).     System.setIn(in).     // we wait for at most three minutes     final int startTimeoutSeconds = 180.     final long deadline = System.currentTimeMillis() + (startTimeoutSeconds * 1000).     Runner runner = new Runner(args, flinkConfiguration, CliFrontend.getConfigurationDirectoryFromEnv(), type, expectedReturnValue, stdinPrintStream).     runner.start().     boolean expectedStringSeen = false.     boolean testPassedFromLog4j = false.     long shutdownTimeout = 30000L.     do {         sleep(1000).         String outContentString = outContent.toString().         String errContentString = errContent.toString().         if (failOnPatterns != null) {             for (String failOnString : failOnPatterns) {                 Pattern pattern = Pattern.compile(failOnString).                 if (pattern.matcher(outContentString).find() || pattern.matcher(errContentString).find()) {                     LOG.warn("Failing test. Output contained illegal string '" + failOnString + "'").                     resetStreamsAndSendOutput().                     // stopping runner.                     runner.sendStop().                     // wait for the thread to stop                     try {                         runner.join(shutdownTimeout).                     } catch (InterruptedException e) {                         LOG.warn("Interrupted while stopping runner", e).                     }                     Assert.fail("Output contained illegal string '" + failOnString + "'").                 }             }         }         // check output for the expected terminateAfterString.         if (checkLogForTerminateString) {             LoggingEvent matchedEvent = UtilsTest.getEventContainingString(terminateAfterString).             if (matchedEvent != null) {                 testPassedFromLog4j = true.                 LOG.info("Found expected output in logging event {}", matchedEvent).             }         }         if (outContentString.contains(terminateAfterString) || errContentString.contains(terminateAfterString) || testPassedFromLog4j) {             expectedStringSeen = true.             LOG.info("Found expected output in redirected streams").             // send "stop" command to command line interface             LOG.info("RunWithArgs: request runner to stop").             runner.sendStop().             // wait for the thread to stop             try {                 runner.join(shutdownTimeout).             } catch (InterruptedException e) {                 LOG.warn("Interrupted while stopping runner", e).             }             LOG.warn("RunWithArgs runner stopped.").         } else {             // check if thread died             if (!runner.isAlive()) {                 // leave loop: the runner died, so we can not expect new strings to show up.                 break.             }         }     } while (runner.getRunnerError() == null && !expectedStringSeen && System.currentTimeMillis() < deadline).     resetStreamsAndSendOutput().     if (runner.getRunnerError() != null) {         // this lets the test fail.         throw new RuntimeException("Runner failed", runner.getRunnerError()).     }     Assert.assertTrue("During the timeout period of " + startTimeoutSeconds + " seconds the " + "expected string \"" + terminateAfterString + "\" did not show up.", expectedStringSeen).     LOG.info("Test was successful"). }
false;protected,static;0;8;;protected static void resetStreamsAndSendOutput() {     System.setOut(ORIGINAL_STDOUT).     System.setErr(ORIGINAL_STDERR).     System.setIn(ORIGINAL_STDIN).     LOG.info("Sending stdout content through logger: \n\n{}\n\n", outContent.toString()).     LOG.info("Sending stderr content through logger: \n\n{}\n\n", errContent.toString()). }
false;public;0;38;;@Override public void run() {     try {         int returnValue.         switch(type) {             case YARN_SESSION:                 yCli = new FlinkYarnSessionCli(configuration, configurationDirectory, "", "", true).                 returnValue = yCli.run(args).                 break.             case CLI_FRONTEND:                 try {                     CliFrontend cli = new CliFrontend(configuration, CliFrontend.loadCustomCommandLines(configuration, configurationDirectory)).                     returnValue = cli.parseParameters(args).                 } catch (Exception e) {                     throw new RuntimeException("Failed to execute the following args with CliFrontend: " + Arrays.toString(args), e).                 }                 break.             default:                 throw new RuntimeException("Unknown type " + type).         }         if (returnValue != this.expectedReturnValue) {             Assert.fail("The YARN session returned with unexpected value=" + returnValue + " expected=" + expectedReturnValue).         }     } catch (Throwable t) {         LOG.info("Runner stopped with exception", t).         // save error.         this.runnerError = t.     } }
true;public;0;3;/**  * Stops the Yarn session.  */ ;/**  * Stops the Yarn session.  */ public void sendStop() {     stdinPrintStream.println("stop"). }
false;public;0;3;;public Throwable getRunnerError() {     return runnerError. }
false;public,static;0;37;;// -------------------------- Tear down -------------------------- // @AfterClass public static void teardown() throws Exception {     LOG.info("Stopping MiniYarn Cluster").     yarnCluster.stop().     // Unset FLINK_CONF_DIR, as it might change the behavior of other tests     Map<String, String> map = new HashMap<>(System.getenv()).     map.remove(ConfigConstants.ENV_FLINK_CONF_DIR).     map.remove("YARN_CONF_DIR").     map.remove("IN_TESTS").     TestBaseUtils.setEnv(map).     if (tempConfPathForSecureRun != null) {         FileUtil.fullyDelete(tempConfPathForSecureRun).         tempConfPathForSecureRun = null.     }     // to upload them to Amazon S3.     if (isOnTravis()) {         File target = new File("../target" + YARN_CONFIGURATION.get(TEST_CLUSTER_NAME_KEY)).         if (!target.mkdirs()) {             LOG.warn("Error creating dirs to {}", target).         }         File src = tmp.getRoot().         LOG.info("copying the final files from {} to {}", src.getAbsolutePath(), target.getAbsolutePath()).         try {             FileUtils.copyDirectoryToDirectory(src, target).         } catch (IOException e) {             LOG.warn("Error copying the final files from {} to {}: msg: {}", src.getAbsolutePath(), target.getAbsolutePath(), e.getMessage(), e).         }     } }
false;public,static;0;3;;public static boolean isOnTravis() {     return System.getenv("TRAVIS") != null && System.getenv("TRAVIS").equals("true"). }
false;public;0;3;;public boolean hasNextLine() {     return scanner.hasNextLine(). }
false;public;0;8;;public String nextLine() {     if (bufferedLines.size() == numLinesBuffered) {         bufferedLines.remove(0).     }     String line = scanner.nextLine().     bufferedLines.add(line).     return line. }
false;public;0;3;;public List<String> getPreviousLines() {     return new ArrayList<>(bufferedLines). }
