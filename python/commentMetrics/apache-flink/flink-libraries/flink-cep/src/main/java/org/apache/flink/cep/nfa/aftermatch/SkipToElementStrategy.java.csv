commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isSkipStrategy() {     return true. }
false;protected;2;4;;@Override protected boolean shouldPrune(EventId startEventID, EventId pruningId) {     return startEventID != null && startEventID.compareTo(pruningId) < 0. }
false;protected;1;31;;@Override protected EventId getPruningId(Collection<Map<String, List<EventId>>> match) {     EventId pruningId = null.     for (Map<String, List<EventId>> resultMap : match) {         List<EventId> pruningPattern = resultMap.get(patternName).         if (pruningPattern == null || pruningPattern.isEmpty()) {             if (shouldThrowException) {                 throw new FlinkRuntimeException(String.format("Could not skip to %s. No such element in the found match %s", patternName, resultMap)).             }         } else {             pruningId = max(pruningId, pruningPattern.get(getIndex(pruningPattern.size()))).         }         if (shouldThrowException) {             EventId startEvent = resultMap.values().stream().flatMap(Collection::stream).min(EventId::compareTo).orElseThrow(() -> new IllegalStateException("Cannot prune based on empty match")).             if (pruningId != null && pruningId.equals(startEvent)) {                 throw new FlinkRuntimeException("Could not skip to first element of a match.").             }         }     }     return pruningId. }
false;public;0;4;;@Override public Optional<String> getPatternName() {     return Optional.of(patternName). }
true;abstract;1;1;/**  * Tells which element from the list of events mapped to *PatternName* to use.  *  * @param size number of elements mapped to the *PatternName*  * @return index of event mapped to *PatternName* to use for pruning  */ ;/**  * Tells which element from the list of events mapped to *PatternName* to use.  *  * @param size number of elements mapped to the *PatternName*  * @return index of event mapped to *PatternName* to use for pruning  */ abstract int getIndex(int size).
true;public,abstract;0;1;/**  * Enables throwing exception if no events mapped to the *PatternName*. If not enabled and no events were mapped,  * {@link NoSkipStrategy} will be used  */ ;/**  * Enables throwing exception if no events mapped to the *PatternName*. If not enabled and no events were mapped,  * {@link NoSkipStrategy} will be used  */ public abstract SkipToElementStrategy throwExceptionOnMiss().
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     SkipToElementStrategy that = (SkipToElementStrategy) o.     return shouldThrowException == that.shouldThrowException && Objects.equals(patternName, that.patternName). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(patternName, shouldThrowException). }
