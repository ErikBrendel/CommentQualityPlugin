commented;modifiers;parameterAmount;loc;comment;code
false;public;3;6;;@Override public void setup(StreamTask<?, ?> containingTask, StreamConfig config, Output<StreamRecord<OUT>> output) {     super.setup(containingTask, config, output).     this.cepRuntimeContext = new CepRuntimeContext(getRuntimeContext()).     FunctionUtils.setFunctionRuntimeContext(getUserFunction(), this.cepRuntimeContext). }
false;public;1;20;;@Override public void initializeState(StateInitializationContext context) throws Exception {     super.initializeState(context).     // initializeState through the provided context     computationStates = context.getKeyedStateStore().getState(new ValueStateDescriptor<>(NFA_STATE_NAME, new NFAStateSerializer())).     partialMatches = new SharedBuffer<>(context.getKeyedStateStore(), inputSerializer).     elementQueueState = context.getKeyedStateStore().getMapState(new MapStateDescriptor<>(EVENT_QUEUE_STATE_NAME, LongSerializer.INSTANCE, new ListSerializer<>(inputSerializer))).     migrateOldState(). }
false;public;2;8;;@Override public void process(Object key, ValueState<MigratedNFA<IN>> state) throws Exception {     MigratedNFA<IN> oldState = state.value().     computationStates.update(new NFAState(oldState.getComputationStates())).     org.apache.flink.cep.nfa.SharedBuffer<IN> sharedBuffer = oldState.getSharedBuffer().     partialMatches.init(sharedBuffer.getEventsBuffer(), sharedBuffer.getPages()).     state.clear(). }
false;private;0;20;;private void migrateOldState() throws Exception {     getKeyedStateBackend().applyToAllKeys(VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, new ValueStateDescriptor<>("nfaOperatorStateName", new NFA.NFASerializer<>(inputSerializer)), new KeyedStateFunction<Object, ValueState<MigratedNFA<IN>>>() {          @Override         public void process(Object key, ValueState<MigratedNFA<IN>> state) throws Exception {             MigratedNFA<IN> oldState = state.value().             computationStates.update(new NFAState(oldState.getComputationStates())).             org.apache.flink.cep.nfa.SharedBuffer<IN> sharedBuffer = oldState.getSharedBuffer().             partialMatches.init(sharedBuffer.getEventsBuffer(), sharedBuffer.getPages()).             state.clear().         }     }). }
false;public;0;15;;@Override public void open() throws Exception {     super.open().     timerService = getInternalTimerService("watermark-callbacks", VoidNamespaceSerializer.INSTANCE, this).     nfa = nfaFactory.createNFA().     nfa.open(cepRuntimeContext, new Configuration()).     context = new ContextFunctionImpl().     collector = new TimestampedCollector<>(output).     cepTimerService = new TimerServiceImpl(). }
false;public;0;7;;@Override public void close() throws Exception {     super.close().     if (nfa != null) {         nfa.close().     } }
false;public;1;41;;@Override public void processElement(StreamRecord<IN> element) throws Exception {     if (isProcessingTime) {         if (comparator == null) {             // there can be no out of order elements in processing time             NFAState nfaState = getNFAState().             long timestamp = getProcessingTimeService().getCurrentProcessingTime().             advanceTime(nfaState, timestamp).             processEvent(nfaState, element.getValue(), timestamp).             updateNFA(nfaState).         } else {             long currentTime = timerService.currentProcessingTime().             bufferEvent(element.getValue(), currentTime).             // register a timer for the next millisecond to sort and emit buffered data             timerService.registerProcessingTimeTimer(VoidNamespace.INSTANCE, currentTime + 1).         }     } else {         long timestamp = element.getTimestamp().         IN value = element.getValue().         if (timestamp > lastWatermark) {             // we have an event with a valid timestamp, so             // we buffer it until we receive the proper watermark.             saveRegisterWatermarkTimer().             bufferEvent(value, timestamp).         } else if (lateDataOutputTag != null) {             output.collect(lateDataOutputTag, element).         }     } }
true;private;0;7;/**  * Registers a timer for {@code current watermark + 1}, this means that we get triggered  * whenever the watermark advances, which is what we want for working off the queue of  * buffered elements.  */ ;/**  * Registers a timer for {@code current watermark + 1}, this means that we get triggered  * whenever the watermark advances, which is what we want for working off the queue of  * buffered elements.  */ private void saveRegisterWatermarkTimer() {     long currentWatermark = timerService.currentWatermark().     // protect against overflow     if (currentWatermark + 1 > currentWatermark) {         timerService.registerEventTimeTimer(VoidNamespace.INSTANCE, currentWatermark + 1).     } }
false;private;2;14;;private void bufferEvent(IN event, long currentTime) throws Exception {     List<IN> elementsForTimestamp = elementQueueState.get(currentTime).     if (elementsForTimestamp == null) {         elementsForTimestamp = new ArrayList<>().     }     if (getExecutionConfig().isObjectReuseEnabled()) {         // copy the StreamRecord so that it cannot be changed         elementsForTimestamp.add(inputSerializer.copy(event)).     } else {         elementsForTimestamp.add(event).     }     elementQueueState.put(currentTime, elementsForTimestamp). }
false;public;1;46;;@Override public void onEventTime(InternalTimer<KEY, VoidNamespace> timer) throws Exception {     // 1) get the queue of pending elements for the key and the corresponding NFA,     // 2) process the pending elements in event time order and custom comparator if exists     // by feeding them in the NFA     // 3) advance the time to the current watermark, so that expired patterns are discarded.     // 4) update the stored state for the key, by only storing the new NFA and MapState iff they     // have state to be used later.     // 5) update the last seen watermark.     // STEP 1     PriorityQueue<Long> sortedTimestamps = getSortedTimestamps().     NFAState nfaState = getNFAState().     // STEP 2     while (!sortedTimestamps.isEmpty() && sortedTimestamps.peek() <= timerService.currentWatermark()) {         long timestamp = sortedTimestamps.poll().         advanceTime(nfaState, timestamp).         try (Stream<IN> elements = sort(elementQueueState.get(timestamp))) {             elements.forEachOrdered(event -> {                 try {                     processEvent(nfaState, event, timestamp).                 } catch (Exception e) {                     throw new RuntimeException(e).                 }             }).         }         elementQueueState.remove(timestamp).     }     // STEP 3     advanceTime(nfaState, timerService.currentWatermark()).     // STEP 4     updateNFA(nfaState).     if (!sortedTimestamps.isEmpty() || !partialMatches.isEmpty()) {         saveRegisterWatermarkTimer().     }     // STEP 5     updateLastSeenWatermark(timerService.currentWatermark()). }
false;public;1;33;;@Override public void onProcessingTime(InternalTimer<KEY, VoidNamespace> timer) throws Exception {     // 1) get the queue of pending elements for the key and the corresponding NFA,     // 2) process the pending elements in process time order and custom comparator if exists     // by feeding them in the NFA     // 3) update the stored state for the key, by only storing the new NFA and MapState iff they     // have state to be used later.     // STEP 1     PriorityQueue<Long> sortedTimestamps = getSortedTimestamps().     NFAState nfa = getNFAState().     // STEP 2     while (!sortedTimestamps.isEmpty()) {         long timestamp = sortedTimestamps.poll().         advanceTime(nfa, timestamp).         try (Stream<IN> elements = sort(elementQueueState.get(timestamp))) {             elements.forEachOrdered(event -> {                 try {                     processEvent(nfa, event, timestamp).                 } catch (Exception e) {                     throw new RuntimeException(e).                 }             }).         }         elementQueueState.remove(timestamp).     }     // STEP 3     updateNFA(nfa). }
false;private;1;4;;private Stream<IN> sort(Collection<IN> elements) {     Stream<IN> stream = elements.stream().     return (comparator == null) ? stream : stream.sorted(comparator). }
false;private;1;3;;private void updateLastSeenWatermark(long timestamp) {     this.lastWatermark = timestamp. }
false;private;0;4;;private NFAState getNFAState() throws IOException {     NFAState nfaState = computationStates.value().     return nfaState != null ? nfaState : nfa.createInitialNFAState(). }
false;private;1;6;;private void updateNFA(NFAState nfaState) throws IOException {     if (nfaState.isStateChanged()) {         nfaState.resetStateChanged().         computationStates.update(nfaState).     } }
false;private;0;7;;private PriorityQueue<Long> getSortedTimestamps() throws Exception {     PriorityQueue<Long> sortedTimestamps = new PriorityQueue<>().     for (Long timestamp : elementQueueState.keys()) {         sortedTimestamps.offer(timestamp).     }     return sortedTimestamps. }
true;private;3;7;/**  * Process the given event by giving it to the NFA and outputting the produced set of matched  * event sequences.  *  * @param nfaState Our NFAState object  * @param event The current event to be processed  * @param timestamp The timestamp of the event  */ ;/**  * Process the given event by giving it to the NFA and outputting the produced set of matched  * event sequences.  *  * @param nfaState Our NFAState object  * @param event The current event to be processed  * @param timestamp The timestamp of the event  */ private void processEvent(NFAState nfaState, IN event, long timestamp) throws Exception {     try (SharedBufferAccessor<IN> sharedBufferAccessor = partialMatches.getAccessor()) {         Collection<Map<String, List<IN>>> patterns = nfa.process(sharedBufferAccessor, nfaState, event, timestamp, afterMatchSkipStrategy, cepTimerService).         processMatchedSequences(patterns, timestamp).     } }
true;private;2;9;/**  * Advances the time for the given NFA to the given timestamp. This means that no more events with timestamp  * <b>lower</b> than the given timestamp should be passed to the nfa, This can lead to pruning and timeouts.  */ ;/**  * Advances the time for the given NFA to the given timestamp. This means that no more events with timestamp  * <b>lower</b> than the given timestamp should be passed to the nfa, This can lead to pruning and timeouts.  */ private void advanceTime(NFAState nfaState, long timestamp) throws Exception {     try (SharedBufferAccessor<IN> sharedBufferAccessor = partialMatches.getAccessor()) {         Collection<Tuple2<Map<String, List<IN>>, Long>> timedOut = nfa.advanceTime(sharedBufferAccessor, nfaState, timestamp).         if (!timedOut.isEmpty()) {             processTimedOutSequences(timedOut).         }     } }
false;private;2;7;;private void processMatchedSequences(Iterable<Map<String, List<IN>>> matchingSequences, long timestamp) throws Exception {     PatternProcessFunction<IN, OUT> function = getUserFunction().     setTimestamp(timestamp).     for (Map<String, List<IN>> matchingSequence : matchingSequences) {         function.processMatch(matchingSequence, context, collector).     } }
false;private;1;13;;private void processTimedOutSequences(Collection<Tuple2<Map<String, List<IN>>, Long>> timedOutSequences) throws Exception {     PatternProcessFunction<IN, OUT> function = getUserFunction().     if (function instanceof TimedOutPartialMatchHandler) {         @SuppressWarnings("unchecked")         TimedOutPartialMatchHandler<IN> timeoutHandler = (TimedOutPartialMatchHandler<IN>) function.         for (Tuple2<Map<String, List<IN>>, Long> matchingSequence : timedOutSequences) {             setTimestamp(matchingSequence.f1).             timeoutHandler.processTimedOutMatch(matchingSequence.f0, context).         }     } }
false;private;1;7;;private void setTimestamp(long timestamp) {     if (!isProcessingTime) {         collector.setAbsoluteTimestamp(timestamp).     }     context.setTimestamp(timestamp). }
false;public;0;4;;@Override public long currentProcessingTime() {     return timerService.currentProcessingTime(). }
false;public;2;10;;@Override public <X> void output(final OutputTag<X> outputTag, final X value) {     final StreamRecord<X> record.     if (isProcessingTime) {         record = new StreamRecord<>(value).     } else {         record = new StreamRecord<>(value, timestamp()).     }     output.collect(outputTag, record). }
false;;1;3;;void setTimestamp(long timestamp) {     this.timestamp = timestamp. }
false;public;0;4;;@Override public long timestamp() {     return timestamp. }
false;public;0;4;;@Override public long currentProcessingTime() {     return timerService.currentProcessingTime(). }
false;;1;5;;// ////////////////////			Testing Methods			////////////////////// @VisibleForTesting boolean hasNonEmptySharedBuffer(KEY key) throws Exception {     setCurrentKey(key).     return !partialMatches.isEmpty(). }
false;;1;5;;@VisibleForTesting boolean hasNonEmptyPQ(KEY key) throws Exception {     setCurrentKey(key).     return elementQueueState.keys().iterator().hasNext(). }
false;;1;9;;@VisibleForTesting int getPQSize(KEY key) throws Exception {     setCurrentKey(key).     int counter = 0.     for (List<IN> elements : elementQueueState.values()) {         counter += elements.size().     }     return counter. }
