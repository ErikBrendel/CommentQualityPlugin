commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static Quantifier one(final ConsumingStrategy consumingStrategy) {     return new Quantifier(consumingStrategy, QuantifierProperty.SINGLE). }
false;public,static;1;3;;public static Quantifier looping(final ConsumingStrategy consumingStrategy) {     return new Quantifier(consumingStrategy, QuantifierProperty.LOOPING). }
false;public,static;1;3;;public static Quantifier times(final ConsumingStrategy consumingStrategy) {     return new Quantifier(consumingStrategy, QuantifierProperty.TIMES). }
false;public;1;3;;public boolean hasProperty(QuantifierProperty property) {     return properties.contains(property). }
false;public;0;3;;public ConsumingStrategy getInnerConsumingStrategy() {     return innerConsumingStrategy. }
false;public;0;3;;public ConsumingStrategy getConsumingStrategy() {     return consumingStrategy. }
false;private,static;2;5;;private static void checkPattern(boolean condition, Object errorMessage) {     if (!condition) {         throw new MalformedPatternException(String.valueOf(errorMessage)).     } }
false;public;0;7;;public void combinations() {     checkPattern(!hasProperty(QuantifierProperty.SINGLE), "Combinations not applicable to " + this + "!").     checkPattern(innerConsumingStrategy != ConsumingStrategy.STRICT, "You can apply either combinations or consecutive, not both!").     checkPattern(innerConsumingStrategy != ConsumingStrategy.SKIP_TILL_ANY, "Combinations already applied!").     innerConsumingStrategy = ConsumingStrategy.SKIP_TILL_ANY. }
false;public;0;7;;public void consecutive() {     checkPattern(hasProperty(QuantifierProperty.LOOPING) || hasProperty(QuantifierProperty.TIMES), "Consecutive not applicable to " + this + "!").     checkPattern(innerConsumingStrategy != ConsumingStrategy.SKIP_TILL_ANY, "You can apply either combinations or consecutive, not both!").     checkPattern(innerConsumingStrategy != ConsumingStrategy.STRICT, "Consecutive already applied!").     innerConsumingStrategy = ConsumingStrategy.STRICT. }
false;public;0;7;;public void optional() {     checkPattern(!hasProperty(QuantifierProperty.OPTIONAL), "Optional already applied!").     checkPattern(!(consumingStrategy == ConsumingStrategy.NOT_NEXT || consumingStrategy == ConsumingStrategy.NOT_FOLLOW), "NOT pattern cannot be optional").     properties.add(Quantifier.QuantifierProperty.OPTIONAL). }
false;public;0;8;;public void greedy() {     checkPattern(!(innerConsumingStrategy == ConsumingStrategy.SKIP_TILL_ANY), "Option not applicable to FollowedByAny pattern").     checkPattern(!hasProperty(Quantifier.QuantifierProperty.SINGLE), "Option not applicable to singleton quantifier").     properties.add(QuantifierProperty.GREEDY). }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     Quantifier that = (Quantifier) o.     return Objects.equals(properties, that.properties) && consumingStrategy == that.consumingStrategy && innerConsumingStrategy == that.innerConsumingStrategy. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(properties, consumingStrategy, innerConsumingStrategy). }
false;public;0;8;;@Override public String toString() {     return "Quantifier{" + "properties=" + properties + ", consumingStrategy=" + consumingStrategy + ", innerConsumingStrategy=" + innerConsumingStrategy + '}'. }
false;public;0;3;;public int getFrom() {     return from. }
false;public;0;3;;public int getTo() {     return to. }
false;public,static;2;3;;public static Times of(int from, int to) {     return new Times(from, to). }
false;public,static;1;3;;public static Times of(int times) {     return new Times(times, times). }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     Times times = (Times) o.     return from == times.from && to == times.to. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(from, to). }
