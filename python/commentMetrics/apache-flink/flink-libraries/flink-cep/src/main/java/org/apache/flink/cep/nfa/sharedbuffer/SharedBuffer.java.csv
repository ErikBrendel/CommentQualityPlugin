commented;modifiers;parameterAmount;loc;comment;code
true;public;2;14;/**  * Initializes underlying state with given map of events and entries. Should be used only in case of migration from  * old state.  *  * @param events  map of events with assigned unique ids  * @param entries map of SharedBufferNodes  * @throws Exception Thrown if the system cannot access the state.  * @deprecated Only for state migration!  */ ;/**  * Initializes underlying state with given map of events and entries. Should be used only in case of migration from  * old state.  *  * @param events  map of events with assigned unique ids  * @param entries map of SharedBufferNodes  * @throws Exception Thrown if the system cannot access the state.  * @deprecated Only for state migration!  */ @Deprecated public void init(Map<EventId, Lockable<V>> events, Map<NodeId, Lockable<SharedBufferNode>> entries) throws Exception {     eventsBuffer.putAll(events).     this.entries.putAll(entries).     Map<Long, Integer> maxIds = events.keySet().stream().collect(Collectors.toMap(EventId::getTimestamp, EventId::getId, Math::max)).     eventsCount.putAll(maxIds). }
true;public;0;3;/**  * Construct an accessor to deal with this sharedBuffer.  *  * @return an accessor to deal with this sharedBuffer.  */ ;/**  * Construct an accessor to deal with this sharedBuffer.  *  * @return an accessor to deal with this sharedBuffer.  */ public SharedBufferAccessor<V> getAccessor() {     return new SharedBufferAccessor<>(this). }
false;;1;9;;void advanceTime(long timestamp) throws Exception {     Iterator<Long> iterator = eventsCount.keys().iterator().     while (iterator.hasNext()) {         Long next = iterator.next().         if (next < timestamp) {             iterator.remove().         }     } }
false;;2;11;;EventId registerEvent(V value, long timestamp) throws Exception {     Integer id = eventsCount.get(timestamp).     if (id == null) {         id = 0.     }     EventId eventId = new EventId(id, timestamp).     Lockable<V> lockableValue = new Lockable<>(value, 1).     eventsCount.put(timestamp, id + 1).     eventsBufferCache.put(eventId, lockableValue).     return eventId. }
true;public;0;3;/**  * Checks if there is no elements in the buffer.  *  * @return true if there is no elements in the buffer  * @throws Exception Thrown if the system cannot access the state.  */ ;/**  * Checks if there is no elements in the buffer.  *  * @return true if there is no elements in the buffer  * @throws Exception Thrown if the system cannot access the state.  */ public boolean isEmpty() throws Exception {     return Iterables.isEmpty(eventsBufferCache.keySet()) && Iterables.isEmpty(eventsBuffer.keys()). }
true;;2;3;/**  * Inserts or updates an event in cache.  *  * @param eventId id of the event  * @param event event body  */ ;/**  * Inserts or updates an event in cache.  *  * @param eventId id of the event  * @param event event body  */ void upsertEvent(EventId eventId, Lockable<V> event) {     this.eventsBufferCache.put(eventId, event). }
true;;2;3;/**  * Inserts or updates a shareBufferNode in cache.  *  * @param nodeId id of the event  * @param entry SharedBufferNode  */ ;/**  * Inserts or updates a shareBufferNode in cache.  *  * @param nodeId id of the event  * @param entry SharedBufferNode  */ void upsertEntry(NodeId nodeId, Lockable<SharedBufferNode> entry) {     this.entryCache.put(nodeId, entry). }
true;;1;4;/**  * Removes an event from cache and state.  *  * @param eventId id of the event  */ ;/**  * Removes an event from cache and state.  *  * @param eventId id of the event  */ void removeEvent(EventId eventId) throws Exception {     this.eventsBufferCache.remove(eventId).     this.eventsBuffer.remove(eventId). }
true;;1;4;/**  * Removes a ShareBufferNode from cache and state.  *  * @param nodeId id of the event  */ ;/**  * Removes a ShareBufferNode from cache and state.  *  * @param nodeId id of the event  */ void removeEntry(NodeId nodeId) throws Exception {     this.entryCache.remove(nodeId).     this.entries.remove(nodeId). }
true;;1;9;/**  * It always returns node either from state or cache.  *  * @param nodeId id of the node  * @return SharedBufferNode  */ ;/**  * It always returns node either from state or cache.  *  * @param nodeId id of the node  * @return SharedBufferNode  */ Lockable<SharedBufferNode> getEntry(NodeId nodeId) {     return entryCache.computeIfAbsent(nodeId, id -> {         try {             return entries.get(id).         } catch (Exception ex) {             throw new WrappingRuntimeException(ex).         }     }). }
true;;1;9;/**  * It always returns event either from state or cache.  *  * @param eventId id of the event  * @return event  */ ;/**  * It always returns event either from state or cache.  *  * @param eventId id of the event  * @return event  */ Lockable<V> getEvent(EventId eventId) {     return eventsBufferCache.computeIfAbsent(eventId, id -> {         try {             return eventsBuffer.get(id).         } catch (Exception ex) {             throw new WrappingRuntimeException(ex).         }     }). }
true;;0;10;/**  * Flush the event and node from cache to state.  *  * @throws Exception Thrown if the system cannot access the state.  */ ;/**  * Flush the event and node from cache to state.  *  * @throws Exception Thrown if the system cannot access the state.  */ void flushCache() throws Exception {     if (!entryCache.isEmpty()) {         entries.putAll(entryCache).         entryCache.clear().     }     if (!eventsBufferCache.isEmpty()) {         eventsBuffer.putAll(eventsBufferCache).         eventsBufferCache.clear().     } }
false;;0;4;;@VisibleForTesting Iterator<Map.Entry<Long, Integer>> getEventCounters() throws Exception {     return eventsCount.iterator(). }
false;public;0;4;;@VisibleForTesting public int getEventsBufferCacheSize() {     return eventsBufferCache.size(). }
false;public;0;4;;@VisibleForTesting public int getEventsBufferSize() throws Exception {     return Iterables.size(eventsBuffer.entries()). }
false;public;0;4;;@VisibleForTesting public int getSharedBufferNodeSize() throws Exception {     return Iterables.size(entries.entries()). }
false;public;0;4;;@VisibleForTesting public int getSharedBufferNodeCacheSize() throws Exception {     return entryCache.size(). }
