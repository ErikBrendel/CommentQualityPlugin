commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;4;/**  * Implements the reverse process of the {@link #getUniqueInternalName(String)}.  *  * @param internalName The name to be decoded.  * @return The original, user-specified name for the state.  */ ;/**  * Implements the reverse process of the {@link #getUniqueInternalName(String)}.  *  * @param internalName The name to be decoded.  * @return The original, user-specified name for the state.  */ public static String getOriginalNameFromInternal(String internalName) {     Preconditions.checkNotNull(internalName).     return internalName.split(STATE_NAME_DELIM)[0]. }
true;public;1;6;/**  * Checks if the given name is already used or not. If yes, it  * throws a {@link MalformedPatternException}.  *  * @param name The name to be checked.  */ ;/**  * Checks if the given name is already used or not. If yes, it  * throws a {@link MalformedPatternException}.  *  * @param name The name to be checked.  */ public void checkNameUniqueness(String name) {     if (usedNames.contains(name)) {         throw new MalformedPatternException("Duplicate pattern name: " + name + ". Names must be unique.").     }     usedNames.add(name). }
true;public;0;3;/**  * Clear the names added during checking name uniqueness.  */ ;/**  * Clear the names added during checking name uniqueness.  */ public void clear() {     usedNames.clear(). }
true;public;1;9;/**  * Used to give a unique name to {@link org.apache.flink.cep.nfa.NFA} states  * created during the translation process. The name format will be  * {@code baseName:counter} , where the counter is increasing for states with  * the same {@code baseName}.  *  * @param baseName The base of the name.  * @return The (unique) name that is going to be used internally for the state.  */ ;/**  * Used to give a unique name to {@link org.apache.flink.cep.nfa.NFA} states  * created during the translation process. The name format will be  * {@code baseName:counter} , where the counter is increasing for states with  * the same {@code baseName}.  *  * @param baseName The base of the name.  * @return The (unique) name that is going to be used internally for the state.  */ public String getUniqueInternalName(String baseName) {     int counter = 0.     String candidate = baseName.     while (usedNames.contains(candidate)) {         candidate = baseName + STATE_NAME_DELIM + counter++.     }     usedNames.add(candidate).     return candidate. }
