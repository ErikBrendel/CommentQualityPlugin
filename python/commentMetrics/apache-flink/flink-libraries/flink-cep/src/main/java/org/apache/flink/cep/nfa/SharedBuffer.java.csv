# id;timestamp;commentText;codeText;commentWords;codeWords
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1495024654;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1495099662;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1495466666;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1495961498;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1496929298;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1497328665;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1498764573;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1503598628;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1504268438;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1507895398;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1514551957;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1514881637;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1516692416;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1517847556;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1517847577;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1518627179;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1518679194;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1528894798;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1528894799;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {_		};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1528894799;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {_		};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1530798894;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {_		};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1539149027;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {_		};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1539149114;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {_		};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferSerializerConfigSnapshot -> public SharedBufferSerializerConfigSnapshot();1550652777;This empty constructor is required for deserializing the configuration.;public SharedBufferSerializerConfigSnapshot() {_		};this,empty,constructor,is,required,for,deserializing,the,configuration;public,shared,buffer,serializer,config,snapshot
SharedBuffer -> SharedBufferEntry -> private void removeEdges(final List<SharedBufferEntry<K, V>> prunedEntries);1514881637;Remove edges with the specified targets.;private void removeEdges(final List<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<SharedBufferEdge<K, V>> itor = edges.iterator()__			while (itor.hasNext()) {_				SharedBufferEdge<K, V> edge = itor.next()__				for (SharedBufferEntry<K, V> prunedEntry : prunedEntries) {_					if (prunedEntry == edge.getTarget()) {_						itor.remove()__						break__					}_				}_			}_		};remove,edges,with,the,specified,targets;private,void,remove,edges,final,list,shared,buffer,entry,k,v,pruned,entries,iterator,shared,buffer,edge,k,v,itor,edges,iterator,while,itor,has,next,shared,buffer,edge,k,v,edge,itor,next,for,shared,buffer,entry,k,v,pruned,entry,pruned,entries,if,pruned,entry,edge,get,target,itor,remove,break
SharedBuffer -> SharedBufferEntry -> private void removeEdges(final List<SharedBufferEntry<K, V>> prunedEntries);1516692416;Remove edges with the specified targets.;private void removeEdges(final List<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<SharedBufferEdge<K, V>> itor = edges.iterator()__			while (itor.hasNext()) {_				SharedBufferEdge<K, V> edge = itor.next()__				for (SharedBufferEntry<K, V> prunedEntry : prunedEntries) {_					if (prunedEntry == edge.getTarget()) {_						itor.remove()__						break__					}_				}_			}_		};remove,edges,with,the,specified,targets;private,void,remove,edges,final,list,shared,buffer,entry,k,v,pruned,entries,iterator,shared,buffer,edge,k,v,itor,edges,iterator,while,itor,has,next,shared,buffer,edge,k,v,edge,itor,next,for,shared,buffer,entry,k,v,pruned,entry,pruned,entries,if,pruned,entry,edge,get,target,itor,remove,break
SharedBuffer -> SharedBufferEntry -> private void removeEdges(final List<SharedBufferEntry<K, V>> prunedEntries);1517847556;Remove edges with the specified targets.;private void removeEdges(final List<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<SharedBufferEdge<K, V>> itor = edges.iterator()__			while (itor.hasNext()) {_				SharedBufferEdge<K, V> edge = itor.next()__				for (SharedBufferEntry<K, V> prunedEntry : prunedEntries) {_					if (prunedEntry == edge.getTarget()) {_						itor.remove()__						break__					}_				}_			}_		};remove,edges,with,the,specified,targets;private,void,remove,edges,final,list,shared,buffer,entry,k,v,pruned,entries,iterator,shared,buffer,edge,k,v,itor,edges,iterator,while,itor,has,next,shared,buffer,edge,k,v,edge,itor,next,for,shared,buffer,entry,k,v,pruned,entry,pruned,entries,if,pruned,entry,edge,get,target,itor,remove,break
SharedBuffer -> public Collection<ListMultimap<K, V>> extractPatterns( 		final K key, 		final V value, 		final long timestamp, 		final DeweyNumber version);1495024651;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<ListMultimap<K, V>> extractPatterns(_		final K key,_		final V value,_		final long timestamp,_		final DeweyNumber version) {_		Collection<ListMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					_					final ListMultimap<K, V> completePath = ArrayListMultimap.create()___					while(!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						completePath.put(currentPathEntry.getKey(), currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,list,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,collection,list,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,list,multimap,k,v,complete,path,array,list,multimap,create,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,complete,path,put,current,path,entry,get,key,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public Collection<ListMultimap<K, V>> extractPatterns( 		final K key, 		final V value, 		final long timestamp, 		final DeweyNumber version);1495024652;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<ListMultimap<K, V>> extractPatterns(_		final K key,_		final V value,_		final long timestamp,_		final DeweyNumber version) {_		Collection<ListMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					_					final ListMultimap<K, V> completePath = ArrayListMultimap.create()___					while(!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						completePath.put(currentPathEntry.getKey(), currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,list,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,collection,list,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,list,multimap,k,v,complete,path,array,list,multimap,create,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,complete,path,put,current,path,entry,get,key,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public void put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final DeweyNumber version);1454421848;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key Key of the current value_@param value Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey Key of the value for the previous relation_@param previousValue Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version Version of the previous relation;public void put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final DeweyNumber version) {_		SharedBufferPage<K, V> page___		if (!pages.containsKey(key)) {_			page = new SharedBufferPage<K, V>(key)__			pages.put(key, page)__		} else {_			page = pages.get(key)__		}__		final SharedBufferEntry<K, V> previousSharedBufferEntry = get(previousKey, previousValue, previousTimestamp)___		page.add(_			new ValueTimeWrapper<>(value, timestamp),_			previousSharedBufferEntry,_			version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,dewey,number,version,shared,buffer,page,k,v,page,if,pages,contains,key,key,page,new,shared,buffer,page,k,v,key,pages,put,key,page,else,page,pages,get,key,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,page,add,new,value,time,wrapper,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public void put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final DeweyNumber version);1459346677;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key Key of the current value_@param value Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey Key of the value for the previous relation_@param previousValue Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version Version of the previous relation;public void put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final DeweyNumber version) {_		SharedBufferPage<K, V> page___		if (!pages.containsKey(key)) {_			page = new SharedBufferPage<K, V>(key)__			pages.put(key, page)__		} else {_			page = pages.get(key)__		}__		final SharedBufferEntry<K, V> previousSharedBufferEntry = get(previousKey, previousValue, previousTimestamp)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous shared buffer entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that the element belonging to the previous " +_				"relation has been already pruned, even though you expect it to be still there.")__		}__		page.add(_			new ValueTimeWrapper<>(value, timestamp),_			previousSharedBufferEntry,_			version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,dewey,number,version,shared,buffer,page,k,v,page,if,pages,contains,key,key,page,new,shared,buffer,page,k,v,key,pages,put,key,page,else,page,pages,get,key,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,shared,buffer,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,the,element,belonging,to,the,previous,relation,has,been,already,pruned,even,though,you,expect,it,to,be,still,there,page,add,new,value,time,wrapper,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public void put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final DeweyNumber version);1490262475;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key Key of the current value_@param value Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey Key of the value for the previous relation_@param previousValue Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version Version of the previous relation;public void put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final DeweyNumber version) {_		SharedBufferPage<K, V> page___		if (!pages.containsKey(key)) {_			page = new SharedBufferPage<K, V>(key)__			pages.put(key, page)__		} else {_			page = pages.get(key)__		}__		final SharedBufferEntry<K, V> previousSharedBufferEntry = get(previousKey, previousValue, previousTimestamp)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous shared buffer entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that the element belonging to the previous " +_				"relation has been already pruned, even though you expect it to be still there.")__		}__		page.add(_			new ValueTimeWrapper<>(value, timestamp),_			previousSharedBufferEntry,_			version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,dewey,number,version,shared,buffer,page,k,v,page,if,pages,contains,key,key,page,new,shared,buffer,page,k,v,key,pages,put,key,page,else,page,pages,get,key,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,shared,buffer,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,the,element,belonging,to,the,previous,relation,has,been,already,pruned,even,though,you,expect,it,to,be,still,there,page,add,new,value,time,wrapper,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public void put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final DeweyNumber version);1490262475;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key Key of the current value_@param value Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey Key of the value for the previous relation_@param previousValue Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version Version of the previous relation;public void put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final DeweyNumber version) {_		SharedBufferPage<K, V> page___		if (!pages.containsKey(key)) {_			page = new SharedBufferPage<K, V>(key)__			pages.put(key, page)__		} else {_			page = pages.get(key)__		}__		final SharedBufferEntry<K, V> previousSharedBufferEntry = get(previousKey, previousValue, previousTimestamp)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous shared buffer entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that the element belonging to the previous " +_				"relation has been already pruned, even though you expect it to be still there.")__		}__		page.add(_			new ValueTimeWrapper<>(value, timestamp),_			previousSharedBufferEntry,_			version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,dewey,number,version,shared,buffer,page,k,v,page,if,pages,contains,key,key,page,new,shared,buffer,page,k,v,key,pages,put,key,page,else,page,pages,get,key,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,shared,buffer,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,the,element,belonging,to,the,previous,relation,has,been,already,pruned,even,though,you,expect,it,to,be,still,there,page,add,new,value,time,wrapper,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public void put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final DeweyNumber version);1490638274;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public void put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry = get(previousKey, previousValue, previousTimestamp)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous shared buffer entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that the element belonging to the previous " +_				"relation has been already pruned, even though you expect it to be still there.")__		}__		put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,shared,buffer,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,the,element,belonging,to,the,previous,relation,has,been,already,pruned,even,though,you,expect,it,to,be,still,there,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public void put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final DeweyNumber version);1492770120;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public void put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry = get(previousKey, previousValue, previousTimestamp)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous shared buffer entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that the element belonging to the previous " +_				"relation has been already pruned, even though you expect it to be still there.")__		}__		put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,shared,buffer,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,the,element,belonging,to,the,previous,relation,has,been,already,pruned,even,though,you,expect,it,to,be,still,there,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public void put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final DeweyNumber version);1495024651;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public void put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry = get(previousKey, previousValue, previousTimestamp)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous shared buffer entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that the element belonging to the previous " +_				"relation has been already pruned, even though you expect it to be still there.")__		}__		put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,shared,buffer,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,the,element,belonging,to,the,previous,relation,has,been,already,pruned,even,though,you,expect,it,to,be,still,there,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public void put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final DeweyNumber version);1495024652;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public void put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry = get(previousKey, previousValue, previousTimestamp)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public void put( 		final K key, 		final V value, 		final long timestamp, 		final DeweyNumber version);1459346677;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key Key of the current value_@param value Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version Version of the previous relation;public void put(_		final K key,_		final V value,_		final long timestamp,_		final DeweyNumber version) {_		SharedBufferPage<K, V> page___		if (!pages.containsKey(key)) {_			page = new SharedBufferPage<K, V>(key)__			pages.put(key, page)__		} else {_			page = pages.get(key)__		}__		page.add(_			new ValueTimeWrapper<>(value, timestamp),_			null,_			version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,shared,buffer,page,k,v,page,if,pages,contains,key,key,page,new,shared,buffer,page,k,v,key,pages,put,key,page,else,page,pages,get,key,page,add,new,value,time,wrapper,value,timestamp,null,version
SharedBuffer -> public void put( 		final K key, 		final V value, 		final long timestamp, 		final DeweyNumber version);1490262475;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key Key of the current value_@param value Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version Version of the previous relation;public void put(_		final K key,_		final V value,_		final long timestamp,_		final DeweyNumber version) {_		SharedBufferPage<K, V> page___		if (!pages.containsKey(key)) {_			page = new SharedBufferPage<K, V>(key)__			pages.put(key, page)__		} else {_			page = pages.get(key)__		}__		page.add(_			new ValueTimeWrapper<>(value, timestamp),_			null,_			version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,shared,buffer,page,k,v,page,if,pages,contains,key,key,page,new,shared,buffer,page,k,v,key,pages,put,key,page,else,page,pages,get,key,page,add,new,value,time,wrapper,value,timestamp,null,version
SharedBuffer -> public void put( 		final K key, 		final V value, 		final long timestamp, 		final DeweyNumber version);1490262475;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key Key of the current value_@param value Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version Version of the previous relation;public void put(_		final K key,_		final V value,_		final long timestamp,_		final DeweyNumber version) {_		SharedBufferPage<K, V> page___		if (!pages.containsKey(key)) {_			page = new SharedBufferPage<K, V>(key)__			pages.put(key, page)__		} else {_			page = pages.get(key)__		}__		page.add(_			new ValueTimeWrapper<>(value, timestamp),_			null,_			version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,shared,buffer,page,k,v,page,if,pages,contains,key,key,page,new,shared,buffer,page,k,v,key,pages,put,key,page,else,page,pages,get,key,page,add,new,value,time,wrapper,value,timestamp,null,version
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1490262475;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1490638274;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1492770120;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1495024651;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1495024652;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1495024653;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1495024654;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1495099662;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1495466666;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1495961498;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1496929298;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1497328665;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> @Internal 	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer);1498764573;For backward compatibility only. Previously the key in {@link SharedBuffer} was {@link State}._Now it is {@link String}.;@Internal_	static <T> SharedBuffer<String, T> migrateSharedBuffer(SharedBuffer<State<T>, T> buffer) {__		final Map<String, SharedBufferPage<String, T>> pageMap = new HashMap<>()__		final Map<SharedBufferEntry<State<T>, T>, SharedBufferEntry<String, T>> entries = new HashMap<>()___		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			final SharedBufferPage<String, T> newPage = new SharedBufferPage<>(page.getKey().getName())__			pageMap.put(newPage.getKey(), newPage)___			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newSharedBufferEntry = new SharedBufferEntry<>(_					pageEntry.getKey(),_					newPage)__				newSharedBufferEntry.referenceCounter = pageEntry.getValue().referenceCounter__				entries.put(pageEntry.getValue(), newSharedBufferEntry)__				newPage.entries.put(pageEntry.getKey(), newSharedBufferEntry)__			}_		}__		for (Map.Entry<State<T>, SharedBufferPage<State<T>, T>> page : buffer.pages.entrySet()) {_			for (Map.Entry<ValueTimeWrapper<T>, SharedBufferEntry<State<T>, T>> pageEntry : page.getValue().entries.entrySet()) {_				final SharedBufferEntry<String, T> newEntry = entries.get(pageEntry.getValue())__				for (SharedBufferEdge<State<T>, T> edge : pageEntry.getValue().edges) {_					final SharedBufferEntry<String, T> targetNewEntry = entries.get(edge.getTarget())___					final SharedBufferEdge<String, T> newEdge = new SharedBufferEdge<>(_						targetNewEntry,_						edge.getVersion())__					newEntry.edges.add(newEdge)__				}_			}_		}__		return new SharedBuffer<>(buffer.valueSerializer, pageMap)__	};for,backward,compatibility,only,previously,the,key,in,link,shared,buffer,was,link,state,now,it,is,link,string;internal,static,t,shared,buffer,string,t,migrate,shared,buffer,shared,buffer,state,t,t,buffer,final,map,string,shared,buffer,page,string,t,page,map,new,hash,map,final,map,shared,buffer,entry,state,t,t,shared,buffer,entry,string,t,entries,new,hash,map,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,final,shared,buffer,page,string,t,new,page,new,shared,buffer,page,page,get,key,get,name,page,map,put,new,page,get,key,new,page,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,shared,buffer,entry,new,shared,buffer,entry,page,entry,get,key,new,page,new,shared,buffer,entry,reference,counter,page,entry,get,value,reference,counter,entries,put,page,entry,get,value,new,shared,buffer,entry,new,page,entries,put,page,entry,get,key,new,shared,buffer,entry,for,map,entry,state,t,shared,buffer,page,state,t,t,page,buffer,pages,entry,set,for,map,entry,value,time,wrapper,t,shared,buffer,entry,state,t,t,page,entry,page,get,value,entries,entry,set,final,shared,buffer,entry,string,t,new,entry,entries,get,page,entry,get,value,for,shared,buffer,edge,state,t,t,edge,page,entry,get,value,edges,final,shared,buffer,entry,string,t,target,new,entry,entries,get,edge,get,target,final,shared,buffer,edge,string,t,new,edge,new,shared,buffer,edge,target,new,entry,edge,get,version,new,entry,edges,add,new,edge,return,new,shared,buffer,buffer,value,serializer,page,map
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1495024653;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1495024654;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1495099662;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1495466666;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1495961498;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1496929298;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1497328665;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1498764573;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1503598628;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1504268438;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1507895398;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1514551957;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1514881637;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1516692416;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1517847556;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1517847577;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1518627179;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1518679194;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1528894798;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1528894799;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1528894799;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1530798894;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1539149027;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1539149114;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> ValueTimeWrapper -> public int getCounter();1550652777;Returns a counter used to disambiguate between different accepted_elements with the same value and timestamp that refer to the same_looping state.;public int getCounter() {_			return counter__		};returns,a,counter,used,to,disambiguate,between,different,accepted,elements,with,the,same,value,and,timestamp,that,refer,to,the,same,looping,state;public,int,get,counter,return,counter
SharedBuffer -> SharedBufferPage -> public boolean prune(long pruningTimestamp);1498764573;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning_@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true__			boolean pruned = false___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__					pruned = true__				} else {_					continuePruning = false__				}_			}__			return pruned__		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,boolean,pruned,false,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,pruned,true,else,continue,pruning,false,return,pruned
SharedBuffer -> SharedBufferPage -> public boolean prune(long pruningTimestamp);1503598628;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning_@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true__			boolean pruned = false___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__					pruned = true__				} else {_					continuePruning = false__				}_			}__			return pruned__		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,boolean,pruned,false,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,pruned,true,else,continue,pruning,false,return,pruned
SharedBuffer -> SharedBufferPage -> public boolean prune(long pruningTimestamp);1504268438;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning_@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true__			boolean pruned = false___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__					pruned = true__				} else {_					continuePruning = false__				}_			}__			return pruned__		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,boolean,pruned,false,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,pruned,true,else,continue,pruning,false,return,pruned
SharedBuffer -> SharedBufferPage -> public boolean prune(long pruningTimestamp);1507895398;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning_@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true__			boolean pruned = false___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__					pruned = true__				} else {_					continuePruning = false__				}_			}__			return pruned__		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,boolean,pruned,false,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,pruned,true,else,continue,pruning,false,return,pruned
SharedBuffer -> SharedBufferPage -> public boolean prune(long pruningTimestamp);1514551957;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning_@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true__			boolean pruned = false___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__					pruned = true__				} else {_					continuePruning = false__				}_			}__			return pruned__		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,boolean,pruned,false,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,pruned,true,else,continue,pruning,false,return,pruned
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1454421848;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1459346677;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1490262475;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1490262475;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1490638274;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1492770120;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1495024651;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1495024652;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1495024653;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1495024654;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1495099662;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1495466666;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1495961498;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1496929298;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1497328665;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1498764573;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1503598628;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1504268438;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1507895398;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1514551957;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1514881637;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1516692416;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)___			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<K, V>(valueTime, this)___				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge___			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}__			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,k,v,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1517847556;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)__			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<>(valueTime, this)__				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge__			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}_			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1517847577;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)__			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<>(valueTime, this)__				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge__			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}_			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1518627179;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)__			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<>(valueTime, this)__				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge__			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}_			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1518679194;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)__			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<>(valueTime, this)__				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge__			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}_			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> SharedBufferPage -> public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version);1528894798;Adds a new value time pair to the page. The new entry is linked to the previous entry_with the given version.__@param valueTime Value time pair to be stored_@param previous Previous shared buffer entry to which the new entry shall be linked_@param version Version of the relation between the new and the previous entry;public void add(final ValueTimeWrapper<V> valueTime, final SharedBufferEntry<K, V> previous, final DeweyNumber version) {_			SharedBufferEntry<K, V> sharedBufferEntry = entries.get(valueTime)__			if (sharedBufferEntry == null) {_				sharedBufferEntry = new SharedBufferEntry<>(valueTime, this)__				entries.put(valueTime, sharedBufferEntry)__			}__			SharedBufferEdge<K, V> newEdge__			if (previous != null) {_				newEdge = new SharedBufferEdge<>(previous, version)__				previous.increaseReferenceCounter()__			} else {_				newEdge = new SharedBufferEdge<>(null, version)__			}_			sharedBufferEntry.addEdge(newEdge)__		};adds,a,new,value,time,pair,to,the,page,the,new,entry,is,linked,to,the,previous,entry,with,the,given,version,param,value,time,value,time,pair,to,be,stored,param,previous,previous,shared,buffer,entry,to,which,the,new,entry,shall,be,linked,param,version,version,of,the,relation,between,the,new,and,the,previous,entry;public,void,add,final,value,time,wrapper,v,value,time,final,shared,buffer,entry,k,v,previous,final,dewey,number,version,shared,buffer,entry,k,v,shared,buffer,entry,entries,get,value,time,if,shared,buffer,entry,null,shared,buffer,entry,new,shared,buffer,entry,value,time,this,entries,put,value,time,shared,buffer,entry,shared,buffer,edge,k,v,new,edge,if,previous,null,new,edge,new,shared,buffer,edge,previous,version,previous,increase,reference,counter,else,new,edge,new,shared,buffer,edge,null,version,shared,buffer,entry,add,edge,new,edge
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1495024653;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1495024654;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1495099662;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1495466666;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1495961498;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1496929298;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1497328665;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1498764573;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1503598628;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1504268438;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1507895398;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1514551957;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1514881637;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1516692416;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1517847556;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1517847577;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1518627179;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1518679194;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp, int counter);1528894798;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public boolean prune(long pruningTimestamp);1498764573;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed._@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()__		boolean pruned = false___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			if (page.prune(pruningTimestamp)) {_				pruned = true__			}__			if (page.isEmpty()) {_				_				iter.remove()__			}_		}__		return pruned__	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,boolean,pruned,false,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,if,page,prune,pruning,timestamp,pruned,true,if,page,is,empty,iter,remove,return,pruned
SharedBuffer -> public boolean prune(long pruningTimestamp);1503598628;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed._@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()__		boolean pruned = false___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			if (page.prune(pruningTimestamp)) {_				pruned = true__			}__			if (page.isEmpty()) {_				_				iter.remove()__			}_		}__		return pruned__	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,boolean,pruned,false,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,if,page,prune,pruning,timestamp,pruned,true,if,page,is,empty,iter,remove,return,pruned
SharedBuffer -> public boolean prune(long pruningTimestamp);1504268438;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed._@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()__		boolean pruned = false___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			if (page.prune(pruningTimestamp)) {_				pruned = true__			}__			if (page.isEmpty()) {_				_				iter.remove()__			}_		}__		return pruned__	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,boolean,pruned,false,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,if,page,prune,pruning,timestamp,pruned,true,if,page,is,empty,iter,remove,return,pruned
SharedBuffer -> public boolean prune(long pruningTimestamp);1507895398;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed._@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()__		boolean pruned = false___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			if (page.prune(pruningTimestamp)) {_				pruned = true__			}__			if (page.isEmpty()) {_				_				iter.remove()__			}_		}__		return pruned__	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,boolean,pruned,false,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,if,page,prune,pruning,timestamp,pruned,true,if,page,is,empty,iter,remove,return,pruned
SharedBuffer -> public boolean prune(long pruningTimestamp);1514551957;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed._@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()__		boolean pruned = false___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			if (page.prune(pruningTimestamp)) {_				pruned = true__			}__			if (page.isEmpty()) {_				_				iter.remove()__			}_		}__		return pruned__	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,boolean,pruned,false,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,if,page,prune,pruning,timestamp,pruned,true,if,page,is,empty,iter,remove,return,pruned
SharedBuffer -> public boolean prune(long pruningTimestamp);1514881637;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed._@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()__		List<SharedBufferEntry<K, V>> prunedEntries = new ArrayList<>()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp, prunedEntries)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}__		if (!prunedEntries.isEmpty()) {_			for (Map.Entry<K, SharedBufferPage<K, V>> entry : pages.entrySet()) {_				entry.getValue().removeEdges(prunedEntries)__			}_			return true__		} else {_			return false__		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,list,shared,buffer,entry,k,v,pruned,entries,new,array,list,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,pruned,entries,if,page,is,empty,iter,remove,if,pruned,entries,is,empty,for,map,entry,k,shared,buffer,page,k,v,entry,pages,entry,set,entry,get,value,remove,edges,pruned,entries,return,true,else,return,false
SharedBuffer -> public boolean prune(long pruningTimestamp);1516692416;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed._@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()__		List<SharedBufferEntry<K, V>> prunedEntries = new ArrayList<>()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp, prunedEntries)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}__		if (!prunedEntries.isEmpty()) {_			for (Map.Entry<K, SharedBufferPage<K, V>> entry : pages.entrySet()) {_				entry.getValue().removeEdges(prunedEntries)__			}_			return true__		} else {_			return false__		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,list,shared,buffer,entry,k,v,pruned,entries,new,array,list,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,pruned,entries,if,page,is,empty,iter,remove,if,pruned,entries,is,empty,for,map,entry,k,shared,buffer,page,k,v,entry,pages,entry,set,entry,get,value,remove,edges,pruned,entries,return,true,else,return,false
SharedBuffer -> public boolean prune(long pruningTimestamp);1517847556;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed._@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_		final List<SharedBufferEntry<K, V>> prunedEntries = new ArrayList<>()___		final Iterator<Map.Entry<K, SharedBufferPage<K, V>>> it = pages.entrySet().iterator()__		while (it.hasNext()) {_			SharedBufferPage<K, V> page = it.next().getValue()___			page.prune(pruningTimestamp, prunedEntries)__			if (page.isEmpty()) {_				it.remove()__			}_		}__		if (prunedEntries.isEmpty()) {_			return false__		}__		for (SharedBufferPage<K, V> entry : pages.values()) {_			entry.removeEdges(prunedEntries)__		}_		return true__	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,final,list,shared,buffer,entry,k,v,pruned,entries,new,array,list,final,iterator,map,entry,k,shared,buffer,page,k,v,it,pages,entry,set,iterator,while,it,has,next,shared,buffer,page,k,v,page,it,next,get,value,page,prune,pruning,timestamp,pruned,entries,if,page,is,empty,it,remove,if,pruned,entries,is,empty,return,false,for,shared,buffer,page,k,v,entry,pages,values,entry,remove,edges,pruned,entries,return,true
SharedBuffer -> public boolean prune(long pruningTimestamp);1517847577;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed._@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_		final Set<SharedBufferEntry<K, V>> prunedEntries = new HashSet<>()___		final Iterator<Map.Entry<K, SharedBufferPage<K, V>>> it = pages.entrySet().iterator()__		while (it.hasNext()) {_			SharedBufferPage<K, V> page = it.next().getValue()___			page.prune(pruningTimestamp, prunedEntries)__			if (page.isEmpty()) {_				it.remove()__			}_		}__		if (prunedEntries.isEmpty()) {_			return false__		}__		for (SharedBufferPage<K, V> entry : pages.values()) {_			entry.removeEdges(prunedEntries)__		}_		return true__	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,final,set,shared,buffer,entry,k,v,pruned,entries,new,hash,set,final,iterator,map,entry,k,shared,buffer,page,k,v,it,pages,entry,set,iterator,while,it,has,next,shared,buffer,page,k,v,page,it,next,get,value,page,prune,pruning,timestamp,pruned,entries,if,page,is,empty,it,remove,if,pruned,entries,is,empty,return,false,for,shared,buffer,page,k,v,entry,pages,values,entry,remove,edges,pruned,entries,return,true
SharedBuffer -> public boolean prune(long pruningTimestamp);1518627179;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed._@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_		final Set<SharedBufferEntry<K, V>> prunedEntries = new HashSet<>()___		final Iterator<Map.Entry<K, SharedBufferPage<K, V>>> it = pages.entrySet().iterator()__		while (it.hasNext()) {_			SharedBufferPage<K, V> page = it.next().getValue()___			page.prune(pruningTimestamp, prunedEntries)__			if (page.isEmpty()) {_				it.remove()__			}_		}__		if (prunedEntries.isEmpty()) {_			return false__		}__		for (SharedBufferPage<K, V> entry : pages.values()) {_			entry.removeEdges(prunedEntries)__		}_		return true__	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,final,set,shared,buffer,entry,k,v,pruned,entries,new,hash,set,final,iterator,map,entry,k,shared,buffer,page,k,v,it,pages,entry,set,iterator,while,it,has,next,shared,buffer,page,k,v,page,it,next,get,value,page,prune,pruning,timestamp,pruned,entries,if,page,is,empty,it,remove,if,pruned,entries,is,empty,return,false,for,shared,buffer,page,k,v,entry,pages,values,entry,remove,edges,pruned,entries,return,true
SharedBuffer -> public boolean prune(long pruningTimestamp);1518679194;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed._@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_		final Set<SharedBufferEntry<K, V>> prunedEntries = new HashSet<>()___		final Iterator<Map.Entry<K, SharedBufferPage<K, V>>> it = pages.entrySet().iterator()__		while (it.hasNext()) {_			SharedBufferPage<K, V> page = it.next().getValue()___			page.prune(pruningTimestamp, prunedEntries)__			if (page.isEmpty()) {_				it.remove()__			}_		}__		if (prunedEntries.isEmpty()) {_			return false__		}__		for (SharedBufferPage<K, V> entry : pages.values()) {_			entry.removeEdges(prunedEntries)__		}_		return true__	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,final,set,shared,buffer,entry,k,v,pruned,entries,new,hash,set,final,iterator,map,entry,k,shared,buffer,page,k,v,it,pages,entry,set,iterator,while,it,has,next,shared,buffer,page,k,v,page,it,next,get,value,page,prune,pruning,timestamp,pruned,entries,if,page,is,empty,it,remove,if,pruned,entries,is,empty,return,false,for,shared,buffer,page,k,v,entry,pages,values,entry,remove,edges,pruned,entries,return,true
SharedBuffer -> public boolean prune(long pruningTimestamp);1528894798;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed._@return {@code true} if pruning happened;public boolean prune(long pruningTimestamp) {_		final Set<SharedBufferEntry<K, V>> prunedEntries = new HashSet<>()___		final Iterator<Map.Entry<K, SharedBufferPage<K, V>>> it = pages.entrySet().iterator()__		while (it.hasNext()) {_			SharedBufferPage<K, V> page = it.next().getValue()___			page.prune(pruningTimestamp, prunedEntries)__			if (page.isEmpty()) {_				it.remove()__			}_		}__		if (prunedEntries.isEmpty()) {_			return false__		}__		for (SharedBufferPage<K, V> entry : pages.values()) {_			entry.removeEdges(prunedEntries)__		}_		return true__	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed,return,code,true,if,pruning,happened;public,boolean,prune,long,pruning,timestamp,final,set,shared,buffer,entry,k,v,pruned,entries,new,hash,set,final,iterator,map,entry,k,shared,buffer,page,k,v,it,pages,entry,set,iterator,while,it,has,next,shared,buffer,page,k,v,page,it,next,get,value,page,prune,pruning,timestamp,pruned,entries,if,page,is,empty,it,remove,if,pruned,entries,is,empty,return,false,for,shared,buffer,page,k,v,entry,pages,values,entry,remove,edges,pruned,entries,return,true
SharedBuffer -> SharedBufferEntry -> private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries);1517847577;Remove edges with the specified targets.;private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<SharedBufferEdge<K, V>> it = edges.iterator()__			while (it.hasNext()) {_				SharedBufferEdge<K, V> edge = it.next()__				if (prunedEntries.contains(edge.getTarget())) {_					it.remove()__				}_			}_		};remove,edges,with,the,specified,targets;private,void,remove,edges,final,set,shared,buffer,entry,k,v,pruned,entries,iterator,shared,buffer,edge,k,v,it,edges,iterator,while,it,has,next,shared,buffer,edge,k,v,edge,it,next,if,pruned,entries,contains,edge,get,target,it,remove
SharedBuffer -> SharedBufferEntry -> private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries);1518627179;Remove edges with the specified targets.;private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<SharedBufferEdge<K, V>> it = edges.iterator()__			while (it.hasNext()) {_				SharedBufferEdge<K, V> edge = it.next()__				if (prunedEntries.contains(edge.getTarget())) {_					it.remove()__				}_			}_		};remove,edges,with,the,specified,targets;private,void,remove,edges,final,set,shared,buffer,entry,k,v,pruned,entries,iterator,shared,buffer,edge,k,v,it,edges,iterator,while,it,has,next,shared,buffer,edge,k,v,edge,it,next,if,pruned,entries,contains,edge,get,target,it,remove
SharedBuffer -> SharedBufferEntry -> private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries);1518679194;Remove edges with the specified targets.;private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<SharedBufferEdge<K, V>> it = edges.iterator()__			while (it.hasNext()) {_				SharedBufferEdge<K, V> edge = it.next()__				if (prunedEntries.contains(edge.getTarget())) {_					it.remove()__				}_			}_		};remove,edges,with,the,specified,targets;private,void,remove,edges,final,set,shared,buffer,entry,k,v,pruned,entries,iterator,shared,buffer,edge,k,v,it,edges,iterator,while,it,has,next,shared,buffer,edge,k,v,edge,it,next,if,pruned,entries,contains,edge,get,target,it,remove
SharedBuffer -> SharedBufferEntry -> private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries);1528894798;Remove edges with the specified targets.;private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<SharedBufferEdge<K, V>> it = edges.iterator()__			while (it.hasNext()) {_				SharedBufferEdge<K, V> edge = it.next()__				if (prunedEntries.contains(edge.getTarget())) {_					it.remove()__				}_			}_		};remove,edges,with,the,specified,targets;private,void,remove,edges,final,set,shared,buffer,entry,k,v,pruned,entries,iterator,shared,buffer,edge,k,v,it,edges,iterator,while,it,has,next,shared,buffer,edge,k,v,edge,it,next,if,pruned,entries,contains,edge,get,target,it,remove
SharedBuffer -> SharedBufferPage -> private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries);1517847577;Remove edges with the specified targets for the entries.;private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries) {_			for (SharedBufferEntry<K, V> entry : entries.values()) {_				entry.removeEdges(prunedEntries)__			}_		};remove,edges,with,the,specified,targets,for,the,entries;private,void,remove,edges,final,set,shared,buffer,entry,k,v,pruned,entries,for,shared,buffer,entry,k,v,entry,entries,values,entry,remove,edges,pruned,entries
SharedBuffer -> SharedBufferPage -> private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries);1518627179;Remove edges with the specified targets for the entries.;private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries) {_			for (SharedBufferEntry<K, V> entry : entries.values()) {_				entry.removeEdges(prunedEntries)__			}_		};remove,edges,with,the,specified,targets,for,the,entries;private,void,remove,edges,final,set,shared,buffer,entry,k,v,pruned,entries,for,shared,buffer,entry,k,v,entry,entries,values,entry,remove,edges,pruned,entries
SharedBuffer -> SharedBufferPage -> private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries);1518679194;Remove edges with the specified targets for the entries.;private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries) {_			for (SharedBufferEntry<K, V> entry : entries.values()) {_				entry.removeEdges(prunedEntries)__			}_		};remove,edges,with,the,specified,targets,for,the,entries;private,void,remove,edges,final,set,shared,buffer,entry,k,v,pruned,entries,for,shared,buffer,entry,k,v,entry,entries,values,entry,remove,edges,pruned,entries
SharedBuffer -> SharedBufferPage -> private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries);1528894798;Remove edges with the specified targets for the entries.;private void removeEdges(final Set<SharedBufferEntry<K, V>> prunedEntries) {_			for (SharedBufferEntry<K, V> entry : entries.values()) {_				entry.removeEdges(prunedEntries)__			}_		};remove,edges,with,the,specified,targets,for,the,entries;private,void,remove,edges,final,set,shared,buffer,entry,k,v,pruned,entries,for,shared,buffer,entry,k,v,entry,entries,values,entry,remove,edges,pruned,entries
SharedBuffer -> public void prune(long pruningTimestamp);1454421848;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1459346677;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1490262475;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1490262475;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1490638274;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1492770120;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1495024651;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1495024652;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1495024653;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1495024654;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1495099662;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1495466666;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1495961498;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1496929298;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public void prune(long pruningTimestamp);1497328665;Deletes all entries in each page which have expired with respect to given pruning timestamp.__@param pruningTimestamp The time which is used for pruning. All elements whose timestamp is_lower than the pruning timestamp will be removed.;public void prune(long pruningTimestamp) {_		Iterator<Map.Entry<K, SharedBufferPage<K, V>>> iter = pages.entrySet().iterator()___		while (iter.hasNext()) {_			SharedBufferPage<K, V> page = iter.next().getValue()___			page.prune(pruningTimestamp)___			if (page.isEmpty()) {_				_				iter.remove()__			}_		}_	};deletes,all,entries,in,each,page,which,have,expired,with,respect,to,given,pruning,timestamp,param,pruning,timestamp,the,time,which,is,used,for,pruning,all,elements,whose,timestamp,is,lower,than,the,pruning,timestamp,will,be,removed;public,void,prune,long,pruning,timestamp,iterator,map,entry,k,shared,buffer,page,k,v,iter,pages,entry,set,iterator,while,iter,has,next,shared,buffer,page,k,v,page,iter,next,get,value,page,prune,pruning,timestamp,if,page,is,empty,iter,remove
SharedBuffer -> public Collection<ListMultimap<K, V>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1495024653;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<ListMultimap<K, V>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		Collection<ListMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final ListMultimap<K, V> completePath = ArrayListMultimap.create()___					while(!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						completePath.put(currentPathEntry.getKey(), currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,list,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,collection,list,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,list,multimap,k,v,complete,path,array,list,multimap,create,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,complete,path,put,current,path,entry,get,key,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public Collection<ListMultimap<K, V>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1495024654;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<ListMultimap<K, V>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		Collection<ListMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final ListMultimap<K, V> completePath = ArrayListMultimap.create()___					while(!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						completePath.put(currentPathEntry.getKey(), currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,list,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,collection,list,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,list,multimap,k,v,complete,path,array,list,multimap,create,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,complete,path,put,current,path,entry,get,key,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public Collection<ListMultimap<K, V>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1495099662;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<ListMultimap<K, V>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		Collection<ListMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final ListMultimap<K, V> completePath = ArrayListMultimap.create()___					while(!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						completePath.put(currentPathEntry.getKey(), currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,list,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,collection,list,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,list,multimap,k,v,complete,path,array,list,multimap,create,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,complete,path,put,current,path,entry,get,key,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public Collection<ListMultimap<K, V>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1495466666;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<ListMultimap<K, V>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		Collection<ListMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final ListMultimap<K, V> completePath = ArrayListMultimap.create()___					while(!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						completePath.put(currentPathEntry.getKey(), currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,list,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,collection,list,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,list,multimap,k,v,complete,path,array,list,multimap,create,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,complete,path,put,current,path,entry,get,key,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public Collection<ListMultimap<K, V>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1495961498;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<ListMultimap<K, V>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		Collection<ListMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final ListMultimap<K, V> completePath = ArrayListMultimap.create()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						completePath.put(currentPathEntry.getKey(), currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,list,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,collection,list,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,list,multimap,k,v,complete,path,array,list,multimap,create,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,complete,path,put,current,path,entry,get,key,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> SharedBufferPage -> private void removeEdges(final List<SharedBufferEntry<K, V>> prunedEntries);1514881637;Remove edges with the specified targets for the entries.;private void removeEdges(final List<SharedBufferEntry<K, V>> prunedEntries) {_			for (Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>> entry : entries.entrySet()) {_				entry.getValue().removeEdges(prunedEntries)__			}_		};remove,edges,with,the,specified,targets,for,the,entries;private,void,remove,edges,final,list,shared,buffer,entry,k,v,pruned,entries,for,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,entry,entries,entry,set,entry,get,value,remove,edges,pruned,entries
SharedBuffer -> SharedBufferPage -> private void removeEdges(final List<SharedBufferEntry<K, V>> prunedEntries);1516692416;Remove edges with the specified targets for the entries.;private void removeEdges(final List<SharedBufferEntry<K, V>> prunedEntries) {_			for (Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>> entry : entries.entrySet()) {_				entry.getValue().removeEdges(prunedEntries)__			}_		};remove,edges,with,the,specified,targets,for,the,entries;private,void,remove,edges,final,list,shared,buffer,entry,k,v,pruned,entries,for,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,entry,entries,entry,set,entry,get,value,remove,edges,pruned,entries
SharedBuffer -> SharedBufferPage -> private void removeEdges(final List<SharedBufferEntry<K, V>> prunedEntries);1517847556;Remove edges with the specified targets for the entries.;private void removeEdges(final List<SharedBufferEntry<K, V>> prunedEntries) {_			for (SharedBufferEntry<K, V> entry : entries.values()) {_				entry.removeEdges(prunedEntries)__			}_		};remove,edges,with,the,specified,targets,for,the,entries;private,void,remove,edges,final,list,shared,buffer,entry,k,v,pruned,entries,for,shared,buffer,entry,k,v,entry,entries,values,entry,remove,edges,pruned,entries
SharedBuffer -> public void release(final K key, final V value, final long timestamp);1454421848;Decreases the reference counter for the given value, key, timstamp entry so that it can be_removed once the reference counter reaches 0.__@param key Key of the value to release_@param value Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null ) {_			entry.decreaseReferenceCounter()__		}_	};decreases,the,reference,counter,for,the,given,value,key,timstamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,decrease,reference,counter
SharedBuffer -> public void release(final K key, final V value, final long timestamp);1459346677;Decreases the reference counter for the given value, key, timstamp entry so that it can be_removed once the reference counter reaches 0.__@param key Key of the value to release_@param value Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null ) {_			entry.decreaseReferenceCounter()__		}_	};decreases,the,reference,counter,for,the,given,value,key,timstamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,decrease,reference,counter
SharedBuffer -> public void release(final K key, final V value, final long timestamp);1490262475;Decreases the reference counter for the given value, key, timstamp entry so that it can be_removed once the reference counter reaches 0.__@param key Key of the value to release_@param value Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null ) {_			entry.decreaseReferenceCounter()__		}_	};decreases,the,reference,counter,for,the,given,value,key,timstamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,decrease,reference,counter
SharedBuffer -> public void release(final K key, final V value, final long timestamp);1490262475;Decreases the reference counter for the given value, key, timstamp entry so that it can be_removed once the reference counter reaches 0.__@param key Key of the value to release_@param value Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null ) {_			entry.decreaseReferenceCounter()__		}_	};decreases,the,reference,counter,for,the,given,value,key,timstamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,decrease,reference,counter
SharedBuffer -> public void release(final K key, final V value, final long timestamp);1490638274;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)__		if (entry != null) {_			entry.decreaseReferenceCounter()__			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,decrease,reference,counter,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp);1492770120;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp);1495024651;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp);1495024652;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,internal,remove,entry
SharedBuffer -> public void remove(final K key, final V value, final long timestamp);1454421848;Removes the given value, key, timestamp entry if its reference counter is 0. It will also_release the next element in its previous relation and apply remove to this element_recursively.__@param key Key of the value to remove_@param value Value to remove_@param timestamp Timestamp of the value to remvoe;public void remove(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			internalRemove(entry)__		}_	};removes,the,given,value,key,timestamp,entry,if,its,reference,counter,is,0,it,will,also,release,the,next,element,in,its,previous,relation,and,apply,remove,to,this,element,recursively,param,key,key,of,the,value,to,remove,param,value,value,to,remove,param,timestamp,timestamp,of,the,value,to,remvoe;public,void,remove,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,internal,remove,entry
SharedBuffer -> public void remove(final K key, final V value, final long timestamp);1459346677;Removes the given value, key, timestamp entry if its reference counter is 0. It will also_release the next element in its previous relation and apply remove to this element_recursively.__@param key Key of the value to remove_@param value Value to remove_@param timestamp Timestamp of the value to remvoe;public void remove(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			internalRemove(entry)__		}_	};removes,the,given,value,key,timestamp,entry,if,its,reference,counter,is,0,it,will,also,release,the,next,element,in,its,previous,relation,and,apply,remove,to,this,element,recursively,param,key,key,of,the,value,to,remove,param,value,value,to,remove,param,timestamp,timestamp,of,the,value,to,remvoe;public,void,remove,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,internal,remove,entry
SharedBuffer -> public void remove(final K key, final V value, final long timestamp);1490262475;Removes the given value, key, timestamp entry if its reference counter is 0. It will also_release the next element in its previous relation and apply remove to this element_recursively.__@param key Key of the value to remove_@param value Value to remove_@param timestamp Timestamp of the value to remvoe;public void remove(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			internalRemove(entry)__		}_	};removes,the,given,value,key,timestamp,entry,if,its,reference,counter,is,0,it,will,also,release,the,next,element,in,its,previous,relation,and,apply,remove,to,this,element,recursively,param,key,key,of,the,value,to,remove,param,value,value,to,remove,param,timestamp,timestamp,of,the,value,to,remvoe;public,void,remove,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,internal,remove,entry
SharedBuffer -> public void remove(final K key, final V value, final long timestamp);1490262475;Removes the given value, key, timestamp entry if its reference counter is 0. It will also_release the next element in its previous relation and apply remove to this element_recursively.__@param key Key of the value to remove_@param value Value to remove_@param timestamp Timestamp of the value to remvoe;public void remove(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			internalRemove(entry)__		}_	};removes,the,given,value,key,timestamp,entry,if,its,reference,counter,is,0,it,will,also,release,the,next,element,in,its,previous,relation,and,apply,remove,to,this,element,recursively,param,key,key,of,the,value,to,remove,param,value,value,to,remove,param,timestamp,timestamp,of,the,value,to,remvoe;public,void,remove,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,internal,remove,entry
SharedBuffer -> public Collection<LinkedHashMultimap<K, V>> extractPatterns( 		final K key, 		final V value, 		final long timestamp, 		final DeweyNumber version);1454421848;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<LinkedHashMultimap<K, V>> extractPatterns(_		final K key,_		final V value,_		final long timestamp,_		final DeweyNumber version) {_		Collection<LinkedHashMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			extractionStates.add(new ExtractionState<K, V>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				ExtractionState<K, V> extractionState = extractionStates.pop()__				DeweyNumber currentVersion = extractionState.getVersion()__				_				Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()___				_				if (currentVersion.length() == 1) {_					LinkedHashMultimap<K, V> completePath = LinkedHashMultimap.create()___					while(!currentPath.isEmpty()) {_						SharedBufferEntry<K, V> currentEntry = currentPath.pop()___						completePath.put(currentEntry.getKey(), currentEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {_					SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<K, V>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<K, V>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}_			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,linked,hash,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,collection,linked,hash,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,extraction,states,add,new,extraction,state,k,v,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,extraction,state,k,v,extraction,state,extraction,states,pop,dewey,number,current,version,extraction,state,get,version,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,if,current,version,length,1,linked,hash,multimap,k,v,complete,path,linked,hash,multimap,create,while,current,path,is,empty,shared,buffer,entry,k,v,current,entry,current,path,pop,complete,path,put,current,entry,get,key,current,entry,get,value,time,get,value,result,add,complete,path,else,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,k,v,edge,get,target,edge,get,version,current,path,first,match,false,else,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,k,v,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public Collection<LinkedHashMultimap<K, V>> extractPatterns( 		final K key, 		final V value, 		final long timestamp, 		final DeweyNumber version);1459346677;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<LinkedHashMultimap<K, V>> extractPatterns(_		final K key,_		final V value,_		final long timestamp,_		final DeweyNumber version) {_		Collection<LinkedHashMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			extractionStates.add(new ExtractionState<K, V>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				ExtractionState<K, V> extractionState = extractionStates.pop()__				DeweyNumber currentVersion = extractionState.getVersion()__				_				Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()___				_				if (currentVersion.length() == 1) {_					LinkedHashMultimap<K, V> completePath = LinkedHashMultimap.create()___					while(!currentPath.isEmpty()) {_						SharedBufferEntry<K, V> currentEntry = currentPath.pop()___						completePath.put(currentEntry.getKey(), currentEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {_					SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<K, V>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<K, V>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}_			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,linked,hash,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,collection,linked,hash,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,extraction,states,add,new,extraction,state,k,v,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,extraction,state,k,v,extraction,state,extraction,states,pop,dewey,number,current,version,extraction,state,get,version,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,if,current,version,length,1,linked,hash,multimap,k,v,complete,path,linked,hash,multimap,create,while,current,path,is,empty,shared,buffer,entry,k,v,current,entry,current,path,pop,complete,path,put,current,entry,get,key,current,entry,get,value,time,get,value,result,add,complete,path,else,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,k,v,edge,get,target,edge,get,version,current,path,first,match,false,else,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,k,v,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public Collection<LinkedHashMultimap<K, V>> extractPatterns( 		final K key, 		final V value, 		final long timestamp, 		final DeweyNumber version);1490262475;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<LinkedHashMultimap<K, V>> extractPatterns(_		final K key,_		final V value,_		final long timestamp,_		final DeweyNumber version) {_		Collection<LinkedHashMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final LinkedHashMultimap<K, V> completePath = LinkedHashMultimap.create()___					while(!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						completePath.put(currentPathEntry.getKey(), currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,linked,hash,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,collection,linked,hash,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,linked,hash,multimap,k,v,complete,path,linked,hash,multimap,create,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,complete,path,put,current,path,entry,get,key,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public Collection<LinkedHashMultimap<K, V>> extractPatterns( 		final K key, 		final V value, 		final long timestamp, 		final DeweyNumber version);1490262475;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<LinkedHashMultimap<K, V>> extractPatterns(_		final K key,_		final V value,_		final long timestamp,_		final DeweyNumber version) {_		Collection<LinkedHashMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final LinkedHashMultimap<K, V> completePath = LinkedHashMultimap.create()___					while(!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						completePath.put(currentPathEntry.getKey(), currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,linked,hash,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,collection,linked,hash,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,linked,hash,multimap,k,v,complete,path,linked,hash,multimap,create,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,complete,path,put,current,path,entry,get,key,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public Collection<LinkedHashMultimap<K, V>> extractPatterns( 		final K key, 		final V value, 		final long timestamp, 		final DeweyNumber version);1490638274;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<LinkedHashMultimap<K, V>> extractPatterns(_		final K key,_		final V value,_		final long timestamp,_		final DeweyNumber version) {_		Collection<LinkedHashMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final LinkedHashMultimap<K, V> completePath = LinkedHashMultimap.create()___					while(!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						completePath.put(currentPathEntry.getKey(), currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,linked,hash,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,collection,linked,hash,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,linked,hash,multimap,k,v,complete,path,linked,hash,multimap,create,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,complete,path,put,current,path,entry,get,key,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public Collection<LinkedHashMultimap<K, V>> extractPatterns( 		final K key, 		final V value, 		final long timestamp, 		final DeweyNumber version);1492770120;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public Collection<LinkedHashMultimap<K, V>> extractPatterns(_		final K key,_		final V value,_		final long timestamp,_		final DeweyNumber version) {_		Collection<LinkedHashMultimap<K, V>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final LinkedHashMultimap<K, V> completePath = LinkedHashMultimap.create()___					while(!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						completePath.put(currentPathEntry.getKey(), currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,collection,linked,hash,multimap,k,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,collection,linked,hash,multimap,k,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,linked,hash,multimap,k,v,complete,path,linked,hash,multimap,create,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,complete,path,put,current,path,entry,get,key,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public boolean contains( 		final K key, 		final V value, 		final long timestamp);1454421848;Checks whether the given key, value, timestamp triple is contained in the shared buffer__@param key Key of the value_@param value Value_@param timestamp Timestamp of the value_@return Whether a value with the given timestamp is registered under the given key;public boolean contains(_		final K key,_		final V value,_		final long timestamp) {__		return pages.containsKey(key) && pages.get(key).contains(new ValueTimeWrapper<>(value, timestamp))__	};checks,whether,the,given,key,value,timestamp,triple,is,contained,in,the,shared,buffer,param,key,key,of,the,value,param,value,value,param,timestamp,timestamp,of,the,value,return,whether,a,value,with,the,given,timestamp,is,registered,under,the,given,key;public,boolean,contains,final,k,key,final,v,value,final,long,timestamp,return,pages,contains,key,key,pages,get,key,contains,new,value,time,wrapper,value,timestamp
SharedBuffer -> public boolean contains( 		final K key, 		final V value, 		final long timestamp);1459346677;Checks whether the given key, value, timestamp triple is contained in the shared buffer__@param key Key of the value_@param value Value_@param timestamp Timestamp of the value_@return Whether a value with the given timestamp is registered under the given key;public boolean contains(_		final K key,_		final V value,_		final long timestamp) {__		return pages.containsKey(key) && pages.get(key).contains(new ValueTimeWrapper<>(value, timestamp))__	};checks,whether,the,given,key,value,timestamp,triple,is,contained,in,the,shared,buffer,param,key,key,of,the,value,param,value,value,param,timestamp,timestamp,of,the,value,return,whether,a,value,with,the,given,timestamp,is,registered,under,the,given,key;public,boolean,contains,final,k,key,final,v,value,final,long,timestamp,return,pages,contains,key,key,pages,get,key,contains,new,value,time,wrapper,value,timestamp
SharedBuffer -> public boolean contains( 		final K key, 		final V value, 		final long timestamp);1490262475;Checks whether the given key, value, timestamp triple is contained in the shared buffer__@param key Key of the value_@param value Value_@param timestamp Timestamp of the value_@return Whether a value with the given timestamp is registered under the given key;public boolean contains(_		final K key,_		final V value,_		final long timestamp) {__		return pages.containsKey(key) && pages.get(key).contains(new ValueTimeWrapper<>(value, timestamp))__	};checks,whether,the,given,key,value,timestamp,triple,is,contained,in,the,shared,buffer,param,key,key,of,the,value,param,value,value,param,timestamp,timestamp,of,the,value,return,whether,a,value,with,the,given,timestamp,is,registered,under,the,given,key;public,boolean,contains,final,k,key,final,v,value,final,long,timestamp,return,pages,contains,key,key,pages,get,key,contains,new,value,time,wrapper,value,timestamp
SharedBuffer -> public boolean contains( 		final K key, 		final V value, 		final long timestamp);1490262475;Checks whether the given key, value, timestamp triple is contained in the shared buffer__@param key Key of the value_@param value Value_@param timestamp Timestamp of the value_@return Whether a value with the given timestamp is registered under the given key;public boolean contains(_		final K key,_		final V value,_		final long timestamp) {__		return pages.containsKey(key) && pages.get(key).contains(new ValueTimeWrapper<>(value, timestamp))__	};checks,whether,the,given,key,value,timestamp,triple,is,contained,in,the,shared,buffer,param,key,key,of,the,value,param,value,value,param,timestamp,timestamp,of,the,value,return,whether,a,value,with,the,given,timestamp,is,registered,under,the,given,key;public,boolean,contains,final,k,key,final,v,value,final,long,timestamp,return,pages,contains,key,key,pages,get,key,contains,new,value,time,wrapper,value,timestamp
SharedBuffer -> public void lock(final K key, final V value, final long timestamp);1454421848;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key Key of the value to lock_@param value Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp);1459346677;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key Key of the value to lock_@param value Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp);1490262475;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key Key of the value to lock_@param value Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp);1490262475;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key Key of the value to lock_@param value Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)___		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp);1490638274;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp);1492770120;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp);1495024651;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void lock(final K key, final V value, final long timestamp);1495024652;Increases the reference counter for the given value, key, timestamp entry so that it is not_accidentally removed.__@param key       Key of the value to lock_@param value     Value to lock_@param timestamp Timestamp of the value to lock;public void lock(final K key, final V value, final long timestamp) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp)__		if (entry != null) {_			entry.increaseReferenceCounter()__		}_	};increases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,is,not,accidentally,removed,param,key,key,of,the,value,to,lock,param,value,value,to,lock,param,timestamp,timestamp,of,the,value,to,lock;public,void,lock,final,k,key,final,v,value,final,long,timestamp,shared,buffer,entry,k,v,entry,get,key,value,timestamp,if,entry,null,entry,increase,reference,counter
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1495024653;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1495024654;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1495099662;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1495466666;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1495961498;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1496929298;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1497328665;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1498764573;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1503598628;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1504268438;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1507895398;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1514551957;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1514881637;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1516692416;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1517847556;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1517847577;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1518627179;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1518679194;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public void release(final K key, final V value, final long timestamp, int counter);1528894798;Decreases the reference counter for the given value, key, timestamp entry so that it can be_removed once the reference counter reaches 0.__@param key       Key of the value to release_@param value     Value to release_@param timestamp Timestamp of the value to release;public void release(final K key, final V value, final long timestamp, int counter) {_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)__		if (entry != null) {_			internalRemove(entry)__		}_	};decreases,the,reference,counter,for,the,given,value,key,timestamp,entry,so,that,it,can,be,removed,once,the,reference,counter,reaches,0,param,key,key,of,the,value,to,release,param,value,value,to,release,param,timestamp,timestamp,of,the,value,to,release;public,void,release,final,k,key,final,v,value,final,long,timestamp,int,counter,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,internal,remove,entry
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1496929298;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new HashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1497328665;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new HashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1498764573;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new HashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1503598628;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new HashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1504268438;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new LinkedHashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,linked,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1507895398;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new LinkedHashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,linked,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1514551957;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new LinkedHashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,linked,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1514881637;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new LinkedHashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,linked,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1516692416;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<SharedBufferEntry<K, V>>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new LinkedHashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}__					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}__		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,shared,buffer,entry,k,v,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,linked,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1517847556;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new LinkedHashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}_					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}_		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,linked,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1517847577;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new LinkedHashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}_					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}_		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,linked,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1518627179;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new LinkedHashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}_					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}_		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,linked,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1518679194;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new LinkedHashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}_					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}_		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,linked,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public List<Map<K, List<V>>> extractPatterns( 			final K key, 			final V value, 			final long timestamp, 			final int counter, 			final DeweyNumber version);1528894798;Returns all elements from the previous relation starting at the given value with the_given key and timestamp.__@param key Key of the starting value_@param value Value of the starting element_@param timestamp Timestamp of the starting value_@param version Version of the previous relation which shall be extracted_@return Collection of previous relations starting with the given value;public List<Map<K, List<V>>> extractPatterns(_			final K key,_			final V value,_			final long timestamp,_			final int counter,_			final DeweyNumber version) {__		List<Map<K, List<V>>> result = new ArrayList<>()___		_		Stack<ExtractionState<K, V>> extractionStates = new Stack<>()___		_		SharedBufferEntry<K, V> entry = get(key, value, timestamp, counter)___		if (entry != null) {_			extractionStates.add(new ExtractionState<>(entry, version, new Stack<>()))___			_			while (!extractionStates.isEmpty()) {_				final ExtractionState<K, V> extractionState = extractionStates.pop()__				_				final Stack<SharedBufferEntry<K, V>> currentPath = extractionState.getPath()__				final SharedBufferEntry<K, V> currentEntry = extractionState.getEntry()___				_				if (currentEntry == null) {_					final Map<K, List<V>> completePath = new LinkedHashMap<>()___					while (!currentPath.isEmpty()) {_						final SharedBufferEntry<K, V> currentPathEntry = currentPath.pop()___						K k = currentPathEntry.getKey()__						List<V> values = completePath.get(k)__						if (values == null) {_							values = new ArrayList<>()__							completePath.put(k, values)__						}_						values.add(currentPathEntry.getValueTime().getValue())__					}_					result.add(completePath)__				} else {__					_					currentPath.push(currentEntry)___					boolean firstMatch = true__					for (SharedBufferEdge<K, V> edge : currentEntry.getEdges()) {_						_						_						final DeweyNumber currentVersion = extractionState.getVersion()__						if (currentVersion.isCompatibleWith(edge.getVersion())) {_							if (firstMatch) {_								_								extractionStates.push(new ExtractionState<>(edge.getTarget(), edge.getVersion(), currentPath))__								firstMatch = false__							} else {_								final Stack<SharedBufferEntry<K, V>> copy = new Stack<>()__								copy.addAll(currentPath)___								extractionStates.push(_									new ExtractionState<>(_										edge.getTarget(),_										edge.getVersion(),_										copy))__							}_						}_					}_				}__			}_		}_		return result__	};returns,all,elements,from,the,previous,relation,starting,at,the,given,value,with,the,given,key,and,timestamp,param,key,key,of,the,starting,value,param,value,value,of,the,starting,element,param,timestamp,timestamp,of,the,starting,value,param,version,version,of,the,previous,relation,which,shall,be,extracted,return,collection,of,previous,relations,starting,with,the,given,value;public,list,map,k,list,v,extract,patterns,final,k,key,final,v,value,final,long,timestamp,final,int,counter,final,dewey,number,version,list,map,k,list,v,result,new,array,list,stack,extraction,state,k,v,extraction,states,new,stack,shared,buffer,entry,k,v,entry,get,key,value,timestamp,counter,if,entry,null,extraction,states,add,new,extraction,state,entry,version,new,stack,while,extraction,states,is,empty,final,extraction,state,k,v,extraction,state,extraction,states,pop,final,stack,shared,buffer,entry,k,v,current,path,extraction,state,get,path,final,shared,buffer,entry,k,v,current,entry,extraction,state,get,entry,if,current,entry,null,final,map,k,list,v,complete,path,new,linked,hash,map,while,current,path,is,empty,final,shared,buffer,entry,k,v,current,path,entry,current,path,pop,k,k,current,path,entry,get,key,list,v,values,complete,path,get,k,if,values,null,values,new,array,list,complete,path,put,k,values,values,add,current,path,entry,get,value,time,get,value,result,add,complete,path,else,current,path,push,current,entry,boolean,first,match,true,for,shared,buffer,edge,k,v,edge,current,entry,get,edges,final,dewey,number,current,version,extraction,state,get,version,if,current,version,is,compatible,with,edge,get,version,if,first,match,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,current,path,first,match,false,else,final,stack,shared,buffer,entry,k,v,copy,new,stack,copy,add,all,current,path,extraction,states,push,new,extraction,state,edge,get,target,edge,get,version,copy,return,result
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1495024653;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1495024654;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1495099662;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1495466666;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1495961498;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1496929298;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1497328665;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1498764573;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1503598628;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1504268438;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1507895398;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1514551957;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1514881637;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1516692416;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1517847556;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1517847577;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1518627179;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1518679194;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final K previousKey, 			final V previousValue, 			final long previousTimestamp, 			final int previousCounter, 			final DeweyNumber version);1528894798;Stores given value (value + timestamp) under the given key. It assigns a preceding element_relation to the entry which is defined by the previous key, value (value + timestamp).__@param key               Key of the current value_@param value             Current value_@param timestamp         Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param previousKey       Key of the value for the previous relation_@param previousValue     Value for the previous relation_@param previousTimestamp Timestamp of the value for the previous relation_@param version           Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final K previousKey,_			final V previousValue,_			final long previousTimestamp,_			final int previousCounter,_			final DeweyNumber version) {__		final SharedBufferEntry<K, V> previousSharedBufferEntry =_				get(previousKey, previousValue, previousTimestamp, previousCounter)___		_		if (previousSharedBufferEntry == null && previousValue != null) {_			throw new IllegalStateException("Could not find previous entry with " +_				"key: " + previousKey + ", value: " + previousValue + " and timestamp: " +_				previousTimestamp + ". This can indicate that either you did not implement " +_				"the equals() and hashCode() methods of your input elements properly or that " +_				"the element belonging to that entry has been already pruned.")__		}__		return put(key, value, timestamp, previousSharedBufferEntry, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,a,preceding,element,relation,to,the,entry,which,is,defined,by,the,previous,key,value,value,timestamp,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,previous,key,key,of,the,value,for,the,previous,relation,param,previous,value,value,for,the,previous,relation,param,previous,timestamp,timestamp,of,the,value,for,the,previous,relation,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,k,previous,key,final,v,previous,value,final,long,previous,timestamp,final,int,previous,counter,final,dewey,number,version,final,shared,buffer,entry,k,v,previous,shared,buffer,entry,get,previous,key,previous,value,previous,timestamp,previous,counter,if,previous,shared,buffer,entry,null,previous,value,null,throw,new,illegal,state,exception,could,not,find,previous,entry,with,key,previous,key,value,previous,value,and,timestamp,previous,timestamp,this,can,indicate,that,either,you,did,not,implement,the,equals,and,hash,code,methods,of,your,input,elements,properly,or,that,the,element,belonging,to,that,entry,has,been,already,pruned,return,put,key,value,timestamp,previous,shared,buffer,entry,version
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1454421848;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1459346677;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1490262475;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1490262475;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1490638274;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1492770120;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1495024651;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1495024652;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1495024653;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1495024654;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1495099662;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1495466666;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1495961498;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1496929298;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp);1497328665;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp, List<SharedBufferEntry<K, V>> prunedEntries);1514881637;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp, List<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					prunedEntries.add(entry)__					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,list,shared,buffer,entry,k,v,pruned,entries,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,pruned,entries,add,entry,iterator,remove,else,continue,pruning,false
SharedBuffer -> SharedBufferPage -> public void prune(long pruningTimestamp, List<SharedBufferEntry<K, V>> prunedEntries);1516692416;Removes all entries from the map whose timestamp is smaller than the pruning timestamp.__@param pruningTimestamp Timestamp for the pruning;public void prune(long pruningTimestamp, List<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> iterator = entries.entrySet().iterator()__			boolean continuePruning = true___			while (iterator.hasNext() && continuePruning) {_				SharedBufferEntry<K, V> entry = iterator.next().getValue()___				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					prunedEntries.add(entry)__					iterator.remove()__				} else {_					continuePruning = false__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning;public,void,prune,long,pruning,timestamp,list,shared,buffer,entry,k,v,pruned,entries,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,iterator,entries,entry,set,iterator,boolean,continue,pruning,true,while,iterator,has,next,continue,pruning,shared,buffer,entry,k,v,entry,iterator,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,pruned,entries,add,entry,iterator,remove,else,continue,pruning,false
SharedBuffer -> public void put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1490638274;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public void put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,put,key,value,timestamp,null,version
SharedBuffer -> public void put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1492770120;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public void put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,put,key,value,timestamp,null,version
SharedBuffer -> public void put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1495024651;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public void put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,put,key,value,timestamp,null,version
SharedBuffer -> public void put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1495024652;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public void put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,void,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,put,key,value,timestamp,null,version
SharedBuffer -> SharedBufferPage -> private void prune(final long pruningTimestamp, final Set<SharedBufferEntry<K, V>> prunedEntries);1517847577;Removes all entries from the map whose timestamp is smaller than the pruning timestamp._@param pruningTimestamp Timestamp for the pruning_@param prunedEntries a {@link Set} to put the removed {@link SharedBufferEntry SharedBufferEntries}.;private void prune(final long pruningTimestamp, final Set<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> it = entries.entrySet().iterator()__			while (it.hasNext()) {_				SharedBufferEntry<K, V> entry = it.next().getValue()__				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					prunedEntries.add(entry)__					it.remove()__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning,param,pruned,entries,a,link,set,to,put,the,removed,link,shared,buffer,entry,shared,buffer,entries;private,void,prune,final,long,pruning,timestamp,final,set,shared,buffer,entry,k,v,pruned,entries,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,it,entries,entry,set,iterator,while,it,has,next,shared,buffer,entry,k,v,entry,it,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,pruned,entries,add,entry,it,remove
SharedBuffer -> SharedBufferPage -> private void prune(final long pruningTimestamp, final Set<SharedBufferEntry<K, V>> prunedEntries);1518627179;Removes all entries from the map whose timestamp is smaller than the pruning timestamp._@param pruningTimestamp Timestamp for the pruning_@param prunedEntries a {@link Set} to put the removed {@link SharedBufferEntry SharedBufferEntries}.;private void prune(final long pruningTimestamp, final Set<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> it = entries.entrySet().iterator()__			while (it.hasNext()) {_				SharedBufferEntry<K, V> entry = it.next().getValue()__				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					prunedEntries.add(entry)__					it.remove()__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning,param,pruned,entries,a,link,set,to,put,the,removed,link,shared,buffer,entry,shared,buffer,entries;private,void,prune,final,long,pruning,timestamp,final,set,shared,buffer,entry,k,v,pruned,entries,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,it,entries,entry,set,iterator,while,it,has,next,shared,buffer,entry,k,v,entry,it,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,pruned,entries,add,entry,it,remove
SharedBuffer -> SharedBufferPage -> private void prune(final long pruningTimestamp, final Set<SharedBufferEntry<K, V>> prunedEntries);1518679194;Removes all entries from the map whose timestamp is smaller than the pruning timestamp._@param pruningTimestamp Timestamp for the pruning_@param prunedEntries a {@link Set} to put the removed {@link SharedBufferEntry SharedBufferEntries}.;private void prune(final long pruningTimestamp, final Set<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> it = entries.entrySet().iterator()__			while (it.hasNext()) {_				SharedBufferEntry<K, V> entry = it.next().getValue()__				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					prunedEntries.add(entry)__					it.remove()__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning,param,pruned,entries,a,link,set,to,put,the,removed,link,shared,buffer,entry,shared,buffer,entries;private,void,prune,final,long,pruning,timestamp,final,set,shared,buffer,entry,k,v,pruned,entries,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,it,entries,entry,set,iterator,while,it,has,next,shared,buffer,entry,k,v,entry,it,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,pruned,entries,add,entry,it,remove
SharedBuffer -> SharedBufferPage -> private void prune(final long pruningTimestamp, final Set<SharedBufferEntry<K, V>> prunedEntries);1528894798;Removes all entries from the map whose timestamp is smaller than the pruning timestamp._@param pruningTimestamp Timestamp for the pruning_@param prunedEntries a {@link Set} to put the removed {@link SharedBufferEntry SharedBufferEntries}.;private void prune(final long pruningTimestamp, final Set<SharedBufferEntry<K, V>> prunedEntries) {_			Iterator<Map.Entry<ValueTimeWrapper<V>, SharedBufferEntry<K, V>>> it = entries.entrySet().iterator()__			while (it.hasNext()) {_				SharedBufferEntry<K, V> entry = it.next().getValue()__				if (entry.getValueTime().getTimestamp() <= pruningTimestamp) {_					prunedEntries.add(entry)__					it.remove()__				}_			}_		};removes,all,entries,from,the,map,whose,timestamp,is,smaller,than,the,pruning,timestamp,param,pruning,timestamp,timestamp,for,the,pruning,param,pruned,entries,a,link,set,to,put,the,removed,link,shared,buffer,entry,shared,buffer,entries;private,void,prune,final,long,pruning,timestamp,final,set,shared,buffer,entry,k,v,pruned,entries,iterator,map,entry,value,time,wrapper,v,shared,buffer,entry,k,v,it,entries,entry,set,iterator,while,it,has,next,shared,buffer,entry,k,v,entry,it,next,get,value,if,entry,get,value,time,get,timestamp,pruning,timestamp,pruned,entries,add,entry,it,remove
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1495024653;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1495024654;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1495099662;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1495466666;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1495961498;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1496929298;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1497328665;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1498764573;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1503598628;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1504268438;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1507895398;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1514551957;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1514881637;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1516692416;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1517847556;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1517847577;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1518627179;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1518679194;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
SharedBuffer -> public int put( 			final K key, 			final V value, 			final long timestamp, 			final DeweyNumber version);1528894798;Stores given value (value + timestamp) under the given key. It assigns no preceding element_relation to the entry.__@param key       Key of the current value_@param value     Current value_@param timestamp Timestamp of the current value (a value requires always a timestamp to make it uniquely referable))_@param version   Version of the previous relation;public int put(_			final K key,_			final V value,_			final long timestamp,_			final DeweyNumber version) {__		return put(key, value, timestamp, null, version)__	};stores,given,value,value,timestamp,under,the,given,key,it,assigns,no,preceding,element,relation,to,the,entry,param,key,key,of,the,current,value,param,value,current,value,param,timestamp,timestamp,of,the,current,value,a,value,requires,always,a,timestamp,to,make,it,uniquely,referable,param,version,version,of,the,previous,relation;public,int,put,final,k,key,final,v,value,final,long,timestamp,final,dewey,number,version,return,put,key,value,timestamp,null,version
