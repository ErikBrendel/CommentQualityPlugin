commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Map<EventId, Lockable<V>> getEventsBuffer() {     return eventsBuffer. }
false;public;0;3;;public Map<NodeId, Lockable<SharedBufferNode>> getPages() {     return pages. }
false;public;4;4;;public NodeId getNodeId(String prevState, long timestamp, int counter, V event) {     return mappingContext.get(Tuple2.of(NFAStateNameHandler.getOriginalNameFromInternal(prevState), new ValueTimeWrapper<>(event, timestamp, counter))). }
false;public;1;3;;public EventId getStartEventId(int run) {     return starters.get(run). }
true;public;0;3;/**  * Returns a counter used to disambiguate between different accepted  * elements with the same value and timestamp that refer to the same  * looping state.  */ ;/**  * Returns a counter used to disambiguate between different accepted  * elements with the same value and timestamp that refer to the same  * looping state.  */ public int getCounter() {     return counter. }
false;public;0;3;;public V getValue() {     return value. }
false;public;0;3;;public long getTimestamp() {     return timestamp. }
false;public;0;4;;@Override public String toString() {     return "ValueTimeWrapper(" + value + ", " + timestamp + ", " + counter + ")". }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (!(obj instanceof ValueTimeWrapper)) {         return false.     }     @SuppressWarnings("unchecked")     ValueTimeWrapper<V> other = (ValueTimeWrapper<V>) obj.     return timestamp == other.getTimestamp() && Objects.equals(value, other.getValue()) && counter == other.getCounter(). }
false;public;0;4;;@Override public int hashCode() {     return (int) (31 * (31 * (timestamp ^ timestamp >>> 32) + value.hashCode()) + counter). }
false;public,static;2;10;;public static <V> ValueTimeWrapper<V> deserialize(final TypeSerializer<V> valueSerializer, final DataInputView source) throws IOException {     final V value = valueSerializer.deserialize(source).     final long timestamp = source.readLong().     final int counter = source.readInt().     return new ValueTimeWrapper<>(value, timestamp, counter). }
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
false;public;1;7;;@Override public TypeSerializerSchemaCompatibility<SharedBuffer<V>> resolveSchemaCompatibility(TypeSerializer<SharedBuffer<V>> newSerializer) {     return CompositeTypeSerializerUtil.delegateCompatibilityCheckToNewSnapshot(newSerializer, new SharedBufferSerializerSnapshot<>(), getNestedSerializerSnapshots()). }
false;protected;0;4;;@Override protected int getCurrentOuterSnapshotVersion() {     return VERSION. }
false;protected;1;4;;@Override protected TypeSerializer<?>[] getNestedSerializers(SharedBufferSerializer<K, V> outerSerializer) {     return new TypeSerializer<?>[] { outerSerializer.keySerializer, outerSerializer.valueSerializer, outerSerializer.versionSerializer }. }
false;protected;1;8;;@Override @SuppressWarnings("unchecked") protected SharedBufferSerializer<K, V> createOuterSerializerWithNestedSerializers(TypeSerializer<?>[] nestedSerializers) {     TypeSerializer<K> keySerializer = (TypeSerializer<K>) nestedSerializers[0].     TypeSerializer<V> valueSerializer = (TypeSerializer<V>) nestedSerializers[1].     TypeSerializer<DeweyNumber> versionSerializer = (TypeSerializer<DeweyNumber>) nestedSerializers[2].     return new SharedBufferSerializer<>(keySerializer, valueSerializer, versionSerializer). }
false;public;0;3;;public TypeSerializer<DeweyNumber> getVersionSerializer() {     return versionSerializer. }
false;public;0;3;;public TypeSerializer<K> getKeySerializer() {     return keySerializer. }
false;public;0;3;;public TypeSerializer<V> getValueSerializer() {     return valueSerializer. }
false;public;0;4;;@Override public boolean isImmutableType() {     return false. }
false;public;0;4;;@Override public SharedBufferSerializer<K, V> duplicate() {     return new SharedBufferSerializer<>(keySerializer.duplicate(), valueSerializer.duplicate()). }
false;public;0;4;;@Override public SharedBuffer<V> createInstance() {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public SharedBuffer<V> copy(SharedBuffer<V> from) {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public SharedBuffer<V> copy(SharedBuffer<V> from, SharedBuffer<V> reuse) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public int getLength() {     return -1. }
false;public;2;4;;@Override public void serialize(SharedBuffer<V> record, DataOutputView target) throws IOException {     throw new UnsupportedOperationException(). }
false;public;1;62;;@Override public SharedBuffer<V> deserialize(DataInputView source) throws IOException {     List<Tuple2<NodeId, Lockable<SharedBufferNode>>> entries = new ArrayList<>().     Map<ValueTimeWrapper<V>, EventId> values = new HashMap<>().     Map<EventId, Lockable<V>> valuesWithIds = new HashMap<>().     Map<Tuple2<String, ValueTimeWrapper<V>>, NodeId> mappingContext = new HashMap<>().     Map<Long, Integer> totalEventsPerTimestamp = new HashMap<>().     int totalPages = source.readInt().     for (int i = 0. i < totalPages. i++) {         // key of the page         K stateName = keySerializer.deserialize(source).         int numberEntries = source.readInt().         for (int j = 0. j < numberEntries. j++) {             ValueTimeWrapper<V> wrapper = ValueTimeWrapper.deserialize(valueSerializer, source).             EventId eventId = values.get(wrapper).             if (eventId == null) {                 int id = totalEventsPerTimestamp.computeIfAbsent(wrapper.timestamp, k -> 0).                 eventId = new EventId(id, wrapper.timestamp).                 values.put(wrapper, eventId).                 valuesWithIds.put(eventId, new Lockable<>(wrapper.value, 1)).                 totalEventsPerTimestamp.computeIfPresent(wrapper.timestamp, (k, v) -> v + 1).             } else {                 Lockable<V> eventWrapper = valuesWithIds.get(eventId).                 eventWrapper.lock().             }             NodeId nodeId = new NodeId(eventId, (String) stateName).             int refCount = source.readInt().             entries.add(Tuple2.of(nodeId, new Lockable<>(new SharedBufferNode(), refCount))).             mappingContext.put(Tuple2.of((String) stateName, wrapper), nodeId).         }     }     // read the edges of the shared buffer entries     int totalEdges = source.readInt().     Map<Integer, EventId> starters = new HashMap<>().     for (int j = 0. j < totalEdges. j++) {         int sourceIdx = source.readInt().         int targetIdx = source.readInt().         DeweyNumber version = versionSerializer.deserialize(source).         // We've already deserialized the shared buffer entry. Simply read its ID and         // retrieve the buffer entry from the list of entries         Tuple2<NodeId, Lockable<SharedBufferNode>> sourceEntry = entries.get(sourceIdx).         Tuple2<NodeId, Lockable<SharedBufferNode>> targetEntry = targetIdx < 0 ? Tuple2.of(null, null) : entries.get(targetIdx).         sourceEntry.f1.getElement().addEdge(new SharedBufferEdge(targetEntry.f0, version)).         if (version.length() == 1) {             starters.put(version.getRun(), sourceEntry.f0.getEventId()).         }     }     Map<NodeId, Lockable<SharedBufferNode>> entriesMap = entries.stream().collect(Collectors.toMap(e -> e.f0, e -> e.f1)).     return new SharedBuffer<>(valuesWithIds, entriesMap, mappingContext, starters). }
false;public;2;4;;@Override public SharedBuffer<V> deserialize(SharedBuffer<V> reuse, DataInputView source) throws IOException {     return deserialize(source). }
false;public;2;4;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     throw new UnsupportedOperationException(). }
false;public;1;16;;@Override public boolean equals(Object obj) {     if (obj == this) {         return true.     }     if (obj == null || !Objects.equals(obj.getClass(), getClass())) {         return false.     }     SharedBufferSerializer other = (SharedBufferSerializer) obj.     return Objects.equals(keySerializer, other.getKeySerializer()) && Objects.equals(valueSerializer, other.getValueSerializer()) && Objects.equals(versionSerializer, other.getVersionSerializer()). }
false;public;0;4;;@Override public int hashCode() {     return 37 * keySerializer.hashCode() + valueSerializer.hashCode(). }
false;public;0;4;;@Override public SharedBufferSerializerSnapshot<K, V> snapshotConfiguration() {     return new SharedBufferSerializerSnapshot<>(this). }
