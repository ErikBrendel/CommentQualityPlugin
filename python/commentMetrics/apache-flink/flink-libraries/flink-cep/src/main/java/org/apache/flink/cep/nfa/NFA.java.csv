# id;timestamp;commentText;codeText;commentWords;codeWords
NFA -> public void close() throws Exception;1546179377;Tear-down method for the NFA.;public void close() throws Exception {_		for (State<T> state : getStates()) {_			for (StateTransition<T> transition : state.getStateTransitions()) {_				IterativeCondition condition = transition.getCondition()__				FunctionUtils.closeFunction(condition)__			}_		}_	};tear,down,method,for,the,nfa;public,void,close,throws,exception,for,state,t,state,get,states,for,state,transition,t,transition,state,get,state,transitions,iterative,condition,condition,transition,get,condition,function,utils,close,function,condition
NFA -> public void close() throws Exception;1547021580;Tear-down method for the NFA.;public void close() throws Exception {_		for (State<T> state : getStates()) {_			for (StateTransition<T> transition : state.getStateTransitions()) {_				IterativeCondition condition = transition.getCondition()__				FunctionUtils.closeFunction(condition)__			}_		}_	};tear,down,method,for,the,nfa;public,void,close,throws,exception,for,state,t,state,get,states,for,state,transition,t,transition,state,get,state,transitions,iterative,condition,condition,transition,get,condition,function,utils,close,function,condition
NFA -> public void close() throws Exception;1550652777;Tear-down method for the NFA.;public void close() throws Exception {_		for (State<T> state : getStates()) {_			for (StateTransition<T> transition : state.getStateTransitions()) {_				IterativeCondition condition = transition.getCondition()__				FunctionUtils.closeFunction(condition)__			}_		}_	};tear,down,method,for,the,nfa;public,void,close,throws,exception,for,state,t,state,get,states,for,state,transition,t,transition,state,get,state,transitions,iterative,condition,condition,transition,get,condition,function,utils,close,function,condition
NFA -> public Collection<Map<String, T>> process(final T event, final long timestamp);1454421848;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned.__@param event The current event to be processed_@param timestamp The timestamp of the current event_@return The collection of matched patterns (e.g. the result of computations which have_reached a final state);public Collection<Map<String, T>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final List<Map<String, T>> result = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0 &&_				timestamp - computationState.getStartTimestamp() > windowTime) {_				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}__			_			if(windowTime > 0) {_				long pruningTimestamp = timestamp - windowTime___				_				sharedBuffer.prune(pruningTimestamp)__			}_		}__		return result__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,param,event,the,current,event,to,be,processed,param,timestamp,the,timestamp,of,the,current,event,return,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state;public,collection,map,string,t,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,list,map,string,t,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0,timestamp,computation,state,get,start,timestamp,window,time,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,new,computation,states,compute,next,states,computation,state,event,timestamp,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0,long,pruning,timestamp,timestamp,window,time,shared,buffer,prune,pruning,timestamp,return,result
NFA -> public Collection<Map<String, T>> process(final T event, final long timestamp);1456417982;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned.__@param event The current event to be processed_@param timestamp The timestamp of the current event_@return The collection of matched patterns (e.g. the result of computations which have_reached a final state);public Collection<Map<String, T>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final List<Map<String, T>> result = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0 &&_				timestamp - computationState.getStartTimestamp() > windowTime) {_				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}__			_			if(windowTime > 0) {_				long pruningTimestamp = timestamp - windowTime___				_				sharedBuffer.prune(pruningTimestamp)__			}_		}__		return result__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,param,event,the,current,event,to,be,processed,param,timestamp,the,timestamp,of,the,current,event,return,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state;public,collection,map,string,t,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,list,map,string,t,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0,timestamp,computation,state,get,start,timestamp,window,time,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,new,computation,states,compute,next,states,computation,state,event,timestamp,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0,long,pruning,timestamp,timestamp,window,time,shared,buffer,prune,pruning,timestamp,return,result
NFA -> public Collection<Map<String, T>> process(final T event, final long timestamp);1459346677;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned.__@param event The current event to be processed_@param timestamp The timestamp of the current event_@return The collection of matched patterns (e.g. the result of computations which have_reached a final state);public Collection<Map<String, T>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final List<Map<String, T>> result = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0 &&_				timestamp - computationState.getStartTimestamp() > windowTime) {_				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}__			_			if(windowTime > 0) {_				long pruningTimestamp = timestamp - windowTime___				_				sharedBuffer.prune(pruningTimestamp)__			}_		}__		return result__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,param,event,the,current,event,to,be,processed,param,timestamp,the,timestamp,of,the,current,event,return,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state;public,collection,map,string,t,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,list,map,string,t,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0,timestamp,computation,state,get,start,timestamp,window,time,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,new,computation,states,compute,next,states,computation,state,event,timestamp,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0,long,pruning,timestamp,timestamp,window,time,shared,buffer,prune,pruning,timestamp,return,result
NFA -> public Collection<Map<String, T>> process(final T event, final long timestamp);1459358363;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned.__@param event The current event to be processed_@param timestamp The timestamp of the current event_@return The collection of matched patterns (e.g. the result of computations which have_reached a final state);public Collection<Map<String, T>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final List<Map<String, T>> result = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0 &&_				timestamp - computationState.getStartTimestamp() > windowTime) {_				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}__			_			if(windowTime > 0) {_				long pruningTimestamp = timestamp - windowTime___				_				if (pruningTimestamp >= timestamp) {_					throw new IllegalStateException("Detected an underflow in the pruning timestamp. This indicates that" +_						" either the window length is too long (" + windowTime + ") or that the timestamp has not been" +_						" set correctly (e.g. Long.MIN_VALUE).")__				}__				_				sharedBuffer.prune(pruningTimestamp)__			}_		}__		return result__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,param,event,the,current,event,to,be,processed,param,timestamp,the,timestamp,of,the,current,event,return,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state;public,collection,map,string,t,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,list,map,string,t,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0,timestamp,computation,state,get,start,timestamp,window,time,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,new,computation,states,compute,next,states,computation,state,event,timestamp,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,throw,new,illegal,state,exception,detected,an,underflow,in,the,pruning,timestamp,this,indicates,that,either,the,window,length,is,too,long,window,time,or,that,the,timestamp,has,not,been,set,correctly,e,g,long,shared,buffer,prune,pruning,timestamp,return,result
NFA -> public Collection<Map<String, T>> process(final T event, final long timestamp);1461083852;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned.__@param event The current event to be processed_@param timestamp The timestamp of the current event_@return The collection of matched patterns (e.g. the result of computations which have_reached a final state);public Collection<Map<String, T>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final List<Map<String, T>> result = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0 &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {_				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}__			_			if(windowTime > 0) {_				long pruningTimestamp = timestamp - windowTime___				_				if (pruningTimestamp >= timestamp) {_					throw new IllegalStateException("Detected an underflow in the pruning timestamp. This indicates that" +_						" either the window length is too long (" + windowTime + ") or that the timestamp has not been" +_						" set correctly (e.g. Long.MIN_VALUE).")__				}__				_				sharedBuffer.prune(pruningTimestamp)__			}_		}__		return result__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,param,event,the,current,event,to,be,processed,param,timestamp,the,timestamp,of,the,current,event,return,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state;public,collection,map,string,t,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,list,map,string,t,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0,timestamp,computation,state,get,start,timestamp,window,time,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,new,computation,states,compute,next,states,computation,state,event,timestamp,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,throw,new,illegal,state,exception,detected,an,underflow,in,the,pruning,timestamp,this,indicates,that,either,the,window,length,is,too,long,window,time,or,that,the,timestamp,has,not,been,set,correctly,e,g,long,shared,buffer,prune,pruning,timestamp,return,result
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBuffer<T> sharedBuffer, 			final NFAState nfaState, 			final T event, 			final long timestamp, 			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception;1528894799;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBuffer the SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBuffer<T> sharedBuffer,_			final NFAState nfaState,_			final T event,_			final long timestamp,_			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception {_		try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBuffer)) {_			return doProcess(sharedBuffer, nfaState, eventWrapper, afterMatchSkipStrategy)__		}_	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,the,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,t,shared,buffer,final,nfastate,nfa,state,final,t,event,final,long,timestamp,final,after,match,skip,strategy,after,match,skip,strategy,throws,exception,try,event,wrapper,event,wrapper,new,event,wrapper,event,timestamp,shared,buffer,return,do,process,shared,buffer,nfa,state,event,wrapper,after,match,skip,strategy
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBuffer<T> sharedBuffer, 			final NFAState nfaState, 			final T event, 			final long timestamp, 			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception;1530798894;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBuffer the SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBuffer<T> sharedBuffer,_			final NFAState nfaState,_			final T event,_			final long timestamp,_			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception {_		try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBuffer)) {_			return doProcess(sharedBuffer, nfaState, eventWrapper, afterMatchSkipStrategy)__		}_	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,the,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,t,shared,buffer,final,nfastate,nfa,state,final,t,event,final,long,timestamp,final,after,match,skip,strategy,after,match,skip,strategy,throws,exception,try,event,wrapper,event,wrapper,new,event,wrapper,event,timestamp,shared,buffer,return,do,process,shared,buffer,nfa,state,event,wrapper,after,match,skip,strategy
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBuffer<T> sharedBuffer, 			final NFAState nfaState, 			final T event, 			final long timestamp, 			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception;1530798894;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBuffer the SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBuffer<T> sharedBuffer,_			final NFAState nfaState,_			final T event,_			final long timestamp,_			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception {_		try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBuffer)) {_			return doProcess(sharedBuffer, nfaState, eventWrapper, afterMatchSkipStrategy)__		}_	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,the,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,t,shared,buffer,final,nfastate,nfa,state,final,t,event,final,long,timestamp,final,after,match,skip,strategy,after,match,skip,strategy,throws,exception,try,event,wrapper,event,wrapper,new,event,wrapper,event,timestamp,shared,buffer,return,do,process,shared,buffer,nfa,state,event,wrapper,after,match,skip,strategy
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1490262475;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()____				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,converted,states,get,current,name,previous,state,read,state,get,event,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1490638274;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()____				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1490692084;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()____				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1493985576;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()____				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1494180263;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()____				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1495024651;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()____				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1495024653;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()____				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1495024654;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()____				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1495024655;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()____				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1495203813;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()____				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1495466666;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()____				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1495961498;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()___				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1496929298;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()___				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1497328665;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()___				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1498764573;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()___				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1501661862;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()___				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1502726910;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()___				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1503470129;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()___				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates);1503555538;Needed for backward compatibility. First migrates the {@link State} graph see {@link NFACompiler#migrateGraph(State)}._Than recreates the {@link ComputationState}s with the new {@link State} graph._@param readStates computation states read from snapshot_@return collection of migrated computation states;private Collection<ComputationState<T>> migrateNFA(Collection<ComputationState<T>> readStates) {_		final ArrayList<ComputationState<T>> computationStates = new ArrayList<>()___		final State<T> startState = Iterators.find(_			readStates.iterator(),_			new Predicate<ComputationState<T>>() {_				@Override_				public boolean apply(@Nullable ComputationState<T> input) {_					return input != null && input.getState().getName().equals(BEGINNING_STATE_NAME)__				}_			}).getState()___		final Map<String, State<T>> convertedStates = NFACompiler.migrateGraph(startState)___		for (ComputationState<T> readState : readStates) {_			if (!readState.isStartState()) {_				final String previousName = readState.getState().getName()__				final String currentName = Iterators.find(_					readState.getState().getStateTransitions().iterator(),_					new Predicate<StateTransition<T>>() {_						@Override_						public boolean apply(@Nullable StateTransition<T> input) {_							return input != null && input.getAction() == StateTransitionAction.TAKE__						}_					}).getTargetState().getName()___				final State<T> previousState = convertedStates.get(previousName)___				computationStates.add(ComputationState.createState(_					this,_					convertedStates.get(currentName),_					previousState,_					readState.getEvent(),_					0,_					readState.getTimestamp(),_					readState.getVersion(),_					readState.getStartTimestamp()_				))__			}_		}__		final String startName = Iterators.find(convertedStates.values().iterator(), new Predicate<State<T>>() {_			@Override_			public boolean apply(@Nullable State<T> input) {_				return input != null && input.isStart()__			}_		}).getName()___		computationStates.add(ComputationState.createStartState(_			this,_			convertedStates.get(startName),_			new DeweyNumber(this.startEventCounter)))___		this.states.clear()__		this.states.addAll(convertedStates.values())___		return computationStates__	};needed,for,backward,compatibility,first,migrates,the,link,state,graph,see,link,nfacompiler,migrate,graph,state,than,recreates,the,link,computation,state,s,with,the,new,link,state,graph,param,read,states,computation,states,read,from,snapshot,return,collection,of,migrated,computation,states;private,collection,computation,state,t,migrate,nfa,collection,computation,state,t,read,states,final,array,list,computation,state,t,computation,states,new,array,list,final,state,t,start,state,iterators,find,read,states,iterator,new,predicate,computation,state,t,override,public,boolean,apply,nullable,computation,state,t,input,return,input,null,input,get,state,get,name,equals,get,state,final,map,string,state,t,converted,states,nfacompiler,migrate,graph,start,state,for,computation,state,t,read,state,read,states,if,read,state,is,start,state,final,string,previous,name,read,state,get,state,get,name,final,string,current,name,iterators,find,read,state,get,state,get,state,transitions,iterator,new,predicate,state,transition,t,override,public,boolean,apply,nullable,state,transition,t,input,return,input,null,input,get,action,state,transition,action,take,get,target,state,get,name,final,state,t,previous,state,converted,states,get,previous,name,computation,states,add,computation,state,create,state,this,converted,states,get,current,name,previous,state,read,state,get,event,0,read,state,get,timestamp,read,state,get,version,read,state,get,start,timestamp,final,string,start,name,iterators,find,converted,states,values,iterator,new,predicate,state,t,override,public,boolean,apply,nullable,state,t,input,return,input,null,input,is,start,get,name,computation,states,add,computation,state,create,start,state,this,converted,states,get,start,name,new,dewey,number,this,start,event,counter,this,states,clear,this,states,add,all,converted,states,values,return,computation,states
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp, 			final AfterMatchSkipStrategy afterMatchSkipStrategy, 			final TimerService timerService) throws Exception;1547021580;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@param timerService gives access to processing time and time characteristic, needed for condition evaluation_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp,_			final AfterMatchSkipStrategy afterMatchSkipStrategy,_			final TimerService timerService) throws Exception {_		try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBufferAccessor)) {_			return doProcess(sharedBufferAccessor, nfaState, eventWrapper, afterMatchSkipStrategy, timerService)__		}_	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,param,timer,service,gives,access,to,processing,time,and,time,characteristic,needed,for,condition,evaluation,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,final,after,match,skip,strategy,after,match,skip,strategy,final,timer,service,timer,service,throws,exception,try,event,wrapper,event,wrapper,new,event,wrapper,event,timestamp,shared,buffer,accessor,return,do,process,shared,buffer,accessor,nfa,state,event,wrapper,after,match,skip,strategy,timer,service
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp, 			final AfterMatchSkipStrategy afterMatchSkipStrategy, 			final TimerService timerService) throws Exception;1550652777;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@param timerService gives access to processing time and time characteristic, needed for condition evaluation_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp,_			final AfterMatchSkipStrategy afterMatchSkipStrategy,_			final TimerService timerService) throws Exception {_		try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBufferAccessor)) {_			return doProcess(sharedBufferAccessor, nfaState, eventWrapper, afterMatchSkipStrategy, timerService)__		}_	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,param,timer,service,gives,access,to,processing,time,and,time,characteristic,needed,for,condition,evaluation,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,final,after,match,skip,strategy,after,match,skip,strategy,final,timer,service,timer,service,throws,exception,try,event,wrapper,event,wrapper,new,event,wrapper,event,timestamp,shared,buffer,accessor,return,do,process,shared,buffer,accessor,nfa,state,event,wrapper,after,match,skip,strategy,timer,service
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp) throws Exception;1535555335;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp) throws Exception {_		return process(sharedBufferAccessor, nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,throws,exception,return,process,shared,buffer,accessor,nfa,state,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp) throws Exception;1539149027;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp) throws Exception {_		return process(sharedBufferAccessor, nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,throws,exception,return,process,shared,buffer,accessor,nfa,state,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp) throws Exception;1539149114;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp) throws Exception {_		return process(sharedBufferAccessor, nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,throws,exception,return,process,shared,buffer,accessor,nfa,state,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp) throws Exception;1540386566;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp) throws Exception {_		return process(sharedBufferAccessor, nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,throws,exception,return,process,shared,buffer,accessor,nfa,state,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp) throws Exception;1546179377;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp) throws Exception {_		return process(sharedBufferAccessor, nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,throws,exception,return,process,shared,buffer,accessor,nfa,state,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp) throws Exception;1546179377;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp) throws Exception {_		return process(sharedBufferAccessor, nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,throws,exception,return,process,shared,buffer,accessor,nfa,state,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp) throws Exception;1546179377;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp) throws Exception {_		return process(sharedBufferAccessor, nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,throws,exception,return,process,shared,buffer,accessor,nfa,state,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp, 			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception;1535555335;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp,_			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception {_		try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBufferAccessor)) {_			return doProcess(sharedBufferAccessor, nfaState, eventWrapper, afterMatchSkipStrategy)__		}_	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,final,after,match,skip,strategy,after,match,skip,strategy,throws,exception,try,event,wrapper,event,wrapper,new,event,wrapper,event,timestamp,shared,buffer,accessor,return,do,process,shared,buffer,accessor,nfa,state,event,wrapper,after,match,skip,strategy
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp, 			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception;1539149027;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp,_			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception {_		try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBufferAccessor)) {_			return doProcess(sharedBufferAccessor, nfaState, eventWrapper, afterMatchSkipStrategy)__		}_	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,final,after,match,skip,strategy,after,match,skip,strategy,throws,exception,try,event,wrapper,event,wrapper,new,event,wrapper,event,timestamp,shared,buffer,accessor,return,do,process,shared,buffer,accessor,nfa,state,event,wrapper,after,match,skip,strategy
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp, 			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception;1539149114;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp,_			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception {_		try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBufferAccessor)) {_			return doProcess(sharedBufferAccessor, nfaState, eventWrapper, afterMatchSkipStrategy)__		}_	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,final,after,match,skip,strategy,after,match,skip,strategy,throws,exception,try,event,wrapper,event,wrapper,new,event,wrapper,event,timestamp,shared,buffer,accessor,return,do,process,shared,buffer,accessor,nfa,state,event,wrapper,after,match,skip,strategy
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp, 			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception;1540386566;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp,_			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception {_		try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBufferAccessor)) {_			return doProcess(sharedBufferAccessor, nfaState, eventWrapper, afterMatchSkipStrategy)__		}_	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,final,after,match,skip,strategy,after,match,skip,strategy,throws,exception,try,event,wrapper,event,wrapper,new,event,wrapper,event,timestamp,shared,buffer,accessor,return,do,process,shared,buffer,accessor,nfa,state,event,wrapper,after,match,skip,strategy
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp, 			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception;1546179377;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp,_			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception {_		try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBufferAccessor)) {_			return doProcess(sharedBufferAccessor, nfaState, eventWrapper, afterMatchSkipStrategy)__		}_	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,final,after,match,skip,strategy,after,match,skip,strategy,throws,exception,try,event,wrapper,event,wrapper,new,event,wrapper,event,timestamp,shared,buffer,accessor,return,do,process,shared,buffer,accessor,nfa,state,event,wrapper,after,match,skip,strategy
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp, 			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception;1546179377;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp,_			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception {_		try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBufferAccessor)) {_			return doProcess(sharedBufferAccessor, nfaState, eventWrapper, afterMatchSkipStrategy)__		}_	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,final,after,match,skip,strategy,after,match,skip,strategy,throws,exception,try,event,wrapper,event,wrapper,new,event,wrapper,event,timestamp,shared,buffer,accessor,return,do,process,shared,buffer,accessor,nfa,state,event,wrapper,after,match,skip,strategy
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final T event, 			final long timestamp, 			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception;1546179377;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final T event,_			final long timestamp,_			final AfterMatchSkipStrategy afterMatchSkipStrategy) throws Exception {_		try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBufferAccessor)) {_			return doProcess(sharedBufferAccessor, nfaState, eventWrapper, afterMatchSkipStrategy)__		}_	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,t,event,final,long,timestamp,final,after,match,skip,strategy,after,match,skip,strategy,throws,exception,try,event,wrapper,event,wrapper,new,event,wrapper,event,timestamp,shared,buffer,accessor,return,do,process,shared,buffer,accessor,nfa,state,event,wrapper,after,match,skip,strategy
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final SharedBuffer<String, T> eventSharedBuffer, 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1528894798;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param eventSharedBuffer The shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final SharedBuffer<String, T> eventSharedBuffer,_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(eventSharedBuffer, computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								eventSharedBuffer,_								resultingComputationStates,_								edge.getTargetState(),_								getState(computationState.getPreviousState()),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = getState(computationState.getPreviousState())___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (isStartState(computationState)) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							eventSharedBuffer,_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(eventSharedBuffer, nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								eventSharedBuffer,_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,event,shared,buffer,the,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,shared,buffer,string,t,event,shared,buffer,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,event,shared,buffer,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,event,shared,buffer,resulting,computation,states,edge,get,target,state,get,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,get,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,is,start,state,computation,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,event,shared,buffer,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,event,shared,buffer,next,state,event,computation,state,if,final,state,null,add,computation,state,event,shared,buffer,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final SharedBuffer<String, T> eventSharedBuffer, 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1528894798;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param eventSharedBuffer The shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final SharedBuffer<String, T> eventSharedBuffer,_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(eventSharedBuffer, computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								eventSharedBuffer,_								resultingComputationStates,_								edge.getTargetState(),_								getState(computationState.getPreviousState()),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = getState(computationState.getPreviousState())___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (isStartState(computationState)) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							eventSharedBuffer,_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(eventSharedBuffer, nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								eventSharedBuffer,_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,event,shared,buffer,the,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,shared,buffer,string,t,event,shared,buffer,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,event,shared,buffer,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,event,shared,buffer,resulting,computation,states,edge,get,target,state,get,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,get,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,is,start,state,computation,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,event,shared,buffer,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,event,shared,buffer,next,state,event,computation,state,if,final,state,null,add,computation,state,event,shared,buffer,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> public void open(RuntimeContext cepRuntimeContext, Configuration conf) throws Exception;1546179377;Initialization method for the NFA. It is called before any element is passed and thus suitable for one time setup_work._@param cepRuntimeContext runtime context of the enclosing operator_@param conf The configuration containing the parameters attached to the contract.;public void open(RuntimeContext cepRuntimeContext, Configuration conf) throws Exception {_		for (State<T> state : getStates()) {_			for (StateTransition<T> transition : state.getStateTransitions()) {_				IterativeCondition condition = transition.getCondition()__				FunctionUtils.setFunctionRuntimeContext(condition, cepRuntimeContext)__				FunctionUtils.openFunction(condition, conf)__			}_		}_	};initialization,method,for,the,nfa,it,is,called,before,any,element,is,passed,and,thus,suitable,for,one,time,setup,work,param,cep,runtime,context,runtime,context,of,the,enclosing,operator,param,conf,the,configuration,containing,the,parameters,attached,to,the,contract;public,void,open,runtime,context,cep,runtime,context,configuration,conf,throws,exception,for,state,t,state,get,states,for,state,transition,t,transition,state,get,state,transitions,iterative,condition,condition,transition,get,condition,function,utils,set,function,runtime,context,condition,cep,runtime,context,function,utils,open,function,condition,conf
NFA -> public void open(RuntimeContext cepRuntimeContext, Configuration conf) throws Exception;1547021580;Initialization method for the NFA. It is called before any element is passed and thus suitable for one time setup_work._@param cepRuntimeContext runtime context of the enclosing operator_@param conf The configuration containing the parameters attached to the contract.;public void open(RuntimeContext cepRuntimeContext, Configuration conf) throws Exception {_		for (State<T> state : getStates()) {_			for (StateTransition<T> transition : state.getStateTransitions()) {_				IterativeCondition condition = transition.getCondition()__				FunctionUtils.setFunctionRuntimeContext(condition, cepRuntimeContext)__				FunctionUtils.openFunction(condition, conf)__			}_		}_	};initialization,method,for,the,nfa,it,is,called,before,any,element,is,passed,and,thus,suitable,for,one,time,setup,work,param,cep,runtime,context,runtime,context,of,the,enclosing,operator,param,conf,the,configuration,containing,the,parameters,attached,to,the,contract;public,void,open,runtime,context,cep,runtime,context,configuration,conf,throws,exception,for,state,t,state,get,states,for,state,transition,t,transition,state,get,state,transitions,iterative,condition,condition,transition,get,condition,function,utils,set,function,runtime,context,condition,cep,runtime,context,function,utils,open,function,condition,conf
NFA -> public void open(RuntimeContext cepRuntimeContext, Configuration conf) throws Exception;1550652777;Initialization method for the NFA. It is called before any element is passed and thus suitable for one time setup_work._@param cepRuntimeContext runtime context of the enclosing operator_@param conf The configuration containing the parameters attached to the contract.;public void open(RuntimeContext cepRuntimeContext, Configuration conf) throws Exception {_		for (State<T> state : getStates()) {_			for (StateTransition<T> transition : state.getStateTransitions()) {_				IterativeCondition condition = transition.getCondition()__				FunctionUtils.setFunctionRuntimeContext(condition, cepRuntimeContext)__				FunctionUtils.openFunction(condition, conf)__			}_		}_	};initialization,method,for,the,nfa,it,is,called,before,any,element,is,passed,and,thus,suitable,for,one,time,setup,work,param,cep,runtime,context,runtime,context,of,the,enclosing,operator,param,conf,the,configuration,containing,the,parameters,attached,to,the,contract;public,void,open,runtime,context,cep,runtime,context,configuration,conf,throws,exception,for,state,t,state,get,states,for,state,transition,t,transition,state,get,state,transitions,iterative,condition,condition,transition,get,condition,function,utils,set,function,runtime,context,condition,cep,runtime,context,function,utils,open,function,condition,conf
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process( 			NFAState<T> nfaState, 			final T event, 			final long timestamp, 			AfterMatchSkipStrategy afterMatchSkipStrategy);1528894798;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(_			NFAState<T> nfaState,_			final T event,_			final long timestamp,_			AfterMatchSkipStrategy afterMatchSkipStrategy) {__		Queue<ComputationState<T>> computationStates = nfaState.getComputationStates()__		SharedBuffer<String, T> eventSharedBuffer = nfaState.getEventSharedBuffer()___		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!isStartState(computationState) &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = extractCurrentMatches(eventSharedBuffer, computationState)__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__				nfaState.setStateChanged(true)__			} else if (event != null) {_				newComputationStates = computeNextStates(eventSharedBuffer, computationState, event, timestamp)___				if (newComputationStates.size() != 1) {_					nfaState.setStateChanged(true)__				} else if (!newComputationStates.iterator().next().equals(computationState)) {_					nfaState.setStateChanged(true)__				}_			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (isFinalState(newComputationState)) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(eventSharedBuffer, newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else if (isStopState(newComputationState)) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		discardComputationStatesAccordingToStrategy(_			eventSharedBuffer, computationStates, result, afterMatchSkipStrategy)___		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				if (eventSharedBuffer.prune(pruningTimestamp)) {_					nfaState.setStateChanged(true)__				}_			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,nfastate,t,nfa,state,final,t,event,final,long,timestamp,after,match,skip,strategy,after,match,skip,strategy,queue,computation,state,t,computation,states,nfa,state,get,computation,states,shared,buffer,string,t,event,shared,buffer,nfa,state,get,event,shared,buffer,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,is,start,state,computation,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timed,out,pattern,extract,current,matches,event,shared,buffer,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,nfa,state,set,state,changed,true,else,if,event,null,new,computation,states,compute,next,states,event,shared,buffer,computation,state,event,timestamp,if,new,computation,states,size,1,nfa,state,set,state,changed,true,else,if,new,computation,states,iterator,next,equals,computation,state,nfa,state,set,state,changed,true,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,is,final,state,new,computation,state,map,string,list,t,matched,pattern,extract,current,matches,event,shared,buffer,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,if,is,stop,state,new,computation,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,discard,computation,states,according,to,strategy,event,shared,buffer,computation,states,result,after,match,skip,strategy,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,if,event,shared,buffer,prune,pruning,timestamp,nfa,state,set,state,changed,true,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process( 			NFAState<T> nfaState, 			final T event, 			final long timestamp, 			AfterMatchSkipStrategy afterMatchSkipStrategy);1528894798;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(_			NFAState<T> nfaState,_			final T event,_			final long timestamp,_			AfterMatchSkipStrategy afterMatchSkipStrategy) {__		Queue<ComputationState<T>> computationStates = nfaState.getComputationStates()__		SharedBuffer<String, T> eventSharedBuffer = nfaState.getEventSharedBuffer()___		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!isStartState(computationState) &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = extractCurrentMatches(eventSharedBuffer, computationState)__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__				nfaState.setStateChanged(true)__			} else if (event != null) {_				newComputationStates = computeNextStates(eventSharedBuffer, computationState, event, timestamp)___				if (newComputationStates.size() != 1) {_					nfaState.setStateChanged(true)__				} else if (!newComputationStates.iterator().next().equals(computationState)) {_					nfaState.setStateChanged(true)__				}_			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (isFinalState(newComputationState)) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(eventSharedBuffer, newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else if (isStopState(newComputationState)) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		discardComputationStatesAccordingToStrategy(_			eventSharedBuffer, computationStates, result, afterMatchSkipStrategy)___		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				if (eventSharedBuffer.prune(pruningTimestamp)) {_					nfaState.setStateChanged(true)__				}_			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,nfastate,t,nfa,state,final,t,event,final,long,timestamp,after,match,skip,strategy,after,match,skip,strategy,queue,computation,state,t,computation,states,nfa,state,get,computation,states,shared,buffer,string,t,event,shared,buffer,nfa,state,get,event,shared,buffer,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,is,start,state,computation,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timed,out,pattern,extract,current,matches,event,shared,buffer,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,nfa,state,set,state,changed,true,else,if,event,null,new,computation,states,compute,next,states,event,shared,buffer,computation,state,event,timestamp,if,new,computation,states,size,1,nfa,state,set,state,changed,true,else,if,new,computation,states,iterator,next,equals,computation,state,nfa,state,set,state,changed,true,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,is,final,state,new,computation,state,map,string,list,t,matched,pattern,extract,current,matches,event,shared,buffer,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,if,is,stop,state,new,computation,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,discard,computation,states,according,to,strategy,event,shared,buffer,computation,states,result,after,match,skip,strategy,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,if,event,shared,buffer,prune,pruning,timestamp,nfa,state,set,state,changed,true,return,tuple2,of,result,timeout,result
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBuffer<T> sharedBuffer, 			final NFAState nfaState, 			final T event, 			final long timestamp) throws Exception;1528894799;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBuffer the SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBuffer<T> sharedBuffer,_			final NFAState nfaState,_			final T event,_			final long timestamp) throws Exception {_		return process(sharedBuffer, nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,the,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,t,shared,buffer,final,nfastate,nfa,state,final,t,event,final,long,timestamp,throws,exception,return,process,shared,buffer,nfa,state,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBuffer<T> sharedBuffer, 			final NFAState nfaState, 			final T event, 			final long timestamp) throws Exception;1530798894;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBuffer the SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBuffer<T> sharedBuffer,_			final NFAState nfaState,_			final T event,_			final long timestamp) throws Exception {_		return process(sharedBuffer, nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,the,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,t,shared,buffer,final,nfastate,nfa,state,final,t,event,final,long,timestamp,throws,exception,return,process,shared,buffer,nfa,state,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Collection<Map<String, List<T>>> process( 			final SharedBuffer<T> sharedBuffer, 			final NFAState nfaState, 			final T event, 			final long timestamp) throws Exception;1530798894;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param sharedBuffer the SharedBuffer object that we need to work upon while processing_@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated)_@throws Exception Thrown if the system cannot access the state.;public Collection<Map<String, List<T>>> process(_			final SharedBuffer<T> sharedBuffer,_			final NFAState nfaState,_			final T event,_			final long timestamp) throws Exception {_		return process(sharedBuffer, nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,shared,buffer,the,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,map,string,list,t,process,final,shared,buffer,t,shared,buffer,final,nfastate,nfa,state,final,t,event,final,long,timestamp,throws,exception,return,process,shared,buffer,nfa,state,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public boolean isNFAChanged();1498764573;Check if the matching status of the NFA has changed so far.__@return {@code true} if matching status has changed, {@code false} otherwise;public boolean isNFAChanged() {_		return nfaChanged__	};check,if,the,matching,status,of,the,nfa,has,changed,so,far,return,code,true,if,matching,status,has,changed,code,false,otherwise;public,boolean,is,nfachanged,return,nfa,changed
NFA -> public boolean isNFAChanged();1501661862;Check if the matching status of the NFA has changed so far.__@return {@code true} if matching status has changed, {@code false} otherwise;public boolean isNFAChanged() {_		return nfaChanged__	};check,if,the,matching,status,of,the,nfa,has,changed,so,far,return,code,true,if,matching,status,has,changed,code,false,otherwise;public,boolean,is,nfachanged,return,nfa,changed
NFA -> public boolean isNFAChanged();1502726910;Check if the matching status of the NFA has changed so far.__@return {@code true} if matching status has changed, {@code false} otherwise;public boolean isNFAChanged() {_		return nfaChanged__	};check,if,the,matching,status,of,the,nfa,has,changed,so,far,return,code,true,if,matching,status,has,changed,code,false,otherwise;public,boolean,is,nfachanged,return,nfa,changed
NFA -> public boolean isNFAChanged();1503470129;Check if the matching status of the NFA has changed so far.__@return {@code true} if matching status has changed, {@code false} otherwise;public boolean isNFAChanged() {_		return nfaChanged__	};check,if,the,matching,status,of,the,nfa,has,changed,so,far,return,code,true,if,matching,status,has,changed,code,false,otherwise;public,boolean,is,nfachanged,return,nfa,changed
NFA -> public boolean isNFAChanged();1503555538;Check if the matching status of the NFA has changed so far.__@return {@code true} if matching status has changed, {@code false} otherwise;public boolean isNFAChanged() {_		return nfaChanged__	};check,if,the,matching,status,of,the,nfa,has,changed,so,far,return,code,true,if,matching,status,has,changed,code,false,otherwise;public,boolean,is,nfachanged,return,nfa,changed
NFA -> public boolean isNFAChanged();1503598628;Check if the matching status of the NFA has changed so far.__@return {@code true} if matching status has changed, {@code false} otherwise;public boolean isNFAChanged() {_		return nfaChanged__	};check,if,the,matching,status,of,the,nfa,has,changed,so,far,return,code,true,if,matching,status,has,changed,code,false,otherwise;public,boolean,is,nfachanged,return,nfa,changed
NFA -> public boolean isNFAChanged();1504268438;Check if the matching status of the NFA has changed so far.__@return {@code true} if matching status has changed, {@code false} otherwise;public boolean isNFAChanged() {_		return nfaChanged__	};check,if,the,matching,status,of,the,nfa,has,changed,so,far,return,code,true,if,matching,status,has,changed,code,false,otherwise;public,boolean,is,nfachanged,return,nfa,changed
NFA -> public boolean isNFAChanged();1507895398;Check if the matching status of the NFA has changed so far.__@return {@code true} if matching status has changed, {@code false} otherwise;public boolean isNFAChanged() {_		return nfaChanged__	};check,if,the,matching,status,of,the,nfa,has,changed,so,far,return,code,true,if,matching,status,has,changed,code,false,otherwise;public,boolean,is,nfachanged,return,nfa,changed
NFA -> public boolean isNFAChanged();1516692416;Check if the matching status of the NFA has changed so far.__@return {@code true} if matching status has changed, {@code false} otherwise;public boolean isNFAChanged() {_		return nfaChanged__	};check,if,the,matching,status,of,the,nfa,has,changed,so,far,return,code,true,if,matching,status,has,changed,code,false,otherwise;public,boolean,is,nfachanged,return,nfa,changed
NFA -> public boolean isNFAChanged();1518030004;Check if the matching status of the NFA has changed so far.__@return {@code true} if matching status has changed, {@code false} otherwise;public boolean isNFAChanged() {_		return nfaChanged__	};check,if,the,matching,status,of,the,nfa,has,changed,so,far,return,code,true,if,matching,status,has,changed,code,false,otherwise;public,boolean,is,nfachanged,return,nfa,changed
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1454421848;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		ArrayList<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			Collection<StateTransition<T>> stateTransitions = currentState.getStateTransitions()___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								resultingComputationStates.add(computationState)___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber newVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									newVersion = new DeweyNumber(startEventCounter++)__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()___									if (newState.equals(computationState.getState())) {_										newVersion = computationState.getVersion().increase()__									} else {_										newVersion = computationState.getVersion().addStage()__									}_								}__								sharedBuffer.put(_									newState,_									event,_									timestamp,_									previousState,_									previousEvent,_									previousTimestamp,_									newVersion)___								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,array,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,while,states,is,empty,state,t,current,state,states,pop,collection,state,transition,t,state,transitions,current,state,get,state,transitions,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,resulting,computation,states,add,computation,state,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,new,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,new,version,new,dewey,number,start,event,counter,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,if,new,state,equals,computation,state,get,state,new,version,computation,state,get,version,increase,else,new,version,computation,state,get,version,add,stage,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,new,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1456417982;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		ArrayList<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			Collection<StateTransition<T>> stateTransitions = currentState.getStateTransitions()___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								resultingComputationStates.add(computationState)___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber oldVersion__								final DeweyNumber newComputationStateVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									oldVersion = new DeweyNumber(startEventCounter++)__									newComputationStateVersion = oldVersion.addStage()__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()__									oldVersion = computationState.getVersion()___									if (newState.equals(computationState.getState())) {_										newComputationStateVersion = oldVersion.increase()__									} else {_										newComputationStateVersion = oldVersion.addStage()__									}_								}__								sharedBuffer.put(_									newState,_									event,_									timestamp,_									previousState,_									previousEvent,_									previousTimestamp,_									oldVersion)___								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newComputationStateVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,array,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,while,states,is,empty,state,t,current,state,states,pop,collection,state,transition,t,state,transitions,current,state,get,state,transitions,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,resulting,computation,states,add,computation,state,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,old,version,final,dewey,number,new,computation,state,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,old,version,new,dewey,number,start,event,counter,new,computation,state,version,old,version,add,stage,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,old,version,computation,state,get,version,if,new,state,equals,computation,state,get,state,new,computation,state,version,old,version,increase,else,new,computation,state,version,old,version,add,stage,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,old,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,computation,state,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1459346677;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		ArrayList<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			Collection<StateTransition<T>> stateTransitions = currentState.getStateTransitions()___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								resultingComputationStates.add(computationState)___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber oldVersion__								final DeweyNumber newComputationStateVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									oldVersion = new DeweyNumber(startEventCounter++)__									newComputationStateVersion = oldVersion.addStage()__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()__									oldVersion = computationState.getVersion()___									if (newState.equals(computationState.getState())) {_										newComputationStateVersion = oldVersion.increase()__									} else {_										newComputationStateVersion = oldVersion.addStage()__									}_								}__								if (previousState.isStart()) {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										oldVersion)__								} else {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										previousState,_										previousEvent,_										previousTimestamp,_										oldVersion)__								}__								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newComputationStateVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,array,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,while,states,is,empty,state,t,current,state,states,pop,collection,state,transition,t,state,transitions,current,state,get,state,transitions,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,resulting,computation,states,add,computation,state,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,old,version,final,dewey,number,new,computation,state,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,old,version,new,dewey,number,start,event,counter,new,computation,state,version,old,version,add,stage,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,old,version,computation,state,get,version,if,new,state,equals,computation,state,get,state,new,computation,state,version,old,version,increase,else,new,computation,state,version,old,version,add,stage,if,previous,state,is,start,shared,buffer,put,new,state,event,timestamp,old,version,else,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,old,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,computation,state,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1459358363;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		ArrayList<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			Collection<StateTransition<T>> stateTransitions = currentState.getStateTransitions()___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								resultingComputationStates.add(computationState)___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber oldVersion__								final DeweyNumber newComputationStateVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									oldVersion = new DeweyNumber(startEventCounter++)__									newComputationStateVersion = oldVersion.addStage()__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()__									oldVersion = computationState.getVersion()___									if (newState.equals(computationState.getState())) {_										newComputationStateVersion = oldVersion.increase()__									} else {_										newComputationStateVersion = oldVersion.addStage()__									}_								}__								if (previousState.isStart()) {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										oldVersion)__								} else {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										previousState,_										previousEvent,_										previousTimestamp,_										oldVersion)__								}__								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newComputationStateVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,array,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,while,states,is,empty,state,t,current,state,states,pop,collection,state,transition,t,state,transitions,current,state,get,state,transitions,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,resulting,computation,states,add,computation,state,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,old,version,final,dewey,number,new,computation,state,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,old,version,new,dewey,number,start,event,counter,new,computation,state,version,old,version,add,stage,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,old,version,computation,state,get,version,if,new,state,equals,computation,state,get,state,new,computation,state,version,old,version,increase,else,new,computation,state,version,old,version,add,stage,if,previous,state,is,start,shared,buffer,put,new,state,event,timestamp,old,version,else,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,old,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,computation,state,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1461083852;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		ArrayList<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			Collection<StateTransition<T>> stateTransitions = currentState.getStateTransitions()___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								resultingComputationStates.add(computationState)___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber oldVersion__								final DeweyNumber newComputationStateVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									oldVersion = new DeweyNumber(startEventCounter++)__									newComputationStateVersion = oldVersion.addStage()__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()__									oldVersion = computationState.getVersion()___									if (newState.equals(computationState.getState())) {_										newComputationStateVersion = oldVersion.increase()__									} else {_										newComputationStateVersion = oldVersion.addStage()__									}_								}__								if (previousState.isStart()) {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										oldVersion)__								} else {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										previousState,_										previousEvent,_										previousTimestamp,_										oldVersion)__								}__								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newComputationStateVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,array,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,while,states,is,empty,state,t,current,state,states,pop,collection,state,transition,t,state,transitions,current,state,get,state,transitions,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,resulting,computation,states,add,computation,state,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,old,version,final,dewey,number,new,computation,state,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,old,version,new,dewey,number,start,event,counter,new,computation,state,version,old,version,add,stage,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,old,version,computation,state,get,version,if,new,state,equals,computation,state,get,state,new,computation,state,version,old,version,increase,else,new,computation,state,version,old,version,add,stage,if,previous,state,is,start,shared,buffer,put,new,state,event,timestamp,old,version,else,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,old,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,computation,state,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1466088497;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		ArrayList<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			Collection<StateTransition<T>> stateTransitions = currentState.getStateTransitions()___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								resultingComputationStates.add(computationState)___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber oldVersion__								final DeweyNumber newComputationStateVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									oldVersion = new DeweyNumber(startEventCounter++)__									newComputationStateVersion = oldVersion.addStage()__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()__									oldVersion = computationState.getVersion()___									if (newState.equals(computationState.getState())) {_										newComputationStateVersion = oldVersion.increase()__									} else {_										newComputationStateVersion = oldVersion.addStage()__									}_								}__								if (previousState.isStart()) {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										oldVersion)__								} else {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										previousState,_										previousEvent,_										previousTimestamp,_										oldVersion)__								}__								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newComputationStateVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,array,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,while,states,is,empty,state,t,current,state,states,pop,collection,state,transition,t,state,transitions,current,state,get,state,transitions,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,resulting,computation,states,add,computation,state,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,old,version,final,dewey,number,new,computation,state,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,old,version,new,dewey,number,start,event,counter,new,computation,state,version,old,version,add,stage,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,old,version,computation,state,get,version,if,new,state,equals,computation,state,get,state,new,computation,state,version,old,version,increase,else,new,computation,state,version,old,version,add,stage,if,previous,state,is,start,shared,buffer,put,new,state,event,timestamp,old,version,else,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,old,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,computation,state,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1468833363;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		ArrayList<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			Collection<StateTransition<T>> stateTransitions = currentState.getStateTransitions()___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								resultingComputationStates.add(computationState)___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber oldVersion__								final DeweyNumber newComputationStateVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									oldVersion = new DeweyNumber(startEventCounter++)__									newComputationStateVersion = oldVersion.addStage()__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()__									oldVersion = computationState.getVersion()___									if (newState.equals(computationState.getState())) {_										newComputationStateVersion = oldVersion.increase()__									} else {_										newComputationStateVersion = oldVersion.addStage()__									}_								}__								if (previousState.isStart()) {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										oldVersion)__								} else {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										previousState,_										previousEvent,_										previousTimestamp,_										oldVersion)__								}__								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newComputationStateVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,array,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,while,states,is,empty,state,t,current,state,states,pop,collection,state,transition,t,state,transitions,current,state,get,state,transitions,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,resulting,computation,states,add,computation,state,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,old,version,final,dewey,number,new,computation,state,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,old,version,new,dewey,number,start,event,counter,new,computation,state,version,old,version,add,stage,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,old,version,computation,state,get,version,if,new,state,equals,computation,state,get,state,new,computation,state,version,old,version,increase,else,new,computation,state,version,old,version,add,stage,if,previous,state,is,start,shared,buffer,put,new,state,event,timestamp,old,version,else,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,old,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,computation,state,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1472663401;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		ArrayList<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			Collection<StateTransition<T>> stateTransitions = currentState.getStateTransitions()___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								resultingComputationStates.add(computationState)___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber oldVersion__								final DeweyNumber newComputationStateVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									oldVersion = new DeweyNumber(startEventCounter++)__									newComputationStateVersion = oldVersion.addStage()__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()__									oldVersion = computationState.getVersion()___									if (newState.equals(computationState.getState())) {_										newComputationStateVersion = oldVersion.increase()__									} else {_										newComputationStateVersion = oldVersion.addStage()__									}_								}__								if (previousState.isStart()) {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										oldVersion)__								} else {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										previousState,_										previousEvent,_										previousTimestamp,_										oldVersion)__								}__								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newComputationStateVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,array,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,while,states,is,empty,state,t,current,state,states,pop,collection,state,transition,t,state,transitions,current,state,get,state,transitions,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,resulting,computation,states,add,computation,state,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,old,version,final,dewey,number,new,computation,state,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,old,version,new,dewey,number,start,event,counter,new,computation,state,version,old,version,add,stage,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,old,version,computation,state,get,version,if,new,state,equals,computation,state,get,state,new,computation,state,version,old,version,increase,else,new,computation,state,version,old,version,add,stage,if,previous,state,is,start,shared,buffer,put,new,state,event,timestamp,old,version,else,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,old,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,computation,state,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1478783881;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		ArrayList<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			Collection<StateTransition<T>> stateTransitions = currentState.getStateTransitions()___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								resultingComputationStates.add(computationState)___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber oldVersion__								final DeweyNumber newComputationStateVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									oldVersion = new DeweyNumber(startEventCounter++)__									newComputationStateVersion = oldVersion.addStage()__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()__									oldVersion = computationState.getVersion()___									if (newState.equals(computationState.getState())) {_										newComputationStateVersion = oldVersion.increase()__									} else {_										newComputationStateVersion = oldVersion.addStage()__									}_								}__								if (previousState.isStart()) {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										oldVersion)__								} else {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										previousState,_										previousEvent,_										previousTimestamp,_										oldVersion)__								}__								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newComputationStateVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,array,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,while,states,is,empty,state,t,current,state,states,pop,collection,state,transition,t,state,transitions,current,state,get,state,transitions,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,resulting,computation,states,add,computation,state,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,old,version,final,dewey,number,new,computation,state,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,old,version,new,dewey,number,start,event,counter,new,computation,state,version,old,version,add,stage,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,old,version,computation,state,get,version,if,new,state,equals,computation,state,get,state,new,computation,state,version,old,version,increase,else,new,computation,state,version,old,version,add,stage,if,previous,state,is,start,shared,buffer,put,new,state,event,timestamp,old,version,else,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,old,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,computation,state,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1488547156;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		ArrayList<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		boolean branched = false__		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			final List<StateTransition<T>> stateTransitions = new ArrayList<>(currentState.getStateTransitions())___			_			Collections.sort(stateTransitions, stateTransitionComparator)___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								final DeweyNumber version__								if (branched) {_									version = computationState.getVersion().increase()__								} else {_									version = computationState.getVersion()__								}_								resultingComputationStates.add(new ComputationState<T>(_									computationState.getState(),_									computationState.getEvent(),_									computationState.getTimestamp(),_									version,_									computationState.getStartTimestamp()))___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber oldVersion__								final DeweyNumber newComputationStateVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									oldVersion = new DeweyNumber(startEventCounter++)__									newComputationStateVersion = oldVersion.addStage()__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()__									oldVersion = computationState.getVersion()___									branched = true__									newComputationStateVersion = oldVersion.addStage()__								}__								if (previousState.isStart()) {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										oldVersion)__								} else {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										previousState,_										previousEvent,_										previousTimestamp,_										oldVersion)__								}__								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newComputationStateVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,array,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,boolean,branched,false,while,states,is,empty,state,t,current,state,states,pop,final,list,state,transition,t,state,transitions,new,array,list,current,state,get,state,transitions,collections,sort,state,transitions,state,transition,comparator,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,final,dewey,number,version,if,branched,version,computation,state,get,version,increase,else,version,computation,state,get,version,resulting,computation,states,add,new,computation,state,t,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,version,computation,state,get,start,timestamp,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,old,version,final,dewey,number,new,computation,state,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,old,version,new,dewey,number,start,event,counter,new,computation,state,version,old,version,add,stage,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,old,version,computation,state,get,version,branched,true,new,computation,state,version,old,version,add,stage,if,previous,state,is,start,shared,buffer,put,new,state,event,timestamp,old,version,else,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,old,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,computation,state,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1489660607;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		boolean branched = false__		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			final List<StateTransition<T>> stateTransitions = new ArrayList<>(currentState.getStateTransitions())___			_			Collections.sort(stateTransitions, stateTransitionComparator)___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								final DeweyNumber version__								if (branched) {_									version = computationState.getVersion().increase()__								} else {_									version = computationState.getVersion()__								}_								resultingComputationStates.add(new ComputationState<T>(_									computationState.getState(),_									computationState.getEvent(),_									computationState.getTimestamp(),_									version,_									computationState.getStartTimestamp()))___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber oldVersion__								final DeweyNumber newComputationStateVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									oldVersion = new DeweyNumber(startEventCounter++)__									newComputationStateVersion = oldVersion.addStage()__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()__									oldVersion = computationState.getVersion()___									branched = true__									newComputationStateVersion = oldVersion.addStage()__								}__								if (previousState.isStart()) {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										oldVersion)__								} else {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										previousState,_										previousEvent,_										previousTimestamp,_										oldVersion)__								}__								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newComputationStateVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,boolean,branched,false,while,states,is,empty,state,t,current,state,states,pop,final,list,state,transition,t,state,transitions,new,array,list,current,state,get,state,transitions,collections,sort,state,transitions,state,transition,comparator,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,final,dewey,number,version,if,branched,version,computation,state,get,version,increase,else,version,computation,state,get,version,resulting,computation,states,add,new,computation,state,t,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,version,computation,state,get,start,timestamp,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,old,version,final,dewey,number,new,computation,state,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,old,version,new,dewey,number,start,event,counter,new,computation,state,version,old,version,add,stage,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,old,version,computation,state,get,version,branched,true,new,computation,state,version,old,version,add,stage,if,previous,state,is,start,shared,buffer,put,new,state,event,timestamp,old,version,else,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,old,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,computation,state,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1489764761;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		boolean branched = false__		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			final List<StateTransition<T>> stateTransitions = new ArrayList<>(currentState.getStateTransitions())___			_			__			if (stateTransitionComparator == null) {_				stateTransitionComparator = new StateTransitionComparator()__			}__			_			Collections.sort(stateTransitions, stateTransitionComparator)___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								final DeweyNumber version__								if (branched) {_									version = computationState.getVersion().increase()__								} else {_									version = computationState.getVersion()__								}_								resultingComputationStates.add(new ComputationState<T>(_									computationState.getState(),_									computationState.getEvent(),_									computationState.getTimestamp(),_									version,_									computationState.getStartTimestamp()))___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber oldVersion__								final DeweyNumber newComputationStateVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									oldVersion = new DeweyNumber(startEventCounter++)__									newComputationStateVersion = oldVersion.addStage()__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()__									oldVersion = computationState.getVersion()___									branched = true__									newComputationStateVersion = oldVersion.addStage()__								}__								if (previousState.isStart()) {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										oldVersion)__								} else {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										previousState,_										previousEvent,_										previousTimestamp,_										oldVersion)__								}__								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newComputationStateVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,boolean,branched,false,while,states,is,empty,state,t,current,state,states,pop,final,list,state,transition,t,state,transitions,new,array,list,current,state,get,state,transitions,if,state,transition,comparator,null,state,transition,comparator,new,state,transition,comparator,collections,sort,state,transitions,state,transition,comparator,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,final,dewey,number,version,if,branched,version,computation,state,get,version,increase,else,version,computation,state,get,version,resulting,computation,states,add,new,computation,state,t,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,version,computation,state,get,start,timestamp,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,old,version,final,dewey,number,new,computation,state,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,old,version,new,dewey,number,start,event,counter,new,computation,state,version,old,version,add,stage,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,old,version,computation,state,get,version,branched,true,new,computation,state,version,old,version,add,stage,if,previous,state,is,start,shared,buffer,put,new,state,event,timestamp,old,version,else,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,old,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,computation,state,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1490186498;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine.__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {_		Stack<State<T>> states = new Stack<>()__		List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		State<T> state = computationState.getState()___		states.push(state)___		boolean branched = false__		while (!states.isEmpty()) {_			State<T> currentState = states.pop()__			final List<StateTransition<T>> stateTransitions = new ArrayList<>(currentState.getStateTransitions())___			_			__			if (stateTransitionComparator == null) {_				stateTransitionComparator = new StateTransitionComparator()__			}__			_			Collections.sort(stateTransitions, stateTransitionComparator)___			_			for (StateTransition<T> stateTransition: stateTransitions) {_				try {_					if (stateTransition.getCondition() == null || stateTransition.getCondition().filter(event)) {_						_						switch (stateTransition.getAction()) {_							case PROCEED:_								_								_								states.push(stateTransition.getTargetState())__								break__							case IGNORE:_								final DeweyNumber version__								if (branched) {_									version = computationState.getVersion().increase()__								} else {_									version = computationState.getVersion()__								}_								resultingComputationStates.add(new ComputationState<T>(_									computationState.getState(),_									computationState.getEvent(),_									computationState.getTimestamp(),_									version,_									computationState.getStartTimestamp()))___								_								_								sharedBuffer.lock(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__								break__							case TAKE:_								final State<T> newState = stateTransition.getTargetState()__								final DeweyNumber oldVersion__								final DeweyNumber newComputationStateVersion__								final State<T> previousState = computationState.getState()__								final T previousEvent = computationState.getEvent()__								final long previousTimestamp__								final long startTimestamp___								if (computationState.isStartState()) {_									oldVersion = new DeweyNumber(startEventCounter++)__									newComputationStateVersion = oldVersion.addStage()__									startTimestamp = timestamp__									previousTimestamp = -1L___								} else {_									startTimestamp = computationState.getStartTimestamp()__									previousTimestamp = computationState.getTimestamp()__									oldVersion = computationState.getVersion()___									branched = true__									newComputationStateVersion = oldVersion.addStage()__								}__								if (previousState.isStart()) {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										oldVersion)__								} else {_									sharedBuffer.put(_										newState,_										event,_										timestamp,_										previousState,_										previousEvent,_										previousTimestamp,_										oldVersion)__								}__								_								sharedBuffer.lock(newState, event, timestamp)___								resultingComputationStates.add(new ComputationState<T>(_									newState,_									event,_									timestamp,_									newComputationStateVersion,_									startTimestamp))__								break__						}_					}_				} catch (Exception e) {_					throw new RuntimeException("Failure happened in filter function.", e)__				}_			}_		}__		if (computationState.isStartState()) {_			_			_			resultingComputationStates.add(computationState)__		} else {_			_			sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__			_			sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,stack,state,t,states,new,stack,list,computation,state,t,resulting,computation,states,new,array,list,state,t,state,computation,state,get,state,states,push,state,boolean,branched,false,while,states,is,empty,state,t,current,state,states,pop,final,list,state,transition,t,state,transitions,new,array,list,current,state,get,state,transitions,if,state,transition,comparator,null,state,transition,comparator,new,state,transition,comparator,collections,sort,state,transitions,state,transition,comparator,for,state,transition,t,state,transition,state,transitions,try,if,state,transition,get,condition,null,state,transition,get,condition,filter,event,switch,state,transition,get,action,case,proceed,states,push,state,transition,get,target,state,break,case,ignore,final,dewey,number,version,if,branched,version,computation,state,get,version,increase,else,version,computation,state,get,version,resulting,computation,states,add,new,computation,state,t,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,version,computation,state,get,start,timestamp,shared,buffer,lock,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,state,transition,get,target,state,final,dewey,number,old,version,final,dewey,number,new,computation,state,version,final,state,t,previous,state,computation,state,get,state,final,t,previous,event,computation,state,get,event,final,long,previous,timestamp,final,long,start,timestamp,if,computation,state,is,start,state,old,version,new,dewey,number,start,event,counter,new,computation,state,version,old,version,add,stage,start,timestamp,timestamp,previous,timestamp,1l,else,start,timestamp,computation,state,get,start,timestamp,previous,timestamp,computation,state,get,timestamp,old,version,computation,state,get,version,branched,true,new,computation,state,version,old,version,add,stage,if,previous,state,is,start,shared,buffer,put,new,state,event,timestamp,old,version,else,shared,buffer,put,new,state,event,timestamp,previous,state,previous,event,previous,timestamp,old,version,shared,buffer,lock,new,state,event,timestamp,resulting,computation,states,add,new,computation,state,t,new,state,event,timestamp,new,computation,state,version,start,timestamp,break,catch,exception,e,throw,new,runtime,exception,failure,happened,in,filter,function,e,if,computation,state,is,start,state,resulting,computation,states,add,computation,state,else,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1490262475;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:__1. Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}_2. Perform transitions:_a) IGNORE (links in {@link SharedBuffer} will still point to the previous event)_- do not perform for Start State - special case_- if stays in the same state increase the current stage for future use with number of_outgoing edges_- if after PROCEED increase current stage and add new stage (as we change the state)_- lock the entry in {@link SharedBuffer} as it is needed in the created branch_b) TAKE (links in {@link SharedBuffer} will point to the current event)_- add entry to the shared buffer with version of the current computation state_- add stage and then increase with number of takes for the future computation states_- peek to the next state if it has PROCEED path to a Final State, if true create_Final ComputationState to emit results_3. Handle the Start State, as it always have to remain_4. Release the corresponding entries in {@link SharedBuffer}.___@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion().increase(ignoreBranchesToVisit).addStage()__							ignoreBranchesToVisit--__						}__						resultingComputationStates.add(_							ComputationState.createState(_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_							)_						)__						sharedBuffer.lock(_							computationState.getPreviousState().getName(),_							computationState.getEvent(),_							computationState.getTimestamp())__					}_				}_				break__				case TAKE:_					final State<T> newState = edge.getTargetState()__					final State<T> consumingState = edge.getSourceState()__					final State<T> previousEventState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()__					final DeweyNumber currentVersion = computationState.getVersion()___					final DeweyNumber newComputationStateVersion = new DeweyNumber(currentVersion).addStage().increase(takeBranchesToVisit)__					takeBranchesToVisit--___					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						sharedBuffer.put(_							consumingState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						sharedBuffer.put(_							consumingState.getName(),_							event,_							timestamp,_							previousEventState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							currentVersion)__					}__					_					sharedBuffer.lock(consumingState.getName(), event, timestamp)___					resultingComputationStates.add(ComputationState.createState(_						newState,_						consumingState,_						event,_						timestamp,_						newComputationStateVersion,_						startTimestamp_					))___					_					final State<T> finalState = findFinalStateAfterProceed(newState, event)__					if (finalState != null) {_						sharedBuffer.lock(consumingState.getName(), event, timestamp)__						resultingComputationStates.add(ComputationState.createState(_							finalState,_							consumingState,_							event,_							timestamp,_							newComputationStateVersion,_							startTimestamp))__					}_					break__			}_		}__		if (computationState.isStartState()) {_			final int totalBranches = calculateIncreasingSelfState(outgoingEdges.getTotalIgnoreBranches(), outgoingEdges.getTotalTakeBranches())__			final ComputationState<T> startState = createStartState(computationState, totalBranches)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			sharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp())__			_			sharedBuffer.remove(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,1,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,2,perform,transitions,a,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,do,not,perform,for,start,state,special,case,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,b,take,links,in,link,shared,buffer,will,point,to,the,current,event,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,3,handle,the,start,state,as,it,always,have,to,remain,4,release,the,corresponding,entries,in,link,shared,buffer,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,resulting,computation,states,add,computation,state,create,state,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,version,computation,state,get,start,timestamp,shared,buffer,lock,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,edge,get,target,state,final,state,t,consuming,state,edge,get,source,state,final,state,t,previous,event,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,final,dewey,number,new,computation,state,version,new,dewey,number,current,version,add,stage,increase,take,branches,to,visit,take,branches,to,visit,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,shared,buffer,put,consuming,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,shared,buffer,put,consuming,state,get,name,event,timestamp,previous,event,state,get,name,previous,event,computation,state,get,timestamp,current,version,shared,buffer,lock,consuming,state,get,name,event,timestamp,resulting,computation,states,add,computation,state,create,state,new,state,consuming,state,event,timestamp,new,computation,state,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,new,state,event,if,final,state,null,shared,buffer,lock,consuming,state,get,name,event,timestamp,resulting,computation,states,add,computation,state,create,state,final,state,consuming,state,event,timestamp,new,computation,state,version,start,timestamp,break,if,computation,state,is,start,state,final,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,final,computation,state,t,start,state,create,start,state,computation,state,total,branches,resulting,computation,states,add,start,state,if,computation,state,get,event,null,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1490262475;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:__1. Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}_2. Perform transitions:_a) IGNORE (links in {@link SharedBuffer} will still point to the previous event)_- do not perform for Start State - special case_- if stays in the same state increase the current stage for future use with number of_outgoing edges_- if after PROCEED increase current stage and add new stage (as we change the state)_- lock the entry in {@link SharedBuffer} as it is needed in the created branch_b) TAKE (links in {@link SharedBuffer} will point to the current event)_- add entry to the shared buffer with version of the current computation state_- add stage and then increase with number of takes for the future computation states_- peek to the next state if it has PROCEED path to a Final State, if true create_Final ComputationState to emit results_3. Handle the Start State, as it always have to remain_4. Release the corresponding entries in {@link SharedBuffer}.___@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion().increase(ignoreBranchesToVisit).addStage()__							ignoreBranchesToVisit--__						}__						resultingComputationStates.add(_							ComputationState.createState(_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_							)_						)__						stringSharedBuffer.lock(_							computationState.getPreviousState().getName(),_							computationState.getEvent(),_							computationState.getTimestamp())__					}_				}_				break__				case TAKE:_					final State<T> newState = edge.getTargetState()__					final State<T> consumingState = edge.getSourceState()__					final State<T> previousEventState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()__					final DeweyNumber currentVersion = computationState.getVersion()___					final DeweyNumber newComputationStateVersion = new DeweyNumber(currentVersion).addStage().increase(takeBranchesToVisit)__					takeBranchesToVisit--___					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						stringSharedBuffer.put(_							consumingState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						stringSharedBuffer.put(_							consumingState.getName(),_							event,_							timestamp,_							previousEventState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							currentVersion)__					}__					_					stringSharedBuffer.lock(consumingState.getName(), event, timestamp)___					resultingComputationStates.add(ComputationState.createState(_						newState,_						consumingState,_						event,_						timestamp,_						newComputationStateVersion,_						startTimestamp_					))___					_					final State<T> finalState = findFinalStateAfterProceed(newState, event)__					if (finalState != null) {_						stringSharedBuffer.lock(consumingState.getName(), event, timestamp)__						resultingComputationStates.add(ComputationState.createState(_							finalState,_							consumingState,_							event,_							timestamp,_							newComputationStateVersion,_							startTimestamp))__					}_					break__			}_		}__		if (computationState.isStartState()) {_			final int totalBranches = calculateIncreasingSelfState(outgoingEdges.getTotalIgnoreBranches(), outgoingEdges.getTotalTakeBranches())__			final ComputationState<T> startState = createStartState(computationState, totalBranches)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			stringSharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp())__			_			stringSharedBuffer.remove(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,1,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,2,perform,transitions,a,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,do,not,perform,for,start,state,special,case,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,b,take,links,in,link,shared,buffer,will,point,to,the,current,event,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,3,handle,the,start,state,as,it,always,have,to,remain,4,release,the,corresponding,entries,in,link,shared,buffer,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,resulting,computation,states,add,computation,state,create,state,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,version,computation,state,get,start,timestamp,string,shared,buffer,lock,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,break,case,take,final,state,t,new,state,edge,get,target,state,final,state,t,consuming,state,edge,get,source,state,final,state,t,previous,event,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,final,dewey,number,new,computation,state,version,new,dewey,number,current,version,add,stage,increase,take,branches,to,visit,take,branches,to,visit,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,string,shared,buffer,put,consuming,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,string,shared,buffer,put,consuming,state,get,name,event,timestamp,previous,event,state,get,name,previous,event,computation,state,get,timestamp,current,version,string,shared,buffer,lock,consuming,state,get,name,event,timestamp,resulting,computation,states,add,computation,state,create,state,new,state,consuming,state,event,timestamp,new,computation,state,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,new,state,event,if,final,state,null,string,shared,buffer,lock,consuming,state,get,name,event,timestamp,resulting,computation,states,add,computation,state,create,state,final,state,consuming,state,event,timestamp,new,computation,state,version,start,timestamp,break,if,computation,state,is,start,state,final,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,final,computation,state,t,start,state,create,start,state,computation,state,total,branches,resulting,computation,states,add,start,state,if,computation,state,get,event,null,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,string,shared,buffer,remove,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1490638274;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion().increase(ignoreBranchesToVisit).addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion()__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage().increase(takeBranchesToVisit)__					takeBranchesToVisit--___					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						stringSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						stringSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							previousState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			stringSharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,increase,take,branches,to,visit,take,branches,to,visit,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,string,shared,buffer,put,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,string,shared,buffer,put,current,state,get,name,event,timestamp,previous,state,get,name,previous,event,computation,state,get,timestamp,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1490692084;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion().increase(ignoreBranchesToVisit).addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion()__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage().increase(takeBranchesToVisit)__					takeBranchesToVisit--___					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						stringSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						stringSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							previousState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			stringSharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,increase,take,branches,to,visit,take,branches,to,visit,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,string,shared,buffer,put,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,string,shared,buffer,put,current,state,get,name,event,timestamp,previous,state,get,name,previous,event,computation,state,get,timestamp,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1493985576;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion().increase(ignoreBranchesToVisit).addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion()__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage().increase(takeBranchesToVisit)__					takeBranchesToVisit--___					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						stringSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						stringSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							previousState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			stringSharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,increase,take,branches,to,visit,take,branches,to,visit,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,string,shared,buffer,put,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,string,shared,buffer,put,current,state,get,name,event,timestamp,previous,state,get,name,previous,event,computation,state,get,timestamp,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1494180263;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion().increase(ignoreBranchesToVisit).addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion()__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage().increase(takeBranchesToVisit)__					takeBranchesToVisit--___					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						stringSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						stringSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							previousState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			stringSharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,increase,take,branches,to,visit,take,branches,to,visit,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,string,shared,buffer,put,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,string,shared,buffer,put,current,state,get,name,event,timestamp,previous,state,get,name,previous,event,computation,state,get,timestamp,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1495024651;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion().increase(ignoreBranchesToVisit).addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion()__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage().increase(takeBranchesToVisit)__					takeBranchesToVisit--___					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						stringSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						stringSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							previousState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			stringSharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,increase,take,branches,to,visit,take,branches,to,visit,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,string,shared,buffer,put,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,string,shared,buffer,put,current,state,get,name,event,timestamp,previous,state,get,name,previous,event,computation,state,get,timestamp,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1495024653;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion().increase(ignoreBranchesToVisit).addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion()__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage().increase(takeBranchesToVisit)__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = stringSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = stringSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							previousState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			stringSharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,increase,take,branches,to,visit,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,string,shared,buffer,put,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,string,shared,buffer,put,current,state,get,name,event,timestamp,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1495024654;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion().increase(ignoreBranchesToVisit).addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion()__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage().increase(takeBranchesToVisit)__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							previousState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,increase,take,branches,to,visit,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,current,state,get,name,event,timestamp,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1495024655;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							previousState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,current,state,get,name,event,timestamp,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1495203813;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							previousState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,current,state,get,name,event,timestamp,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1495466666;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							previousState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,current,state,get,name,event,timestamp,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1495961498;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							currentState.getName(),_							event,_							timestamp,_							previousState.getName(),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,current,state,get,name,event,timestamp,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1496929298;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState().getName()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1497328665;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState().getName()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1498764573;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState().getName()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1501661862;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState().getName()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1502726910;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState().getName()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1503470129;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState().getName()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1503555538;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState().getName()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1503598628;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState().getName()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1504268438;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState().getName()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1507895398;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState().getName()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1516692416;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState().getName()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> private Collection<ComputationState<T>> computeNextStates( 			final ComputationState<T> computationState, 			final T event, 			final long timestamp);1518030004;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState<T>> computeNextStates(_			final ComputationState<T> computationState,_			final T event,_			final long timestamp) {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event)___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState<T>> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!computationState.isStartState()) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousState(),_								computationState.getEvent(),_								computationState.getCounter(),_								computationState.getTimestamp(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()__					final State<T> previousState = computationState.getPreviousState()___					final T previousEvent = computationState.getEvent()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final int counter__					final long startTimestamp__					if (computationState.isStartState()) {_						startTimestamp = timestamp__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						counter = eventSharedBuffer.put(_							NFAStateNameHandler.getOriginalNameFromInternal(_									currentState.getName()),_							event,_							timestamp,_							NFAStateNameHandler.getOriginalNameFromInternal(_									previousState.getName()),_							previousEvent,_							computationState.getTimestamp(),_							computationState.getCounter(),_							currentVersion)__					}__					addComputationState(_							resultingComputationStates,_							nextState,_							currentState,_							event,_							counter,_							timestamp,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState)__					if (finalState != null) {_						addComputationState(_								resultingComputationStates,_								finalState,_								currentState,_								event,_								counter,_								timestamp,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (computationState.isStartState()) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getEvent() != null) {_			_			eventSharedBuffer.release(_					NFAStateNameHandler.getOriginalNameFromInternal(_							computationState.getPreviousState().getName()),_					computationState.getEvent(),_					computationState.getTimestamp(),_					computationState.getCounter())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,t,compute,next,states,final,computation,state,t,computation,state,final,t,event,final,long,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,computation,state,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,t,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,computation,state,is,start,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,computation,state,get,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,resulting,computation,states,edge,get,target,state,computation,state,get,previous,state,computation,state,get,event,computation,state,get,counter,computation,state,get,timestamp,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,state,t,previous,state,computation,state,get,previous,state,final,t,previous,event,computation,state,get,event,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,int,counter,final,long,start,timestamp,if,computation,state,is,start,state,start,timestamp,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,current,version,else,start,timestamp,computation,state,get,start,timestamp,counter,event,shared,buffer,put,nfastate,name,handler,get,original,name,from,internal,current,state,get,name,event,timestamp,nfastate,name,handler,get,original,name,from,internal,previous,state,get,name,previous,event,computation,state,get,timestamp,computation,state,get,counter,current,version,add,computation,state,resulting,computation,states,next,state,current,state,event,counter,timestamp,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,next,state,event,computation,state,if,final,state,null,add,computation,state,resulting,computation,states,final,state,current,state,event,counter,timestamp,next,version,start,timestamp,break,if,computation,state,is,start,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,t,start,state,computation,state,create,start,state,this,computation,state,get,state,start,version,resulting,computation,states,add,start,state,if,computation,state,get,event,null,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,return,resulting,computation,states
NFA -> public void resetNFAChanged();1498764573;Reset {@link #nfaChanged} to {@code false}.;public void resetNFAChanged() {_		this.nfaChanged = false__	};reset,link,nfa,changed,to,code,false;public,void,reset,nfachanged,this,nfa,changed,false
NFA -> public void resetNFAChanged();1501661862;Reset {@link #nfaChanged} to {@code false}.;public void resetNFAChanged() {_		this.nfaChanged = false__	};reset,link,nfa,changed,to,code,false;public,void,reset,nfachanged,this,nfa,changed,false
NFA -> public void resetNFAChanged();1502726910;Reset {@link #nfaChanged} to {@code false}.;public void resetNFAChanged() {_		this.nfaChanged = false__	};reset,link,nfa,changed,to,code,false;public,void,reset,nfachanged,this,nfa,changed,false
NFA -> public void resetNFAChanged();1503470129;Reset {@link #nfaChanged} to {@code false}.;public void resetNFAChanged() {_		this.nfaChanged = false__	};reset,link,nfa,changed,to,code,false;public,void,reset,nfachanged,this,nfa,changed,false
NFA -> public void resetNFAChanged();1503555538;Reset {@link #nfaChanged} to {@code false}.;public void resetNFAChanged() {_		this.nfaChanged = false__	};reset,link,nfa,changed,to,code,false;public,void,reset,nfachanged,this,nfa,changed,false
NFA -> public void resetNFAChanged();1503598628;Reset {@link #nfaChanged} to {@code false}.;public void resetNFAChanged() {_		this.nfaChanged = false__	};reset,link,nfa,changed,to,code,false;public,void,reset,nfachanged,this,nfa,changed,false
NFA -> public void resetNFAChanged();1504268438;Reset {@link #nfaChanged} to {@code false}.;public void resetNFAChanged() {_		this.nfaChanged = false__	};reset,link,nfa,changed,to,code,false;public,void,reset,nfachanged,this,nfa,changed,false
NFA -> public void resetNFAChanged();1507895398;Reset {@link #nfaChanged} to {@code false}.;public void resetNFAChanged() {_		this.nfaChanged = false__	};reset,link,nfa,changed,to,code,false;public,void,reset,nfachanged,this,nfa,changed,false
NFA -> public void resetNFAChanged();1516692416;Reset {@link #nfaChanged} to {@code false}.;public void resetNFAChanged() {_		this.nfaChanged = false__	};reset,link,nfa,changed,to,code,false;public,void,reset,nfachanged,this,nfa,changed,false
NFA -> public void resetNFAChanged();1518030004;Reset {@link #nfaChanged} to {@code false}.;public void resetNFAChanged() {_		this.nfaChanged = false__	};reset,link,nfa,changed,to,code,false;public,void,reset,nfachanged,this,nfa,changed,false
NFA -> public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime( 			final SharedBuffer<T> sharedBuffer, 			final NFAState nfaState, 			final long timestamp) throws Exception;1528894799;Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one._It cleares the sharedBuffer and also emits all timed out partial matches.__@param sharedBuffer the SharedBuffer object that we need to work upon while processing_@param nfaState     The NFAState object that we need to affect while processing_@param timestamp    timestamp that indicates that there will be no more events with lower timestamp_@return all timed outed partial matches_@throws Exception Thrown if the system cannot access the state.;public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(_			final SharedBuffer<T> sharedBuffer,_			final NFAState nfaState,_			final long timestamp) throws Exception {__		Queue<ComputationState> computationStates = nfaState.getComputationStates()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		final int numberComputationStates = computationStates.size()__		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState computationState = computationStates.poll()___			if (isStateTimedOut(computationState, timestamp)) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = extractCurrentMatches(sharedBuffer, computationState)__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				sharedBuffer.releaseNode(computationState.getPreviousBufferEntry())___				nfaState.setStateChanged()__			} else {_				computationStates.add(computationState)__			}_		}__		sharedBuffer.advanceTime(timestamp)___		return timeoutResult__	};prunes,states,assuming,there,will,be,no,events,with,timestamp,b,lower,b,than,the,given,one,it,cleares,the,shared,buffer,and,also,emits,all,timed,out,partial,matches,param,shared,buffer,the,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,timestamp,timestamp,that,indicates,that,there,will,be,no,more,events,with,lower,timestamp,return,all,timed,outed,partial,matches,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,tuple2,map,string,list,t,long,advance,time,final,shared,buffer,t,shared,buffer,final,nfastate,nfa,state,final,long,timestamp,throws,exception,queue,computation,state,computation,states,nfa,state,get,computation,states,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,final,int,number,computation,states,computation,states,size,for,int,i,0,i,number,computation,states,i,computation,state,computation,state,computation,states,poll,if,is,state,timed,out,computation,state,timestamp,if,handle,timeout,map,string,list,t,timed,out,pattern,extract,current,matches,shared,buffer,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,shared,buffer,release,node,computation,state,get,previous,buffer,entry,nfa,state,set,state,changed,else,computation,states,add,computation,state,shared,buffer,advance,time,timestamp,return,timeout,result
NFA -> public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime( 			final SharedBuffer<T> sharedBuffer, 			final NFAState nfaState, 			final long timestamp) throws Exception;1530798894;Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one._It cleares the sharedBuffer and also emits all timed out partial matches.__@param sharedBuffer the SharedBuffer object that we need to work upon while processing_@param nfaState     The NFAState object that we need to affect while processing_@param timestamp    timestamp that indicates that there will be no more events with lower timestamp_@return all timed outed partial matches_@throws Exception Thrown if the system cannot access the state.;public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(_			final SharedBuffer<T> sharedBuffer,_			final NFAState nfaState,_			final long timestamp) throws Exception {__		Queue<ComputationState> computationStates = nfaState.getComputationStates()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		final int numberComputationStates = computationStates.size()__		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState computationState = computationStates.poll()___			if (isStateTimedOut(computationState, timestamp)) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = extractCurrentMatches(sharedBuffer, computationState)__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				sharedBuffer.releaseNode(computationState.getPreviousBufferEntry())___				nfaState.setStateChanged()__			} else {_				computationStates.add(computationState)__			}_		}__		sharedBuffer.advanceTime(timestamp)___		return timeoutResult__	};prunes,states,assuming,there,will,be,no,events,with,timestamp,b,lower,b,than,the,given,one,it,cleares,the,shared,buffer,and,also,emits,all,timed,out,partial,matches,param,shared,buffer,the,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,timestamp,timestamp,that,indicates,that,there,will,be,no,more,events,with,lower,timestamp,return,all,timed,outed,partial,matches,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,tuple2,map,string,list,t,long,advance,time,final,shared,buffer,t,shared,buffer,final,nfastate,nfa,state,final,long,timestamp,throws,exception,queue,computation,state,computation,states,nfa,state,get,computation,states,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,final,int,number,computation,states,computation,states,size,for,int,i,0,i,number,computation,states,i,computation,state,computation,state,computation,states,poll,if,is,state,timed,out,computation,state,timestamp,if,handle,timeout,map,string,list,t,timed,out,pattern,extract,current,matches,shared,buffer,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,shared,buffer,release,node,computation,state,get,previous,buffer,entry,nfa,state,set,state,changed,else,computation,states,add,computation,state,shared,buffer,advance,time,timestamp,return,timeout,result
NFA -> public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime( 			final SharedBuffer<T> sharedBuffer, 			final NFAState nfaState, 			final long timestamp) throws Exception;1530798894;Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one._It cleares the sharedBuffer and also emits all timed out partial matches.__@param sharedBuffer the SharedBuffer object that we need to work upon while processing_@param nfaState     The NFAState object that we need to affect while processing_@param timestamp    timestamp that indicates that there will be no more events with lower timestamp_@return all timed outed partial matches_@throws Exception Thrown if the system cannot access the state.;public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(_			final SharedBuffer<T> sharedBuffer,_			final NFAState nfaState,_			final long timestamp) throws Exception {__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()__		final PriorityQueue<ComputationState> newPartialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR)___		Map<EventId, T> eventsCache = new HashMap<>()__		for (ComputationState computationState : nfaState.getPartialMatches()) {_			if (isStateTimedOut(computationState, timestamp)) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = sharedBuffer.materializeMatch(extractCurrentMatches(_						sharedBuffer,_						computationState), eventsCache)__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				sharedBuffer.releaseNode(computationState.getPreviousBufferEntry())___				nfaState.setStateChanged()__			} else {_				newPartialMatches.add(computationState)__			}_		}__		nfaState.setNewPartialMatches(newPartialMatches)___		sharedBuffer.advanceTime(timestamp)___		return timeoutResult__	};prunes,states,assuming,there,will,be,no,events,with,timestamp,b,lower,b,than,the,given,one,it,cleares,the,shared,buffer,and,also,emits,all,timed,out,partial,matches,param,shared,buffer,the,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,timestamp,timestamp,that,indicates,that,there,will,be,no,more,events,with,lower,timestamp,return,all,timed,outed,partial,matches,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,tuple2,map,string,list,t,long,advance,time,final,shared,buffer,t,shared,buffer,final,nfastate,nfa,state,final,long,timestamp,throws,exception,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,final,priority,queue,computation,state,new,partial,matches,new,priority,queue,nfastate,map,event,id,t,events,cache,new,hash,map,for,computation,state,computation,state,nfa,state,get,partial,matches,if,is,state,timed,out,computation,state,timestamp,if,handle,timeout,map,string,list,t,timed,out,pattern,shared,buffer,materialize,match,extract,current,matches,shared,buffer,computation,state,events,cache,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,shared,buffer,release,node,computation,state,get,previous,buffer,entry,nfa,state,set,state,changed,else,new,partial,matches,add,computation,state,nfa,state,set,new,partial,matches,new,partial,matches,shared,buffer,advance,time,timestamp,return,timeout,result
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBuffer<T> sharedBuffer, 			final ComputationState computationState, 			final EventWrapper event, 			final long timestamp) throws Exception;1528894799;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBuffer The shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one;private Collection<ComputationState> computeNextStates(_			final SharedBuffer<T> sharedBuffer,_			final ComputationState computationState,_			final EventWrapper event,_			final long timestamp) throws Exception {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(sharedBuffer, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								sharedBuffer,_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousBufferEntry(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry__					final long startTimestamp__					if (isStartState(computationState)) {_						startTimestamp = timestamp__						newEntry = sharedBuffer.put(_							currentState.getName(),_							event.getEventId(),_							previousEntry,_							currentVersion)__					} else {_						startTimestamp = computationState.getStartTimestamp()__						newEntry = sharedBuffer.put(_							currentState.getName(),_							event.getEventId(),_							previousEntry,_							currentVersion)__					}__					addComputationState(_							sharedBuffer,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(sharedBuffer, nextState, event.getEvent(), computationState)__					if (finalState != null) {_						addComputationState(_								sharedBuffer,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBuffer.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,the,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one;private,collection,computation,state,compute,next,states,final,shared,buffer,t,shared,buffer,final,computation,state,computation,state,final,event,wrapper,event,final,long,timestamp,throws,exception,final,outgoing,edges,t,outgoing,edges,create,decision,graph,shared,buffer,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,final,long,start,timestamp,if,is,start,state,computation,state,start,timestamp,timestamp,new,entry,shared,buffer,put,current,state,get,name,event,get,event,id,previous,entry,current,version,else,start,timestamp,computation,state,get,start,timestamp,new,entry,shared,buffer,put,current,state,get,name,event,get,event,id,previous,entry,current,version,add,computation,state,shared,buffer,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,shared,buffer,next,state,event,get,event,computation,state,if,final,state,null,add,computation,state,shared,buffer,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBuffer<T> sharedBuffer, 			final ComputationState computationState, 			final EventWrapper event, 			final long timestamp) throws Exception;1528894799;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBuffer The shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one_@throws Exception Thrown if the system cannot access the state.;private Collection<ComputationState> computeNextStates(_			final SharedBuffer<T> sharedBuffer,_			final ComputationState computationState,_			final EventWrapper event,_			final long timestamp) throws Exception {__		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(sharedBuffer, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								sharedBuffer,_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousBufferEntry(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry = sharedBuffer.put(_						currentState.getName(),_						event.getEventId(),_						previousEntry,_						currentVersion)___					final long startTimestamp__					if (isStartState(computationState)) {_						startTimestamp = timestamp__					} else {_						startTimestamp = computationState.getStartTimestamp()__					}__					addComputationState(_							sharedBuffer,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(sharedBuffer, nextState, event.getEvent(), computationState)__					if (finalState != null) {_						addComputationState(_								sharedBuffer,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBuffer.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,the,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one,throws,exception,thrown,if,the,system,cannot,access,the,state;private,collection,computation,state,compute,next,states,final,shared,buffer,t,shared,buffer,final,computation,state,computation,state,final,event,wrapper,event,final,long,timestamp,throws,exception,final,outgoing,edges,t,outgoing,edges,create,decision,graph,shared,buffer,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,shared,buffer,put,current,state,get,name,event,get,event,id,previous,entry,current,version,final,long,start,timestamp,if,is,start,state,computation,state,start,timestamp,timestamp,else,start,timestamp,computation,state,get,start,timestamp,add,computation,state,shared,buffer,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,shared,buffer,next,state,event,get,event,computation,state,if,final,state,null,add,computation,state,shared,buffer,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBuffer<T> sharedBuffer, 			final ComputationState computationState, 			final EventWrapper event, 			final long timestamp) throws Exception;1530798894;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBuffer The shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one_@throws Exception Thrown if the system cannot access the state.;private Collection<ComputationState> computeNextStates(_			final SharedBuffer<T> sharedBuffer,_			final ComputationState computationState,_			final EventWrapper event,_			final long timestamp) throws Exception {__		final ConditionContext<T> context = new ConditionContext<>(this, sharedBuffer, computationState)___		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(context, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_								sharedBuffer,_								resultingComputationStates,_								edge.getTargetState(),_								computationState.getPreviousBufferEntry(),_								version,_								computationState.getStartTimestamp()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry = sharedBuffer.put(_						currentState.getName(),_						event.getEventId(),_						previousEntry,_						currentVersion)___					final long startTimestamp__					if (isStartState(computationState)) {_						startTimestamp = timestamp__					} else {_						startTimestamp = computationState.getStartTimestamp()__					}__					addComputationState(_							sharedBuffer,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp)___					_					final State<T> finalState = findFinalStateAfterProceed(context, nextState, event.getEvent())__					if (finalState != null) {_						addComputationState(_								sharedBuffer,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBuffer.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,the,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one,throws,exception,thrown,if,the,system,cannot,access,the,state;private,collection,computation,state,compute,next,states,final,shared,buffer,t,shared,buffer,final,computation,state,computation,state,final,event,wrapper,event,final,long,timestamp,throws,exception,final,condition,context,t,context,new,condition,context,this,shared,buffer,computation,state,final,outgoing,edges,t,outgoing,edges,create,decision,graph,context,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,shared,buffer,put,current,state,get,name,event,get,event,id,previous,entry,current,version,final,long,start,timestamp,if,is,start,state,computation,state,start,timestamp,timestamp,else,start,timestamp,computation,state,get,start,timestamp,add,computation,state,shared,buffer,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,final,state,t,final,state,find,final,state,after,proceed,context,next,state,event,get,event,if,final,state,null,add,computation,state,shared,buffer,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBuffer<T> sharedBuffer, 			final ComputationState computationState, 			final EventWrapper event, 			final long timestamp) throws Exception;1530798894;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBuffer The shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one_@throws Exception Thrown if the system cannot access the state.;private Collection<ComputationState> computeNextStates(_			final SharedBuffer<T> sharedBuffer,_			final ComputationState computationState,_			final EventWrapper event,_			final long timestamp) throws Exception {__		final ConditionContext<T> context = new ConditionContext<>(this, sharedBuffer, computationState)___		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(context, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_							sharedBuffer,_							resultingComputationStates,_							edge.getTargetState(),_							computationState.getPreviousBufferEntry(),_							version,_							computationState.getStartTimestamp(),_							computationState.getStartEventID()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry = sharedBuffer.put(_						currentState.getName(),_						event.getEventId(),_						previousEntry,_						currentVersion)___					final long startTimestamp__					final EventId startEventId__					if (isStartState(computationState)) {_						startTimestamp = timestamp__						startEventId = event.getEventId()__					} else {_						startTimestamp = computationState.getStartTimestamp()__						startEventId = computationState.getStartEventID()__					}__					addComputationState(_							sharedBuffer,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp,_							startEventId)___					_					final State<T> finalState = findFinalStateAfterProceed(context, nextState, event.getEvent())__					if (finalState != null) {_						addComputationState(_								sharedBuffer,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp,_								startEventId)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBuffer.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,the,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one,throws,exception,thrown,if,the,system,cannot,access,the,state;private,collection,computation,state,compute,next,states,final,shared,buffer,t,shared,buffer,final,computation,state,computation,state,final,event,wrapper,event,final,long,timestamp,throws,exception,final,condition,context,t,context,new,condition,context,this,shared,buffer,computation,state,final,outgoing,edges,t,outgoing,edges,create,decision,graph,context,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,computation,state,get,start,event,id,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,shared,buffer,put,current,state,get,name,event,get,event,id,previous,entry,current,version,final,long,start,timestamp,final,event,id,start,event,id,if,is,start,state,computation,state,start,timestamp,timestamp,start,event,id,event,get,event,id,else,start,timestamp,computation,state,get,start,timestamp,start,event,id,computation,state,get,start,event,id,add,computation,state,shared,buffer,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,start,event,id,final,state,t,final,state,find,final,state,after,proceed,context,next,state,event,get,event,if,final,state,null,add,computation,state,shared,buffer,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,start,event,id,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> private Map<String, List<EventId>> extractCurrentMatches( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState) throws Exception;1535555335;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param sharedBufferAccessor The accessor to {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state_@throws Exception Thrown if the system cannot access the state.;private Map<String, List<EventId>> extractCurrentMatches(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState) throws Exception {_		if (computationState.getPreviousBufferEntry() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<EventId>>> paths = sharedBufferAccessor.extractPatterns(_				computationState.getPreviousBufferEntry(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		return paths.get(0)__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,shared,buffer,accessor,the,accessor,to,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state,throws,exception,thrown,if,the,system,cannot,access,the,state;private,map,string,list,event,id,extract,current,matches,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,throws,exception,if,computation,state,get,previous,buffer,entry,null,return,new,hash,map,list,map,string,list,event,id,paths,shared,buffer,accessor,extract,patterns,computation,state,get,previous,buffer,entry,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,return,paths,get,0
NFA -> private Map<String, List<EventId>> extractCurrentMatches( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState) throws Exception;1539149027;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param sharedBufferAccessor The accessor to {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state_@throws Exception Thrown if the system cannot access the state.;private Map<String, List<EventId>> extractCurrentMatches(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState) throws Exception {_		if (computationState.getPreviousBufferEntry() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<EventId>>> paths = sharedBufferAccessor.extractPatterns(_				computationState.getPreviousBufferEntry(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		return paths.get(0)__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,shared,buffer,accessor,the,accessor,to,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state,throws,exception,thrown,if,the,system,cannot,access,the,state;private,map,string,list,event,id,extract,current,matches,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,throws,exception,if,computation,state,get,previous,buffer,entry,null,return,new,hash,map,list,map,string,list,event,id,paths,shared,buffer,accessor,extract,patterns,computation,state,get,previous,buffer,entry,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,return,paths,get,0
NFA -> private Map<String, List<EventId>> extractCurrentMatches( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState) throws Exception;1539149114;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param sharedBufferAccessor The accessor to {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state_@throws Exception Thrown if the system cannot access the state.;private Map<String, List<EventId>> extractCurrentMatches(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState) throws Exception {_		if (computationState.getPreviousBufferEntry() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<EventId>>> paths = sharedBufferAccessor.extractPatterns(_				computationState.getPreviousBufferEntry(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		return paths.get(0)__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,shared,buffer,accessor,the,accessor,to,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state,throws,exception,thrown,if,the,system,cannot,access,the,state;private,map,string,list,event,id,extract,current,matches,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,throws,exception,if,computation,state,get,previous,buffer,entry,null,return,new,hash,map,list,map,string,list,event,id,paths,shared,buffer,accessor,extract,patterns,computation,state,get,previous,buffer,entry,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,return,paths,get,0
NFA -> private Map<String, List<EventId>> extractCurrentMatches( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState) throws Exception;1540386566;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param sharedBufferAccessor The accessor to {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state_@throws Exception Thrown if the system cannot access the state.;private Map<String, List<EventId>> extractCurrentMatches(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState) throws Exception {_		if (computationState.getPreviousBufferEntry() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<EventId>>> paths = sharedBufferAccessor.extractPatterns(_				computationState.getPreviousBufferEntry(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		return paths.get(0)__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,shared,buffer,accessor,the,accessor,to,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state,throws,exception,thrown,if,the,system,cannot,access,the,state;private,map,string,list,event,id,extract,current,matches,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,throws,exception,if,computation,state,get,previous,buffer,entry,null,return,new,hash,map,list,map,string,list,event,id,paths,shared,buffer,accessor,extract,patterns,computation,state,get,previous,buffer,entry,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,return,paths,get,0
NFA -> private Map<String, List<EventId>> extractCurrentMatches( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState) throws Exception;1546179377;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param sharedBufferAccessor The accessor to {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state_@throws Exception Thrown if the system cannot access the state.;private Map<String, List<EventId>> extractCurrentMatches(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState) throws Exception {_		if (computationState.getPreviousBufferEntry() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<EventId>>> paths = sharedBufferAccessor.extractPatterns(_				computationState.getPreviousBufferEntry(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		return paths.get(0)__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,shared,buffer,accessor,the,accessor,to,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state,throws,exception,thrown,if,the,system,cannot,access,the,state;private,map,string,list,event,id,extract,current,matches,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,throws,exception,if,computation,state,get,previous,buffer,entry,null,return,new,hash,map,list,map,string,list,event,id,paths,shared,buffer,accessor,extract,patterns,computation,state,get,previous,buffer,entry,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,return,paths,get,0
NFA -> private Map<String, List<EventId>> extractCurrentMatches( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState) throws Exception;1546179377;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param sharedBufferAccessor The accessor to {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state_@throws Exception Thrown if the system cannot access the state.;private Map<String, List<EventId>> extractCurrentMatches(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState) throws Exception {_		if (computationState.getPreviousBufferEntry() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<EventId>>> paths = sharedBufferAccessor.extractPatterns(_				computationState.getPreviousBufferEntry(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		return paths.get(0)__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,shared,buffer,accessor,the,accessor,to,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state,throws,exception,thrown,if,the,system,cannot,access,the,state;private,map,string,list,event,id,extract,current,matches,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,throws,exception,if,computation,state,get,previous,buffer,entry,null,return,new,hash,map,list,map,string,list,event,id,paths,shared,buffer,accessor,extract,patterns,computation,state,get,previous,buffer,entry,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,return,paths,get,0
NFA -> private Map<String, List<EventId>> extractCurrentMatches( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState) throws Exception;1546179377;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param sharedBufferAccessor The accessor to {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state_@throws Exception Thrown if the system cannot access the state.;private Map<String, List<EventId>> extractCurrentMatches(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState) throws Exception {_		if (computationState.getPreviousBufferEntry() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<EventId>>> paths = sharedBufferAccessor.extractPatterns(_				computationState.getPreviousBufferEntry(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		return paths.get(0)__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,shared,buffer,accessor,the,accessor,to,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state,throws,exception,thrown,if,the,system,cannot,access,the,state;private,map,string,list,event,id,extract,current,matches,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,throws,exception,if,computation,state,get,previous,buffer,entry,null,return,new,hash,map,list,map,string,list,event,id,paths,shared,buffer,accessor,extract,patterns,computation,state,get,previous,buffer,entry,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,return,paths,get,0
NFA -> private Map<String, List<EventId>> extractCurrentMatches( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState) throws Exception;1547021580;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param sharedBufferAccessor The accessor to {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state_@throws Exception Thrown if the system cannot access the state.;private Map<String, List<EventId>> extractCurrentMatches(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState) throws Exception {_		if (computationState.getPreviousBufferEntry() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<EventId>>> paths = sharedBufferAccessor.extractPatterns(_				computationState.getPreviousBufferEntry(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		return paths.get(0)__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,shared,buffer,accessor,the,accessor,to,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state,throws,exception,thrown,if,the,system,cannot,access,the,state;private,map,string,list,event,id,extract,current,matches,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,throws,exception,if,computation,state,get,previous,buffer,entry,null,return,new,hash,map,list,map,string,list,event,id,paths,shared,buffer,accessor,extract,patterns,computation,state,get,previous,buffer,entry,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,return,paths,get,0
NFA -> private Map<String, List<EventId>> extractCurrentMatches( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState) throws Exception;1550652777;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param sharedBufferAccessor The accessor to {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state_@throws Exception Thrown if the system cannot access the state.;private Map<String, List<EventId>> extractCurrentMatches(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState) throws Exception {_		if (computationState.getPreviousBufferEntry() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<EventId>>> paths = sharedBufferAccessor.extractPatterns(_				computationState.getPreviousBufferEntry(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		return paths.get(0)__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,shared,buffer,accessor,the,accessor,to,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state,throws,exception,thrown,if,the,system,cannot,access,the,state;private,map,string,list,event,id,extract,current,matches,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,throws,exception,if,computation,state,get,previous,buffer,entry,null,return,new,hash,map,list,map,string,list,event,id,paths,shared,buffer,accessor,extract,patterns,computation,state,get,previous,buffer,entry,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,return,paths,get,0
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1495024651;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		Collection<ListMultimap<String, T>> paths = stringSharedBuffer.extractPatterns(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getVersion())___		_		Preconditions.checkState(paths.size() <= 1)___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		Map<String, List<T>> result = new HashMap<>()__		for (ListMultimap<String, T> path: paths) {_			for (String key: path.keySet()) {_				List<T> events = path.get(key)___				List<T> values = new ArrayList<>(events.size())__				for (T event: events) {_					_					values.add(serializer.isImmutableType() ? event : serializer.copy(event))__				}_				result.put(key, values)__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,collection,list,multimap,string,t,paths,string,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,preconditions,check,state,paths,size,1,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,map,string,list,t,result,new,hash,map,for,list,multimap,string,t,path,paths,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,new,array,list,events,size,for,t,event,events,values,add,serializer,is,immutable,type,event,serializer,copy,event,result,put,key,values,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1495024653;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		Collection<ListMultimap<String, T>> paths = stringSharedBuffer.extractPatterns(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		_		Preconditions.checkState(paths.size() <= 1)___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		Map<String, List<T>> result = new HashMap<>()__		for (ListMultimap<String, T> path: paths) {_			for (String key: path.keySet()) {_				List<T> events = path.get(key)___				List<T> values = new ArrayList<>(events.size())__				for (T event: events) {_					_					values.add(serializer.isImmutableType() ? event : serializer.copy(event))__				}_				result.put(key, values)__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,collection,list,multimap,string,t,paths,string,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,preconditions,check,state,paths,size,1,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,map,string,list,t,result,new,hash,map,for,list,multimap,string,t,path,paths,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,new,array,list,events,size,for,t,event,events,values,add,serializer,is,immutable,type,event,serializer,copy,event,result,put,key,values,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1495024654;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		Collection<ListMultimap<String, T>> paths = eventSharedBuffer.extractPatterns(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		_		Preconditions.checkState(paths.size() <= 1)___		Map<String, List<T>> result = new HashMap<>()__		for (ListMultimap<String, T> path: paths) {_			for (String key: path.keySet()) {_				List<T> events = path.get(key)___				String originalKey = NFACompiler.getOriginalStateNameFromInternal(key)__				List<T> values = result.get(originalKey)__				if (values == null) {_					values = new ArrayList<>(events.size())__				}__				for (T event: events) {_					_					values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__				}_				result.put(originalKey, values)__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,collection,list,multimap,string,t,paths,event,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,for,list,multimap,string,t,path,paths,for,string,key,path,key,set,list,t,events,path,get,key,string,original,key,nfacompiler,get,original,state,name,from,internal,key,list,t,values,result,get,original,key,if,values,null,values,new,array,list,events,size,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,result,put,original,key,values,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1495024655;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		Collection<ListMultimap<String, T>> paths = eventSharedBuffer.extractPatterns(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		_		Preconditions.checkState(paths.size() <= 1)___		Map<String, List<T>> result = new HashMap<>()__		for (ListMultimap<String, T> path: paths) {_			for (String key: path.keySet()) {_				List<T> events = path.get(key)___				String originalKey = NFACompiler.getOriginalStateNameFromInternal(key)__				List<T> values = result.get(originalKey)__				if (values == null) {_					values = new ArrayList<>(events.size())__				}__				for (T event: events) {_					_					values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__				}_				result.put(originalKey, values)__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,collection,list,multimap,string,t,paths,event,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,for,list,multimap,string,t,path,paths,for,string,key,path,key,set,list,t,events,path,get,key,string,original,key,nfacompiler,get,original,state,name,from,internal,key,list,t,values,result,get,original,key,if,values,null,values,new,array,list,events,size,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,result,put,original,key,values,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1495203813;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		Collection<ListMultimap<String, T>> paths = eventSharedBuffer.extractPatterns(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		_		Preconditions.checkState(paths.size() <= 1)___		Map<String, List<T>> result = new HashMap<>()__		for (ListMultimap<String, T> path: paths) {_			for (String key: path.keySet()) {_				List<T> events = path.get(key)___				String originalKey = NFACompiler.getOriginalStateNameFromInternal(key)__				List<T> values = result.get(originalKey)__				if (values == null) {_					values = new ArrayList<>(events.size())__				}__				for (T event: events) {_					_					values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__				}_				result.put(originalKey, values)__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,collection,list,multimap,string,t,paths,event,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,for,list,multimap,string,t,path,paths,for,string,key,path,key,set,list,t,events,path,get,key,string,original,key,nfacompiler,get,original,state,name,from,internal,key,list,t,values,result,get,original,key,if,values,null,values,new,array,list,events,size,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,result,put,original,key,values,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1495466666;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		Collection<ListMultimap<String, T>> paths = eventSharedBuffer.extractPatterns(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		_		Preconditions.checkState(paths.size() <= 1)___		Map<String, List<T>> result = new HashMap<>()__		for (ListMultimap<String, T> path: paths) {_			for (String key: path.keySet()) {_				List<T> events = path.get(key)___				String originalKey = NFACompiler.getOriginalStateNameFromInternal(key)__				List<T> values = result.get(originalKey)__				if (values == null) {_					values = new ArrayList<>(events.size())__				}__				for (T event: events) {_					_					values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__				}_				result.put(originalKey, values)__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,collection,list,multimap,string,t,paths,event,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,for,list,multimap,string,t,path,paths,for,string,key,path,key,set,list,t,events,path,get,key,string,original,key,nfacompiler,get,original,state,name,from,internal,key,list,t,values,result,get,original,key,if,values,null,values,new,array,list,events,size,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,result,put,original,key,values,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1495961498;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		Collection<ListMultimap<String, T>> paths = eventSharedBuffer.extractPatterns(_				computationState.getPreviousState().getName(),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		_		Preconditions.checkState(paths.size() <= 1)___		Map<String, List<T>> result = new HashMap<>()__		for (ListMultimap<String, T> path: paths) {_			for (String key: path.keySet()) {_				List<T> events = path.get(key)___				String originalKey = NFACompiler.getOriginalStateNameFromInternal(key)__				List<T> values = result.get(originalKey)__				if (values == null) {_					values = new ArrayList<>(events.size())__				}__				for (T event: events) {_					_					values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__				}_				result.put(originalKey, values)__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,collection,list,multimap,string,t,paths,event,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,for,list,multimap,string,t,path,paths,for,string,key,path,key,set,list,t,events,path,get,key,string,original,key,nfacompiler,get,original,state,name,from,internal,key,list,t,values,result,get,original,key,if,values,null,values,new,array,list,events,size,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,result,put,original,key,values,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1496929298;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState().getName()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new HashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1497328665;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState().getName()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new HashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1498764573;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState().getName()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new HashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1501661862;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState().getName()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new HashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1502726910;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState().getName()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new HashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1503470129;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState().getName()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new HashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1503555538;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState().getName()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new HashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1503598628;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState().getName()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new HashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1504268438;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState().getName()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new LinkedHashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,linked,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1507895398;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		_		if (eventSerializer == null) {_			eventSerializer = nonDuplicatingTypeSerializer.getTypeSerializer()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState().getName()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new LinkedHashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,if,event,serializer,null,event,serializer,non,duplicating,type,serializer,get,type,serializer,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,linked,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1516692416;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState().getName()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new LinkedHashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,linked,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState);1518030004;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState().getName()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new LinkedHashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,linked,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches( 		SharedBuffer<String, T> eventSharedBuffer, final ComputationState<T> computationState);1528894798;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param eventSharedBuffer The {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(_		SharedBuffer<String, T> eventSharedBuffer, final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new LinkedHashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,event,shared,buffer,the,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,shared,buffer,string,t,event,shared,buffer,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,linked,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> Map<String, List<T>> extractCurrentMatches( 		SharedBuffer<String, T> eventSharedBuffer, final ComputationState<T> computationState);1528894798;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param eventSharedBuffer The {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;Map<String, List<T>> extractCurrentMatches(_		SharedBuffer<String, T> eventSharedBuffer, final ComputationState<T> computationState) {_		if (computationState.getPreviousState() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(_				NFAStateNameHandler.getOriginalNameFromInternal(_						computationState.getPreviousState()),_				computationState.getEvent(),_				computationState.getTimestamp(),_				computationState.getCounter(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new LinkedHashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.get(key)__			if (values == null) {_				values = new ArrayList<>(events.size())__				result.put(key, values)__			}__			for (T event: events) {_				_				values.add(eventSerializer.isImmutableType() ? event : eventSerializer.copy(event))__			}_		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,event,shared,buffer,the,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;map,string,list,t,extract,current,matches,shared,buffer,string,t,event,shared,buffer,final,computation,state,t,computation,state,if,computation,state,get,previous,state,null,return,new,hash,map,list,map,string,list,t,paths,event,shared,buffer,extract,patterns,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,linked,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,get,key,if,values,null,values,new,array,list,events,size,result,put,key,values,for,t,event,events,values,add,event,serializer,is,immutable,type,event,event,serializer,copy,event,return,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1495024651;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				stringSharedBuffer.release(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}___			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					stringSharedBuffer.release(_							newComputationState.getPreviousState().getName(),_							newComputationState.getEvent(),_							newComputationState.getTimestamp())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					stringSharedBuffer.release(_						newComputationState.getPreviousState().getName(),_						newComputationState.getEvent(),_						newComputationState.getTimestamp())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					stringSharedBuffer.release(_						state.getPreviousState().getName(),_						state.getEvent(),_						state.getTimestamp())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				stringSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,string,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,else,if,new,computation,state,is,stop,state,should,discard,path,true,string,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,string,shared,buffer,release,state,get,previous,state,get,name,state,get,event,state,get,timestamp,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,string,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1495024653;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				stringSharedBuffer.release(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					stringSharedBuffer.release(_							newComputationState.getPreviousState().getName(),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							computationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					stringSharedBuffer.release(_						newComputationState.getPreviousState().getName(),_						newComputationState.getEvent(),_						newComputationState.getTimestamp(),_						computationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					stringSharedBuffer.release(_						state.getPreviousState().getName(),_						state.getEvent(),_						state.getTimestamp(),_						state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				stringSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,string,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,string,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,string,shared,buffer,release,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,string,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1495024654;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				eventSharedBuffer.release(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							newComputationState.getPreviousState().getName(),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							computationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_						newComputationState.getPreviousState().getName(),_						newComputationState.getEvent(),_						newComputationState.getTimestamp(),_						computationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_						state.getPreviousState().getName(),_						state.getEvent(),_						state.getTimestamp(),_						state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				eventSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,event,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,event,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1495024655;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				eventSharedBuffer.release(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							newComputationState.getPreviousState().getName(),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							computationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_						newComputationState.getPreviousState().getName(),_						newComputationState.getEvent(),_						newComputationState.getTimestamp(),_						computationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_						state.getPreviousState().getName(),_						state.getEvent(),_						state.getTimestamp(),_						state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				eventSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,event,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,event,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1495203813;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				eventSharedBuffer.release(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							newComputationState.getPreviousState().getName(),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							computationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_						newComputationState.getPreviousState().getName(),_						newComputationState.getEvent(),_						newComputationState.getTimestamp(),_						computationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_						state.getPreviousState().getName(),_						state.getEvent(),_						state.getTimestamp(),_						state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				eventSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,event,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,event,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1495466666;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				eventSharedBuffer.release(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							newComputationState.getPreviousState().getName(),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							computationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_						newComputationState.getPreviousState().getName(),_						newComputationState.getEvent(),_						newComputationState.getTimestamp(),_						computationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_						state.getPreviousState().getName(),_						state.getEvent(),_						state.getTimestamp(),_						state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				eventSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,event,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,event,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1495961498;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				eventSharedBuffer.release(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							newComputationState.getPreviousState().getName(),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							computationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_						newComputationState.getPreviousState().getName(),_						newComputationState.getEvent(),_						newComputationState.getTimestamp(),_						computationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_						state.getPreviousState().getName(),_						state.getEvent(),_						state.getTimestamp(),_						state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				eventSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,event,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,event,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1496929298;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							computationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							computationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState().getName()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				eventSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,event,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1497328665;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							computationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							computationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState().getName()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				eventSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,event,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1498764573;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__				nfaChanged = true__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)___				if (newComputationStates.size() != 1) {_					nfaChanged = true__				} else if (!newComputationStates.iterator().next().equals(computationState)) {_					nfaChanged = true__				}_			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							computationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							computationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState().getName()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				if (eventSharedBuffer.prune(pruningTimestamp)) {_					nfaChanged = true__				}_			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,nfa,changed,true,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,if,new,computation,states,size,1,nfa,changed,true,else,if,new,computation,states,iterator,next,equals,computation,state,nfa,changed,true,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,if,event,shared,buffer,prune,pruning,timestamp,nfa,changed,true,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1501661862;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__				nfaChanged = true__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)___				if (newComputationStates.size() != 1) {_					nfaChanged = true__				} else if (!newComputationStates.iterator().next().equals(computationState)) {_					nfaChanged = true__				}_			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState().getName()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				if (eventSharedBuffer.prune(pruningTimestamp)) {_					nfaChanged = true__				}_			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,nfa,changed,true,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,if,new,computation,states,size,1,nfa,changed,true,else,if,new,computation,states,iterator,next,equals,computation,state,nfa,changed,true,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,if,event,shared,buffer,prune,pruning,timestamp,nfa,changed,true,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1502726910;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__				nfaChanged = true__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)___				if (newComputationStates.size() != 1) {_					nfaChanged = true__				} else if (!newComputationStates.iterator().next().equals(computationState)) {_					nfaChanged = true__				}_			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState().getName()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				if (eventSharedBuffer.prune(pruningTimestamp)) {_					nfaChanged = true__				}_			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,nfa,changed,true,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,if,new,computation,states,size,1,nfa,changed,true,else,if,new,computation,states,iterator,next,equals,computation,state,nfa,changed,true,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,if,event,shared,buffer,prune,pruning,timestamp,nfa,changed,true,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1503470129;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedoutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedoutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__				nfaChanged = true__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)___				if (newComputationStates.size() != 1) {_					nfaChanged = true__				} else if (!newComputationStates.iterator().next().equals(computationState)) {_					nfaChanged = true__				}_			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState().getName()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				if (eventSharedBuffer.prune(pruningTimestamp)) {_					nfaChanged = true__				}_			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timedout,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timedout,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,nfa,changed,true,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,if,new,computation,states,size,1,nfa,changed,true,else,if,new,computation,states,iterator,next,equals,computation,state,nfa,changed,true,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,if,event,shared,buffer,prune,pruning,timestamp,nfa,changed,true,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1503555538;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__				nfaChanged = true__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)___				if (newComputationStates.size() != 1) {_					nfaChanged = true__				} else if (!newComputationStates.iterator().next().equals(computationState)) {_					nfaChanged = true__				}_			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState().getName()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				if (eventSharedBuffer.prune(pruningTimestamp)) {_					nfaChanged = true__				}_			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timed,out,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,nfa,changed,true,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,if,new,computation,states,size,1,nfa,changed,true,else,if,new,computation,states,iterator,next,equals,computation,state,nfa,changed,true,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,if,event,shared,buffer,prune,pruning,timestamp,nfa,changed,true,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1503598628;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__				nfaChanged = true__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)___				if (newComputationStates.size() != 1) {_					nfaChanged = true__				} else if (!newComputationStates.iterator().next().equals(computationState)) {_					nfaChanged = true__				}_			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState().getName()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				if (eventSharedBuffer.prune(pruningTimestamp)) {_					nfaChanged = true__				}_			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timed,out,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,nfa,changed,true,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,if,new,computation,states,size,1,nfa,changed,true,else,if,new,computation,states,iterator,next,equals,computation,state,nfa,changed,true,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,if,event,shared,buffer,prune,pruning,timestamp,nfa,changed,true,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1504268438;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		return process(event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,return,process,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1507895398;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		return process(event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,return,process,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1516692416;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		return process(event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,return,process,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp);1518030004;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {_		return process(event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,return,process,event,timestamp,after,match,skip,strategy,no,skip
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState, 			final EventWrapper event, 			final TimerService timerService) throws Exception;1547021580;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBufferAccessor The accessor to shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timerService timer service which provides access to time related features_@return Collection of computation states which result from the current one_@throws Exception Thrown if the system cannot access the state.;private Collection<ComputationState> computeNextStates(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState,_			final EventWrapper event,_			final TimerService timerService) throws Exception {__		final ConditionContext context = new ConditionContext(_			sharedBufferAccessor,_			computationState,_			timerService,_			event.getTimestamp())___		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(context, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							edge.getTargetState(),_							computationState.getPreviousBufferEntry(),_							version,_							computationState.getStartTimestamp(),_							computationState.getStartEventID()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry = sharedBufferAccessor.put(_						currentState.getName(),_						event.getEventId(),_						previousEntry,_						currentVersion)___					final long startTimestamp__					final EventId startEventId__					if (isStartState(computationState)) {_						startTimestamp = event.getTimestamp()__						startEventId = event.getEventId()__					} else {_						startTimestamp = computationState.getStartTimestamp()__						startEventId = computationState.getStartEventID()__					}__					addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp,_							startEventId)___					_					final State<T> finalState = findFinalStateAfterProceed(context, nextState, event.getEvent())__					if (finalState != null) {_						addComputationState(_								sharedBufferAccessor,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp,_								startEventId)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,accessor,the,accessor,to,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timer,service,timer,service,which,provides,access,to,time,related,features,return,collection,of,computation,states,which,result,from,the,current,one,throws,exception,thrown,if,the,system,cannot,access,the,state;private,collection,computation,state,compute,next,states,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,final,event,wrapper,event,final,timer,service,timer,service,throws,exception,final,condition,context,context,new,condition,context,shared,buffer,accessor,computation,state,timer,service,event,get,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,context,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,accessor,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,computation,state,get,start,event,id,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,shared,buffer,accessor,put,current,state,get,name,event,get,event,id,previous,entry,current,version,final,long,start,timestamp,final,event,id,start,event,id,if,is,start,state,computation,state,start,timestamp,event,get,timestamp,start,event,id,event,get,event,id,else,start,timestamp,computation,state,get,start,timestamp,start,event,id,computation,state,get,start,event,id,add,computation,state,shared,buffer,accessor,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,start,event,id,final,state,t,final,state,find,final,state,after,proceed,context,next,state,event,get,event,if,final,state,null,add,computation,state,shared,buffer,accessor,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,start,event,id,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState, 			final EventWrapper event, 			final TimerService timerService) throws Exception;1550652777;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBufferAccessor The accessor to shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timerService timer service which provides access to time related features_@return Collection of computation states which result from the current one_@throws Exception Thrown if the system cannot access the state.;private Collection<ComputationState> computeNextStates(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState,_			final EventWrapper event,_			final TimerService timerService) throws Exception {__		final ConditionContext context = new ConditionContext(_			sharedBufferAccessor,_			computationState,_			timerService,_			event.getTimestamp())___		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(context, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							edge.getTargetState(),_							computationState.getPreviousBufferEntry(),_							version,_							computationState.getStartTimestamp(),_							computationState.getStartEventID()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry = sharedBufferAccessor.put(_						currentState.getName(),_						event.getEventId(),_						previousEntry,_						currentVersion)___					final long startTimestamp__					final EventId startEventId__					if (isStartState(computationState)) {_						startTimestamp = event.getTimestamp()__						startEventId = event.getEventId()__					} else {_						startTimestamp = computationState.getStartTimestamp()__						startEventId = computationState.getStartEventID()__					}__					addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp,_							startEventId)___					_					final State<T> finalState = findFinalStateAfterProceed(context, nextState, event.getEvent())__					if (finalState != null) {_						addComputationState(_								sharedBufferAccessor,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp,_								startEventId)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,accessor,the,accessor,to,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timer,service,timer,service,which,provides,access,to,time,related,features,return,collection,of,computation,states,which,result,from,the,current,one,throws,exception,thrown,if,the,system,cannot,access,the,state;private,collection,computation,state,compute,next,states,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,final,event,wrapper,event,final,timer,service,timer,service,throws,exception,final,condition,context,context,new,condition,context,shared,buffer,accessor,computation,state,timer,service,event,get,timestamp,final,outgoing,edges,t,outgoing,edges,create,decision,graph,context,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,accessor,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,computation,state,get,start,event,id,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,shared,buffer,accessor,put,current,state,get,name,event,get,event,id,previous,entry,current,version,final,long,start,timestamp,final,event,id,start,event,id,if,is,start,state,computation,state,start,timestamp,event,get,timestamp,start,event,id,event,get,event,id,else,start,timestamp,computation,state,get,start,timestamp,start,event,id,computation,state,get,start,event,id,add,computation,state,shared,buffer,accessor,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,start,event,id,final,state,t,final,state,find,final,state,after,proceed,context,next,state,event,get,event,if,final,state,null,add,computation,state,shared,buffer,accessor,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,start,event,id,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> private Map<String, List<T>> extractCurrentMatches( 			final SharedBuffer<T> sharedBuffer, 			final ComputationState computationState) throws Exception;1528894799;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param sharedBuffer The {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state_@throws Exception Thrown if the system cannot access the state.;private Map<String, List<T>> extractCurrentMatches(_			final SharedBuffer<T> sharedBuffer,_			final ComputationState computationState) throws Exception {_		if (computationState.getPreviousBufferEntry() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<T>>> paths = sharedBuffer.extractPatterns(_				computationState.getPreviousBufferEntry(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new LinkedHashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.computeIfAbsent(key, k -> new ArrayList<>(events.size()))__			values.addAll(events)__		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,shared,buffer,the,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state,throws,exception,thrown,if,the,system,cannot,access,the,state;private,map,string,list,t,extract,current,matches,final,shared,buffer,t,shared,buffer,final,computation,state,computation,state,throws,exception,if,computation,state,get,previous,buffer,entry,null,return,new,hash,map,list,map,string,list,t,paths,shared,buffer,extract,patterns,computation,state,get,previous,buffer,entry,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,linked,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,compute,if,absent,key,k,new,array,list,events,size,values,add,all,events,return,result
NFA -> private Map<String, List<T>> extractCurrentMatches( 			final SharedBuffer<T> sharedBuffer, 			final ComputationState computationState) throws Exception;1530798894;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param sharedBuffer The {@link SharedBuffer} from which to extract the matches_@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state_@throws Exception Thrown if the system cannot access the state.;private Map<String, List<T>> extractCurrentMatches(_			final SharedBuffer<T> sharedBuffer,_			final ComputationState computationState) throws Exception {_		if (computationState.getPreviousBufferEntry() == null) {_			return new HashMap<>()__		}__		List<Map<String, List<T>>> paths = sharedBuffer.extractPatterns(_				computationState.getPreviousBufferEntry(),_				computationState.getVersion())___		if (paths.isEmpty()) {_			return new HashMap<>()__		}_		_		Preconditions.checkState(paths.size() == 1)___		Map<String, List<T>> result = new LinkedHashMap<>()__		Map<String, List<T>> path = paths.get(0)__		for (String key: path.keySet()) {_			List<T> events = path.get(key)___			List<T> values = result.computeIfAbsent(key, k -> new ArrayList<>(events.size()))__			values.addAll(events)__		}_		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,shared,buffer,the,link,shared,buffer,from,which,to,extract,the,matches,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state,throws,exception,thrown,if,the,system,cannot,access,the,state;private,map,string,list,t,extract,current,matches,final,shared,buffer,t,shared,buffer,final,computation,state,computation,state,throws,exception,if,computation,state,get,previous,buffer,entry,null,return,new,hash,map,list,map,string,list,t,paths,shared,buffer,extract,patterns,computation,state,get,previous,buffer,entry,computation,state,get,version,if,paths,is,empty,return,new,hash,map,preconditions,check,state,paths,size,1,map,string,list,t,result,new,linked,hash,map,map,string,list,t,path,paths,get,0,for,string,key,path,key,set,list,t,events,path,get,key,list,t,values,result,compute,if,absent,key,k,new,array,list,events,size,values,add,all,events,return,result
NFA -> public boolean isEmpty();1489660607;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return sharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,shared,buffer,is,empty
NFA -> public boolean isEmpty();1489764761;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return sharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,shared,buffer,is,empty
NFA -> public boolean isEmpty();1490186498;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return sharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,shared,buffer,is,empty
NFA -> public boolean isEmpty();1490262475;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return sharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,shared,buffer,is,empty
NFA -> public boolean isEmpty();1490262475;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return stringSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,string,shared,buffer,is,empty
NFA -> public boolean isEmpty();1490638274;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return stringSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,string,shared,buffer,is,empty
NFA -> public boolean isEmpty();1490692084;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return stringSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,string,shared,buffer,is,empty
NFA -> public boolean isEmpty();1493985576;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return stringSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,string,shared,buffer,is,empty
NFA -> public boolean isEmpty();1494180263;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return stringSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,string,shared,buffer,is,empty
NFA -> public boolean isEmpty();1495024651;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return stringSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,string,shared,buffer,is,empty
NFA -> public boolean isEmpty();1495024653;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return stringSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,string,shared,buffer,is,empty
NFA -> public boolean isEmpty();1495024654;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1495024655;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1495203813;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1495466666;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1495961498;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1496929298;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1497328665;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1498764573;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1501661862;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1502726910;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1503470129;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1503555538;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1503598628;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1504268438;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1507895398;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1516692416;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> public boolean isEmpty();1518030004;Check if the NFA has finished processing all incoming data so far. That is_when the buffer keeping the matches is empty.__@return {@code true} if there are no elements in the {@link SharedBuffer},_{@code false} otherwise.;public boolean isEmpty() {_		return eventSharedBuffer.isEmpty()__	};check,if,the,nfa,has,finished,processing,all,incoming,data,so,far,that,is,when,the,buffer,keeping,the,matches,is,empty,return,code,true,if,there,are,no,elements,in,the,link,shared,buffer,code,false,otherwise;public,boolean,is,empty,return,event,shared,buffer,is,empty
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState, 			final EventWrapper event, 			final long timestamp) throws Exception;1535555335;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBufferAccessor The accessor to shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one_@throws Exception Thrown if the system cannot access the state.;private Collection<ComputationState> computeNextStates(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState,_			final EventWrapper event,_			final long timestamp) throws Exception {__		final ConditionContext<T> context = new ConditionContext<>(this, sharedBufferAccessor, computationState)___		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(context, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							edge.getTargetState(),_							computationState.getPreviousBufferEntry(),_							version,_							computationState.getStartTimestamp(),_							computationState.getStartEventID()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry = sharedBufferAccessor.put(_						currentState.getName(),_						event.getEventId(),_						previousEntry,_						currentVersion)___					final long startTimestamp__					final EventId startEventId__					if (isStartState(computationState)) {_						startTimestamp = timestamp__						startEventId = event.getEventId()__					} else {_						startTimestamp = computationState.getStartTimestamp()__						startEventId = computationState.getStartEventID()__					}__					addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp,_							startEventId)___					_					final State<T> finalState = findFinalStateAfterProceed(context, nextState, event.getEvent())__					if (finalState != null) {_						addComputationState(_								sharedBufferAccessor,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp,_								startEventId)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,accessor,the,accessor,to,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one,throws,exception,thrown,if,the,system,cannot,access,the,state;private,collection,computation,state,compute,next,states,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,final,event,wrapper,event,final,long,timestamp,throws,exception,final,condition,context,t,context,new,condition,context,this,shared,buffer,accessor,computation,state,final,outgoing,edges,t,outgoing,edges,create,decision,graph,context,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,accessor,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,computation,state,get,start,event,id,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,shared,buffer,accessor,put,current,state,get,name,event,get,event,id,previous,entry,current,version,final,long,start,timestamp,final,event,id,start,event,id,if,is,start,state,computation,state,start,timestamp,timestamp,start,event,id,event,get,event,id,else,start,timestamp,computation,state,get,start,timestamp,start,event,id,computation,state,get,start,event,id,add,computation,state,shared,buffer,accessor,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,start,event,id,final,state,t,final,state,find,final,state,after,proceed,context,next,state,event,get,event,if,final,state,null,add,computation,state,shared,buffer,accessor,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,start,event,id,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState, 			final EventWrapper event, 			final long timestamp) throws Exception;1539149027;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBufferAccessor The accessor to shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one_@throws Exception Thrown if the system cannot access the state.;private Collection<ComputationState> computeNextStates(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState,_			final EventWrapper event,_			final long timestamp) throws Exception {__		final ConditionContext<T> context = new ConditionContext<>(this, sharedBufferAccessor, computationState)___		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(context, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							edge.getTargetState(),_							computationState.getPreviousBufferEntry(),_							version,_							computationState.getStartTimestamp(),_							computationState.getStartEventID()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry = sharedBufferAccessor.put(_						currentState.getName(),_						event.getEventId(),_						previousEntry,_						currentVersion)___					final long startTimestamp__					final EventId startEventId__					if (isStartState(computationState)) {_						startTimestamp = timestamp__						startEventId = event.getEventId()__					} else {_						startTimestamp = computationState.getStartTimestamp()__						startEventId = computationState.getStartEventID()__					}__					addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp,_							startEventId)___					_					final State<T> finalState = findFinalStateAfterProceed(context, nextState, event.getEvent())__					if (finalState != null) {_						addComputationState(_								sharedBufferAccessor,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp,_								startEventId)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,accessor,the,accessor,to,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one,throws,exception,thrown,if,the,system,cannot,access,the,state;private,collection,computation,state,compute,next,states,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,final,event,wrapper,event,final,long,timestamp,throws,exception,final,condition,context,t,context,new,condition,context,this,shared,buffer,accessor,computation,state,final,outgoing,edges,t,outgoing,edges,create,decision,graph,context,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,accessor,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,computation,state,get,start,event,id,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,shared,buffer,accessor,put,current,state,get,name,event,get,event,id,previous,entry,current,version,final,long,start,timestamp,final,event,id,start,event,id,if,is,start,state,computation,state,start,timestamp,timestamp,start,event,id,event,get,event,id,else,start,timestamp,computation,state,get,start,timestamp,start,event,id,computation,state,get,start,event,id,add,computation,state,shared,buffer,accessor,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,start,event,id,final,state,t,final,state,find,final,state,after,proceed,context,next,state,event,get,event,if,final,state,null,add,computation,state,shared,buffer,accessor,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,start,event,id,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState, 			final EventWrapper event, 			final long timestamp) throws Exception;1539149114;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBufferAccessor The accessor to shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one_@throws Exception Thrown if the system cannot access the state.;private Collection<ComputationState> computeNextStates(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState,_			final EventWrapper event,_			final long timestamp) throws Exception {__		final ConditionContext<T> context = new ConditionContext<>(this, sharedBufferAccessor, computationState)___		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(context, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							edge.getTargetState(),_							computationState.getPreviousBufferEntry(),_							version,_							computationState.getStartTimestamp(),_							computationState.getStartEventID()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry = sharedBufferAccessor.put(_						currentState.getName(),_						event.getEventId(),_						previousEntry,_						currentVersion)___					final long startTimestamp__					final EventId startEventId__					if (isStartState(computationState)) {_						startTimestamp = timestamp__						startEventId = event.getEventId()__					} else {_						startTimestamp = computationState.getStartTimestamp()__						startEventId = computationState.getStartEventID()__					}__					addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp,_							startEventId)___					_					final State<T> finalState = findFinalStateAfterProceed(context, nextState, event.getEvent())__					if (finalState != null) {_						addComputationState(_								sharedBufferAccessor,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp,_								startEventId)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,accessor,the,accessor,to,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one,throws,exception,thrown,if,the,system,cannot,access,the,state;private,collection,computation,state,compute,next,states,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,final,event,wrapper,event,final,long,timestamp,throws,exception,final,condition,context,t,context,new,condition,context,this,shared,buffer,accessor,computation,state,final,outgoing,edges,t,outgoing,edges,create,decision,graph,context,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,accessor,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,computation,state,get,start,event,id,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,shared,buffer,accessor,put,current,state,get,name,event,get,event,id,previous,entry,current,version,final,long,start,timestamp,final,event,id,start,event,id,if,is,start,state,computation,state,start,timestamp,timestamp,start,event,id,event,get,event,id,else,start,timestamp,computation,state,get,start,timestamp,start,event,id,computation,state,get,start,event,id,add,computation,state,shared,buffer,accessor,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,start,event,id,final,state,t,final,state,find,final,state,after,proceed,context,next,state,event,get,event,if,final,state,null,add,computation,state,shared,buffer,accessor,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,start,event,id,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState, 			final EventWrapper event, 			final long timestamp) throws Exception;1540386566;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBufferAccessor The accessor to shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one_@throws Exception Thrown if the system cannot access the state.;private Collection<ComputationState> computeNextStates(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState,_			final EventWrapper event,_			final long timestamp) throws Exception {__		final ConditionContext<T> context = new ConditionContext<>(this, sharedBufferAccessor, computationState)___		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(context, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							edge.getTargetState(),_							computationState.getPreviousBufferEntry(),_							version,_							computationState.getStartTimestamp(),_							computationState.getStartEventID()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry = sharedBufferAccessor.put(_						currentState.getName(),_						event.getEventId(),_						previousEntry,_						currentVersion)___					final long startTimestamp__					final EventId startEventId__					if (isStartState(computationState)) {_						startTimestamp = timestamp__						startEventId = event.getEventId()__					} else {_						startTimestamp = computationState.getStartTimestamp()__						startEventId = computationState.getStartEventID()__					}__					addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp,_							startEventId)___					_					final State<T> finalState = findFinalStateAfterProceed(context, nextState, event.getEvent())__					if (finalState != null) {_						addComputationState(_								sharedBufferAccessor,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp,_								startEventId)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,accessor,the,accessor,to,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one,throws,exception,thrown,if,the,system,cannot,access,the,state;private,collection,computation,state,compute,next,states,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,final,event,wrapper,event,final,long,timestamp,throws,exception,final,condition,context,t,context,new,condition,context,this,shared,buffer,accessor,computation,state,final,outgoing,edges,t,outgoing,edges,create,decision,graph,context,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,accessor,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,computation,state,get,start,event,id,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,shared,buffer,accessor,put,current,state,get,name,event,get,event,id,previous,entry,current,version,final,long,start,timestamp,final,event,id,start,event,id,if,is,start,state,computation,state,start,timestamp,timestamp,start,event,id,event,get,event,id,else,start,timestamp,computation,state,get,start,timestamp,start,event,id,computation,state,get,start,event,id,add,computation,state,shared,buffer,accessor,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,start,event,id,final,state,t,final,state,find,final,state,after,proceed,context,next,state,event,get,event,if,final,state,null,add,computation,state,shared,buffer,accessor,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,start,event,id,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState, 			final EventWrapper event, 			final long timestamp) throws Exception;1546179377;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBufferAccessor The accessor to shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one_@throws Exception Thrown if the system cannot access the state.;private Collection<ComputationState> computeNextStates(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState,_			final EventWrapper event,_			final long timestamp) throws Exception {__		final ConditionContext<T> context = new ConditionContext<>(this, sharedBufferAccessor, computationState)___		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(context, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							edge.getTargetState(),_							computationState.getPreviousBufferEntry(),_							version,_							computationState.getStartTimestamp(),_							computationState.getStartEventID()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry = sharedBufferAccessor.put(_						currentState.getName(),_						event.getEventId(),_						previousEntry,_						currentVersion)___					final long startTimestamp__					final EventId startEventId__					if (isStartState(computationState)) {_						startTimestamp = timestamp__						startEventId = event.getEventId()__					} else {_						startTimestamp = computationState.getStartTimestamp()__						startEventId = computationState.getStartEventID()__					}__					addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp,_							startEventId)___					_					final State<T> finalState = findFinalStateAfterProceed(context, nextState, event.getEvent())__					if (finalState != null) {_						addComputationState(_								sharedBufferAccessor,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp,_								startEventId)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,accessor,the,accessor,to,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one,throws,exception,thrown,if,the,system,cannot,access,the,state;private,collection,computation,state,compute,next,states,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,final,event,wrapper,event,final,long,timestamp,throws,exception,final,condition,context,t,context,new,condition,context,this,shared,buffer,accessor,computation,state,final,outgoing,edges,t,outgoing,edges,create,decision,graph,context,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,accessor,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,computation,state,get,start,event,id,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,shared,buffer,accessor,put,current,state,get,name,event,get,event,id,previous,entry,current,version,final,long,start,timestamp,final,event,id,start,event,id,if,is,start,state,computation,state,start,timestamp,timestamp,start,event,id,event,get,event,id,else,start,timestamp,computation,state,get,start,timestamp,start,event,id,computation,state,get,start,event,id,add,computation,state,shared,buffer,accessor,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,start,event,id,final,state,t,final,state,find,final,state,after,proceed,context,next,state,event,get,event,if,final,state,null,add,computation,state,shared,buffer,accessor,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,start,event,id,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState, 			final EventWrapper event, 			final long timestamp) throws Exception;1546179377;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBufferAccessor The accessor to shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one_@throws Exception Thrown if the system cannot access the state.;private Collection<ComputationState> computeNextStates(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState,_			final EventWrapper event,_			final long timestamp) throws Exception {__		final ConditionContext<T> context = new ConditionContext<>(this, sharedBufferAccessor, computationState)___		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(context, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							edge.getTargetState(),_							computationState.getPreviousBufferEntry(),_							version,_							computationState.getStartTimestamp(),_							computationState.getStartEventID()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry = sharedBufferAccessor.put(_						currentState.getName(),_						event.getEventId(),_						previousEntry,_						currentVersion)___					final long startTimestamp__					final EventId startEventId__					if (isStartState(computationState)) {_						startTimestamp = timestamp__						startEventId = event.getEventId()__					} else {_						startTimestamp = computationState.getStartTimestamp()__						startEventId = computationState.getStartEventID()__					}__					addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp,_							startEventId)___					_					final State<T> finalState = findFinalStateAfterProceed(context, nextState, event.getEvent())__					if (finalState != null) {_						addComputationState(_								sharedBufferAccessor,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp,_								startEventId)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,accessor,the,accessor,to,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one,throws,exception,thrown,if,the,system,cannot,access,the,state;private,collection,computation,state,compute,next,states,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,final,event,wrapper,event,final,long,timestamp,throws,exception,final,condition,context,t,context,new,condition,context,this,shared,buffer,accessor,computation,state,final,outgoing,edges,t,outgoing,edges,create,decision,graph,context,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,accessor,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,computation,state,get,start,event,id,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,shared,buffer,accessor,put,current,state,get,name,event,get,event,id,previous,entry,current,version,final,long,start,timestamp,final,event,id,start,event,id,if,is,start,state,computation,state,start,timestamp,timestamp,start,event,id,event,get,event,id,else,start,timestamp,computation,state,get,start,timestamp,start,event,id,computation,state,get,start,event,id,add,computation,state,shared,buffer,accessor,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,start,event,id,final,state,t,final,state,find,final,state,after,proceed,context,next,state,event,get,event,if,final,state,null,add,computation,state,shared,buffer,accessor,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,start,event,id,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> private Collection<ComputationState> computeNextStates( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final ComputationState computationState, 			final EventWrapper event, 			final long timestamp) throws Exception;1546179377;Computes the next computation states based on the given computation state, the current event,_its timestamp and the internal state machine. The algorithm is:_<ol>_<li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>_<li>Perform transitions:_<ol>_<li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>_<ul>_<li>do not perform for Start State - special case</li>_<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>_<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>_<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>_</ul>_<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>_<ul>_<li>add entry to the shared buffer with version of the current computation state</li>_<li>add stage and then increase with number of takes for the future computation states</li>_<li>peek to the next state if it has PROCEED path to a Final State, if true create Final_ComputationState to emit results</li>_</ul>_</ol>_</li>_<li>Handle the Start State, as it always have to remain </li>_<li>Release the corresponding entries in {@link SharedBuffer}.</li>_</ol>__@param sharedBufferAccessor The accessor to shared buffer that we need to change_@param computationState Current computation state_@param event Current event which is processed_@param timestamp Timestamp of the current event_@return Collection of computation states which result from the current one_@throws Exception Thrown if the system cannot access the state.;private Collection<ComputationState> computeNextStates(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final ComputationState computationState,_			final EventWrapper event,_			final long timestamp) throws Exception {__		final ConditionContext<T> context = new ConditionContext<>(this, sharedBufferAccessor, computationState)___		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(context, computationState, event.getEvent())___		_		_		_		final List<StateTransition<T>> edges = outgoingEdges.getEdges()__		int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)__		int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches()__		int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1)___		final List<ComputationState> resultingComputationStates = new ArrayList<>()__		for (StateTransition<T> edge : edges) {_			switch (edge.getAction()) {_				case IGNORE: {_					if (!isStartState(computationState)) {_						final DeweyNumber version__						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {_							_							final int toIncrease = calculateIncreasingSelfState(_								outgoingEdges.getTotalIgnoreBranches(),_								outgoingEdges.getTotalTakeBranches())__							version = computationState.getVersion().increase(toIncrease)__						} else {_							_							version = computationState.getVersion()_								.increase(totalTakeToSkip + ignoreBranchesToVisit)_								.addStage()__							ignoreBranchesToVisit--__						}__						addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							edge.getTargetState(),_							computationState.getPreviousBufferEntry(),_							version,_							computationState.getStartTimestamp(),_							computationState.getStartEventID()_						)__					}_				}_				break__				case TAKE:_					final State<T> nextState = edge.getTargetState()__					final State<T> currentState = edge.getSourceState()___					final NodeId previousEntry = computationState.getPreviousBufferEntry()___					final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit)__					final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage()__					takeBranchesToVisit--___					final NodeId newEntry = sharedBufferAccessor.put(_						currentState.getName(),_						event.getEventId(),_						previousEntry,_						currentVersion)___					final long startTimestamp__					final EventId startEventId__					if (isStartState(computationState)) {_						startTimestamp = timestamp__						startEventId = event.getEventId()__					} else {_						startTimestamp = computationState.getStartTimestamp()__						startEventId = computationState.getStartEventID()__					}__					addComputationState(_							sharedBufferAccessor,_							resultingComputationStates,_							nextState,_							newEntry,_							nextVersion,_							startTimestamp,_							startEventId)___					_					final State<T> finalState = findFinalStateAfterProceed(context, nextState, event.getEvent())__					if (finalState != null) {_						addComputationState(_								sharedBufferAccessor,_								resultingComputationStates,_								finalState,_								newEntry,_								nextVersion,_								startTimestamp,_								startEventId)__					}_					break__			}_		}__		if (isStartState(computationState)) {_			int totalBranches = calculateIncreasingSelfState(_					outgoingEdges.getTotalIgnoreBranches(),_					outgoingEdges.getTotalTakeBranches())___			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches)__			ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion)__			resultingComputationStates.add(startState)__		}__		if (computationState.getPreviousBufferEntry() != null) {_			_			sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())__		}__		return resultingComputationStates__	};computes,the,next,computation,states,based,on,the,given,computation,state,the,current,event,its,timestamp,and,the,internal,state,machine,the,algorithm,is,ol,li,decide,on,valid,transitions,and,number,of,branching,paths,see,link,outgoing,edges,li,li,perform,transitions,ol,li,ignore,links,in,link,shared,buffer,will,still,point,to,the,previous,event,li,ul,li,do,not,perform,for,start,state,special,case,li,li,if,stays,in,the,same,state,increase,the,current,stage,for,future,use,with,number,of,outgoing,edges,li,li,if,after,proceed,increase,current,stage,and,add,new,stage,as,we,change,the,state,li,li,lock,the,entry,in,link,shared,buffer,as,it,is,needed,in,the,created,branch,li,ul,li,take,links,in,link,shared,buffer,will,point,to,the,current,event,li,ul,li,add,entry,to,the,shared,buffer,with,version,of,the,current,computation,state,li,li,add,stage,and,then,increase,with,number,of,takes,for,the,future,computation,states,li,li,peek,to,the,next,state,if,it,has,proceed,path,to,a,final,state,if,true,create,final,computation,state,to,emit,results,li,ul,ol,li,li,handle,the,start,state,as,it,always,have,to,remain,li,li,release,the,corresponding,entries,in,link,shared,buffer,li,ol,param,shared,buffer,accessor,the,accessor,to,shared,buffer,that,we,need,to,change,param,computation,state,current,computation,state,param,event,current,event,which,is,processed,param,timestamp,timestamp,of,the,current,event,return,collection,of,computation,states,which,result,from,the,current,one,throws,exception,thrown,if,the,system,cannot,access,the,state;private,collection,computation,state,compute,next,states,final,shared,buffer,accessor,t,shared,buffer,accessor,final,computation,state,computation,state,final,event,wrapper,event,final,long,timestamp,throws,exception,final,condition,context,t,context,new,condition,context,this,shared,buffer,accessor,computation,state,final,outgoing,edges,t,outgoing,edges,create,decision,graph,context,computation,state,event,get,event,final,list,state,transition,t,edges,outgoing,edges,get,edges,int,take,branches,to,visit,math,max,0,outgoing,edges,get,total,take,branches,1,int,ignore,branches,to,visit,outgoing,edges,get,total,ignore,branches,int,total,take,to,skip,math,max,0,outgoing,edges,get,total,take,branches,1,final,list,computation,state,resulting,computation,states,new,array,list,for,state,transition,t,edge,edges,switch,edge,get,action,case,ignore,if,is,start,state,computation,state,final,dewey,number,version,if,is,equivalent,state,edge,get,target,state,get,state,computation,state,final,int,to,increase,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,version,computation,state,get,version,increase,to,increase,else,version,computation,state,get,version,increase,total,take,to,skip,ignore,branches,to,visit,add,stage,ignore,branches,to,visit,add,computation,state,shared,buffer,accessor,resulting,computation,states,edge,get,target,state,computation,state,get,previous,buffer,entry,version,computation,state,get,start,timestamp,computation,state,get,start,event,id,break,case,take,final,state,t,next,state,edge,get,target,state,final,state,t,current,state,edge,get,source,state,final,node,id,previous,entry,computation,state,get,previous,buffer,entry,final,dewey,number,current,version,computation,state,get,version,increase,take,branches,to,visit,final,dewey,number,next,version,new,dewey,number,current,version,add,stage,take,branches,to,visit,final,node,id,new,entry,shared,buffer,accessor,put,current,state,get,name,event,get,event,id,previous,entry,current,version,final,long,start,timestamp,final,event,id,start,event,id,if,is,start,state,computation,state,start,timestamp,timestamp,start,event,id,event,get,event,id,else,start,timestamp,computation,state,get,start,timestamp,start,event,id,computation,state,get,start,event,id,add,computation,state,shared,buffer,accessor,resulting,computation,states,next,state,new,entry,next,version,start,timestamp,start,event,id,final,state,t,final,state,find,final,state,after,proceed,context,next,state,event,get,event,if,final,state,null,add,computation,state,shared,buffer,accessor,resulting,computation,states,final,state,new,entry,next,version,start,timestamp,start,event,id,break,if,is,start,state,computation,state,int,total,branches,calculate,increasing,self,state,outgoing,edges,get,total,ignore,branches,outgoing,edges,get,total,take,branches,dewey,number,start,version,computation,state,get,version,increase,total,branches,computation,state,start,state,computation,state,create,start,state,computation,state,get,current,state,name,start,version,resulting,computation,states,add,start,state,if,computation,state,get,previous,buffer,entry,null,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,return,resulting,computation,states
NFA -> static String generateStateName(final String name, final int index);1454421848;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1456417982;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1459346677;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1459358363;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1461083852;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1466088497;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1468833363;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1472663401;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1478783881;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1488547156;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1489660607;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1489764761;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1490186498;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1490262475;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1490262475;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1490638274;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1490692084;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1493985576;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> static String generateStateName(final String name, final int index);1494180263;Generates a state name from a given name template and an index._<p>_If the template ends with "[]" the index is inserted in between the square brackets._Otherwise, an underscore and the index is appended to the name.__@param name Name template_@param index Index of the state_@return Generated state name from the given state name template;static String generateStateName(final String name, final int index) {_		Matcher matcher = namePattern.matcher(name)___		if (matcher.matches()) {_			return matcher.group(1) + index + matcher.group(2)__		} else {_			return name + "_" + index__		}_	};generates,a,state,name,from,a,given,name,template,and,an,index,p,if,the,template,ends,with,the,index,is,inserted,in,between,the,square,brackets,otherwise,an,underscore,and,the,index,is,appended,to,the,name,param,name,name,template,param,index,index,of,the,state,return,generated,state,name,from,the,given,state,name,template;static,string,generate,state,name,final,string,name,final,int,index,matcher,matcher,name,pattern,matcher,name,if,matcher,matches,return,matcher,group,1,index,matcher,group,2,else,return,name,index
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1454421848;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		ArrayList<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,array,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1456417982;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		ArrayList<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,array,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1459346677;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		ArrayList<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,array,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1459358363;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		ArrayList<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,array,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1461083852;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		ArrayList<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,array,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1466088497;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		ArrayList<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,array,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1468833363;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		ArrayList<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,array,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1472663401;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		ArrayList<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,array,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1478783881;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		ArrayList<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,array,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1488547156;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		ArrayList<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,array,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1489660607;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		List<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1489764761;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		List<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1490186498;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<State<T>, T>> paths = sharedBuffer.extractPatterns(_			computationState.getState(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		List<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<State<T>, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (State<T> key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key.getName(), counter): key.getName(),_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,state,t,t,paths,shared,buffer,extract,patterns,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,state,t,t,path,paths,map,string,t,result,path,new,hash,map,for,state,t,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,get,name,counter,key,get,name,serializer,is,immutable,type,event,serializer,copy,event,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1490262475;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<String, T>> paths = sharedBuffer.extractPatterns(_			computationState.getPreviousState().getName(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		List<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<String, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (String key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key, counter): key,_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__					counter++__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,string,t,paths,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,string,t,path,paths,map,string,t,result,path,new,hash,map,for,string,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,counter,key,serializer,is,immutable,type,event,serializer,copy,event,counter,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1490262475;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<String, T>> paths = stringSharedBuffer.extractPatterns(_			computationState.getPreviousState().getName(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		List<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<String, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (String key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key, counter): key,_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__					counter++__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,string,t,paths,string,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,string,t,path,paths,map,string,t,result,path,new,hash,map,for,string,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,counter,key,serializer,is,immutable,type,event,serializer,copy,event,counter,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1490638274;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<String, T>> paths = stringSharedBuffer.extractPatterns(_			computationState.getPreviousState().getName(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		_		Preconditions.checkArgument(paths.size() <= 1)___		List<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<String, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (String key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key, counter): key,_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__					counter++__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,string,t,paths,string,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,preconditions,check,argument,paths,size,1,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,string,t,path,paths,map,string,t,result,path,new,hash,map,for,string,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,counter,key,serializer,is,immutable,type,event,serializer,copy,event,counter,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1490692084;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<String, T>> paths = stringSharedBuffer.extractPatterns(_			computationState.getPreviousState().getName(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		_		Preconditions.checkState(paths.size() <= 1)___		List<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<String, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (String key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key, counter): key,_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__					counter++__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,string,t,paths,string,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,preconditions,check,state,paths,size,1,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,string,t,path,paths,map,string,t,result,path,new,hash,map,for,string,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,counter,key,serializer,is,immutable,type,event,serializer,copy,event,counter,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1493985576;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<String, T>> paths = stringSharedBuffer.extractPatterns(_			computationState.getPreviousState().getName(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		_		Preconditions.checkState(paths.size() <= 1)___		List<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<String, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (String key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key, counter): key,_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__					counter++__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,string,t,paths,string,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,preconditions,check,state,paths,size,1,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,string,t,path,paths,map,string,t,result,path,new,hash,map,for,string,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,counter,key,serializer,is,immutable,type,event,serializer,copy,event,counter,result,add,result,path,return,result
NFA -> private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState);1494180263;Extracts all the sequences of events from the start to the given computation state. An event_sequence is returned as a map which contains the events and the names of the states to which_the events were mapped.__@param computationState The end computation state of the extracted event sequences_@return Collection of event sequences which end in the given computation state;private Collection<Map<String, T>> extractPatternMatches(final ComputationState<T> computationState) {_		Collection<LinkedHashMultimap<String, T>> paths = stringSharedBuffer.extractPatterns(_			computationState.getPreviousState().getName(),_			computationState.getEvent(),_			computationState.getTimestamp(),_			computationState.getVersion())___		_		Preconditions.checkState(paths.size() <= 1)___		List<Map<String, T>> result = new ArrayList<>()___		TypeSerializer<T> serializer = nonDuplicatingTypeSerializer.getTypeSerializer()___		_		for (LinkedHashMultimap<String, T> path: paths) {_			Map<String, T> resultPath = new HashMap<>()__			for (String key: path.keySet()) {_				int counter = 0__				Set<T> events = path.get(key)___				_				for (T event: events) {_					resultPath.put(_						events.size() > 1 ? generateStateName(key, counter): key,_						_						serializer.isImmutableType() ? event : serializer.copy(event)_					)__					counter++__				}_			}__			result.add(resultPath)__		}__		return result__	};extracts,all,the,sequences,of,events,from,the,start,to,the,given,computation,state,an,event,sequence,is,returned,as,a,map,which,contains,the,events,and,the,names,of,the,states,to,which,the,events,were,mapped,param,computation,state,the,end,computation,state,of,the,extracted,event,sequences,return,collection,of,event,sequences,which,end,in,the,given,computation,state;private,collection,map,string,t,extract,pattern,matches,final,computation,state,t,computation,state,collection,linked,hash,multimap,string,t,paths,string,shared,buffer,extract,patterns,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,version,preconditions,check,state,paths,size,1,list,map,string,t,result,new,array,list,type,serializer,t,serializer,non,duplicating,type,serializer,get,type,serializer,for,linked,hash,multimap,string,t,path,paths,map,string,t,result,path,new,hash,map,for,string,key,path,key,set,int,counter,0,set,t,events,path,get,key,for,t,event,events,result,path,put,events,size,1,generate,state,name,key,counter,key,serializer,is,immutable,type,event,serializer,copy,event,counter,result,add,result,path,return,result
NFA -> public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final long timestamp) throws Exception;1535555335;Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one._It cleares the sharedBuffer and also emits all timed out partial matches.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState     The NFAState object that we need to affect while processing_@param timestamp    timestamp that indicates that there will be no more events with lower timestamp_@return all timed outed partial matches_@throws Exception Thrown if the system cannot access the state.;public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final long timestamp) throws Exception {__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()__		final PriorityQueue<ComputationState> newPartialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR)___		for (ComputationState computationState : nfaState.getPartialMatches()) {_			if (isStateTimedOut(computationState, timestamp)) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = sharedBufferAccessor.materializeMatch(extractCurrentMatches(_						sharedBufferAccessor,_						computationState))__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())___				nfaState.setStateChanged()__			} else {_				newPartialMatches.add(computationState)__			}_		}__		nfaState.setNewPartialMatches(newPartialMatches)___		sharedBufferAccessor.advanceTime(timestamp)___		return timeoutResult___	};prunes,states,assuming,there,will,be,no,events,with,timestamp,b,lower,b,than,the,given,one,it,cleares,the,shared,buffer,and,also,emits,all,timed,out,partial,matches,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,timestamp,timestamp,that,indicates,that,there,will,be,no,more,events,with,lower,timestamp,return,all,timed,outed,partial,matches,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,tuple2,map,string,list,t,long,advance,time,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,long,timestamp,throws,exception,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,final,priority,queue,computation,state,new,partial,matches,new,priority,queue,nfastate,for,computation,state,computation,state,nfa,state,get,partial,matches,if,is,state,timed,out,computation,state,timestamp,if,handle,timeout,map,string,list,t,timed,out,pattern,shared,buffer,accessor,materialize,match,extract,current,matches,shared,buffer,accessor,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,nfa,state,set,state,changed,else,new,partial,matches,add,computation,state,nfa,state,set,new,partial,matches,new,partial,matches,shared,buffer,accessor,advance,time,timestamp,return,timeout,result
NFA -> public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final long timestamp) throws Exception;1539149027;Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one._It cleares the sharedBuffer and also emits all timed out partial matches.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState     The NFAState object that we need to affect while processing_@param timestamp    timestamp that indicates that there will be no more events with lower timestamp_@return all timed outed partial matches_@throws Exception Thrown if the system cannot access the state.;public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final long timestamp) throws Exception {__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()__		final PriorityQueue<ComputationState> newPartialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR)___		for (ComputationState computationState : nfaState.getPartialMatches()) {_			if (isStateTimedOut(computationState, timestamp)) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = sharedBufferAccessor.materializeMatch(extractCurrentMatches(_						sharedBufferAccessor,_						computationState))__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())___				nfaState.setStateChanged()__			} else {_				newPartialMatches.add(computationState)__			}_		}__		nfaState.setNewPartialMatches(newPartialMatches)___		sharedBufferAccessor.advanceTime(timestamp)___		return timeoutResult___	};prunes,states,assuming,there,will,be,no,events,with,timestamp,b,lower,b,than,the,given,one,it,cleares,the,shared,buffer,and,also,emits,all,timed,out,partial,matches,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,timestamp,timestamp,that,indicates,that,there,will,be,no,more,events,with,lower,timestamp,return,all,timed,outed,partial,matches,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,tuple2,map,string,list,t,long,advance,time,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,long,timestamp,throws,exception,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,final,priority,queue,computation,state,new,partial,matches,new,priority,queue,nfastate,for,computation,state,computation,state,nfa,state,get,partial,matches,if,is,state,timed,out,computation,state,timestamp,if,handle,timeout,map,string,list,t,timed,out,pattern,shared,buffer,accessor,materialize,match,extract,current,matches,shared,buffer,accessor,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,nfa,state,set,state,changed,else,new,partial,matches,add,computation,state,nfa,state,set,new,partial,matches,new,partial,matches,shared,buffer,accessor,advance,time,timestamp,return,timeout,result
NFA -> public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final long timestamp) throws Exception;1539149114;Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one._It cleares the sharedBuffer and also emits all timed out partial matches.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState     The NFAState object that we need to affect while processing_@param timestamp    timestamp that indicates that there will be no more events with lower timestamp_@return all timed outed partial matches_@throws Exception Thrown if the system cannot access the state.;public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final long timestamp) throws Exception {__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()__		final PriorityQueue<ComputationState> newPartialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR)___		for (ComputationState computationState : nfaState.getPartialMatches()) {_			if (isStateTimedOut(computationState, timestamp)) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = sharedBufferAccessor.materializeMatch(extractCurrentMatches(_						sharedBufferAccessor,_						computationState))__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())___				nfaState.setStateChanged()__			} else {_				newPartialMatches.add(computationState)__			}_		}__		nfaState.setNewPartialMatches(newPartialMatches)___		sharedBufferAccessor.advanceTime(timestamp)___		return timeoutResult___	};prunes,states,assuming,there,will,be,no,events,with,timestamp,b,lower,b,than,the,given,one,it,cleares,the,shared,buffer,and,also,emits,all,timed,out,partial,matches,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,timestamp,timestamp,that,indicates,that,there,will,be,no,more,events,with,lower,timestamp,return,all,timed,outed,partial,matches,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,tuple2,map,string,list,t,long,advance,time,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,long,timestamp,throws,exception,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,final,priority,queue,computation,state,new,partial,matches,new,priority,queue,nfastate,for,computation,state,computation,state,nfa,state,get,partial,matches,if,is,state,timed,out,computation,state,timestamp,if,handle,timeout,map,string,list,t,timed,out,pattern,shared,buffer,accessor,materialize,match,extract,current,matches,shared,buffer,accessor,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,nfa,state,set,state,changed,else,new,partial,matches,add,computation,state,nfa,state,set,new,partial,matches,new,partial,matches,shared,buffer,accessor,advance,time,timestamp,return,timeout,result
NFA -> public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final long timestamp) throws Exception;1540386566;Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one._It cleares the sharedBuffer and also emits all timed out partial matches.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState     The NFAState object that we need to affect while processing_@param timestamp    timestamp that indicates that there will be no more events with lower timestamp_@return all timed outed partial matches_@throws Exception Thrown if the system cannot access the state.;public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final long timestamp) throws Exception {__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()__		final PriorityQueue<ComputationState> newPartialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR)___		for (ComputationState computationState : nfaState.getPartialMatches()) {_			if (isStateTimedOut(computationState, timestamp)) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = sharedBufferAccessor.materializeMatch(extractCurrentMatches(_						sharedBufferAccessor,_						computationState))__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())___				nfaState.setStateChanged()__			} else {_				newPartialMatches.add(computationState)__			}_		}__		nfaState.setNewPartialMatches(newPartialMatches)___		sharedBufferAccessor.advanceTime(timestamp)___		return timeoutResult___	};prunes,states,assuming,there,will,be,no,events,with,timestamp,b,lower,b,than,the,given,one,it,cleares,the,shared,buffer,and,also,emits,all,timed,out,partial,matches,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,timestamp,timestamp,that,indicates,that,there,will,be,no,more,events,with,lower,timestamp,return,all,timed,outed,partial,matches,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,tuple2,map,string,list,t,long,advance,time,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,long,timestamp,throws,exception,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,final,priority,queue,computation,state,new,partial,matches,new,priority,queue,nfastate,for,computation,state,computation,state,nfa,state,get,partial,matches,if,is,state,timed,out,computation,state,timestamp,if,handle,timeout,map,string,list,t,timed,out,pattern,shared,buffer,accessor,materialize,match,extract,current,matches,shared,buffer,accessor,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,nfa,state,set,state,changed,else,new,partial,matches,add,computation,state,nfa,state,set,new,partial,matches,new,partial,matches,shared,buffer,accessor,advance,time,timestamp,return,timeout,result
NFA -> public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final long timestamp) throws Exception;1546179377;Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one._It cleares the sharedBuffer and also emits all timed out partial matches.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState     The NFAState object that we need to affect while processing_@param timestamp    timestamp that indicates that there will be no more events with lower timestamp_@return all timed outed partial matches_@throws Exception Thrown if the system cannot access the state.;public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final long timestamp) throws Exception {__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()__		final PriorityQueue<ComputationState> newPartialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR)___		for (ComputationState computationState : nfaState.getPartialMatches()) {_			if (isStateTimedOut(computationState, timestamp)) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = sharedBufferAccessor.materializeMatch(extractCurrentMatches(_						sharedBufferAccessor,_						computationState))__					timeoutResult.add(Tuple2.of(timedOutPattern, computationState.getStartTimestamp() + windowTime))__				}__				sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())___				nfaState.setStateChanged()__			} else {_				newPartialMatches.add(computationState)__			}_		}__		nfaState.setNewPartialMatches(newPartialMatches)___		sharedBufferAccessor.advanceTime(timestamp)___		return timeoutResult___	};prunes,states,assuming,there,will,be,no,events,with,timestamp,b,lower,b,than,the,given,one,it,cleares,the,shared,buffer,and,also,emits,all,timed,out,partial,matches,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,timestamp,timestamp,that,indicates,that,there,will,be,no,more,events,with,lower,timestamp,return,all,timed,outed,partial,matches,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,tuple2,map,string,list,t,long,advance,time,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,long,timestamp,throws,exception,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,final,priority,queue,computation,state,new,partial,matches,new,priority,queue,nfastate,for,computation,state,computation,state,nfa,state,get,partial,matches,if,is,state,timed,out,computation,state,timestamp,if,handle,timeout,map,string,list,t,timed,out,pattern,shared,buffer,accessor,materialize,match,extract,current,matches,shared,buffer,accessor,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,computation,state,get,start,timestamp,window,time,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,nfa,state,set,state,changed,else,new,partial,matches,add,computation,state,nfa,state,set,new,partial,matches,new,partial,matches,shared,buffer,accessor,advance,time,timestamp,return,timeout,result
NFA -> public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final long timestamp) throws Exception;1546179377;Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one._It cleares the sharedBuffer and also emits all timed out partial matches.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState     The NFAState object that we need to affect while processing_@param timestamp    timestamp that indicates that there will be no more events with lower timestamp_@return all timed outed partial matches_@throws Exception Thrown if the system cannot access the state.;public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final long timestamp) throws Exception {__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()__		final PriorityQueue<ComputationState> newPartialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR)___		for (ComputationState computationState : nfaState.getPartialMatches()) {_			if (isStateTimedOut(computationState, timestamp)) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = sharedBufferAccessor.materializeMatch(extractCurrentMatches(_						sharedBufferAccessor,_						computationState))__					timeoutResult.add(Tuple2.of(timedOutPattern, computationState.getStartTimestamp() + windowTime))__				}__				sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())___				nfaState.setStateChanged()__			} else {_				newPartialMatches.add(computationState)__			}_		}__		nfaState.setNewPartialMatches(newPartialMatches)___		sharedBufferAccessor.advanceTime(timestamp)___		return timeoutResult___	};prunes,states,assuming,there,will,be,no,events,with,timestamp,b,lower,b,than,the,given,one,it,cleares,the,shared,buffer,and,also,emits,all,timed,out,partial,matches,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,timestamp,timestamp,that,indicates,that,there,will,be,no,more,events,with,lower,timestamp,return,all,timed,outed,partial,matches,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,tuple2,map,string,list,t,long,advance,time,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,long,timestamp,throws,exception,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,final,priority,queue,computation,state,new,partial,matches,new,priority,queue,nfastate,for,computation,state,computation,state,nfa,state,get,partial,matches,if,is,state,timed,out,computation,state,timestamp,if,handle,timeout,map,string,list,t,timed,out,pattern,shared,buffer,accessor,materialize,match,extract,current,matches,shared,buffer,accessor,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,computation,state,get,start,timestamp,window,time,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,nfa,state,set,state,changed,else,new,partial,matches,add,computation,state,nfa,state,set,new,partial,matches,new,partial,matches,shared,buffer,accessor,advance,time,timestamp,return,timeout,result
NFA -> public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final long timestamp) throws Exception;1546179377;Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one._It clears the sharedBuffer and also emits all timed out partial matches.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState     The NFAState object that we need to affect while processing_@param timestamp    timestamp that indicates that there will be no more events with lower timestamp_@return all timed outed partial matches_@throws Exception Thrown if the system cannot access the state.;public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final long timestamp) throws Exception {__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()__		final PriorityQueue<ComputationState> newPartialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR)___		for (ComputationState computationState : nfaState.getPartialMatches()) {_			if (isStateTimedOut(computationState, timestamp)) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = sharedBufferAccessor.materializeMatch(extractCurrentMatches(_						sharedBufferAccessor,_						computationState))__					timeoutResult.add(Tuple2.of(timedOutPattern, computationState.getStartTimestamp() + windowTime))__				}__				sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())___				nfaState.setStateChanged()__			} else {_				newPartialMatches.add(computationState)__			}_		}__		nfaState.setNewPartialMatches(newPartialMatches)___		sharedBufferAccessor.advanceTime(timestamp)___		return timeoutResult__	};prunes,states,assuming,there,will,be,no,events,with,timestamp,b,lower,b,than,the,given,one,it,clears,the,shared,buffer,and,also,emits,all,timed,out,partial,matches,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,timestamp,timestamp,that,indicates,that,there,will,be,no,more,events,with,lower,timestamp,return,all,timed,outed,partial,matches,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,tuple2,map,string,list,t,long,advance,time,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,long,timestamp,throws,exception,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,final,priority,queue,computation,state,new,partial,matches,new,priority,queue,nfastate,for,computation,state,computation,state,nfa,state,get,partial,matches,if,is,state,timed,out,computation,state,timestamp,if,handle,timeout,map,string,list,t,timed,out,pattern,shared,buffer,accessor,materialize,match,extract,current,matches,shared,buffer,accessor,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,computation,state,get,start,timestamp,window,time,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,nfa,state,set,state,changed,else,new,partial,matches,add,computation,state,nfa,state,set,new,partial,matches,new,partial,matches,shared,buffer,accessor,advance,time,timestamp,return,timeout,result
NFA -> public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final long timestamp) throws Exception;1547021580;Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one._It clears the sharedBuffer and also emits all timed out partial matches.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState     The NFAState object that we need to affect while processing_@param timestamp    timestamp that indicates that there will be no more events with lower timestamp_@return all timed outed partial matches_@throws Exception Thrown if the system cannot access the state.;public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final long timestamp) throws Exception {__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()__		final PriorityQueue<ComputationState> newPartialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR)___		for (ComputationState computationState : nfaState.getPartialMatches()) {_			if (isStateTimedOut(computationState, timestamp)) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = sharedBufferAccessor.materializeMatch(extractCurrentMatches(_						sharedBufferAccessor,_						computationState))__					timeoutResult.add(Tuple2.of(timedOutPattern, computationState.getStartTimestamp() + windowTime))__				}__				sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())___				nfaState.setStateChanged()__			} else {_				newPartialMatches.add(computationState)__			}_		}__		nfaState.setNewPartialMatches(newPartialMatches)___		sharedBufferAccessor.advanceTime(timestamp)___		return timeoutResult__	};prunes,states,assuming,there,will,be,no,events,with,timestamp,b,lower,b,than,the,given,one,it,clears,the,shared,buffer,and,also,emits,all,timed,out,partial,matches,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,timestamp,timestamp,that,indicates,that,there,will,be,no,more,events,with,lower,timestamp,return,all,timed,outed,partial,matches,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,tuple2,map,string,list,t,long,advance,time,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,long,timestamp,throws,exception,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,final,priority,queue,computation,state,new,partial,matches,new,priority,queue,nfastate,for,computation,state,computation,state,nfa,state,get,partial,matches,if,is,state,timed,out,computation,state,timestamp,if,handle,timeout,map,string,list,t,timed,out,pattern,shared,buffer,accessor,materialize,match,extract,current,matches,shared,buffer,accessor,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,computation,state,get,start,timestamp,window,time,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,nfa,state,set,state,changed,else,new,partial,matches,add,computation,state,nfa,state,set,new,partial,matches,new,partial,matches,shared,buffer,accessor,advance,time,timestamp,return,timeout,result
NFA -> public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime( 			final SharedBufferAccessor<T> sharedBufferAccessor, 			final NFAState nfaState, 			final long timestamp) throws Exception;1550652777;Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one._It clears the sharedBuffer and also emits all timed out partial matches.__@param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing_@param nfaState     The NFAState object that we need to affect while processing_@param timestamp    timestamp that indicates that there will be no more events with lower timestamp_@return all timed outed partial matches_@throws Exception Thrown if the system cannot access the state.;public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(_			final SharedBufferAccessor<T> sharedBufferAccessor,_			final NFAState nfaState,_			final long timestamp) throws Exception {__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()__		final PriorityQueue<ComputationState> newPartialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR)___		for (ComputationState computationState : nfaState.getPartialMatches()) {_			if (isStateTimedOut(computationState, timestamp)) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = sharedBufferAccessor.materializeMatch(extractCurrentMatches(_						sharedBufferAccessor,_						computationState))__					timeoutResult.add(Tuple2.of(timedOutPattern, computationState.getStartTimestamp() + windowTime))__				}__				sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry())___				nfaState.setStateChanged()__			} else {_				newPartialMatches.add(computationState)__			}_		}__		nfaState.setNewPartialMatches(newPartialMatches)___		sharedBufferAccessor.advanceTime(timestamp)___		return timeoutResult__	};prunes,states,assuming,there,will,be,no,events,with,timestamp,b,lower,b,than,the,given,one,it,clears,the,shared,buffer,and,also,emits,all,timed,out,partial,matches,param,shared,buffer,accessor,the,accessor,to,shared,buffer,object,that,we,need,to,work,upon,while,processing,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,timestamp,timestamp,that,indicates,that,there,will,be,no,more,events,with,lower,timestamp,return,all,timed,outed,partial,matches,throws,exception,thrown,if,the,system,cannot,access,the,state;public,collection,tuple2,map,string,list,t,long,advance,time,final,shared,buffer,accessor,t,shared,buffer,accessor,final,nfastate,nfa,state,final,long,timestamp,throws,exception,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,final,priority,queue,computation,state,new,partial,matches,new,priority,queue,nfastate,for,computation,state,computation,state,nfa,state,get,partial,matches,if,is,state,timed,out,computation,state,timestamp,if,handle,timeout,map,string,list,t,timed,out,pattern,shared,buffer,accessor,materialize,match,extract,current,matches,shared,buffer,accessor,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,computation,state,get,start,timestamp,window,time,shared,buffer,accessor,release,node,computation,state,get,previous,buffer,entry,nfa,state,set,state,changed,else,new,partial,matches,add,computation,state,nfa,state,set,new,partial,matches,new,partial,matches,shared,buffer,accessor,advance,time,timestamp,return,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, 		final long timestamp, AfterMatchSkipStrategy afterMatchSkipStrategy);1504268438;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event,_		final long timestamp, AfterMatchSkipStrategy afterMatchSkipStrategy) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__				nfaChanged = true__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)___				if (newComputationStates.size() != 1) {_					nfaChanged = true__				} else if (!newComputationStates.iterator().next().equals(computationState)) {_					nfaChanged = true__				}_			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState().getName()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		discardComputationStatesAccordingToStrategy(computationStates, result, afterMatchSkipStrategy)___		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				if (eventSharedBuffer.prune(pruningTimestamp)) {_					nfaChanged = true__				}_			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,after,match,skip,strategy,after,match,skip,strategy,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timed,out,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,nfa,changed,true,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,if,new,computation,states,size,1,nfa,changed,true,else,if,new,computation,states,iterator,next,equals,computation,state,nfa,changed,true,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,discard,computation,states,according,to,strategy,computation,states,result,after,match,skip,strategy,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,if,event,shared,buffer,prune,pruning,timestamp,nfa,changed,true,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, 		final long timestamp, AfterMatchSkipStrategy afterMatchSkipStrategy);1507895398;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event,_		final long timestamp, AfterMatchSkipStrategy afterMatchSkipStrategy) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__				nfaChanged = true__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)___				if (newComputationStates.size() != 1) {_					nfaChanged = true__				} else if (!newComputationStates.iterator().next().equals(computationState)) {_					nfaChanged = true__				}_			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState().getName()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		discardComputationStatesAccordingToStrategy(computationStates, result, afterMatchSkipStrategy)___		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				if (eventSharedBuffer.prune(pruningTimestamp)) {_					nfaChanged = true__				}_			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,after,match,skip,strategy,after,match,skip,strategy,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timed,out,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,nfa,changed,true,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,if,new,computation,states,size,1,nfa,changed,true,else,if,new,computation,states,iterator,next,equals,computation,state,nfa,changed,true,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,discard,computation,states,according,to,strategy,computation,states,result,after,match,skip,strategy,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,if,event,shared,buffer,prune,pruning,timestamp,nfa,changed,true,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, 		final long timestamp, AfterMatchSkipStrategy afterMatchSkipStrategy);1516692416;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event,_		final long timestamp, AfterMatchSkipStrategy afterMatchSkipStrategy) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__				nfaChanged = true__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)___				if (newComputationStates.size() != 1) {_					nfaChanged = true__				} else if (!newComputationStates.iterator().next().equals(computationState)) {_					nfaChanged = true__				}_			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState().getName()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		discardComputationStatesAccordingToStrategy(computationStates, result, afterMatchSkipStrategy)___		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				if (eventSharedBuffer.prune(pruningTimestamp)) {_					nfaChanged = true__				}_			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,after,match,skip,strategy,after,match,skip,strategy,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timed,out,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,nfa,changed,true,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,if,new,computation,states,size,1,nfa,changed,true,else,if,new,computation,states,iterator,next,equals,computation,state,nfa,changed,true,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,discard,computation,states,according,to,strategy,computation,states,result,after,match,skip,strategy,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,if,event,shared,buffer,prune,pruning,timestamp,nfa,changed,true,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, 		final long timestamp, AfterMatchSkipStrategy afterMatchSkipStrategy);1518030004;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@param afterMatchSkipStrategy The skip strategy to use after per match_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event,_		final long timestamp, AfterMatchSkipStrategy afterMatchSkipStrategy) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, List<T>>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Map<String, List<T>> timedOutPattern = extractCurrentMatches(computationState)__					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp))__				}__				eventSharedBuffer.release(_						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),_						computationState.getEvent(),_						computationState.getTimestamp(),_						computationState.getCounter())___				newComputationStates = Collections.emptyList()__				nfaChanged = true__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)___				if (newComputationStates.size() != 1) {_					nfaChanged = true__				} else if (!newComputationStates.iterator().next().equals(computationState)) {_					nfaChanged = true__				}_			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {__				if (newComputationState.isFinalState()) {_					_					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState)__					result.add(matchedPattern)___					_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									newComputationState.getPreviousState().getName()),_							newComputationState.getEvent(),_							newComputationState.getTimestamp(),_							newComputationState.getCounter())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					eventSharedBuffer.release(_							NFAStateNameHandler.getOriginalNameFromInternal(_									state.getPreviousState().getName()),_							state.getEvent(),_							state.getTimestamp(),_							state.getCounter())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		discardComputationStatesAccordingToStrategy(computationStates, result, afterMatchSkipStrategy)___		_		if (windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				if (eventSharedBuffer.prune(pruningTimestamp)) {_					nfaChanged = true__				}_			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,param,after,match,skip,strategy,the,skip,strategy,to,use,after,per,match,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,final,t,event,final,long,timestamp,after,match,skip,strategy,after,match,skip,strategy,final,int,number,computation,states,computation,states,size,final,collection,map,string,list,t,result,new,array,list,final,collection,tuple2,map,string,list,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,map,string,list,t,timed,out,pattern,extract,current,matches,computation,state,timeout,result,add,tuple2,of,timed,out,pattern,timestamp,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,computation,state,get,counter,new,computation,states,collections,empty,list,nfa,changed,true,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,if,new,computation,states,size,1,nfa,changed,true,else,if,new,computation,states,iterator,next,equals,computation,state,nfa,changed,true,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,map,string,list,t,matched,pattern,extract,current,matches,new,computation,state,result,add,matched,pattern,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,if,new,computation,state,is,stop,state,should,discard,path,true,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,new,computation,state,get,counter,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,event,shared,buffer,release,nfastate,name,handler,get,original,name,from,internal,state,get,previous,state,get,name,state,get,event,state,get,timestamp,state,get,counter,else,computation,states,add,all,states,to,retain,discard,computation,states,according,to,strategy,computation,states,result,after,match,skip,strategy,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,if,event,shared,buffer,prune,pruning,timestamp,nfa,changed,true,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process( 		NFAState<T> nfaState, final T event, final long timestamp);1528894798;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(_		NFAState<T> nfaState, final T event, final long timestamp) {_		return process(nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,nfastate,t,nfa,state,final,t,event,final,long,timestamp,return,process,nfa,state,event,timestamp,after,match,skip,strategy,no,skip
NFA -> public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process( 		NFAState<T> nfaState, final T event, final long timestamp);1528894798;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param nfaState The NFAState object that we need to affect while processing_@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(_		NFAState<T> nfaState, final T event, final long timestamp) {_		return process(nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip())__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,nfa,state,the,nfastate,object,that,we,need,to,affect,while,processing,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,list,t,collection,tuple2,map,string,list,t,long,process,nfastate,t,nfa,state,final,t,event,final,long,timestamp,return,process,nfa,state,event,timestamp,after,match,skip,strategy,no,skip
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1495024654;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1495024655;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1495203813;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1495466666;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1495961498;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1496929298;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1497328665;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1498764573;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1501661862;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1502726910;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1503470129;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1503555538;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1503598628;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1504268438;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1507895398;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1516692416;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1518030004;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1528894798;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1528894799;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1528894799;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1530798894;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1530798894;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1535555335;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1539149027;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1539149114;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1540386566;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1546179377;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1546179377;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1546179377;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1547021580;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> NFASerializerConfigSnapshot -> public NFASerializerConfigSnapshot();1550652777;This empty constructor is required for deserializing the configuration.;public NFASerializerConfigSnapshot() {};this,empty,constructor,is,required,for,deserializing,the,configuration;public,nfaserializer,config,snapshot
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1466088497;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__@param event The current event to be processed_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0 &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}_		}__		_		if(windowTime > 0) {_			long pruningTimestamp = timestamp - windowTime___			_			if (pruningTimestamp >= timestamp) {_				throw new IllegalStateException("Detected an underflow in the pruning timestamp. This indicates that" +_					" either the window length is too long (" + windowTime + ") or that the timestamp has not been" +_					" set correctly (e.g. Long.MIN_VALUE).")__			}__			_			sharedBuffer.prune(pruningTimestamp)__		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,param,event,the,current,event,to,be,processed,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,new,computation,states,compute,next,states,computation,state,event,timestamp,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,throw,new,illegal,state,exception,detected,an,underflow,in,the,pruning,timestamp,this,indicates,that,either,the,window,length,is,too,long,window,time,or,that,the,timestamp,has,not,been,set,correctly,e,g,long,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1468833363;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__@param event The current event to be processed_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0 &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}_		}__		_		if(windowTime > 0) {_			long pruningTimestamp = timestamp - windowTime___			_			if (pruningTimestamp >= timestamp) {_				throw new IllegalStateException("Detected an underflow in the pruning timestamp. This indicates that" +_					" either the window length is too long (" + windowTime + ") or that the timestamp has not been" +_					" set correctly (e.g. Long.MIN_VALUE).")__			}__			_			sharedBuffer.prune(pruningTimestamp)__		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,param,event,the,current,event,to,be,processed,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,new,computation,states,compute,next,states,computation,state,event,timestamp,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,throw,new,illegal,state,exception,detected,an,underflow,in,the,pruning,timestamp,this,indicates,that,either,the,window,length,is,too,long,window,time,or,that,the,timestamp,has,not,been,set,correctly,e,g,long,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1472663401;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__@param event The current event to be processed_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0 &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}_		}__		_		if(windowTime > 0) {_			long pruningTimestamp = timestamp - windowTime___			_			if (pruningTimestamp >= timestamp) {_				throw new IllegalStateException("Detected an underflow in the pruning timestamp. This indicates that" +_					" either the window length is too long (" + windowTime + ") or that the timestamp has not been" +_					" set correctly (e.g. Long.MIN_VALUE).")__			}__			_			sharedBuffer.prune(pruningTimestamp)__		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,param,event,the,current,event,to,be,processed,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,new,computation,states,compute,next,states,computation,state,event,timestamp,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,throw,new,illegal,state,exception,detected,an,underflow,in,the,pruning,timestamp,this,indicates,that,either,the,window,length,is,too,long,window,time,or,that,the,timestamp,has,not,been,set,correctly,e,g,long,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1478783881;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}_		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			_			if (pruningTimestamp >= timestamp) {_				throw new IllegalStateException("Detected an underflow in the pruning timestamp. This indicates that" +_					" either the window length is too long (" + windowTime + ") or that the timestamp has not been" +_					" set correctly (e.g. Long.MIN_VALUE).")__			}__			_			sharedBuffer.prune(pruningTimestamp)__		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,throw,new,illegal,state,exception,detected,an,underflow,in,the,pruning,timestamp,this,indicates,that,either,the,window,length,is,too,long,window,time,or,that,the,timestamp,has,not,been,set,correctly,e,g,long,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1488547156;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}_		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			_			if (pruningTimestamp >= timestamp) {_				throw new IllegalStateException("Detected an underflow in the pruning timestamp. This indicates that" +_					" either the window length is too long (" + windowTime + ") or that the timestamp has not been" +_					" set correctly (e.g. Long.MIN_VALUE).")__			}__			_			sharedBuffer.prune(pruningTimestamp)__		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,throw,new,illegal,state,exception,detected,an,underflow,in,the,pruning,timestamp,this,indicates,that,either,the,window,length,is,too,long,window,time,or,that,the,timestamp,has,not,been,set,correctly,e,g,long,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1489660607;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}_		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				sharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1489764761;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}_		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				sharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1490186498;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				_				sharedBuffer.release(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getState(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}_		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				sharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,shared,buffer,release,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,state,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1490262475;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				_				sharedBuffer.release(computationState.getState().getName(), computationState.getEvent(), computationState.getTimestamp())__				sharedBuffer.remove(computationState.getState().getName(), computationState.getEvent(), computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					sharedBuffer.release(newComputationState.getPreviousState().getName(), newComputationState.getEvent(), newComputationState.getTimestamp())__					sharedBuffer.remove(newComputationState.getPreviousState().getName(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}_		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				sharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,shared,buffer,release,computation,state,get,state,get,name,computation,state,get,event,computation,state,get,timestamp,shared,buffer,remove,computation,state,get,state,get,name,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,shared,buffer,remove,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1490262475;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				stringSharedBuffer.release(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp())__				stringSharedBuffer.remove(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					stringSharedBuffer.release(newComputationState.getPreviousState().getName(), newComputationState.getEvent(), newComputationState.getTimestamp())__					stringSharedBuffer.remove(newComputationState.getPreviousState().getName(), newComputationState.getEvent(), newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}_		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				stringSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,string,shared,buffer,remove,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,string,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,string,shared,buffer,remove,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,string,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1490638274;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				stringSharedBuffer.release(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					stringSharedBuffer.release(_							newComputationState.getPreviousState().getName(),_							newComputationState.getEvent(),_							newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}_		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				stringSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,string,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,string,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1490692084;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				stringSharedBuffer.release(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}__			for (ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					stringSharedBuffer.release(_							newComputationState.getPreviousState().getName(),_							newComputationState.getEvent(),_							newComputationState.getTimestamp())__				} else {_					_					computationStates.add(newComputationState)__				}_			}_		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				stringSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,for,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,string,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,else,computation,states,add,new,computation,state,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,string,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1493985576;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				stringSharedBuffer.release(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}___			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					stringSharedBuffer.release(_							newComputationState.getPreviousState().getName(),_							newComputationState.getEvent(),_							newComputationState.getTimestamp())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					stringSharedBuffer.release(_						newComputationState.getPreviousState().getName(),_						newComputationState.getEvent(),_						newComputationState.getTimestamp())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					stringSharedBuffer.release(_						state.getPreviousState().getName(),_						state.getEvent(),_						state.getTimestamp())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				stringSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,string,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,else,if,new,computation,state,is,stop,state,should,discard,path,true,string,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,string,shared,buffer,release,state,get,previous,state,get,name,state,get,event,state,get,timestamp,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,string,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
NFA -> public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp);1494180263;Processes the next input event. If some of the computations reach a final state then the_resulting event sequences are returned. If computations time out and timeout handling is_activated, then the timed out event patterns are returned.__<p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned_with the element that resulted in the stop state.__@param event The current event to be processed or null if only pruning shall be done_@param timestamp The timestamp of the current event_@return Tuple of the collection of matched patterns (e.g. the result of computations which have_reached a final state) and the collection of timed out patterns (if timeout handling is_activated);public Tuple2<Collection<Map<String, T>>, Collection<Tuple2<Map<String, T>, Long>>> process(final T event, final long timestamp) {_		final int numberComputationStates = computationStates.size()__		final Collection<Map<String, T>> result = new ArrayList<>()__		final Collection<Tuple2<Map<String, T>, Long>> timeoutResult = new ArrayList<>()___		_		for (int i = 0_ i < numberComputationStates_ i++) {_			ComputationState<T> computationState = computationStates.poll()___			final Collection<ComputationState<T>> newComputationStates___			if (!computationState.isStartState() &&_				windowTime > 0L &&_				timestamp - computationState.getStartTimestamp() >= windowTime) {__				if (handleTimeout) {_					_					Collection<Map<String, T>> timeoutPatterns = extractPatternMatches(computationState)___					for (Map<String, T> timeoutPattern : timeoutPatterns) {_						timeoutResult.add(Tuple2.of(timeoutPattern, timestamp))__					}_				}__				stringSharedBuffer.release(_						computationState.getPreviousState().getName(),_						computationState.getEvent(),_						computationState.getTimestamp())___				newComputationStates = Collections.emptyList()__			} else if (event != null) {_				newComputationStates = computeNextStates(computationState, event, timestamp)__			} else {_				newComputationStates = Collections.singleton(computationState)__			}___			_			final Collection<ComputationState<T>> statesToRetain = new ArrayList<>()__			_			boolean shouldDiscardPath = false__			for (final ComputationState<T> newComputationState: newComputationStates) {_				if (newComputationState.isFinalState()) {_					_					Collection<Map<String, T>> matches = extractPatternMatches(newComputationState)__					result.addAll(matches)___					_					stringSharedBuffer.release(_							newComputationState.getPreviousState().getName(),_							newComputationState.getEvent(),_							newComputationState.getTimestamp())__				} else if (newComputationState.isStopState()) {_					_					shouldDiscardPath = true__					stringSharedBuffer.release(_						newComputationState.getPreviousState().getName(),_						newComputationState.getEvent(),_						newComputationState.getTimestamp())__				} else {_					_					statesToRetain.add(newComputationState)__				}_			}__			if (shouldDiscardPath) {_				_				_				for (final ComputationState<T> state : statesToRetain) {_					stringSharedBuffer.release(_						state.getPreviousState().getName(),_						state.getEvent(),_						state.getTimestamp())__				}_			} else {_				computationStates.addAll(statesToRetain)__			}__		}__		_		if(windowTime > 0L) {_			long pruningTimestamp = timestamp - windowTime___			if (pruningTimestamp < timestamp) {_				__				_				_				stringSharedBuffer.prune(pruningTimestamp)__			}_		}__		return Tuple2.of(result, timeoutResult)__	};processes,the,next,input,event,if,some,of,the,computations,reach,a,final,state,then,the,resulting,event,sequences,are,returned,if,computations,time,out,and,timeout,handling,is,activated,then,the,timed,out,event,patterns,are,returned,p,if,computations,reach,a,stop,state,the,path,forward,is,discarded,and,currently,constructed,path,is,returned,with,the,element,that,resulted,in,the,stop,state,param,event,the,current,event,to,be,processed,or,null,if,only,pruning,shall,be,done,param,timestamp,the,timestamp,of,the,current,event,return,tuple,of,the,collection,of,matched,patterns,e,g,the,result,of,computations,which,have,reached,a,final,state,and,the,collection,of,timed,out,patterns,if,timeout,handling,is,activated;public,tuple2,collection,map,string,t,collection,tuple2,map,string,t,long,process,final,t,event,final,long,timestamp,final,int,number,computation,states,computation,states,size,final,collection,map,string,t,result,new,array,list,final,collection,tuple2,map,string,t,long,timeout,result,new,array,list,for,int,i,0,i,number,computation,states,i,computation,state,t,computation,state,computation,states,poll,final,collection,computation,state,t,new,computation,states,if,computation,state,is,start,state,window,time,0l,timestamp,computation,state,get,start,timestamp,window,time,if,handle,timeout,collection,map,string,t,timeout,patterns,extract,pattern,matches,computation,state,for,map,string,t,timeout,pattern,timeout,patterns,timeout,result,add,tuple2,of,timeout,pattern,timestamp,string,shared,buffer,release,computation,state,get,previous,state,get,name,computation,state,get,event,computation,state,get,timestamp,new,computation,states,collections,empty,list,else,if,event,null,new,computation,states,compute,next,states,computation,state,event,timestamp,else,new,computation,states,collections,singleton,computation,state,final,collection,computation,state,t,states,to,retain,new,array,list,boolean,should,discard,path,false,for,final,computation,state,t,new,computation,state,new,computation,states,if,new,computation,state,is,final,state,collection,map,string,t,matches,extract,pattern,matches,new,computation,state,result,add,all,matches,string,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,else,if,new,computation,state,is,stop,state,should,discard,path,true,string,shared,buffer,release,new,computation,state,get,previous,state,get,name,new,computation,state,get,event,new,computation,state,get,timestamp,else,states,to,retain,add,new,computation,state,if,should,discard,path,for,final,computation,state,t,state,states,to,retain,string,shared,buffer,release,state,get,previous,state,get,name,state,get,event,state,get,timestamp,else,computation,states,add,all,states,to,retain,if,window,time,0l,long,pruning,timestamp,timestamp,window,time,if,pruning,timestamp,timestamp,string,shared,buffer,prune,pruning,timestamp,return,tuple2,of,result,timeout,result
