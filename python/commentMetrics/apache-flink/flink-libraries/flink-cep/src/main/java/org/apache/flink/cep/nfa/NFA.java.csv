commented;modifiers;parameterAmount;loc;comment;code
false;private;1;7;;private Map<String, State<T>> loadStates(final Collection<State<T>> validStates) {     Map<String, State<T>> tmp = new HashMap<>(4).     for (State<T> state : validStates) {         tmp.put(state.getName(), state).     }     return Collections.unmodifiableMap(tmp). }
false;public;0;4;;@VisibleForTesting public Collection<State<T>> getStates() {     return states.values(). }
false;public;0;9;;public NFAState createInitialNFAState() {     Queue<ComputationState> startingStates = new LinkedList<>().     for (State<T> state : states.values()) {         if (state.isStart()) {             startingStates.add(ComputationState.createStartState(state.getName())).         }     }     return new NFAState(startingStates). }
false;private;1;3;;private State<T> getState(ComputationState state) {     return states.get(state.getCurrentStateName()). }
false;private;1;9;;private boolean isStartState(ComputationState state) {     State<T> stateObject = getState(state).     if (stateObject == null) {         throw new FlinkRuntimeException("State " + state.getCurrentStateName() + " does not exist in the NFA. NFA has states " + states.values()).     }     return stateObject.isStart(). }
false;private;1;9;;private boolean isStopState(ComputationState state) {     State<T> stateObject = getState(state).     if (stateObject == null) {         throw new FlinkRuntimeException("State " + state.getCurrentStateName() + " does not exist in the NFA. NFA has states " + states.values()).     }     return stateObject.isStop(). }
false;private;1;9;;private boolean isFinalState(ComputationState state) {     State<T> stateObject = getState(state).     if (stateObject == null) {         throw new FlinkRuntimeException("State " + state.getCurrentStateName() + " does not exist in the NFA. NFA has states " + states.values()).     }     return stateObject.isFinal(). }
true;public;2;9;/**  * Initialization method for the NFA. It is called before any element is passed and thus suitable for one time setup  * work.  * @param cepRuntimeContext runtime context of the enclosing operator  * @param conf The configuration containing the parameters attached to the contract.  */ ;/**  * Initialization method for the NFA. It is called before any element is passed and thus suitable for one time setup  * work.  * @param cepRuntimeContext runtime context of the enclosing operator  * @param conf The configuration containing the parameters attached to the contract.  */ public void open(RuntimeContext cepRuntimeContext, Configuration conf) throws Exception {     for (State<T> state : getStates()) {         for (StateTransition<T> transition : state.getStateTransitions()) {             IterativeCondition condition = transition.getCondition().             FunctionUtils.setFunctionRuntimeContext(condition, cepRuntimeContext).             FunctionUtils.openFunction(condition, conf).         }     } }
true;public;0;8;/**  * Tear-down method for the NFA.  */ ;/**  * Tear-down method for the NFA.  */ public void close() throws Exception {     for (State<T> state : getStates()) {         for (StateTransition<T> transition : state.getStateTransitions()) {             IterativeCondition condition = transition.getCondition().             FunctionUtils.closeFunction(condition).         }     } }
true;public;6;11;/**  * Processes the next input event. If some of the computations reach a final state then the  * resulting event sequences are returned. If computations time out and timeout handling is  * activated, then the timed out event patterns are returned.  *  * <p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned  * with the element that resulted in the stop state.  *  * @param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing  * @param nfaState The NFAState object that we need to affect while processing  * @param event The current event to be processed or null if only pruning shall be done  * @param timestamp The timestamp of the current event  * @param afterMatchSkipStrategy The skip strategy to use after per match  * @param timerService gives access to processing time and time characteristic, needed for condition evaluation  * @return Tuple of the collection of matched patterns (e.g. the result of computations which have  * reached a final state) and the collection of timed out patterns (if timeout handling is  * activated)  * @throws Exception Thrown if the system cannot access the state.  */ ;/**  * Processes the next input event. If some of the computations reach a final state then the  * resulting event sequences are returned. If computations time out and timeout handling is  * activated, then the timed out event patterns are returned.  *  * <p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned  * with the element that resulted in the stop state.  *  * @param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing  * @param nfaState The NFAState object that we need to affect while processing  * @param event The current event to be processed or null if only pruning shall be done  * @param timestamp The timestamp of the current event  * @param afterMatchSkipStrategy The skip strategy to use after per match  * @param timerService gives access to processing time and time characteristic, needed for condition evaluation  * @return Tuple of the collection of matched patterns (e.g. the result of computations which have  * reached a final state) and the collection of timed out patterns (if timeout handling is  * activated)  * @throws Exception Thrown if the system cannot access the state.  */ public Collection<Map<String, List<T>>> process(final SharedBufferAccessor<T> sharedBufferAccessor, final NFAState nfaState, final T event, final long timestamp, final AfterMatchSkipStrategy afterMatchSkipStrategy, final TimerService timerService) throws Exception {     try (EventWrapper eventWrapper = new EventWrapper(event, timestamp, sharedBufferAccessor)) {         return doProcess(sharedBufferAccessor, nfaState, eventWrapper, afterMatchSkipStrategy, timerService).     } }
true;public;3;33;/**  * Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one.  * It clears the sharedBuffer and also emits all timed out partial matches.  *  * @param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing  * @param nfaState     The NFAState object that we need to affect while processing  * @param timestamp    timestamp that indicates that there will be no more events with lower timestamp  * @return all timed outed partial matches  * @throws Exception Thrown if the system cannot access the state.  */ ;/**  * Prunes states assuming there will be no events with timestamp <b>lower</b> than the given one.  * It clears the sharedBuffer and also emits all timed out partial matches.  *  * @param sharedBufferAccessor the accessor to SharedBuffer object that we need to work upon while processing  * @param nfaState     The NFAState object that we need to affect while processing  * @param timestamp    timestamp that indicates that there will be no more events with lower timestamp  * @return all timed outed partial matches  * @throws Exception Thrown if the system cannot access the state.  */ public Collection<Tuple2<Map<String, List<T>>, Long>> advanceTime(final SharedBufferAccessor<T> sharedBufferAccessor, final NFAState nfaState, final long timestamp) throws Exception {     final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>().     final PriorityQueue<ComputationState> newPartialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR).     for (ComputationState computationState : nfaState.getPartialMatches()) {         if (isStateTimedOut(computationState, timestamp)) {             if (handleTimeout) {                 // extract the timed out event pattern                 Map<String, List<T>> timedOutPattern = sharedBufferAccessor.materializeMatch(extractCurrentMatches(sharedBufferAccessor, computationState)).                 timeoutResult.add(Tuple2.of(timedOutPattern, computationState.getStartTimestamp() + windowTime)).             }             sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry()).             nfaState.setStateChanged().         } else {             newPartialMatches.add(computationState).         }     }     nfaState.setNewPartialMatches(newPartialMatches).     sharedBufferAccessor.advanceTime(timestamp).     return timeoutResult. }
false;private;2;3;;private boolean isStateTimedOut(final ComputationState state, final long timestamp) {     return !isStartState(state) && windowTime > 0L && timestamp - state.getStartTimestamp() >= windowTime. }
false;private;5;83;;private Collection<Map<String, List<T>>> doProcess(final SharedBufferAccessor<T> sharedBufferAccessor, final NFAState nfaState, final EventWrapper event, final AfterMatchSkipStrategy afterMatchSkipStrategy, final TimerService timerService) throws Exception {     final PriorityQueue<ComputationState> newPartialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR).     final PriorityQueue<ComputationState> potentialMatches = new PriorityQueue<>(NFAState.COMPUTATION_STATE_COMPARATOR).     // iterate over all current computations     for (ComputationState computationState : nfaState.getPartialMatches()) {         final Collection<ComputationState> newComputationStates = computeNextStates(sharedBufferAccessor, computationState, event, timerService).         if (newComputationStates.size() != 1) {             nfaState.setStateChanged().         } else if (!newComputationStates.iterator().next().equals(computationState)) {             nfaState.setStateChanged().         }         // delay adding new computation states in case a stop state is reached and we discard the path.         final Collection<ComputationState> statesToRetain = new ArrayList<>().         // if stop state reached in this path         boolean shouldDiscardPath = false.         for (final ComputationState newComputationState : newComputationStates) {             if (isFinalState(newComputationState)) {                 potentialMatches.add(newComputationState).             } else if (isStopState(newComputationState)) {                 // reached stop state. release entry for the stop state                 shouldDiscardPath = true.                 sharedBufferAccessor.releaseNode(newComputationState.getPreviousBufferEntry()).             } else {                 // add new computation state. it will be processed once the next event arrives                 statesToRetain.add(newComputationState).             }         }         if (shouldDiscardPath) {             // the buffer             for (final ComputationState state : statesToRetain) {                 sharedBufferAccessor.releaseNode(state.getPreviousBufferEntry()).             }         } else {             newPartialMatches.addAll(statesToRetain).         }     }     if (!potentialMatches.isEmpty()) {         nfaState.setStateChanged().     }     List<Map<String, List<T>>> result = new ArrayList<>().     if (afterMatchSkipStrategy.isSkipStrategy()) {         processMatchesAccordingToSkipStrategy(sharedBufferAccessor, nfaState, afterMatchSkipStrategy, potentialMatches, newPartialMatches, result).     } else {         for (ComputationState match : potentialMatches) {             Map<String, List<T>> materializedMatch = sharedBufferAccessor.materializeMatch(sharedBufferAccessor.extractPatterns(match.getPreviousBufferEntry(), match.getVersion()).get(0)).             result.add(materializedMatch).             sharedBufferAccessor.releaseNode(match.getPreviousBufferEntry()).         }     }     nfaState.setNewPartialMatches(newPartialMatches).     return result. }
false;private;6;41;;private void processMatchesAccordingToSkipStrategy(SharedBufferAccessor<T> sharedBufferAccessor, NFAState nfaState, AfterMatchSkipStrategy afterMatchSkipStrategy, PriorityQueue<ComputationState> potentialMatches, PriorityQueue<ComputationState> partialMatches, List<Map<String, List<T>>> result) throws Exception {     nfaState.getCompletedMatches().addAll(potentialMatches).     ComputationState earliestMatch = nfaState.getCompletedMatches().peek().     if (earliestMatch != null) {         ComputationState earliestPartialMatch.         while (earliestMatch != null && ((earliestPartialMatch = partialMatches.peek()) == null || isEarlier(earliestMatch, earliestPartialMatch))) {             nfaState.setStateChanged().             nfaState.getCompletedMatches().poll().             List<Map<String, List<EventId>>> matchedResult = sharedBufferAccessor.extractPatterns(earliestMatch.getPreviousBufferEntry(), earliestMatch.getVersion()).             afterMatchSkipStrategy.prune(partialMatches, matchedResult, sharedBufferAccessor).             afterMatchSkipStrategy.prune(nfaState.getCompletedMatches(), matchedResult, sharedBufferAccessor).             result.add(sharedBufferAccessor.materializeMatch(matchedResult.get(0))).             sharedBufferAccessor.releaseNode(earliestMatch.getPreviousBufferEntry()).             earliestMatch = nfaState.getCompletedMatches().peek().         }         nfaState.getPartialMatches().removeIf(pm -> pm.getStartEventID() != null && !partialMatches.contains(pm)).     } }
false;private;2;3;;private boolean isEarlier(ComputationState earliestMatch, ComputationState earliestPartialMatch) {     return NFAState.COMPUTATION_STATE_COMPARATOR.compare(earliestMatch, earliestPartialMatch) <= 0. }
false;private,static;2;3;;private static <T> boolean isEquivalentState(final State<T> s1, final State<T> s2) {     return s1.getName().equals(s2.getName()). }
false;;1;12;;void add(StateTransition<T> edge) {     if (!isSelfIgnore(edge)) {         if (edge.getAction() == StateTransitionAction.IGNORE) {             totalIgnoreBranches++.         } else if (edge.getAction() == StateTransitionAction.TAKE) {             totalTakeBranches++.         }     }     edges.add(edge). }
false;;0;3;;int getTotalIgnoreBranches() {     return totalIgnoreBranches. }
false;;0;3;;int getTotalTakeBranches() {     return totalTakeBranches. }
false;;0;3;;List<StateTransition<T>> getEdges() {     return edges. }
false;private;1;4;;private boolean isSelfIgnore(final StateTransition<T> edge) {     return isEquivalentState(edge.getTargetState(), currentState) && edge.getAction() == StateTransitionAction.IGNORE. }
false;;0;7;;EventId getEventId() throws Exception {     if (eventId == null) {         this.eventId = sharedBufferAccessor.registerEvent(event, timestamp).     }     return eventId. }
false;;0;3;;T getEvent() {     return event. }
false;public;0;3;;public long getTimestamp() {     return timestamp. }
false;public;0;6;;@Override public void close() throws Exception {     if (eventId != null) {         sharedBufferAccessor.releaseEvent(eventId).     } }
true;private;4;122;/**  *  Computes the next computation states based on the given computation state, the current event,  *  its timestamp and the internal state machine. The algorithm is:  * <ol>  *      <li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>  *  	   <li>Perform transitions:  *  	   	<ol>  *           <li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>  *           <ul>  *               <li>do not perform for Start State - special case</li>  *           	<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>  *           	<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>  *           	<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>  *       	</ul>  *       	<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>  *           <ul>  *               <li>add entry to the shared buffer with version of the current computation state</li>  *               <li>add stage and then increase with number of takes for the future computation states</li>  *               <li>peek to the next state if it has PROCEED path to a Final State, if true create Final  *               ComputationState to emit results</li>  *           </ul>  *       </ol>  *      </li>  *  	   <li>Handle the Start State, as it always have to remain </li>  *      <li>Release the corresponding entries in {@link SharedBuffer}.</li>  * </ol>  *  *  @param sharedBufferAccessor The accessor to shared buffer that we need to change  *  @param computationState Current computation state  *  @param event Current event which is processed  *  @param timerService timer service which provides access to time related features  *  @return Collection of computation states which result from the current one  *  @throws Exception Thrown if the system cannot access the state.  */ ;/**  *  Computes the next computation states based on the given computation state, the current event,  *  its timestamp and the internal state machine. The algorithm is:  * <ol>  *      <li>Decide on valid transitions and number of branching paths. See {@link OutgoingEdges}</li>  *  	   <li>Perform transitions:  *  	   	<ol>  *           <li>IGNORE (links in {@link SharedBuffer} will still point to the previous event)</li>  *           <ul>  *               <li>do not perform for Start State - special case</li>  *           	<li>if stays in the same state increase the current stage for future use with number of outgoing edges</li>  *           	<li>if after PROCEED increase current stage and add new stage (as we change the state)</li>  *           	<li>lock the entry in {@link SharedBuffer} as it is needed in the created branch</li>  *       	</ul>  *       	<li>TAKE (links in {@link SharedBuffer} will point to the current event)</li>  *           <ul>  *               <li>add entry to the shared buffer with version of the current computation state</li>  *               <li>add stage and then increase with number of takes for the future computation states</li>  *               <li>peek to the next state if it has PROCEED path to a Final State, if true create Final  *               ComputationState to emit results</li>  *           </ul>  *       </ol>  *      </li>  *  	   <li>Handle the Start State, as it always have to remain </li>  *      <li>Release the corresponding entries in {@link SharedBuffer}.</li>  * </ol>  *  *  @param sharedBufferAccessor The accessor to shared buffer that we need to change  *  @param computationState Current computation state  *  @param event Current event which is processed  *  @param timerService timer service which provides access to time related features  *  @return Collection of computation states which result from the current one  *  @throws Exception Thrown if the system cannot access the state.  */ private Collection<ComputationState> computeNextStates(final SharedBufferAccessor<T> sharedBufferAccessor, final ComputationState computationState, final EventWrapper event, final TimerService timerService) throws Exception {     final ConditionContext context = new ConditionContext(sharedBufferAccessor, computationState, timerService, event.getTimestamp()).     final OutgoingEdges<T> outgoingEdges = createDecisionGraph(context, computationState, event.getEvent()).     // Create the computing version based on the previously computed edges     // We need to defer the creation of computation states until we know how many edges start     // at this computation state so that we can assign proper version     final List<StateTransition<T>> edges = outgoingEdges.getEdges().     int takeBranchesToVisit = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1).     int ignoreBranchesToVisit = outgoingEdges.getTotalIgnoreBranches().     int totalTakeToSkip = Math.max(0, outgoingEdges.getTotalTakeBranches() - 1).     final List<ComputationState> resultingComputationStates = new ArrayList<>().     for (StateTransition<T> edge : edges) {         switch(edge.getAction()) {             case IGNORE:                 {                     if (!isStartState(computationState)) {                         final DeweyNumber version.                         if (isEquivalentState(edge.getTargetState(), getState(computationState))) {                             // Stay in the same state (it can be either looping one or singleton)                             final int toIncrease = calculateIncreasingSelfState(outgoingEdges.getTotalIgnoreBranches(), outgoingEdges.getTotalTakeBranches()).                             version = computationState.getVersion().increase(toIncrease).                         } else {                             // IGNORE after PROCEED                             version = computationState.getVersion().increase(totalTakeToSkip + ignoreBranchesToVisit).addStage().                             ignoreBranchesToVisit--.                         }                         addComputationState(sharedBufferAccessor, resultingComputationStates, edge.getTargetState(), computationState.getPreviousBufferEntry(), version, computationState.getStartTimestamp(), computationState.getStartEventID()).                     }                 }                 break.             case TAKE:                 final State<T> nextState = edge.getTargetState().                 final State<T> currentState = edge.getSourceState().                 final NodeId previousEntry = computationState.getPreviousBufferEntry().                 final DeweyNumber currentVersion = computationState.getVersion().increase(takeBranchesToVisit).                 final DeweyNumber nextVersion = new DeweyNumber(currentVersion).addStage().                 takeBranchesToVisit--.                 final NodeId newEntry = sharedBufferAccessor.put(currentState.getName(), event.getEventId(), previousEntry, currentVersion).                 final long startTimestamp.                 final EventId startEventId.                 if (isStartState(computationState)) {                     startTimestamp = event.getTimestamp().                     startEventId = event.getEventId().                 } else {                     startTimestamp = computationState.getStartTimestamp().                     startEventId = computationState.getStartEventID().                 }                 addComputationState(sharedBufferAccessor, resultingComputationStates, nextState, newEntry, nextVersion, startTimestamp, startEventId).                 // check if newly created state is optional (have a PROCEED path to Final state)                 final State<T> finalState = findFinalStateAfterProceed(context, nextState, event.getEvent()).                 if (finalState != null) {                     addComputationState(sharedBufferAccessor, resultingComputationStates, finalState, newEntry, nextVersion, startTimestamp, startEventId).                 }                 break.         }     }     if (isStartState(computationState)) {         int totalBranches = calculateIncreasingSelfState(outgoingEdges.getTotalIgnoreBranches(), outgoingEdges.getTotalTakeBranches()).         DeweyNumber startVersion = computationState.getVersion().increase(totalBranches).         ComputationState startState = ComputationState.createStartState(computationState.getCurrentStateName(), startVersion).         resultingComputationStates.add(startState).     }     if (computationState.getPreviousBufferEntry() != null) {         // release the shared entry referenced by the current computation state.         sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry()).     }     return resultingComputationStates. }
false;private;7;14;;private void addComputationState(SharedBufferAccessor<T> sharedBufferAccessor, List<ComputationState> computationStates, State<T> currentState, NodeId previousEntry, DeweyNumber version, long startTimestamp, EventId startEventId) throws Exception {     ComputationState computationState = ComputationState.createState(currentState.getName(), previousEntry, version, startTimestamp, startEventId).     computationStates.add(computationState).     sharedBufferAccessor.lockNode(previousEntry). }
false;private;3;26;;private State<T> findFinalStateAfterProceed(ConditionContext context, State<T> state, T event) {     final Stack<State<T>> statesToCheck = new Stack<>().     statesToCheck.push(state).     try {         while (!statesToCheck.isEmpty()) {             final State<T> currentState = statesToCheck.pop().             for (StateTransition<T> transition : currentState.getStateTransitions()) {                 if (transition.getAction() == StateTransitionAction.PROCEED && checkFilterCondition(context, transition.getCondition(), event)) {                     if (transition.getTargetState().isFinal()) {                         return transition.getTargetState().                     } else {                         statesToCheck.push(transition.getTargetState()).                     }                 }             }         }     } catch (Exception e) {         throw new FlinkRuntimeException("Failure happened in filter function.", e).     }     return null. }
false;private;2;3;;private int calculateIncreasingSelfState(int ignoreBranches, int takeBranches) {     return takeBranches == 0 && ignoreBranches == 0 ? 0 : ignoreBranches + Math.max(1, takeBranches). }
false;private;3;39;;private OutgoingEdges<T> createDecisionGraph(ConditionContext context, ComputationState computationState, T event) {     State<T> state = getState(computationState).     final OutgoingEdges<T> outgoingEdges = new OutgoingEdges<>(state).     final Stack<State<T>> states = new Stack<>().     states.push(state).     // First create all outgoing edges, so to be able to reason about the Dewey version     while (!states.isEmpty()) {         State<T> currentState = states.pop().         Collection<StateTransition<T>> stateTransitions = currentState.getStateTransitions().         // check all state transitions for each state         for (StateTransition<T> stateTransition : stateTransitions) {             try {                 if (checkFilterCondition(context, stateTransition.getCondition(), event)) {                     // filter condition is true                     switch(stateTransition.getAction()) {                         case PROCEED:                             // simply advance the computation state, but apply the current event to it                             // PROCEED is equivalent to an epsilon transition                             states.push(stateTransition.getTargetState()).                             break.                         case IGNORE:                         case TAKE:                             outgoingEdges.add(stateTransition).                             break.                     }                 }             } catch (Exception e) {                 throw new FlinkRuntimeException("Failure happened in filter function.", e).             }         }     }     return outgoingEdges. }
false;private;3;6;;private boolean checkFilterCondition(ConditionContext context, IterativeCondition<T> condition, T event) throws Exception {     return condition == null || condition.filter(event, context). }
true;private;2;19;/**  * Extracts all the sequences of events from the start to the given computation state. An event  * sequence is returned as a map which contains the events and the names of the states to which  * the events were mapped.  *  * @param sharedBufferAccessor The accessor to {@link SharedBuffer} from which to extract the matches  * @param computationState The end computation state of the extracted event sequences  * @return Collection of event sequences which end in the given computation state  * @throws Exception Thrown if the system cannot access the state.  */ ;/**  * Extracts all the sequences of events from the start to the given computation state. An event  * sequence is returned as a map which contains the events and the names of the states to which  * the events were mapped.  *  * @param sharedBufferAccessor The accessor to {@link SharedBuffer} from which to extract the matches  * @param computationState The end computation state of the extracted event sequences  * @return Collection of event sequences which end in the given computation state  * @throws Exception Thrown if the system cannot access the state.  */ private Map<String, List<EventId>> extractCurrentMatches(final SharedBufferAccessor<T> sharedBufferAccessor, final ComputationState computationState) throws Exception {     if (computationState.getPreviousBufferEntry() == null) {         return new HashMap<>().     }     List<Map<String, List<EventId>>> paths = sharedBufferAccessor.extractPatterns(computationState.getPreviousBufferEntry(), computationState.getVersion()).     if (paths.isEmpty()) {         return new HashMap<>().     }     // for a given computation state, we cannot have more than one matching patterns.     Preconditions.checkState(paths.size() == 1).     return paths.get(0). }
false;public;0;7;;@Override public Iterator<T> iterator() {     List<T> elements = matchedEvents.get(key).     return elements == null ? Collections.EMPTY_LIST.<T>iterator() : elements.iterator(). }
false;public;1;23;;@Override public Iterable<T> getEventsForPattern(final String key) throws Exception {     Preconditions.checkNotNull(key).     if (matchedEvents == null) {         this.matchedEvents = sharedBufferAccessor.materializeMatch(extractCurrentMatches(sharedBufferAccessor, computationState)).     }     return new Iterable<T>() {          @Override         public Iterator<T> iterator() {             List<T> elements = matchedEvents.get(key).             return elements == null ? Collections.EMPTY_LIST.<T>iterator() : elements.iterator().         }     }. }
false;public;0;4;;@Override public long timestamp() {     return eventTimestamp. }
false;public;0;4;;@Override public long currentProcessingTime() {     return timerService.currentProcessingTime(). }
false;public;0;3;;public org.apache.flink.cep.nfa.SharedBuffer<T> getSharedBuffer() {     return sharedBuffer. }
false;public;0;3;;public Queue<ComputationState> getComputationStates() {     return computationStates. }
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
false;public;1;7;;@Override public TypeSerializerSchemaCompatibility<MigratedNFA<T>> resolveSchemaCompatibility(TypeSerializer<MigratedNFA<T>> newSerializer) {     return CompositeTypeSerializerUtil.delegateCompatibilityCheckToNewSnapshot(newSerializer, new MigratedNFASerializerSnapshot<>(), getNestedSerializerSnapshots()). }
false;protected;0;4;;@Override protected int getCurrentOuterSnapshotVersion() {     return VERSION. }
false;protected;1;4;;@Override protected TypeSerializer<?>[] getNestedSerializers(NFASerializer<T> outerSerializer) {     return new TypeSerializer<?>[] { outerSerializer.eventSerializer, outerSerializer.sharedBufferSerializer }. }
false;protected;1;11;;@Override protected NFASerializer<T> createOuterSerializerWithNestedSerializers(TypeSerializer<?>[] nestedSerializers) {     @SuppressWarnings("unchecked")     TypeSerializer<T> eventSerializer = (TypeSerializer<T>) nestedSerializers[0].     @SuppressWarnings("unchecked")     TypeSerializer<org.apache.flink.cep.nfa.SharedBuffer<T>> sharedBufferSerializer = (TypeSerializer<org.apache.flink.cep.nfa.SharedBuffer<T>>) nestedSerializers[1].     return new NFASerializer<>(eventSerializer, sharedBufferSerializer). }
false;public;0;4;;@Override public boolean isImmutableType() {     return false. }
false;public;0;4;;@Override public NFASerializer<T> duplicate() {     return new NFASerializer<>(eventSerializer.duplicate()). }
false;public;0;4;;@Override public MigratedNFA<T> createInstance() {     return null. }
false;public;1;4;;@Override public MigratedNFA<T> copy(MigratedNFA<T> from) {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public MigratedNFA<T> copy(MigratedNFA<T> from, MigratedNFA<T> reuse) {     return copy(from). }
false;public;0;4;;@Override public int getLength() {     return -1. }
false;public;2;4;;@Override public void serialize(MigratedNFA<T> record, DataOutputView target) {     throw new UnsupportedOperationException(). }
false;public;1;11;;@Override public MigratedNFA<T> deserialize(DataInputView source) throws IOException {     MigrationUtils.skipSerializedStates(source).     source.readLong().     source.readBoolean().     org.apache.flink.cep.nfa.SharedBuffer<T> sharedBuffer = sharedBufferSerializer.deserialize(source).     Queue<ComputationState> computationStates = deserializeComputationStates(sharedBuffer, eventSerializer, source).     return new MigratedNFA<>(computationStates, sharedBuffer). }
false;public;2;6;;@Override public MigratedNFA<T> deserialize(MigratedNFA<T> reuse, DataInputView source) throws IOException {     return deserialize(source). }
false;public;2;4;;@Override public void copy(DataInputView source, DataOutputView target) {     throw new UnsupportedOperationException(). }
false;public;1;7;;@Override public boolean equals(Object obj) {     return obj == this || (obj != null && obj.getClass().equals(getClass()) && sharedBufferSerializer.equals(((NFASerializer) obj).sharedBufferSerializer) && eventSerializer.equals(((NFASerializer) obj).eventSerializer)). }
false;public;0;4;;@Override public int hashCode() {     return 37 * sharedBufferSerializer.hashCode() + eventSerializer.hashCode(). }
false;public;0;4;;@Override public MigratedNFASerializerSnapshot<T> snapshotConfiguration() {     return new MigratedNFASerializerSnapshot<>(this). }
