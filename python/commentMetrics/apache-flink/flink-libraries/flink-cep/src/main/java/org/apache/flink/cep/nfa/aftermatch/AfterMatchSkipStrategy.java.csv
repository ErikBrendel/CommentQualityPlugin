commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Discards every partial match that started before the first event of emitted match mapped to *PatternName*.  *  * @param patternName the pattern name to skip to  * @return the created AfterMatchSkipStrategy  */ ;/**  * Discards every partial match that started before the first event of emitted match mapped to *PatternName*.  *  * @param patternName the pattern name to skip to  * @return the created AfterMatchSkipStrategy  */ public static SkipToFirstStrategy skipToFirst(String patternName) {     return new SkipToFirstStrategy(patternName, false). }
true;public,static;1;3;/**  * Discards every partial match that started before the last event of emitted match mapped to *PatternName*.  *  * @param patternName the pattern name to skip to  * @return the created AfterMatchSkipStrategy  */ ;/**  * Discards every partial match that started before the last event of emitted match mapped to *PatternName*.  *  * @param patternName the pattern name to skip to  * @return the created AfterMatchSkipStrategy  */ public static SkipToLastStrategy skipToLast(String patternName) {     return new SkipToLastStrategy(patternName, false). }
true;public,static;0;3;/**  * Discards every partial match that started before emitted match ended.  *  * @return the created AfterMatchSkipStrategy  */ ;/**  * Discards every partial match that started before emitted match ended.  *  * @return the created AfterMatchSkipStrategy  */ public static SkipPastLastStrategy skipPastLastEvent() {     return SkipPastLastStrategy.INSTANCE. }
true;public,static;0;3;/**  * Discards every partial match that started with the same event, emitted match was started.  *  * @return the created AfterMatchSkipStrategy  */ ;/**  * Discards every partial match that started with the same event, emitted match was started.  *  * @return the created AfterMatchSkipStrategy  */ public static AfterMatchSkipStrategy skipToNext() {     return SkipToNextStrategy.INSTANCE. }
true;public,static;0;3;/**  * Every possible match will be emitted.  *  * @return the created AfterMatchSkipStrategy  */ ;/**  * Every possible match will be emitted.  *  * @return the created AfterMatchSkipStrategy  */ public static NoSkipStrategy noSkip() {     return NoSkipStrategy.INSTANCE. }
true;public,abstract;0;1;/**  * Tells if the strategy may skip some matches.  *  * @return false if the strategy is NO_SKIP strategy  */ ;/**  * Tells if the strategy may skip some matches.  *  * @return false if the strategy is NO_SKIP strategy  */ public abstract boolean isSkipStrategy().
true;public;3;18;/**  * Prunes matches/partial matches based on the chosen strategy.  *  * @param matchesToPrune current partial matches  * @param matchedResult  already completed matches  * @param sharedBufferAccessor   accessor to corresponding shared buffer  * @throws Exception thrown if could not access the state  */ ;/**  * Prunes matches/partial matches based on the chosen strategy.  *  * @param matchesToPrune current partial matches  * @param matchedResult  already completed matches  * @param sharedBufferAccessor   accessor to corresponding shared buffer  * @throws Exception thrown if could not access the state  */ public void prune(Collection<ComputationState> matchesToPrune, Collection<Map<String, List<EventId>>> matchedResult, SharedBufferAccessor<?> sharedBufferAccessor) throws Exception {     EventId pruningId = getPruningId(matchedResult).     if (pruningId != null) {         List<ComputationState> discardStates = new ArrayList<>().         for (ComputationState computationState : matchesToPrune) {             if (computationState.getStartEventID() != null && shouldPrune(computationState.getStartEventID(), pruningId)) {                 sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry()).                 discardStates.add(computationState).             }         }         matchesToPrune.removeAll(discardStates).     } }
true;protected,abstract;2;1;/**  * Tells if the partial/completed match starting at given id should be prunned by given pruningId.  *  * @param startEventID starting event id of a partial/completed match  * @param pruningId   pruningId calculated by this strategy  * @return true if the match should be pruned  */ ;/**  * Tells if the partial/completed match starting at given id should be prunned by given pruningId.  *  * @param startEventID starting event id of a partial/completed match  * @param pruningId   pruningId calculated by this strategy  * @return true if the match should be pruned  */ protected abstract boolean shouldPrune(EventId startEventID, EventId pruningId).
true;protected,abstract;1;1;/**  * Retrieves event id of the pruning element from the given match based on the strategy.  *  * @param match match corresponding to which should the pruning happen  * @return pruning event id  */ ;/**  * Retrieves event id of the pruning element from the given match based on the strategy.  *  * @param match match corresponding to which should the pruning happen  * @return pruning event id  */ protected abstract EventId getPruningId(Collection<Map<String, List<EventId>>> match).
true;public;0;3;/**  * Name of pattern that processing will be skipped to.  */ ;/**  * Name of pattern that processing will be skipped to.  */ public Optional<String> getPatternName() {     return Optional.empty(). }
false;static;2;15;;static EventId max(EventId o1, EventId o2) {     if (o2 == null) {         return o1.     }     if (o1 == null) {         return o2.     }     if (o1.compareTo(o2) >= 0) {         return o1.     } else {         return o2.     } }
false;static;2;15;;static EventId min(EventId o1, EventId o2) {     if (o2 == null) {         return o1.     }     if (o1 == null) {         return o2.     }     if (o1.compareTo(o2) <= 0) {         return o1.     } else {         return o2.     } }
