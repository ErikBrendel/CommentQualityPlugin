commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public long getStateWrites() {     return keyedStateStore.stateWrites. }
false;public;0;3;;public long getStateReads() {     return keyedStateStore.stateReads. }
false;public;0;3;;public long getStateAccesses() {     return getStateWrites() + getStateReads(). }
true;public,static;1;3;/**  * Creates instance of {@link TestSharedBuffer}.  *  * @param typeSerializer serializer used to serialize incoming events  * @param <T>            type of incoming events  * @return TestSharedBuffer instance  */ ;/**  * Creates instance of {@link TestSharedBuffer}.  *  * @param typeSerializer serializer used to serialize incoming events  * @param <T>            type of incoming events  * @return TestSharedBuffer instance  */ public static <T> TestSharedBuffer<T> createTestBuffer(TypeSerializer<T> typeSerializer) {     return new TestSharedBuffer<>(new MockKeyedStateStore(), typeSerializer). }
false;public;0;5;;@Override public T value() throws IOException {     stateReads++.     return value. }
false;public;1;5;;@Override public void update(T value) throws IOException {     stateWrites++.     this.value = value. }
false;public;0;4;;@Override public void clear() {     this.value = null. }
false;public;1;24;;@Override public <T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties) {     return new ValueState<T>() {          private T value.          @Override         public T value() throws IOException {             stateReads++.             return value.         }          @Override         public void update(T value) throws IOException {             stateWrites++.             this.value = value.         }          @Override         public void clear() {             this.value = null.         }     }. }
false;public;1;4;;@Override public <T> ListState<T> getListState(ListStateDescriptor<T> stateProperties) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public <T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public <IN, ACC, OUT> AggregatingState<IN, OUT> getAggregatingState(AggregatingStateDescriptor<IN, ACC, OUT> stateProperties) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public <T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties) {     throw new UnsupportedOperationException(). }
false;private;0;6;;private Map<UK, UV> getOrSetMap() {     if (values == null) {         this.values = new HashMap<>().     }     return values. }
false;public;1;9;;@Override public UV get(UK key) throws Exception {     stateReads++.     if (values == null) {         return null.     }     return values.get(key). }
false;public;2;5;;@Override public void put(UK key, UV value) throws Exception {     stateWrites++.     getOrSetMap().put(key, value). }
false;public;1;5;;@Override public void putAll(Map<UK, UV> map) throws Exception {     stateWrites++.     getOrSetMap().putAll(map). }
false;public;1;9;;@Override public void remove(UK key) throws Exception {     if (values == null) {         return.     }     stateWrites++.     values.remove(key). }
false;public;1;9;;@Override public boolean contains(UK key) throws Exception {     if (values == null) {         return false.     }     stateReads++.     return values.containsKey(key). }
false;public;0;8;;@Override public Iterable<Map.Entry<UK, UV>> entries() throws Exception {     if (values == null) {         return Collections.emptyList().     }     return () -> new CountingIterator<>(values.entrySet().iterator()). }
false;public;0;8;;@Override public Iterable<UK> keys() throws Exception {     if (values == null) {         return Collections.emptyList().     }     return () -> new CountingIterator<>(values.keySet().iterator()). }
false;public;0;8;;@Override public Iterable<UV> values() throws Exception {     if (values == null) {         return Collections.emptyList().     }     return () -> new CountingIterator<>(values.values().iterator()). }
false;public;0;8;;@Override public Iterator<Map.Entry<UK, UV>> iterator() throws Exception {     if (values == null) {         return Iterators.emptyIterator().     }     return new CountingIterator<>(values.entrySet().iterator()). }
false;public;0;5;;@Override public void clear() {     stateWrites++.     this.values = null. }
false;public;1;98;;@Override public <UK, UV> MapState<UK, UV> getMapState(MapStateDescriptor<UK, UV> stateProperties) {     return new MapState<UK, UV>() {          private Map<UK, UV> values.          private Map<UK, UV> getOrSetMap() {             if (values == null) {                 this.values = new HashMap<>().             }             return values.         }          @Override         public UV get(UK key) throws Exception {             stateReads++.             if (values == null) {                 return null.             }             return values.get(key).         }          @Override         public void put(UK key, UV value) throws Exception {             stateWrites++.             getOrSetMap().put(key, value).         }          @Override         public void putAll(Map<UK, UV> map) throws Exception {             stateWrites++.             getOrSetMap().putAll(map).         }          @Override         public void remove(UK key) throws Exception {             if (values == null) {                 return.             }             stateWrites++.             values.remove(key).         }          @Override         public boolean contains(UK key) throws Exception {             if (values == null) {                 return false.             }             stateReads++.             return values.containsKey(key).         }          @Override         public Iterable<Map.Entry<UK, UV>> entries() throws Exception {             if (values == null) {                 return Collections.emptyList().             }             return () -> new CountingIterator<>(values.entrySet().iterator()).         }          @Override         public Iterable<UK> keys() throws Exception {             if (values == null) {                 return Collections.emptyList().             }             return () -> new CountingIterator<>(values.keySet().iterator()).         }          @Override         public Iterable<UV> values() throws Exception {             if (values == null) {                 return Collections.emptyList().             }             return () -> new CountingIterator<>(values.values().iterator()).         }          @Override         public Iterator<Map.Entry<UK, UV>> iterator() throws Exception {             if (values == null) {                 return Iterators.emptyIterator().             }             return new CountingIterator<>(values.entrySet().iterator()).         }          @Override         public void clear() {             stateWrites++.             this.values = null.         }     }. }
false;public;0;4;;@Override public boolean hasNext() {     return iterator.hasNext(). }
false;public;0;5;;@Override public T next() {     stateReads++.     return iterator.next(). }
false;public;0;5;;@Override public void remove() {     stateWrites++.     iterator.remove(). }
