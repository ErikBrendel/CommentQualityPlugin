commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("start"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("end"). }
false;public;0;60;;@Test public void testSimpleNFA() throws Exception {     List<StreamRecord<Event>> streamEvents = new ArrayList<>().     streamEvents.add(new StreamRecord<>(new Event(1, "start", 1.0), 1L)).     streamEvents.add(new StreamRecord<>(new Event(2, "bar", 2.0), 2L)).     streamEvents.add(new StreamRecord<>(new Event(3, "start", 3.0), 3L)).     streamEvents.add(new StreamRecord<>(new Event(4, "end", 4.0), 4L)).     State<Event> startState = new State<>("start", State.StateType.Start).     State<Event> endState = new State<>("end", State.StateType.Normal).     State<Event> endingState = new State<>("", State.StateType.Final).     startState.addTake(endState, new SimpleCondition<Event>() {          private static final long serialVersionUID = -4869589195918650396L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("start").         }     }).     endState.addTake(endingState, new SimpleCondition<Event>() {          private static final long serialVersionUID = 2979804163709590673L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("end").         }     }).     endState.addIgnore(BooleanConditions.<Event>trueFunction()).     List<State<Event>> states = new ArrayList<>().     states.add(startState).     states.add(endState).     states.add(endingState).     List<Map<String, List<Event>>> expectedPatterns = new ArrayList<>().     Map<String, List<Event>> firstPattern = new HashMap<>().     firstPattern.put("start", Collections.singletonList(new Event(1, "start", 1.0))).     firstPattern.put("end", Collections.singletonList(new Event(4, "end", 4.0))).     Map<String, List<Event>> secondPattern = new HashMap<>().     secondPattern.put("start", Collections.singletonList(new Event(3, "start", 3.0))).     secondPattern.put("end", Collections.singletonList(new Event(4, "end", 4.0))).     expectedPatterns.add(firstPattern).     expectedPatterns.add(secondPattern).     NFA<Event> nfa = new NFA<>(states, 0, false).     NFATestHarness nfaTestHarness = NFATestHarness.forNFA(nfa).build().     Collection<Map<String, List<Event>>> actualPatterns = nfaTestHarness.consumeRecords(streamEvents).     assertEquals(expectedPatterns, actualPatterns). }
false;public;0;24;;@Test public void testTimeoutWindowPruning() throws Exception {     List<StreamRecord<Event>> streamEvents = new ArrayList<>().     streamEvents.add(new StreamRecord<>(new Event(1, "start", 1.0), 1L)).     streamEvents.add(new StreamRecord<>(new Event(2, "bar", 2.0), 2L)).     streamEvents.add(new StreamRecord<>(new Event(3, "start", 3.0), 3L)).     streamEvents.add(new StreamRecord<>(new Event(4, "end", 4.0), 4L)).     List<Map<String, List<Event>>> expectedPatterns = new ArrayList<>().     Map<String, List<Event>> secondPattern = new HashMap<>().     secondPattern.put("start", Collections.singletonList(new Event(3, "start", 3.0))).     secondPattern.put("end", Collections.singletonList(new Event(4, "end", 4.0))).     expectedPatterns.add(secondPattern).     NFA<Event> nfa = createStartEndNFA().     NFATestHarness nfaTestHarness = NFATestHarness.forNFA(nfa).build().     Collection<Map<String, List<Event>>> actualPatterns = nfaTestHarness.consumeRecords(streamEvents).     assertEquals(expectedPatterns, actualPatterns). }
true;public;0;16;/**  * Tests that elements whose timestamp difference is exactly the window length are not matched.  * The reason is that the right window side (later elements) is exclusive.  */ ;/**  * Tests that elements whose timestamp difference is exactly the window length are not matched.  * The reason is that the right window side (later elements) is exclusive.  */ @Test public void testWindowBorders() throws Exception {     List<StreamRecord<Event>> streamEvents = new ArrayList<>().     streamEvents.add(new StreamRecord<>(new Event(1, "start", 1.0), 1L)).     streamEvents.add(new StreamRecord<>(new Event(2, "end", 2.0), 3L)).     List<Map<String, List<Event>>> expectedPatterns = Collections.emptyList().     NFA<Event> nfa = createStartEndNFA().     NFATestHarness nfaTestHarness = NFATestHarness.forNFA(nfa).build().     Collection<Map<String, List<Event>>> actualPatterns = nfaTestHarness.consumeRecords(streamEvents).     assertEquals(expectedPatterns, actualPatterns). }
true;public;0;24;/**  * Tests that pruning shared buffer elements and computations state use the same window border  * semantics (left side inclusive and right side exclusive).  */ ;/**  * Tests that pruning shared buffer elements and computations state use the same window border  * semantics (left side inclusive and right side exclusive).  */ @Test public void testTimeoutWindowPruningWindowBorders() throws Exception {     List<StreamRecord<Event>> streamEvents = new ArrayList<>().     streamEvents.add(new StreamRecord<>(new Event(1, "start", 1.0), 1L)).     streamEvents.add(new StreamRecord<>(new Event(2, "start", 2.0), 2L)).     streamEvents.add(new StreamRecord<>(new Event(3, "foobar", 3.0), 3L)).     streamEvents.add(new StreamRecord<>(new Event(4, "end", 4.0), 3L)).     List<Map<String, List<Event>>> expectedPatterns = new ArrayList<>().     Map<String, List<Event>> secondPattern = new HashMap<>().     secondPattern.put("start", Collections.singletonList(new Event(2, "start", 2.0))).     secondPattern.put("end", Collections.singletonList(new Event(4, "end", 4.0))).     expectedPatterns.add(secondPattern).     NFA<Event> nfa = createStartEndNFA().     NFATestHarness nfaTestHarness = NFATestHarness.forNFA(nfa).build().     Collection<Map<String, List<Event>>> actualPatterns = nfaTestHarness.consumeRecords(streamEvents).     assertEquals(expectedPatterns, actualPatterns). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("d"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("b"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("a"). }
false;public;2;8;;@Override public boolean filter(Event value, IterativeCondition.Context<Event> ctx) throws Exception {     double sum = 0.0.     for (Event e : ctx.getEventsForPattern("middle")) {         sum += e.getPrice().     }     return sum > 5.0. }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("b"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("c"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("a"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("d"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("b"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("c"). }
false;public;0;133;;@Test public void testNFASerialization() throws Exception {     Pattern<Event, ?> pattern1 = Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 1858562682635302605L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("a").         }     }).followedByAny("middle").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 8061969839441121955L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("b").         }     }).oneOrMore().optional().allowCombinations().followedByAny("end").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 8061969839441121955L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("d").         }     }).     Pattern<Event, ?> pattern2 = Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 1858562682635302605L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("a").         }     }).notFollowedBy("not").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = -6085237016591726715L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("c").         }     }).followedByAny("middle").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 8061969839441121955L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("b").         }     }).oneOrMore().optional().allowCombinations().followedByAny("end").where(new IterativeCondition<Event>() {          private static final long serialVersionUID = 8061969839441121955L.          @Override         public boolean filter(Event value, IterativeCondition.Context<Event> ctx) throws Exception {             double sum = 0.0.             for (Event e : ctx.getEventsForPattern("middle")) {                 sum += e.getPrice().             }             return sum > 5.0.         }     }).     Pattern<Event, ?> pattern3 = Pattern.<Event>begin("start").notFollowedBy("not").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = -6085237016591726715L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("c").         }     }).followedByAny("middle").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 8061969839441121955L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("b").         }     }).oneOrMore().allowCombinations().followedByAny("end").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 8061969839441121955L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("d").         }     }).     List<Pattern<Event, ?>> patterns = new ArrayList<>().     patterns.add(pattern1).     patterns.add(pattern2).     patterns.add(pattern3).     for (Pattern<Event, ?> p : patterns) {         NFA<Event> nfa = compile(p, false).         Event a = new Event(40, "a", 1.0).         Event b = new Event(41, "b", 2.0).         Event c = new Event(42, "c", 3.0).         Event b1 = new Event(41, "b", 3.0).         Event b2 = new Event(41, "b", 4.0).         Event b3 = new Event(41, "b", 5.0).         Event d = new Event(43, "d", 4.0).         NFAState nfaState = nfa.createInitialNFAState().         NFATestHarness nfaTestHarness = NFATestHarness.forNFA(nfa).withNFAState(nfaState).build().         nfaTestHarness.consumeRecord(new StreamRecord<>(a, 1)).         nfaTestHarness.consumeRecord(new StreamRecord<>(b, 2)).         nfaTestHarness.consumeRecord(new StreamRecord<>(c, 3)).         nfaTestHarness.consumeRecord(new StreamRecord<>(b1, 4)).         nfaTestHarness.consumeRecord(new StreamRecord<>(b2, 5)).         nfaTestHarness.consumeRecord(new StreamRecord<>(b3, 6)).         nfaTestHarness.consumeRecord(new StreamRecord<>(d, 7)).         nfaTestHarness.consumeRecord(new StreamRecord<>(a, 8)).         NFAStateSerializer serializer = new NFAStateSerializer().         // serialize         ByteArrayOutputStream baos = new ByteArrayOutputStream().         serializer.serialize(nfaState, new DataOutputViewStreamWrapper(baos)).         baos.close().         // copy         ByteArrayInputStream in = new ByteArrayInputStream(baos.toByteArray()).         ByteArrayOutputStream out = new ByteArrayOutputStream().         serializer.duplicate().copy(new DataInputViewStreamWrapper(in), new DataOutputViewStreamWrapper(out)).         in.close().         out.close().         // deserialize         ByteArrayInputStream bais = new ByteArrayInputStream(out.toByteArray()).         NFAState copy = serializer.duplicate().deserialize(new DataInputViewStreamWrapper(bais)).         bais.close().         assertEquals(nfaState, copy).     } }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("start"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("end"). }
false;private;0;35;;private NFA<Event> createStartEndNFA() {     State<Event> startState = new State<>("start", State.StateType.Start).     State<Event> endState = new State<>("end", State.StateType.Normal).     State<Event> endingState = new State<>("", State.StateType.Final).     startState.addTake(endState, new SimpleCondition<Event>() {          private static final long serialVersionUID = -4869589195918650396L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("start").         }     }).     endState.addTake(endingState, new SimpleCondition<Event>() {          private static final long serialVersionUID = 2979804163709590673L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("end").         }     }).     endState.addIgnore(BooleanConditions.<Event>trueFunction()).     List<State<Event>> states = new ArrayList<>().     states.add(startState).     states.add(endState).     states.add(endingState).     return new NFA<>(states, 2L, false). }
