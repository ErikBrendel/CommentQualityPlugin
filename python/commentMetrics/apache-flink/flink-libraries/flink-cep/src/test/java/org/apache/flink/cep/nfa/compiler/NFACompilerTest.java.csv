commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getPrice() > 2. }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("end"). }
false;public;0;14;;@Test public void testNFACompilerUniquePatternName() {     // adjust the rule     expectedException.expect(MalformedPatternException.class).     expectedException.expectMessage("Duplicate pattern name: start. Names must be unique.").     Pattern<Event, ?> invalidPattern = Pattern.<Event>begin("start").where(new TestFilter()).followedBy("middle").where(new TestFilter()).followedBy("start").where(new TestFilter()).     // here we must have an exception because of the two "start" patterns with the same name.     compile(invalidPattern, false). }
false;public;0;14;;@Test public void testNFACompilerPatternEndsWithNotFollowedBy() {     // adjust the rule     expectedException.expect(MalformedPatternException.class).     expectedException.expectMessage("NotFollowedBy is not supported as a last part of a Pattern!").     Pattern<Event, ?> invalidPattern = Pattern.<Event>begin("start").where(new TestFilter()).followedBy("middle").where(new TestFilter()).notFollowedBy("end").where(new TestFilter()).     // here we must have an exception because of the two "start" patterns with the same name.     compile(invalidPattern, false). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     throw new RuntimeException("It should never arrive here."). }
true;public;0;44;/**  * Tests that the NFACompiler generates the correct NFA from a given Pattern.  */ ;/**  * Tests that the NFACompiler generates the correct NFA from a given Pattern.  */ @Test public void testNFACompilerWithSimplePattern() {     Pattern<Event, Event> pattern = Pattern.<Event>begin("start").where(startFilter).followedBy("middle").subtype(SubEvent.class).next("end").where(endFilter).     NFA<Event> nfa = compile(pattern, false).     Collection<State<Event>> states = nfa.getStates().     assertEquals(4, states.size()).     Map<String, State<Event>> stateMap = new HashMap<>().     for (State<Event> state : states) {         stateMap.put(state.getName(), state).     }     assertTrue(stateMap.containsKey("start")).     State<Event> startState = stateMap.get("start").     assertTrue(startState.isStart()).     final Set<Tuple2<String, StateTransitionAction>> startTransitions = unfoldTransitions(startState).     assertEquals(Sets.newHashSet(Tuple2.of("middle", StateTransitionAction.TAKE)), startTransitions).     assertTrue(stateMap.containsKey("middle")).     State<Event> middleState = stateMap.get("middle").     final Set<Tuple2<String, StateTransitionAction>> middleTransitions = unfoldTransitions(middleState).     assertEquals(Sets.newHashSet(Tuple2.of("middle", StateTransitionAction.IGNORE), Tuple2.of("end", StateTransitionAction.TAKE)), middleTransitions).     assertTrue(stateMap.containsKey("end")).     State<Event> endState = stateMap.get("end").     final Set<Tuple2<String, StateTransitionAction>> endTransitions = unfoldTransitions(endState).     assertEquals(Sets.newHashSet(Tuple2.of(NFACompiler.ENDING_STATE_NAME, StateTransitionAction.TAKE)), endTransitions).     assertTrue(stateMap.containsKey(NFACompiler.ENDING_STATE_NAME)).     State<Event> endingState = stateMap.get(NFACompiler.ENDING_STATE_NAME).     assertTrue(endingState.isFinal()).     assertEquals(0, endingState.getStateTransitions().size()). }
false;public;0;19;;@Test public void testNoUnnecessaryStateCopiesCreated() {     final Pattern<Event, Event> pattern = Pattern.<Event>begin("start").where(startFilter).notFollowedBy("not").where(startFilter).followedBy("oneOrMore").where(startFilter).oneOrMore().followedBy("end").where(endFilter).     final NFACompiler.NFAFactoryCompiler<Event> nfaFactoryCompiler = new NFACompiler.NFAFactoryCompiler<>(pattern).     nfaFactoryCompiler.compileFactory().     int endStateCount = 0.     for (State<Event> state : nfaFactoryCompiler.getStates()) {         if (state.getName().equals("end")) {             endStateCount++.         }     }     assertEquals(1, endStateCount). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().contains("c"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().contains("d"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().contains("a"). }
false;public;0;30;;@Test public void testSkipToNotExistsMatchingPattern() {     expectedException.expect(MalformedPatternException.class).     expectedException.expectMessage("The pattern name specified in AfterMatchSkipStrategy can not be found in the given Pattern").     Pattern<Event, ?> invalidPattern = Pattern.<Event>begin("start", AfterMatchSkipStrategy.skipToLast("midd")).where(new SimpleCondition<Event>() {          @Override         public boolean filter(Event value) throws Exception {             return value.getName().contains("a").         }     }).next("middle").where(new SimpleCondition<Event>() {          @Override         public boolean filter(Event value) throws Exception {             return value.getName().contains("d").         }     }).oneOrMore().optional().next("end").where(new SimpleCondition<Event>() {          @Override         public boolean filter(Event value) throws Exception {             return value.getName().contains("c").         }     }).     compile(invalidPattern, false). }
false;private;1;9;;private <T> Set<Tuple2<String, StateTransitionAction>> unfoldTransitions(final State<T> state) {     final Set<Tuple2<String, StateTransitionAction>> transitions = new HashSet<>().     for (StateTransition<T> transition : state.getStateTransitions()) {         transitions.add(Tuple2.of(transition.getTargetState().getName(), transition.getAction())).     }     return transitions. }
false;public;0;10;;@Test public void testCheckingEmptyMatches() {     assertThat(NFACompiler.canProduceEmptyMatches(Pattern.begin("a").optional()), is(true)).     assertThat(NFACompiler.canProduceEmptyMatches(Pattern.begin("a").oneOrMore().optional()), is(true)).     assertThat(NFACompiler.canProduceEmptyMatches(Pattern.begin("a").oneOrMore().optional().next("b").optional()), is(true)).     assertThat(NFACompiler.canProduceEmptyMatches(Pattern.begin("a")), is(false)).     assertThat(NFACompiler.canProduceEmptyMatches(Pattern.begin("a").oneOrMore()), is(false)).     assertThat(NFACompiler.canProduceEmptyMatches(Pattern.begin("a").oneOrMore().next("b").optional()), is(false)). }
