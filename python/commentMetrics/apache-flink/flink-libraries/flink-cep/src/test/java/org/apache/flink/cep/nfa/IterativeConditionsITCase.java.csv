commented;modifiers;parameterAmount;loc;comment;code
false;public;0;14;;@Test public void testIterativeWithBranchingPatternEager() throws Exception {     List<List<Event>> actual = testIterativeWithBranchingPattern(true).     compareMaps(actual, Lists.<List<Event>>newArrayList(Lists.newArrayList(startEvent1, endEvent, middleEvent1, middleEvent2, middleEvent4), Lists.newArrayList(startEvent1, endEvent, middleEvent2, middleEvent1), Lists.newArrayList(startEvent1, endEvent, middleEvent1), Lists.newArrayList(startEvent2, endEvent, middleEvent3, middleEvent4), Lists.newArrayList(startEvent2, endEvent, middleEvent3))). }
false;public;0;16;;@Test public void testIterativeWithBranchingPatternCombinations() throws Exception {     List<List<Event>> actual = testIterativeWithBranchingPattern(false).     compareMaps(actual, Lists.<List<Event>>newArrayList(Lists.newArrayList(startEvent1, endEvent, middleEvent1, middleEvent2, middleEvent4), Lists.newArrayList(startEvent1, endEvent, middleEvent2, middleEvent1), Lists.newArrayList(startEvent1, endEvent, middleEvent3, middleEvent1), Lists.newArrayList(startEvent2, endEvent, middleEvent3, middleEvent4), Lists.newArrayList(startEvent1, endEvent, middleEvent4, middleEvent1), Lists.newArrayList(startEvent1, endEvent, middleEvent1), Lists.newArrayList(startEvent2, endEvent, middleEvent3))). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("end"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("start"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("end"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("start"). }
false;private;1;52;;private List<List<Event>> testIterativeWithBranchingPattern(boolean eager) throws Exception {     List<StreamRecord<Event>> inputEvents = new ArrayList<>().     inputEvents.add(new StreamRecord<>(startEvent1, 1)).     inputEvents.add(new StreamRecord<Event>(middleEvent1, 2)).     inputEvents.add(new StreamRecord<Event>(middleEvent2, 3)).     inputEvents.add(new StreamRecord<>(startEvent2, 4)).     inputEvents.add(new StreamRecord<Event>(middleEvent3, 5)).     inputEvents.add(new StreamRecord<Event>(middleEvent4, 5)).     inputEvents.add(new StreamRecord<>(nextOne, 6)).     inputEvents.add(new StreamRecord<>(endEvent, 8)).     Pattern<Event, ?> pattern = eager ? Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 5726188262756267490L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("start").         }     }).followedBy("middle").subtype(SubEvent.class).where(new MySubeventIterCondition()).oneOrMore().followedBy("end").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 7056763917392056548L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("end").         }     }) : Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 5726188262756267490L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("start").         }     }).followedBy("middle").subtype(SubEvent.class).where(new MySubeventIterCondition()).oneOrMore().allowCombinations().followedBy("end").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 7056763917392056548L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("end").         }     }).     NFA<Event> nfa = compile(pattern, false).     return feedNFA(inputEvents, nfa). }
false;public;2;13;;@Override public boolean filter(SubEvent value, Context<SubEvent> ctx) throws Exception {     if (!value.getName().startsWith("foo")) {         return false.     }     double sum = 0.0.     for (Event event : ctx.getEventsForPattern("middle")) {         sum += event.getPrice().     }     sum += value.getPrice().     return Double.compare(sum, 5.0) < 0. }
false;public;0;14;;@Test public void testIterativeWithLoopingStartingEager() throws Exception {     List<List<Event>> actual = testIterativeWithLoopingStarting(true).     compareMaps(actual, Lists.<List<Event>>newArrayList(Lists.newArrayList(startEvent1, startEvent2, endEvent), Lists.newArrayList(startEvent1, endEvent), Lists.newArrayList(startEvent2, endEvent), Lists.newArrayList(startEvent3, endEvent), Lists.newArrayList(endEvent))). }
false;public;0;15;;@Test public void testIterativeWithLoopingStartingCombination() throws Exception {     List<List<Event>> actual = testIterativeWithLoopingStarting(false).     compareMaps(actual, Lists.<List<Event>>newArrayList(Lists.newArrayList(startEvent1, startEvent2, endEvent), Lists.newArrayList(startEvent1, startEvent3, endEvent), Lists.newArrayList(startEvent1, endEvent), Lists.newArrayList(startEvent2, endEvent), Lists.newArrayList(startEvent3, endEvent), Lists.newArrayList(endEvent))). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("end"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("end"). }
false;private;1;36;;private List<List<Event>> testIterativeWithLoopingStarting(boolean eager) throws Exception {     List<StreamRecord<Event>> inputEvents = new ArrayList<>().     inputEvents.add(new StreamRecord<>(startEvent1, 1L)).     inputEvents.add(new StreamRecord<>(startEvent2, 2L)).     inputEvents.add(new StreamRecord<>(startEvent3, 3L)).     inputEvents.add(new StreamRecord<>(endEvent, 4L)).     // for now, a pattern inherits its continuity property from the followedBy() or next(), and the default     // behavior (which is the one applied in the case that the pattern graph starts with such a pattern)     // of a looping pattern is with relaxed continuity (as in followedBy).     Pattern<Event, ?> pattern = eager ? Pattern.<Event>begin("start").where(new MyEventIterCondition()).oneOrMore().optional().followedBy("end").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 7056763917392056548L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("end").         }     }) : Pattern.<Event>begin("start").where(new MyEventIterCondition()).oneOrMore().allowCombinations().optional().followedBy("end").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 7056763917392056548L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("end").         }     }).     NFA<Event> nfa = compile(pattern, false).     return feedNFA(inputEvents, nfa). }
false;public;2;13;;@Override public boolean filter(Event value, Context<Event> ctx) throws Exception {     if (!value.getName().equals("start")) {         return false.     }     double sum = 0.0.     for (Event event : ctx.getEventsForPattern("start")) {         sum += event.getPrice().     }     sum += value.getPrice().     return Double.compare(sum, 5.0) < 0. }
false;public;2;12;;@Override public boolean filter(Event value, Context<Event> ctx) throws Exception {     if (!value.getName().equals("end")) {         return false.     }     double sum = 0.0.     for (Event event : ctx.getEventsForPattern("start")) {         sum += event.getPrice().     }     return Double.compare(sum, 2.0) >= 0. }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("start"). }
false;public;0;43;;@Test public void testIterativeWithPrevPatternDependency() throws Exception {     List<StreamRecord<Event>> inputEvents = new ArrayList<>().     inputEvents.add(new StreamRecord<>(startEvent1, 1L)).     inputEvents.add(new StreamRecord<>(startEvent2, 2L)).     inputEvents.add(new StreamRecord<>(endEvent, 4L)).     Pattern<Event, ?> pattern = Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 6215754202506583964L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("start").         }     }).oneOrMore().followedBy("end").where(new IterativeCondition<Event>() {          private static final long serialVersionUID = 7056763917392056548L.          @Override         public boolean filter(Event value, Context<Event> ctx) throws Exception {             if (!value.getName().equals("end")) {                 return false.             }             double sum = 0.0.             for (Event event : ctx.getEventsForPattern("start")) {                 sum += event.getPrice().             }             return Double.compare(sum, 2.0) >= 0.         }     }).     NFA<Event> nfa = compile(pattern, false).     List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa).     compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(Lists.newArrayList(startEvent1, startEvent2, endEvent), Lists.newArrayList(startEvent2, endEvent))). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("end"). }
false;public;2;13;;@Override public boolean filter(Event value, Context<Event> ctx) throws Exception {     if (!value.getName().equals("start")) {         return false.     }     double sum = 0.0.     for (Event e : ctx.getEventsForPattern("middle2")) {         sum += e.getPrice().     }     sum += value.getPrice().     return Double.compare(sum, 5.0) <= 0. }
false;public;1;4;;@Override public boolean filter(SubEvent value) throws Exception {     return value.getName().startsWith("foo"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("start"). }
false;public;0;69;;@Test public void testIterativeWithABACPattern() throws Exception {     List<StreamRecord<Event>> inputEvents = new ArrayList<>().     // 1     inputEvents.add(new StreamRecord<>(startEvent1, 1L)).     // 1     inputEvents.add(new StreamRecord<Event>(middleEvent1, 2L)).     // 2     inputEvents.add(new StreamRecord<>(startEvent2, 2L)).     // 3     inputEvents.add(new StreamRecord<>(startEvent3, 2L)).     // 2     inputEvents.add(new StreamRecord<Event>(middleEvent2, 2L)).     // 4     inputEvents.add(new StreamRecord<>(startEvent4, 2L)).     // 3     inputEvents.add(new StreamRecord<Event>(middleEvent3, 2L)).     // 1     inputEvents.add(new StreamRecord<Event>(middleEvent4, 2L)).     inputEvents.add(new StreamRecord<>(endEvent, 4L)).     Pattern<Event, ?> pattern = Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 6215754202506583964L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("start").         }     }).followedByAny("middle1").subtype(SubEvent.class).where(new SimpleCondition<SubEvent>() {          private static final long serialVersionUID = 2178338526904474690L.          @Override         public boolean filter(SubEvent value) throws Exception {             return value.getName().startsWith("foo").         }     }).followedBy("middle2").where(new IterativeCondition<Event>() {          private static final long serialVersionUID = -1223388426808292695L.          @Override         public boolean filter(Event value, Context<Event> ctx) throws Exception {             if (!value.getName().equals("start")) {                 return false.             }             double sum = 0.0.             for (Event e : ctx.getEventsForPattern("middle2")) {                 sum += e.getPrice().             }             sum += value.getPrice().             return Double.compare(sum, 5.0) <= 0.         }     }).oneOrMore().followedBy("end").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 562590474115118323L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("end").         }     }).     NFA<Event> nfa = compile(pattern, false).     List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa).     compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(Lists.newArrayList(startEvent1, startEvent2, startEvent3, middleEvent1, endEvent), Lists.newArrayList(startEvent1, middleEvent1, startEvent2, endEvent), Lists.newArrayList(startEvent1, middleEvent2, startEvent4, endEvent), Lists.newArrayList(startEvent2, middleEvent2, startEvent4, endEvent), Lists.newArrayList(startEvent3, middleEvent2, startEvent4, endEvent))). }
false;public;2;12;;@Override public boolean filter(Event value, Context<Event> ctx) throws Exception {     if (!value.getName().equals("end")) {         return false.     }     double sum = 0.0.     for (Event event : ctx.getEventsForPattern("start")) {         sum += event.getPrice().     }     return Double.compare(sum, 2.0) >= 0. }
false;public;1;4;;@Override public boolean filter(SubEvent value) throws Exception {     return value.getName().startsWith("foo"). }
false;public;1;4;;@Override public boolean filter(Event value) throws Exception {     return value.getName().equals("start"). }
false;public;0;58;;@Test public void testIterativeWithPrevPatternDependencyAfterBranching() throws Exception {     List<StreamRecord<Event>> inputEvents = new ArrayList<>().     inputEvents.add(new StreamRecord<>(startEvent1, 1L)).     inputEvents.add(new StreamRecord<>(startEvent2, 2L)).     inputEvents.add(new StreamRecord<Event>(middleEvent1, 4L)).     inputEvents.add(new StreamRecord<>(startEvent3, 5L)).     inputEvents.add(new StreamRecord<Event>(middleEvent2, 6L)).     inputEvents.add(new StreamRecord<>(endEvent, 7L)).     Pattern<Event, ?> pattern = Pattern.<Event>begin("start").where(new SimpleCondition<Event>() {          private static final long serialVersionUID = 6215754202506583964L.          @Override         public boolean filter(Event value) throws Exception {             return value.getName().equals("start").         }     }).oneOrMore().followedByAny("middle1").subtype(SubEvent.class).where(new SimpleCondition<SubEvent>() {          private static final long serialVersionUID = 2178338526904474690L.          @Override         public boolean filter(SubEvent value) throws Exception {             return value.getName().startsWith("foo").         }     }).followedByAny("end").where(new IterativeCondition<Event>() {          private static final long serialVersionUID = 7056763917392056548L.          @Override         public boolean filter(Event value, Context<Event> ctx) throws Exception {             if (!value.getName().equals("end")) {                 return false.             }             double sum = 0.0.             for (Event event : ctx.getEventsForPattern("start")) {                 sum += event.getPrice().             }             return Double.compare(sum, 2.0) >= 0.         }     }).     NFA<Event> nfa = compile(pattern, false).     List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa).     compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(Lists.newArrayList(startEvent1, startEvent2, middleEvent1, endEvent), Lists.newArrayList(startEvent2, middleEvent1, endEvent), Lists.newArrayList(startEvent1, startEvent2, middleEvent2, endEvent), Lists.newArrayList(startEvent1, startEvent2, startEvent3, middleEvent2, endEvent), Lists.newArrayList(startEvent2, startEvent3, middleEvent2, endEvent), Lists.newArrayList(startEvent2, middleEvent2, endEvent), Lists.newArrayList(startEvent3, middleEvent2, endEvent))). }
