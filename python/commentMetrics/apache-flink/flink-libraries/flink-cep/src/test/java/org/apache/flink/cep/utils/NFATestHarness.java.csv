commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Constructs a test harness starting from a given {@link Pattern}.  */ ;/**  * Constructs a test harness starting from a given {@link Pattern}.  */ public static NFATestHarnessBuilderPattern forPattern(Pattern<Event, ?> pattern) {     return new NFATestHarnessBuilderPattern(pattern). }
true;public,static;1;3;/**  * Constructs a test harness starting from a given {@link NFA}.  */ ;/**  * Constructs a test harness starting from a given {@link NFA}.  */ public static NFATestHarnessBuilderNFA forNFA(NFA<Event> nfa) {     return new NFATestHarnessBuilderNFA(nfa). }
false;public;1;7;;public List<List<Event>> feedRecords(List<StreamRecord<Event>> inputEvents) throws Exception {     final List<List<Event>> resultingPatterns = new ArrayList<>().     for (StreamRecord<Event> inputEvent : inputEvents) {         resultingPatterns.addAll(feedRecord(inputEvent)).     }     return resultingPatterns. }
false;public;1;12;;public List<List<Event>> feedRecord(StreamRecord<Event> inputEvent) throws Exception {     final List<List<Event>> resultingPatterns = new ArrayList<>().     final Collection<Map<String, List<Event>>> matches = consumeRecord(inputEvent).     for (Map<String, List<Event>> p : matches) {         List<Event> res = new ArrayList<>().         for (List<Event> le : p.values()) {             res.addAll(le).         }         resultingPatterns.add(res).     }     return resultingPatterns. }
false;public;1;8;;public Collection<Map<String, List<Event>>> consumeRecords(Collection<StreamRecord<Event>> inputEvents) throws Exception {     final List<Map<String, List<Event>>> resultingPatterns = new ArrayList<>().     for (StreamRecord<Event> inputEvent : inputEvents) {         resultingPatterns.addAll(consumeRecord(inputEvent)).     }     return resultingPatterns. }
false;public;1;12;;public Collection<Map<String, List<Event>>> consumeRecord(StreamRecord<Event> inputEvent) throws Exception {     try (SharedBufferAccessor<Event> sharedBufferAccessor = sharedBuffer.getAccessor()) {         nfa.advanceTime(sharedBufferAccessor, nfaState, inputEvent.getTimestamp()).         return nfa.process(sharedBufferAccessor, nfaState, inputEvent.getValue(), inputEvent.getTimestamp(), afterMatchSkipStrategy, timerService).     } }
false;public;0;4;;public NFATestHarnessBuilderBase withTimeoutHandling() {     this.timeoutHandling = true.     return this. }
false;public;0;10;;@Override public NFATestHarness build() {     final NFA<Event> nfa = NFAUtils.compile(pattern, timeoutHandling).     return new NFATestHarness(sharedBuffer, nfa, nfa.createInitialNFAState(), afterMatchSkipStrategy, timerService). }
false;public;1;4;;public NFATestHarnessBuilderBase withNFAState(NFAState nfaState) {     this.nfaState = nfaState.     return this. }
false;public;0;9;;@Override public NFATestHarness build() {     return new NFATestHarness(sharedBuffer, nfa, nfaState, afterMatchSkipStrategy, timerService). }
false;public;1;4;;public NFATestHarnessBuilderBase withSharedBuffer(SharedBuffer<Event> sharedBuffer) {     this.sharedBuffer = sharedBuffer.     return this. }
false;public;1;4;;public NFATestHarnessBuilderBase withAfterMatchSkipStrategy(AfterMatchSkipStrategy afterMatchSkipStrategy) {     this.afterMatchSkipStrategy = afterMatchSkipStrategy.     return this. }
false;public;1;4;;public NFATestHarnessBuilderBase withTimerService(TimerService timerService) {     this.timerService = timerService.     return this. }
false;public,abstract;0;1;;public abstract NFATestHarness build().
