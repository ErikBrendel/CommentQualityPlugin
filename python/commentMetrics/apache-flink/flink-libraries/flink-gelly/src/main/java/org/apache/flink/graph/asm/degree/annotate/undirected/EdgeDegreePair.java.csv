commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * The degree can be counted from either the edge source or target IDs.  * By default the source IDs are counted. Reducing on target IDs may  * optimize the algorithm if the input edge list is sorted by target ID.  *  * @param reduceOnTargetId set to {@code true} if the input edge list  *                         is sorted by target ID  * @return this  */ ;/**  * The degree can be counted from either the edge source or target IDs.  * By default the source IDs are counted. Reducing on target IDs may  * optimize the algorithm if the input edge list is sorted by target ID.  *  * @param reduceOnTargetId set to {@code true} if the input edge list  *                         is sorted by target ID  * @return this  */ public EdgeDegreePair<K, VV, EV> setReduceOnTargetId(boolean reduceOnTargetId) {     this.reduceOnTargetId.set(reduceOnTargetId).     return this. }
false;protected;1;8;;@Override protected void mergeConfiguration(GraphAlgorithmWrappingBase other) {     super.mergeConfiguration(other).     EdgeDegreePair rhs = (EdgeDegreePair) other.     reduceOnTargetId.mergeWith(rhs.reduceOnTargetId). }
false;public;1;24;;@Override public DataSet<Edge<K, Tuple3<EV, LongValue, LongValue>>> runInternal(Graph<K, VV, EV> input) throws Exception {     // s, t, d(s)     DataSet<Edge<K, Tuple2<EV, LongValue>>> edgeSourceDegrees = input.run(new EdgeSourceDegree<K, VV, EV>().setReduceOnTargetId(reduceOnTargetId.get()).setParallelism(parallelism)).     // t, d(t)     DataSet<Vertex<K, LongValue>> vertexDegrees = input.run(new VertexDegree<K, VV, EV>().setReduceOnTargetId(reduceOnTargetId.get()).setParallelism(parallelism)).     // s, t, (d(s), d(t))     return edgeSourceDegrees.join(vertexDegrees, JoinHint.REPARTITION_HASH_SECOND).where(1).equalTo(0).with(new JoinEdgeDegreeWithVertexDegree<>()).setParallelism(parallelism).name("Edge target degree"). }
