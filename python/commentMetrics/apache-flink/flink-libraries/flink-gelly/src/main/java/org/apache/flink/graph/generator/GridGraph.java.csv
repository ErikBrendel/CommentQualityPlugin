commented;modifiers;parameterAmount;loc;comment;code
true;public;2;14;/**  * Required configuration for each dimension of the graph.  *  * @param size number of vertices. dimensions of size 1 are prohibited due to having no effect  *             on the generated graph  * @param wrapEndpoints whether to connect first and last vertices. this has no effect on  *                      dimensions of size 2  * @return this  */ ;/**  * Required configuration for each dimension of the graph.  *  * @param size number of vertices. dimensions of size 1 are prohibited due to having no effect  *             on the generated graph  * @param wrapEndpoints whether to connect first and last vertices. this has no effect on  *                      dimensions of size 2  * @return this  */ public GridGraph addDimension(long size, boolean wrapEndpoints) {     Preconditions.checkArgument(size >= 2, "Dimension size must be at least 2").     vertexCount = Math.multiplyExact(vertexCount, size).     // prevent duplicate edges     if (size == 2) {         wrapEndpoints = false.     }     dimensions.add(new Tuple2<>(size, wrapEndpoints)).     return this. }
false;public;0;21;;@Override public Graph<LongValue, NullValue, NullValue> generate() {     Preconditions.checkState(!dimensions.isEmpty(), "No dimensions added to GridGraph").     // Vertices     DataSet<Vertex<LongValue, NullValue>> vertices = GraphGeneratorUtils.vertexSequence(env, parallelism, vertexCount).     // Edges     LongValueSequenceIterator iterator = new LongValueSequenceIterator(0, this.vertexCount - 1).     DataSet<Edge<LongValue, NullValue>> edges = env.fromParallelCollection(iterator, LongValue.class).setParallelism(parallelism).name("Edge iterators").flatMap(new LinkVertexToNeighbors(vertexCount, dimensions)).setParallelism(parallelism).name("Grid graph edges").     // Graph     return Graph.fromDataSet(vertices, edges, env). }
false;public;2;37;;@Override public void flatMap(LongValue source, Collector<Edge<LongValue, NullValue>> out) throws Exception {     edge.f0 = source.     long val = source.getValue().     // the distance between neighbors in a given iteration     long increment = vertexCount.     // the value in the remaining dimensions     long remainder = val.     for (Tuple2<Long, Boolean> dimension : dimensions) {         increment /= dimension.f0.         // the index within this dimension         long index = remainder / increment.         if (index > 0) {             target.setValue(val - increment).             out.collect(edge).         } else if (dimension.f1) {             target.setValue(val + increment * (dimension.f0 - 1)).             out.collect(edge).         }         if (index < dimension.f0 - 1) {             target.setValue(val + increment).             out.collect(edge).         } else if (dimension.f1) {             target.setValue(val - increment * (dimension.f0 - 1)).             out.collect(edge).         }         remainder %= increment.     } }
