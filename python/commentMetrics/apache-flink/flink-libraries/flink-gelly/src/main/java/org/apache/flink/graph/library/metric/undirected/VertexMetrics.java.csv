commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * By default only the edge set is processed for the computation of degree.  * When this flag is set an additional join is performed against the vertex  * set in order to output vertices with a degree of zero.  *  * @param includeZeroDegreeVertices whether to output vertices with a  *                                  degree of zero  * @return this  */ ;/**  * By default only the edge set is processed for the computation of degree.  * When this flag is set an additional join is performed against the vertex  * set in order to output vertices with a degree of zero.  *  * @param includeZeroDegreeVertices whether to output vertices with a  *                                  degree of zero  * @return this  */ public VertexMetrics<K, VV, EV> setIncludeZeroDegreeVertices(boolean includeZeroDegreeVertices) {     this.includeZeroDegreeVertices = includeZeroDegreeVertices.     return this. }
true;public;1;5;/**  * The degree can be counted from either the edge source or target IDs.  * By default the source IDs are counted. Reducing on target IDs may  * optimize the algorithm if the input edge list is sorted by target ID.  *  * @param reduceOnTargetId set to {@code true} if the input edge list  *                         is sorted by target ID  * @return this  */ ;/**  * The degree can be counted from either the edge source or target IDs.  * By default the source IDs are counted. Reducing on target IDs may  * optimize the algorithm if the input edge list is sorted by target ID.  *  * @param reduceOnTargetId set to {@code true} if the input edge list  *                         is sorted by target ID  * @return this  */ public VertexMetrics<K, VV, EV> setReduceOnTargetId(boolean reduceOnTargetId) {     this.reduceOnTargetId = reduceOnTargetId.     return this. }
false;public;1;19;;@Override public VertexMetrics<K, VV, EV> run(Graph<K, VV, EV> input) throws Exception {     super.run(input).     DataSet<Vertex<K, LongValue>> vertexDegree = input.run(new VertexDegree<K, VV, EV>().setIncludeZeroDegreeVertices(includeZeroDegreeVertices).setReduceOnTargetId(reduceOnTargetId).setParallelism(parallelism)).     vertexMetricsHelper = new VertexMetricsHelper<>().     vertexDegree.output(vertexMetricsHelper).name("Vertex metrics").     return this. }
false;public;0;11;;@Override public Result getResult() {     long vertexCount = vertexMetricsHelper.getAccumulator(env, VERTEX_COUNT).     long edgeCount = vertexMetricsHelper.getAccumulator(env, EDGE_COUNT).     long tripletCount = vertexMetricsHelper.getAccumulator(env, TRIPLET_COUNT).     long maximumDegree = vertexMetricsHelper.getAccumulator(env, MAXIMUM_DEGREE).     long maximumTriplets = vertexMetricsHelper.getAccumulator(env, MAXIMUM_TRIPLETS).     // each edge is counted twice, once from each vertex, so must be halved     return new Result(vertexCount, edgeCount / 2, tripletCount, maximumDegree, maximumTriplets). }
false;public;1;11;;@Override public void writeRecord(Vertex<T, LongValue> record) throws IOException {     long degree = record.f1.getValue().     long triplets = degree * (degree - 1) / 2.     vertexCount++.     edgeCount += degree.     tripletCount += triplets.     maximumDegree = Math.max(maximumDegree, degree).     maximumTriplets = Math.max(maximumTriplets, triplets). }
false;public;0;8;;@Override public void close() throws IOException {     addAccumulator(VERTEX_COUNT, new LongCounter(vertexCount)).     addAccumulator(EDGE_COUNT, new LongCounter(edgeCount)).     addAccumulator(TRIPLET_COUNT, new LongCounter(tripletCount)).     addAccumulator(MAXIMUM_DEGREE, new LongMaximum(maximumDegree)).     addAccumulator(MAXIMUM_TRIPLETS, new LongMaximum(maximumTriplets)). }
true;public;0;3;/**  * Get the number of vertices.  *  * @return number of vertices  */ ;/**  * Get the number of vertices.  *  * @return number of vertices  */ public long getNumberOfVertices() {     return vertexCount. }
true;public;0;3;/**  * Get the number of edges. Each edge is counted once even though Gelly  * stores undirected edges twice, once in each direction.  *  * @return number of edges  */ ;/**  * Get the number of edges. Each edge is counted once even though Gelly  * stores undirected edges twice, once in each direction.  *  * @return number of edges  */ public long getNumberOfEdges() {     return edgeCount. }
true;public;0;4;/**  * Get the average degree, the average number of edges per vertex.  *  * <p>A result of {@code Float.NaN} is returned for an empty graph for  * which both the number of edges and number of vertices is zero.  *  * @return average degree  */ ;/**  * Get the average degree, the average number of edges per vertex.  *  * <p>A result of {@code Float.NaN} is returned for an empty graph for  * which both the number of edges and number of vertices is zero.  *  * @return average degree  */ public double getAverageDegree() {     // each edge is incident on two vertices     return vertexCount == 0 ? Double.NaN : 2 * edgeCount / (double) vertexCount. }
true;public;0;3;/**  * Get the density, the ratio of actual to potential edges between vertices.  *  * <p>A result of {@code Float.NaN} is returned for a graph with fewer than  * two vertices for which the number of edges is zero.  *  * @return density  */ ;/**  * Get the density, the ratio of actual to potential edges between vertices.  *  * <p>A result of {@code Float.NaN} is returned for a graph with fewer than  * two vertices for which the number of edges is zero.  *  * @return density  */ public double getDensity() {     return vertexCount <= 1 ? Double.NaN : edgeCount / (double) (vertexCount * (vertexCount - 1) / 2). }
true;public;0;3;/**  * Get the number of triplets.  *  * @return number of triplets  */ ;/**  * Get the number of triplets.  *  * @return number of triplets  */ public long getNumberOfTriplets() {     return tripletCount. }
true;public;0;3;/**  * Get the maximum degree.  *  * @return maximum degree  */ ;/**  * Get the maximum degree.  *  * @return maximum degree  */ public long getMaximumDegree() {     return maximumDegree. }
true;public;0;3;/**  * Get the maximum triplets.  *  * @return maximum triplets  */ ;/**  * Get the maximum triplets.  *  * @return maximum triplets  */ public long getMaximumTriplets() {     return maximumTriplets. }
false;public;0;4;;@Override public String toString() {     return toPrintableString(). }
false;public;0;16;;@Override public String toPrintableString() {     NumberFormat nf = NumberFormat.getInstance().     // format for very small fractional numbers     NumberFormat ff = NumberFormat.getInstance().     ff.setMaximumFractionDigits(8).     return "vertex count: " + nf.format(vertexCount) + ". edge count: " + nf.format(edgeCount) + ". average degree: " + nf.format(getAverageDegree()) + ". density: " + ff.format(getDensity()) + ". triplet count: " + nf.format(tripletCount) + ". maximum degree: " + nf.format(maximumDegree) + ". maximum triplets: " + nf.format(maximumTriplets). }
false;public;0;10;;@Override public int hashCode() {     return new HashCodeBuilder().append(vertexCount).append(edgeCount).append(tripletCount).append(maximumDegree).append(maximumTriplets).hashCode(). }
false;public;1;24;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (obj == this) {         return true.     }     if (obj.getClass() != getClass()) {         return false.     }     Result rhs = (Result) obj.     return new EqualsBuilder().append(vertexCount, rhs.vertexCount).append(edgeCount, rhs.edgeCount).append(tripletCount, rhs.tripletCount).append(maximumDegree, rhs.maximumDegree).append(maximumTriplets, rhs.maximumTriplets).isEquals(). }
