commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;1;1;/**  * The implementation of the algorithm, renamed from {@link GraphAlgorithm#run(Graph)}.  *  * @param input the input graph  * @return the algorithm's output  * @throws Exception  */ ;/**  * The implementation of the algorithm, renamed from {@link GraphAlgorithm#run(Graph)}.  *  * @param input the input graph  * @return the algorithm's output  * @throws Exception  */ protected abstract Graph<OUT_K, OUT_VV, OUT_EV> runInternal(Graph<IN_K, IN_VV, IN_EV> input) throws Exception.
false;public,final;0;7;;@Override public final int hashCode() {     return new HashCodeBuilder(17, 37).append(input).append(getAlgorithmName()).toHashCode(). }
false;public,final;1;21;;@Override public final boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (obj == this) {         return true.     }     if (!GraphAlgorithmWrappingGraph.class.isAssignableFrom(obj.getClass())) {         return false.     }     GraphAlgorithmWrappingGraph rhs = (GraphAlgorithmWrappingGraph) obj.     return new EqualsBuilder().append(input, rhs.input).append(getAlgorithmName(), rhs.getAlgorithmName()).isEquals(). }
false;public,final;1;41;;@Override @SuppressWarnings("unchecked") public final Graph<OUT_K, OUT_VV, OUT_EV> run(Graph<IN_K, IN_VV, IN_EV> input) throws Exception {     this.input = input.     if (cache.containsKey(this)) {         for (GraphAlgorithmWrappingGraph<IN_K, IN_VV, IN_EV, OUT_K, OUT_VV, OUT_EV> other : cache.get(this)) {             if (canMergeConfigurationWith(other)) {                 mergeConfiguration(other).                 // configuration has been merged so generate new output                 Graph<OUT_K, OUT_VV, OUT_EV> output = runInternal(input).                 other.verticesWrappingOperator.setInput(output.getVertices()).                 other.edgesWrappingOperator.setInput(output.getEdges()).                 verticesWrappingOperator = other.verticesWrappingOperator.                 edgesWrappingOperator = other.edgesWrappingOperator.                 return Graph.fromDataSet(verticesWrappingOperator, edgesWrappingOperator, output.getContext()).             }         }     }     // no mergeable configuration found so generate new output     Graph<OUT_K, OUT_VV, OUT_EV> output = runInternal(input).     // create a new operator to wrap the algorithm output     verticesWrappingOperator = new NoOpOperator<>(output.getVertices(), output.getVertices().getType()).     edgesWrappingOperator = new NoOpOperator<>(output.getEdges(), output.getEdges().getType()).     // cache this result     if (cache.containsKey(this)) {         cache.get(this).add(this).     } else {         cache.put(this, new ArrayList(Collections.singletonList(this))).     }     return Graph.fromDataSet(verticesWrappingOperator, edgesWrappingOperator, output.getContext()). }
