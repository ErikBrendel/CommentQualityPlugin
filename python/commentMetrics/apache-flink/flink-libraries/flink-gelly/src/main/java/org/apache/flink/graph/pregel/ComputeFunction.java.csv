commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;2;1;/**  * This method is invoked once per superstep, for each active vertex.  * A vertex is active during a superstep, if at least one message was produced for it,  * in the previous superstep. During the first superstep, all vertices are active.  *  * <p>This method can iterate over all received messages, set the new vertex value, and  * send messages to other vertices (which will be delivered in the next superstep).  *  * @param vertex The vertex executing this function  * @param messages The messages that were sent to this vertex in the previous superstep  * @throws Exception  */ ;// -------------------------------------------------------------------------------------------- // Public API Methods // -------------------------------------------------------------------------------------------- /**  * This method is invoked once per superstep, for each active vertex.  * A vertex is active during a superstep, if at least one message was produced for it,  * in the previous superstep. During the first superstep, all vertices are active.  *  * <p>This method can iterate over all received messages, set the new vertex value, and  * send messages to other vertices (which will be delivered in the next superstep).  *  * @param vertex The vertex executing this function  * @param messages The messages that were sent to this vertex in the previous superstep  * @throws Exception  */ public abstract void compute(Vertex<K, VV> vertex, MessageIterator<Message> messages) throws Exception.
true;public;0;1;/**  * This method is executed once per superstep before the vertex update function is invoked for each vertex.  *  * @throws Exception Exceptions in the pre-superstep phase cause the superstep to fail.  */ ;/**  * This method is executed once per superstep before the vertex update function is invoked for each vertex.  *  * @throws Exception Exceptions in the pre-superstep phase cause the superstep to fail.  */ public void preSuperstep() throws Exception { }
true;public;0;1;/**  * This method is executed once per superstep after the vertex update function has been invoked for each vertex.  *  * @throws Exception Exceptions in the post-superstep phase cause the superstep to fail.  */ ;/**  * This method is executed once per superstep after the vertex update function has been invoked for each vertex.  *  * @throws Exception Exceptions in the post-superstep phase cause the superstep to fail.  */ public void postSuperstep() throws Exception { }
true;public,final;0;5;/**  * Gets an {@link java.lang.Iterable} with all out-going edges. This method is mutually exclusive with  * {@link #sendMessageToAllNeighbors(Object)} and may be called only once.  *  * @return An iterator with all edges.  */ ;/**  * Gets an {@link java.lang.Iterable} with all out-going edges. This method is mutually exclusive with  * {@link #sendMessageToAllNeighbors(Object)} and may be called only once.  *  * @return An iterator with all edges.  */ public final Iterable<Edge<K, EV>> getEdges() {     verifyEdgeUsage().     this.edgeIterator.set(edges).     return this.edgeIterator. }
true;public,final;1;9;/**  * Sends the given message to all vertices that adjacent to the changed vertex.  * This method is mutually exclusive to the method {@link #getEdges()} and may be called only once.  *  * @param m The message to send.  */ ;/**  * Sends the given message to all vertices that adjacent to the changed vertex.  * This method is mutually exclusive to the method {@link #getEdges()} and may be called only once.  *  * @param m The message to send.  */ public final void sendMessageToAllNeighbors(Message m) {     verifyEdgeUsage().     outMsg.f1 = m.     while (edges.hasNext()) {         Tuple next = edges.next().         outMsg.f0 = next.getField(1).         out.collect(Either.Right(outMsg)).     } }
true;public,final;2;7;/**  * Sends the given message to the vertex identified by the given key. If the target vertex does not exist,  * the next superstep will cause an exception due to a non-deliverable message.  *  * @param target The key (id) of the target vertex to message.  * @param m The message.  */ ;/**  * Sends the given message to the vertex identified by the given key. If the target vertex does not exist,  * the next superstep will cause an exception due to a non-deliverable message.  *  * @param target The key (id) of the target vertex to message.  * @param m The message.  */ public final void sendMessageTo(K target, Message m) {     outMsg.f0 = target.     outMsg.f1 = m.     out.collect(Either.Right(outMsg)). }
true;public,final;1;10;/**  * Sets the new value of this vertex.  *  * <p>This should be called at most once per ComputeFunction.  *  * @param newValue The new vertex value.  */ ;/**  * Sets the new value of this vertex.  *  * <p>This should be called at most once per ComputeFunction.  *  * @param newValue The new vertex value.  */ public final void setNewVertexValue(VV newValue) {     if (setNewVertexValueCalled) {         throw new IllegalStateException("setNewVertexValue should only be called at most once per updateVertex").     }     setNewVertexValueCalled = true.     outVertex.f1 = newValue.     out.collect(Either.Left(outVertex)). }
true;public,final;0;3;/**  * Gets the number of the superstep, starting at <tt>1</tt>.  *  * @return The number of the current superstep.  */ ;// -------------------------------------------------------------------------------------------- /**  * Gets the number of the superstep, starting at <tt>1</tt>.  *  * @return The number of the current superstep.  */ public final int getSuperstepNumber() {     return this.runtimeContext.getSuperstepNumber(). }
true;public,final;1;3;/**  * Gets the iteration aggregator registered under the given name. The iteration aggregator combines  * all aggregates globally once per superstep and makes them available in the next superstep.  *  * @param name The name of the aggregator.  * @return The aggregator registered under this name, or {@code null}, if no aggregator was registered.  */ ;/**  * Gets the iteration aggregator registered under the given name. The iteration aggregator combines  * all aggregates globally once per superstep and makes them available in the next superstep.  *  * @param name The name of the aggregator.  * @return The aggregator registered under this name, or {@code null}, if no aggregator was registered.  */ public final <T extends Aggregator<?>> T getIterationAggregator(String name) {     return this.runtimeContext.getIterationAggregator(name). }
true;public,final;1;3;/**  * Get the aggregated value that an aggregator computed in the previous iteration.  *  * @param name The name of the aggregator.  * @return The aggregated value of the previous iteration.  */ ;/**  * Get the aggregated value that an aggregator computed in the previous iteration.  *  * @param name The name of the aggregator.  * @return The aggregated value of the previous iteration.  */ public final <T extends Value> T getPreviousIterationAggregate(String name) {     return this.runtimeContext.getPreviousIterationAggregate(name). }
true;public,final;1;3;/**  * Gets the broadcast data set registered under the given name. Broadcast data sets  * are available on all parallel instances of a function. They can be registered via  * {@link org.apache.flink.graph.pregel.VertexCentricConfiguration#addBroadcastSet(String, DataSet)}.  *  * @param name The name under which the broadcast set is registered.  * @return The broadcast data set.  */ ;/**  * Gets the broadcast data set registered under the given name. Broadcast data sets  * are available on all parallel instances of a function. They can be registered via  * {@link org.apache.flink.graph.pregel.VertexCentricConfiguration#addBroadcastSet(String, DataSet)}.  *  * @param name The name under which the broadcast set is registered.  * @return The broadcast data set.  */ public final <T> Collection<T> getBroadcastSet(String name) {     return this.runtimeContext.getBroadcastVariable(name). }
false;;1;6;;void init(IterationRuntimeContext context) {     this.runtimeContext = context.     this.outVertex = new Vertex<>().     this.outMsg = new Tuple2<>().     this.edgeIterator = new EdgesIterator<>(). }
false;;3;10;;@SuppressWarnings("unchecked") void set(K vertexId, Iterator<Edge<K, EV>> edges, Collector<Either<Vertex<K, VV>, Tuple2<K, Message>>> out) {     this.outVertex.f0 = vertexId.     this.edges = edges.     this.out = (Collector<Either<?, ?>>) (Collector<?>) out.     this.edgesUsed = false.     setNewVertexValueCalled = false. }
false;private;0;7;;private void verifyEdgeUsage() throws IllegalStateException {     if (edgesUsed) {         throw new IllegalStateException("Can use either 'getEdges()' or 'sendMessageToAllNeighbors()' exactly once.").     }     edgesUsed = true. }
false;;1;3;;void set(Iterator<Edge<K, EV>> input) {     this.input = input. }
false;public;0;4;;@Override public boolean hasNext() {     return input.hasNext(). }
false;public;0;8;;@Override public Edge<K, EV> next() {     Edge<K, EV> next = input.next().     edge.setSource(next.f0).     edge.setTarget(next.f1).     edge.setValue(next.f2).     return edge. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public Iterator<Edge<K, EV>> iterator() {     return this. }
