commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;0;1;// the cost of generating random values. ;// This should be sufficiently large relative to the cost of instantiating // and initializing the random generator and sufficiently small relative to // the cost of generating random values. protected abstract int getMinimumCyclesPerBlock().
false;protected,abstract;0;1;;protected abstract RandomGenerable<T> next().
false;public;2;25;;@Override public List<BlockInfo<T>> getRandomGenerables(long elementCount, int cyclesPerElement) {     long cycles = elementCount * cyclesPerElement.     int blockCount = Math.min((int) Math.ceil(cycles / (float) getMinimumCyclesPerBlock()), MAXIMUM_BLOCK_COUNT).     long elementsPerBlock = elementCount / blockCount.     long elementRemainder = elementCount % blockCount.     List<BlockInfo<T>> blocks = new ArrayList<>(blockCount).     long blockStart = 0.     for (int blockIndex = 0. blockIndex < blockCount. blockIndex++) {         if (blockIndex == blockCount - elementRemainder) {             elementsPerBlock++.         }         RandomGenerable<T> randomGenerable = next().         blocks.add(new BlockInfo<>(randomGenerable, blockIndex, blockCount, blockStart, elementsPerBlock)).         blockStart += elementsPerBlock.     }     return blocks. }
