commented;modifiers;parameterAmount;loc;comment;code
false;public;1;13;;@Override public Graph<K, Long, Double> run(Graph<K, Long, Double> graph) {     DataSet<Vertex<K, Tuple2<Long, Double>>> initializedVertices = graph.getVertices().map(new AddScoreToVertexValuesMapper<>()).     Graph<K, Tuple2<Long, Double>, Double> graphWithScoredVertices = Graph.fromDataSet(initializedVertices, graph.getEdges(), graph.getContext()).getUndirected().     return graphWithScoredVertices.runScatterGatherIteration(new LabelMessenger<>(), new VertexLabelUpdater<>(delta), maxIterations).mapVertices(new RemoveScoreFromVertexValuesMapper<>()). }
false;public;1;8;;@Override public void sendMessages(Vertex<K, Tuple2<Long, Double>> vertex) throws Exception {     for (Edge<K, Double> edge : getEdges()) {         sendMessageTo(edge.getTarget(), new Tuple2<>(vertex.getValue().f0, vertex.getValue().f1 * edge.getValue())).     } }
false;public;2;58;;@Override public void updateVertex(Vertex<K, Tuple2<Long, Double>> vertex, MessageIterator<Tuple2<Long, Double>> inMessages) throws Exception {     // we would like these two maps to be ordered     Map<Long, Double> receivedLabelsWithScores = new TreeMap<>().     Map<Long, Double> labelsWithHighestScore = new TreeMap<>().     for (Tuple2<Long, Double> message : inMessages) {         // split the message into received label and score         long receivedLabel = message.f0.         double receivedScore = message.f1.         // if the label was received before         if (receivedLabelsWithScores.containsKey(receivedLabel)) {             double newScore = receivedScore + receivedLabelsWithScores.get(receivedLabel).             receivedLabelsWithScores.put(receivedLabel, newScore).         } else {             // first time we see the label             receivedLabelsWithScores.put(receivedLabel, receivedScore).         }         // store the labels with the highest scores         if (labelsWithHighestScore.containsKey(receivedLabel)) {             double currentScore = labelsWithHighestScore.get(receivedLabel).             if (currentScore < receivedScore) {                 // record the highest score                 labelsWithHighestScore.put(receivedLabel, receivedScore).             }         } else {             // first time we see this label             labelsWithHighestScore.put(receivedLabel, receivedScore).         }     }     if (receivedLabelsWithScores.size() > 0) {         // find the label with the highest score from the ones received         double maxScore = -Double.MAX_VALUE.         long maxScoreLabel = vertex.getValue().f0.         for (long curLabel : receivedLabelsWithScores.keySet()) {             if (receivedLabelsWithScores.get(curLabel) > maxScore) {                 maxScore = receivedLabelsWithScores.get(curLabel).                 maxScoreLabel = curLabel.             }         }         // find the highest score of maxScoreLabel         double highestScore = labelsWithHighestScore.get(maxScoreLabel).         // re-score the new label         if (maxScoreLabel != vertex.getValue().f0) {             highestScore -= delta / getSuperstepNumber().         }         // else delta = 0         // update own label         setNewVertexValue(new Tuple2<>(maxScoreLabel, highestScore)).     } }
false;public;1;3;;public Vertex<K, Tuple2<Long, Double>> map(Vertex<K, Long> vertex) {     return new Vertex<>(vertex.getId(), new Tuple2<>(vertex.getValue(), 1.0)). }
false;public;1;4;;@Override public Long map(Vertex<K, Tuple2<Long, Double>> vertex) throws Exception {     return vertex.getValue().f0. }
