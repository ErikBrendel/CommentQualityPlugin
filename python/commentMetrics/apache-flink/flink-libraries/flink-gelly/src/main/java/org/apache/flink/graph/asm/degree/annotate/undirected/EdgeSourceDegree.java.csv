commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * The degree can be counted from either the edge source or target IDs.  * By default the source IDs are counted. Reducing on target IDs may  * optimize the algorithm if the input edge list is sorted by target ID.  *  * @param reduceOnTargetId set to {@code true} if the input edge list  *                         is sorted by target ID  * @return this  */ ;/**  * The degree can be counted from either the edge source or target IDs.  * By default the source IDs are counted. Reducing on target IDs may  * optimize the algorithm if the input edge list is sorted by target ID.  *  * @param reduceOnTargetId set to {@code true} if the input edge list  *                         is sorted by target ID  * @return this  */ public EdgeSourceDegree<K, VV, EV> setReduceOnTargetId(boolean reduceOnTargetId) {     this.reduceOnTargetId.set(reduceOnTargetId).     return this. }
false;protected;1;8;;@Override protected void mergeConfiguration(GraphAlgorithmWrappingBase other) {     super.mergeConfiguration(other).     EdgeSourceDegree rhs = (EdgeSourceDegree) other.     reduceOnTargetId.mergeWith(rhs.reduceOnTargetId). }
false;public;1;18;;@Override public DataSet<Edge<K, Tuple2<EV, LongValue>>> runInternal(Graph<K, VV, EV> input) throws Exception {     // s, d(s)     DataSet<Vertex<K, LongValue>> vertexDegrees = input.run(new VertexDegree<K, VV, EV>().setReduceOnTargetId(reduceOnTargetId.get()).setParallelism(parallelism)).     // s, t, d(s)     return input.getEdges().join(vertexDegrees, JoinHint.REPARTITION_HASH_SECOND).where(0).equalTo(0).with(new JoinEdgeWithVertexDegree<>()).setParallelism(parallelism).name("Edge source degree"). }
