commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * By default only the edge set is processed for the computation of degree.  * When this flag is set an additional join is performed against the vertex  * set in order to output vertices with a degree of zero.  *  * @param includeZeroDegreeVertices whether to output vertices with a  *                                  degree of zero  * @return this  */ ;/**  * By default only the edge set is processed for the computation of degree.  * When this flag is set an additional join is performed against the vertex  * set in order to output vertices with a degree of zero.  *  * @param includeZeroDegreeVertices whether to output vertices with a  *                                  degree of zero  * @return this  */ public VertexMetrics<K, VV, EV> setIncludeZeroDegreeVertices(boolean includeZeroDegreeVertices) {     this.includeZeroDegreeVertices = includeZeroDegreeVertices.     return this. }
false;public;1;18;;@Override public VertexMetrics<K, VV, EV> run(Graph<K, VV, EV> input) throws Exception {     super.run(input).     DataSet<Vertex<K, Degrees>> vertexDegree = input.run(new VertexDegrees<K, VV, EV>().setIncludeZeroDegreeVertices(includeZeroDegreeVertices).setParallelism(parallelism)).     vertexMetricsHelper = new VertexMetricsHelper<>().     vertexDegree.output(vertexMetricsHelper).name("Vertex metrics").     return this. }
false;public;0;15;;@Override public Result getResult() {     long vertexCount = vertexMetricsHelper.getAccumulator(env, VERTEX_COUNT).     long unidirectionalEdgeCount = vertexMetricsHelper.getAccumulator(env, UNIDIRECTIONAL_EDGE_COUNT).     long bidirectionalEdgeCount = vertexMetricsHelper.getAccumulator(env, BIDIRECTIONAL_EDGE_COUNT).     long tripletCount = vertexMetricsHelper.getAccumulator(env, TRIPLET_COUNT).     long maximumDegree = vertexMetricsHelper.getAccumulator(env, MAXIMUM_DEGREE).     long maximumOutDegree = vertexMetricsHelper.getAccumulator(env, MAXIMUM_OUT_DEGREE).     long maximumInDegree = vertexMetricsHelper.getAccumulator(env, MAXIMUM_IN_DEGREE).     long maximumTriplets = vertexMetricsHelper.getAccumulator(env, MAXIMUM_TRIPLETS).     // each edge is counted twice, once from each vertex, so must be halved     return new Result(vertexCount, unidirectionalEdgeCount / 2, bidirectionalEdgeCount / 2, tripletCount, maximumDegree, maximumOutDegree, maximumInDegree, maximumTriplets). }
false;public;1;18;;@Override public void writeRecord(Vertex<T, Degrees> record) throws IOException {     long degree = record.f1.getDegree().getValue().     long outDegree = record.f1.getOutDegree().getValue().     long inDegree = record.f1.getInDegree().getValue().     long bidirectionalEdges = outDegree + inDegree - degree.     long triplets = degree * (degree - 1) / 2.     vertexCount++.     unidirectionalEdgeCount += degree - bidirectionalEdges.     bidirectionalEdgeCount += bidirectionalEdges.     tripletCount += triplets.     maximumDegree = Math.max(maximumDegree, degree).     maximumOutDegree = Math.max(maximumOutDegree, outDegree).     maximumInDegree = Math.max(maximumInDegree, inDegree).     maximumTriplets = Math.max(maximumTriplets, triplets). }
false;public;0;11;;@Override public void close() throws IOException {     addAccumulator(VERTEX_COUNT, new LongCounter(vertexCount)).     addAccumulator(UNIDIRECTIONAL_EDGE_COUNT, new LongCounter(unidirectionalEdgeCount)).     addAccumulator(BIDIRECTIONAL_EDGE_COUNT, new LongCounter(bidirectionalEdgeCount)).     addAccumulator(TRIPLET_COUNT, new LongCounter(tripletCount)).     addAccumulator(MAXIMUM_DEGREE, new LongMaximum(maximumDegree)).     addAccumulator(MAXIMUM_OUT_DEGREE, new LongMaximum(maximumOutDegree)).     addAccumulator(MAXIMUM_IN_DEGREE, new LongMaximum(maximumInDegree)).     addAccumulator(MAXIMUM_TRIPLETS, new LongMaximum(maximumTriplets)). }
true;public;0;3;/**  * Get the number of vertices.  *  * @return number of vertices  */ ;/**  * Get the number of vertices.  *  * @return number of vertices  */ public long getNumberOfVertices() {     return vertexCount. }
true;public;0;3;/**  * Get the number of edges.  *  * @return number of edges  */ ;/**  * Get the number of edges.  *  * @return number of edges  */ public long getNumberOfEdges() {     return unidirectionalEdgeCount + 2 * bidirectionalEdgeCount. }
true;public;0;3;/**  * Get the number of unidirectional edges.  *  * @return number of unidirectional edges  */ ;/**  * Get the number of unidirectional edges.  *  * @return number of unidirectional edges  */ public long getNumberOfDirectedEdges() {     return unidirectionalEdgeCount. }
true;public;0;3;/**  * Get the number of bidirectional edges.  *  * @return number of bidirectional edges  */ ;/**  * Get the number of bidirectional edges.  *  * @return number of bidirectional edges  */ public long getNumberOfUndirectedEdges() {     return bidirectionalEdgeCount. }
true;public;0;3;/**  * Get the average degree, the average number of in- plus out-edges per vertex.  *  * <p>A result of {@code Float.NaN} is returned for an empty graph for  * which both the number of edges and number of vertices is zero.  *  * @return average degree  */ ;/**  * Get the average degree, the average number of in- plus out-edges per vertex.  *  * <p>A result of {@code Float.NaN} is returned for an empty graph for  * which both the number of edges and number of vertices is zero.  *  * @return average degree  */ public double getAverageDegree() {     return vertexCount == 0 ? Double.NaN : getNumberOfEdges() / (double) vertexCount. }
true;public;0;3;/**  * Get the density, the ratio of actual to potential edges between vertices.  *  * <p>A result of {@code Float.NaN} is returned for a graph with fewer than  * two vertices for which the number of edges is zero.  *  * @return density  */ ;/**  * Get the density, the ratio of actual to potential edges between vertices.  *  * <p>A result of {@code Float.NaN} is returned for a graph with fewer than  * two vertices for which the number of edges is zero.  *  * @return density  */ public double getDensity() {     return vertexCount <= 1 ? Double.NaN : getNumberOfEdges() / (double) (vertexCount * (vertexCount - 1)). }
true;public;0;3;/**  * Get the number of triplets.  *  * @return number of triplets  */ ;/**  * Get the number of triplets.  *  * @return number of triplets  */ public long getNumberOfTriplets() {     return tripletCount. }
true;public;0;3;/**  * Get the maximum degree.  *  * @return maximum degree  */ ;/**  * Get the maximum degree.  *  * @return maximum degree  */ public long getMaximumDegree() {     return maximumDegree. }
true;public;0;3;/**  * Get the maximum out degree.  *  * @return maximum out degree  */ ;/**  * Get the maximum out degree.  *  * @return maximum out degree  */ public long getMaximumOutDegree() {     return maximumOutDegree. }
true;public;0;3;/**  * Get the maximum in degree.  *  * @return maximum in degree  */ ;/**  * Get the maximum in degree.  *  * @return maximum in degree  */ public long getMaximumInDegree() {     return maximumInDegree. }
true;public;0;3;/**  * Get the maximum triplets.  *  * @return maximum triplets  */ ;/**  * Get the maximum triplets.  *  * @return maximum triplets  */ public long getMaximumTriplets() {     return maximumTriplets. }
false;public;0;4;;@Override public String toString() {     return toPrintableString(). }
false;public;0;20;;@Override public String toPrintableString() {     NumberFormat nf = NumberFormat.getInstance().     // format for very small fractional numbers     NumberFormat ff = NumberFormat.getInstance().     ff.setMaximumFractionDigits(8).     return "vertex count: " + nf.format(vertexCount) + ". edge count: " + nf.format(getNumberOfEdges()) + ". unidirectional edge count: " + nf.format(unidirectionalEdgeCount) + ". bidirectional edge count: " + nf.format(bidirectionalEdgeCount) + ". average degree: " + nf.format(getAverageDegree()) + ". density: " + ff.format(getDensity()) + ". triplet count: " + nf.format(tripletCount) + ". maximum degree: " + nf.format(maximumDegree) + ". maximum out degree: " + nf.format(maximumOutDegree) + ". maximum in degree: " + nf.format(maximumInDegree) + ". maximum triplets: " + nf.format(maximumTriplets). }
false;public;0;13;;@Override public int hashCode() {     return new HashCodeBuilder().append(vertexCount).append(unidirectionalEdgeCount).append(bidirectionalEdgeCount).append(tripletCount).append(maximumDegree).append(maximumOutDegree).append(maximumInDegree).append(maximumTriplets).hashCode(). }
false;public;1;27;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (obj == this) {         return true.     }     if (obj.getClass() != getClass()) {         return false.     }     Result rhs = (Result) obj.     return new EqualsBuilder().append(vertexCount, rhs.vertexCount).append(unidirectionalEdgeCount, rhs.unidirectionalEdgeCount).append(bidirectionalEdgeCount, rhs.bidirectionalEdgeCount).append(tripletCount, rhs.tripletCount).append(maximumDegree, rhs.maximumDegree).append(maximumOutDegree, rhs.maximumOutDegree).append(maximumInDegree, rhs.maximumInDegree).append(maximumTriplets, rhs.maximumTriplets).isEquals(). }
