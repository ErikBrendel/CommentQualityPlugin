commented;modifiers;parameterAmount;loc;comment;code
false;public;1;48;;/* 	 * Implementation notes: 	 * 	 * The requirement that "K extends CopyableValue<K>" can be removed when 	 *   Flink has a self-join and GenerateTriplets is implemented as such. 	 * 	 * ProjectTriangles should eventually be replaced by ".projectFirst("*")" 	 *   when projections use code generation. 	 */ @Override public DataSet<Result<K>> runInternal(Graph<K, VV, EV> input) throws Exception {     // u, v where u < v     DataSet<Tuple2<K, K>> filteredByID = input.getEdges().flatMap(new FilterByID<>()).setParallelism(parallelism).name("Filter by ID").     // u, v, (edge value, deg(u), deg(v))     DataSet<Edge<K, Tuple3<EV, LongValue, LongValue>>> pairDegree = input.run(new EdgeDegreePair<K, VV, EV>().setParallelism(parallelism)).     // u, v where deg(u) < deg(v) or (deg(u) == deg(v) and u < v)     DataSet<Tuple2<K, K>> filteredByDegree = pairDegree.flatMap(new FilterByDegree<>()).setParallelism(parallelism).name("Filter by degree").     // u, v, w where (u, v) and (u, w) are edges in graph, v < w     DataSet<Tuple3<K, K, K>> triplets = filteredByDegree.groupBy(0).sortGroup(1, Order.ASCENDING).reduceGroup(new GenerateTriplets<>()).name("Generate triplets").     // u, v, w where (u, v), (u, w), and (v, w) are edges in graph, v < w     DataSet<Result<K>> triangles = triplets.join(filteredByID, JoinOperatorBase.JoinHint.REPARTITION_HASH_SECOND).where(1, 2).equalTo(0, 1).with(new ProjectTriangles<>()).name("Triangle listing").     if (permuteResults) {         triangles = triangles.flatMap(new PermuteResult<>()).name("Permute triangle vertices").     } else if (sortTriangleVertices.get()) {         triangles = triangles.map(new SortTriangleVertices<>()).name("Sort triangle vertices").     }     return triangles. }
false;public;2;9;;@Override public void flatMap(Edge<T, ET> value, Collector<Tuple2<T, T>> out) throws Exception {     if (value.f0.compareTo(value.f1) < 0) {         edge.f0 = value.f0.         edge.f1 = value.f1.         out.collect(edge).     } }
false;public;2;14;;@Override public void flatMap(Edge<T, Tuple3<ET, LongValue, LongValue>> value, Collector<Tuple2<T, T>> out) throws Exception {     Tuple3<ET, LongValue, LongValue> degrees = value.f2.     long sourceDegree = degrees.f1.getValue().     long targetDegree = degrees.f2.getValue().     if (sourceDegree < targetDegree || (sourceDegree == targetDegree && value.f0.compareTo(value.f1) < 0)) {         edge.f0 = value.f0.         edge.f1 = value.f1.         out.collect(edge).     } }
false;public;2;31;;@Override public void reduce(Iterable<Tuple2<T, T>> values, Collector<Tuple3<T, T, T>> out) throws Exception {     int visitedCount = 0.     Iterator<Tuple2<T, T>> iter = values.iterator().     while (true) {         Tuple2<T, T> edge = iter.next().         output.f0 = edge.f0.         output.f2 = edge.f1.         for (int i = 0. i < visitedCount. i++) {             output.f1 = visited.get(i).             out.collect(output).         }         if (!iter.hasNext()) {             break.         }         if (visitedCount == visited.size()) {             visited.add(edge.f1.copy()).         } else {             edge.f1.copyTo(visited.get(visitedCount)).         }         visitedCount += 1.     } }
false;public;2;8;;@Override public Result<T> join(Tuple3<T, T, T> triplet, Tuple2<T, T> edge) throws Exception {     output.setVertexId0(triplet.f0).     output.setVertexId1(triplet.f1).     output.setVertexId2(triplet.f2).     return output. }
false;public;2;43;;@Override public void flatMap(Result<T> value, Collector<Result<T>> out) throws Exception {     T tmp.     // 0, 1, 2     out.collect(value).     tmp = value.getVertexId0().     value.setVertexId0(value.getVertexId1()).     value.setVertexId1(tmp).     // 1, 0, 2     out.collect(value).     tmp = value.getVertexId1().     value.setVertexId1(value.getVertexId2()).     value.setVertexId2(tmp).     // 1, 2, 0     out.collect(value).     tmp = value.getVertexId0().     value.setVertexId0(value.getVertexId2()).     value.setVertexId2(tmp).     // 0, 2, 1     out.collect(value).     tmp = value.getVertexId0().     value.setVertexId0(value.getVertexId1()).     value.setVertexId1(tmp).     // 2, 0, 1     out.collect(value).     tmp = value.getVertexId1().     value.setVertexId1(value.getVertexId2()).     value.setVertexId2(tmp).     // 2, 1, 0     out.collect(value). }
false;public;1;18;;@Override public Result<T> map(Result<T> value) throws Exception {     // by the triangle listing algorithm we know f1 < f2     if (value.getVertexId0().compareTo(value.getVertexId1()) > 0) {         T tempVal = value.getVertexId0().         value.setVertexId0(value.getVertexId1()).         if (tempVal.compareTo(value.getVertexId2()) <= 0) {             value.setVertexId1(tempVal).         } else {             value.setVertexId1(value.getVertexId2()).             value.setVertexId2(tempVal).         }     }     return value. }
false;public;0;7;;@Override public String toString() {     return "(" + getVertexId0() + "," + getVertexId1() + "," + getVertexId2() + ")". }
false;public;0;6;;@Override public String toPrintableString() {     return "1st vertex ID: " + getVertexId0() + ", 2nd vertex ID: " + getVertexId1() + ", 3rd vertex ID: " + getVertexId2(). }
false;public;0;12;;@Override public int hashCode() {     if (hasher == null) {         hasher = new MurmurHash(HASH_SEED).     }     return hasher.reset().hash(getVertexId0().hashCode()).hash(getVertexId1().hashCode()).hash(getVertexId2().hashCode()).hash(). }
