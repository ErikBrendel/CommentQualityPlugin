commented;modifiers;parameterAmount;loc;comment;code
true;public;1;8;/**  * Set the parallelism for this algorithm's operators. This parameter is  * necessary because processing a small amount of data with high operator  * parallelism is slow and wasteful with memory and buffers.  *  * <p>Operator parallelism should be set to this given value unless  * processing asymptotically more data, in which case the default job  * parallelism should be inherited.  *  * @param parallelism operator parallelism  * @return this  */ ;/**  * Set the parallelism for this algorithm's operators. This parameter is  * necessary because processing a small amount of data with high operator  * parallelism is slow and wasteful with memory and buffers.  *  * <p>Operator parallelism should be set to this given value unless  * processing asymptotically more data, in which case the default job  * parallelism should be inherited.  *  * @param parallelism operator parallelism  * @return this  */ public GraphAlgorithmWrappingBase<K, VV, EV, R> setParallelism(int parallelism) {     Preconditions.checkArgument(parallelism > 0 || parallelism == PARALLELISM_DEFAULT, "The parallelism must be at least one, or ExecutionConfig.PARALLELISM_DEFAULT (use system default).").     this.parallelism = parallelism.     return this. }
true;public;0;3;/**  *  Algorithms are identified by name rather than by class to allow subclassing.  *  *  @return name of the algorithm, which may be shared by multiple classes  * 		 implementing the same algorithm and generating the same output  */ ;/**  *  Algorithms are identified by name rather than by class to allow subclassing.  *  *  @return name of the algorithm, which may be shared by multiple classes  * 		 implementing the same algorithm and generating the same output  */ public String getAlgorithmName() {     return this.getClass().getName(). }
true;protected;1;5;/**  * First test whether the algorithm configurations can be merged before the  * call to {@link #mergeConfiguration}.  *  * @param other the algorithm with which to compare configuration  * @return true if and only if configuration can be merged and the  *         algorithm's output can be reused  *  * @see #mergeConfiguration(GraphAlgorithmWrappingBase)  */ ;/**  * First test whether the algorithm configurations can be merged before the  * call to {@link #mergeConfiguration}.  *  * @param other the algorithm with which to compare configuration  * @return true if and only if configuration can be merged and the  *         algorithm's output can be reused  *  * @see #mergeConfiguration(GraphAlgorithmWrappingBase)  */ protected boolean canMergeConfigurationWith(GraphAlgorithmWrappingBase other) {     Preconditions.checkNotNull(other).     return this.getClass().equals(other.getClass()). }
true;protected;1;6;/**  * Merge the other configuration into this algorithm's after the call to  * {@link #canMergeConfigurationWith} has checked that the configurations  * can be merged.  *  * @param other the algorithm from which to merge configuration  *  * @see #canMergeConfigurationWith(GraphAlgorithmWrappingBase)  */ ;/**  * Merge the other configuration into this algorithm's after the call to  * {@link #canMergeConfigurationWith} has checked that the configurations  * can be merged.  *  * @param other the algorithm from which to merge configuration  *  * @see #canMergeConfigurationWith(GraphAlgorithmWrappingBase)  */ protected void mergeConfiguration(GraphAlgorithmWrappingBase other) {     Preconditions.checkNotNull(other).     parallelism = (parallelism == PARALLELISM_DEFAULT) ? other.parallelism : ((other.parallelism == PARALLELISM_DEFAULT) ? parallelism : Math.min(parallelism, other.parallelism)). }
