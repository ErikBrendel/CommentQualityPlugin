commented;modifiers;parameterAmount;loc;comment;code
true;public;2;10;/**  * Required configuration for each range of offsets in the graph.  *  * @param offset first offset appointing the vertices' position  * @param length number of contiguous offsets in range  * @return this  */ ;/**  * Required configuration for each range of offsets in the graph.  *  * @param offset first offset appointing the vertices' position  * @param length number of contiguous offsets in range  * @return this  */ public CirculantGraph addRange(long offset, long length) {     Preconditions.checkArgument(offset >= MINIMUM_OFFSET, "Range offset must be at least " + MINIMUM_OFFSET).     Preconditions.checkArgument(length <= vertexCount - offset, "Range length must not be greater than the vertex count minus the range offset.").     offsetRanges.add(new OffsetRange(offset, length)).     return this. }
false;public;0;34;;@Override public Graph<LongValue, NullValue, NullValue> generate() {     // Vertices     DataSet<Vertex<LongValue, NullValue>> vertices = GraphGeneratorUtils.vertexSequence(env, parallelism, vertexCount).     // Edges     LongValueSequenceIterator iterator = new LongValueSequenceIterator(0, this.vertexCount - 1).     // Validate ranges     Collections.sort(offsetRanges).     Iterator<OffsetRange> iter = offsetRanges.iterator().     OffsetRange lastRange = iter.next().     while (iter.hasNext()) {         OffsetRange nextRange = iter.next().         if (lastRange.overlaps(nextRange)) {             throw new IllegalArgumentException("Overlapping ranges " + lastRange + " and " + nextRange).         }         lastRange = nextRange.     }     DataSet<Edge<LongValue, NullValue>> edges = env.fromParallelCollection(iterator, LongValue.class).setParallelism(parallelism).name("Edge iterators").flatMap(new LinkVertexToOffsets(vertexCount, offsetRanges)).setParallelism(parallelism).name("Circulant graph edges").     // Graph     return Graph.fromDataSet(vertices, edges, env). }
false;public;2;16;;@Override public void flatMap(LongValue source, Collector<Edge<LongValue, NullValue>> out) throws Exception {     edge.f0 = source.     long sourceID = source.getValue().     for (OffsetRange offsetRange : offsetRanges) {         long targetID = sourceID + offsetRange.getOffset().         for (long i = offsetRange.getLength(). i > 0. i--) {             // add positive offset             target.setValue(targetID++ % vertexCount).             out.collect(edge).         }     } }
true;public;0;3;/**  * Get the range offset.  *  * @return the offset  */ ;/**  * Get the range offset.  *  * @return the offset  */ public long getOffset() {     return offset. }
true;public;0;3;/**  * Get the range length.  *  * @return the length  */ ;/**  * Get the range length.  *  * @return the length  */ public long getLength() {     return length. }
true;public;0;3;/**  * Get the offset of the last index in the range.  *  * @return last offset  */ ;/**  * Get the offset of the last index in the range.  *  * @return last offset  */ public long getLastOffset() {     return offset + length - 1. }
true;public;1;16;/**  * Return true if and only if the other range and this range share a  * common offset ID.  *  * @param other other range  * @return whether ranges are overlapping  */ ;/**  * Return true if and only if the other range and this range share a  * common offset ID.  *  * @param other other range  * @return whether ranges are overlapping  */ public boolean overlaps(OffsetRange other) {     boolean overlapping = false.     long lastOffset = getLastOffset().     long otherLastOffset = other.getLastOffset().     // check whether this range contains other     overlapping |= (offset <= other.offset && other.offset <= lastOffset).     overlapping |= (offset <= otherLastOffset && otherLastOffset <= lastOffset).     // check whether other contains this range     overlapping |= (other.offset <= offset && offset <= otherLastOffset).     overlapping |= (other.offset <= lastOffset && lastOffset <= otherLastOffset).     return overlapping. }
false;public;0;4;;@Override public String toString() {     return Long.toString(offset) + ":" + Long.toString(length). }
false;public;1;9;;@Override public int compareTo(OffsetRange o) {     int cmp = Long.compare(offset, o.offset).     if (cmp != 0) {         return cmp.     }     return Long.compare(length, o.length). }
