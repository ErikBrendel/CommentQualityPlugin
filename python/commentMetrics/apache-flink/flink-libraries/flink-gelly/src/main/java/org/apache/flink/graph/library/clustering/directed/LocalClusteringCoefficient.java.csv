commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * By default the vertex set is checked for zero degree vertices. When this  * flag is disabled only clustering coefficient scores for vertices with  * a degree of a least one will be produced.  *  * @param includeZeroDegreeVertices whether to output scores for vertices  *                                  with a degree of zero  * @return this  */ ;/**  * By default the vertex set is checked for zero degree vertices. When this  * flag is disabled only clustering coefficient scores for vertices with  * a degree of a least one will be produced.  *  * @param includeZeroDegreeVertices whether to output scores for vertices  *                                  with a degree of zero  * @return this  */ public LocalClusteringCoefficient<K, VV, EV> setIncludeZeroDegreeVertices(boolean includeZeroDegreeVertices) {     this.includeZeroDegreeVertices.set(includeZeroDegreeVertices).     return this. }
false;protected;1;10;;@Override protected boolean canMergeConfigurationWith(GraphAlgorithmWrappingBase other) {     if (!super.canMergeConfigurationWith(other)) {         return false.     }     LocalClusteringCoefficient rhs = (LocalClusteringCoefficient) other.     return !includeZeroDegreeVertices.conflictsWith(rhs.includeZeroDegreeVertices). }
false;protected;1;8;;@Override protected void mergeConfiguration(GraphAlgorithmWrappingBase other) {     super.mergeConfiguration(other).     LocalClusteringCoefficient rhs = (LocalClusteringCoefficient) other.     includeZeroDegreeVertices.mergeWith(rhs.includeZeroDegreeVertices). }
false;public;1;36;;/* 	 * Implementation notes: 	 * 	 * The requirement that "K extends CopyableValue<K>" can be removed when 	 *   removed from TriangleListing. 	 * 	 * CountVertices can be replaced by ".sum(1)" when Flink aggregators use 	 *   code generation. 	 */ @Override public DataSet<Result<K>> runInternal(Graph<K, VV, EV> input) throws Exception {     // u, v, w, bitmask     DataSet<TriangleListing.Result<K>> triangles = input.run(new TriangleListing<K, VV, EV>().setParallelism(parallelism)).     // u, edge count     DataSet<Tuple2<K, LongValue>> triangleVertices = triangles.flatMap(new SplitTriangles<>()).name("Split triangle vertices").     // u, triangle count     DataSet<Tuple2<K, LongValue>> vertexTriangleCount = triangleVertices.groupBy(0).reduce(new CountTriangles<>()).setCombineHint(CombineHint.HASH).name("Count triangles").setParallelism(parallelism).     // u, deg(u)     DataSet<Vertex<K, Degrees>> vertexDegree = input.run(new VertexDegrees<K, VV, EV>().setIncludeZeroDegreeVertices(includeZeroDegreeVertices.get()).setParallelism(parallelism)).     // u, deg(u), triangle count     return vertexDegree.leftOuterJoin(vertexTriangleCount).where(0).equalTo(0).with(new JoinVertexDegreeWithTriangleCount<>()).setParallelism(parallelism).name("Clustering coefficient"). }
false;public;2;17;;@Override public void flatMap(TriangleListing.Result<T> value, Collector<Tuple2<T, LongValue>> out) throws Exception {     byte bitmask = value.getBitmask().getValue().     output.f0 = value.getVertexId0().     output.f1 = ((bitmask & 0b000011) == 0b000011) ? two : one.     out.collect(output).     output.f0 = value.getVertexId1().     output.f1 = ((bitmask & 0b001100) == 0b001100) ? two : one.     out.collect(output).     output.f0 = value.getVertexId2().     output.f1 = ((bitmask & 0b110000) == 0b110000) ? two : one.     out.collect(output). }
false;public;2;6;;@Override public Tuple2<T, LongValue> reduce(Tuple2<T, LongValue> left, Tuple2<T, LongValue> right) throws Exception {     left.f1.setValue(left.f1.getValue() + right.f1.getValue()).     return left. }
false;public;2;9;;@Override public Result<T> join(Vertex<T, Degrees> vertexAndDegree, Tuple2<T, LongValue> vertexAndTriangleCount) throws Exception {     output.setVertexId0(vertexAndDegree.f0).     output.setDegree(vertexAndDegree.f1.f0).     output.setTriangleCount((vertexAndTriangleCount == null) ? zero : vertexAndTriangleCount.f1).     return output. }
true;public;0;3;/**  * Get the vertex degree.  *  * @return vertex degree  */ ;/**  * Get the vertex degree.  *  * @return vertex degree  */ public LongValue getDegree() {     return degree. }
true;public;1;3;/**  * Set the vertex degree.  *  * @param degree vertex degree  */ ;/**  * Set the vertex degree.  *  * @param degree vertex degree  */ public void setDegree(LongValue degree) {     this.degree = degree. }
true;public;0;3;/**  * Get the number of triangles containing this vertex. equivalently,  * this is the number of edges between neighbors of this vertex.  *  * @return triangle count  */ ;/**  * Get the number of triangles containing this vertex. equivalently,  * this is the number of edges between neighbors of this vertex.  *  * @return triangle count  */ public LongValue getTriangleCount() {     return triangleCount. }
true;public;1;3;/**  * Set the number of triangles containing this vertex. equivalently,  * this is the number of edges between neighbors of this vertex.  *  * @param triangleCount triangle count  */ ;/**  * Set the number of triangles containing this vertex. equivalently,  * this is the number of edges between neighbors of this vertex.  *  * @param triangleCount triangle count  */ public void setTriangleCount(LongValue triangleCount) {     this.triangleCount = triangleCount. }
true;public;0;6;/**  * Get the local clustering coefficient score. This is computed as the  * number of edges between neighbors, equal to the triangle count,  * divided by the number of potential edges between neighbors.  *  * <p>A score of {@code Double.NaN} is returned for a vertex with degree 1  * for which both the triangle count and number of neighbors are zero.  *  * @return local clustering coefficient score  */ ;/**  * Get the local clustering coefficient score. This is computed as the  * number of edges between neighbors, equal to the triangle count,  * divided by the number of potential edges between neighbors.  *  * <p>A score of {@code Double.NaN} is returned for a vertex with degree 1  * for which both the triangle count and number of neighbors are zero.  *  * @return local clustering coefficient score  */ public double getLocalClusteringCoefficientScore() {     long degree = getDegree().getValue().     long neighborPairs = degree * (degree - 1).     return (neighborPairs == 0) ? Double.NaN : getTriangleCount().getValue() / (double) neighborPairs. }
false;public;0;7;;@Override public String toString() {     return "(" + getVertexId0() + "," + getDegree() + "," + getTriangleCount() + ")". }
true;public;0;7;/**  * Format values into a human-readable string.  *  * @return verbose string  */ ;/**  * Format values into a human-readable string.  *  * @return verbose string  */ @Override public String toPrintableString() {     return "Vertex ID: " + getVertexId0() + ", vertex degree: " + getDegree() + ", triangle count: " + getTriangleCount() + ", local clustering coefficient: " + getLocalClusteringCoefficientScore(). }
false;public;0;12;;@Override public int hashCode() {     if (hasher == null) {         hasher = new MurmurHash(HASH_SEED).     }     return hasher.reset().hash(getVertexId0().hashCode()).hash(degree.getValue()).hash(triangleCount.getValue()).hash(). }
