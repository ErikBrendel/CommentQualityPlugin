commented;modifiers;parameterAmount;loc;comment;code
false;public;1;56;;/* 	 * Implementation notes: 	 * 	 * The requirement that "K extends CopyableValue<K>" can be removed when 	 *   Flink has a self-join and GenerateTriplets is implemented as such. 	 * 	 * ProjectTriangles should eventually be replaced by ".projectFirst("*")" 	 *   when projections use code generation. 	 */ @Override public DataSet<Result<K>> runInternal(Graph<K, VV, EV> input) throws Exception {     // u, v, bitmask where u < v     DataSet<Tuple3<K, K, ByteValue>> filteredByID = input.getEdges().map(new OrderByID<>()).setParallelism(parallelism).name("Order by ID").groupBy(0, 1).reduceGroup(new ReduceBitmask<>()).setParallelism(parallelism).name("Flatten by ID").     // u, v, (deg(u), deg(v))     DataSet<Edge<K, Tuple3<EV, Degrees, Degrees>>> pairDegrees = input.run(new EdgeDegreesPair<K, VV, EV>().setParallelism(parallelism)).     // u, v, bitmask where deg(u) < deg(v) or (deg(u) == deg(v) and u < v)     DataSet<Tuple3<K, K, ByteValue>> filteredByDegree = pairDegrees.map(new OrderByDegree<>()).setParallelism(parallelism).name("Order by degree").groupBy(0, 1).reduceGroup(new ReduceBitmask<>()).setParallelism(parallelism).name("Flatten by degree").     // u, v, w, bitmask where (u, v) and (u, w) are edges in graph     DataSet<Tuple4<K, K, K, ByteValue>> triplets = filteredByDegree.groupBy(0).sortGroup(1, Order.ASCENDING).reduceGroup(new GenerateTriplets<>()).name("Generate triplets").     // u, v, w, bitmask where (u, v), (u, w), and (v, w) are edges in graph     DataSet<Result<K>> triangles = triplets.join(filteredByID, JoinOperatorBase.JoinHint.REPARTITION_HASH_SECOND).where(1, 2).equalTo(0, 1).with(new ProjectTriangles<>()).name("Triangle listing").     if (permuteResults) {         triangles = triangles.flatMap(new PermuteResult<>()).name("Permute triangle vertices").     } else if (sortTriangleVertices.get()) {         triangles = triangles.map(new SortTriangleVertices<>()).name("Sort triangle vertices").     }     return triangles. }
false;public;1;15;;@Override public Tuple3<T, T, ByteValue> map(Edge<T, ET> value) throws Exception {     if (value.f0.compareTo(value.f1) < 0) {         output.f0 = value.f0.         output.f1 = value.f1.         output.f2 = forward.     } else {         output.f0 = value.f1.         output.f1 = value.f0.         output.f2 = reverse.     }     return output. }
false;public;2;15;;@Override public void reduce(Iterable<Tuple3<T, T, ByteValue>> values, Collector<Tuple3<T, T, ByteValue>> out) throws Exception {     Tuple3<T, T, ByteValue> output = null.     byte bitmask = 0.     for (Tuple3<T, T, ByteValue> value : values) {         output = value.         bitmask |= value.f2.getValue().     }     output.f2.setValue(bitmask).     out.collect(output). }
false;public;1;20;;@Override public Tuple3<T, T, ByteValue> map(Edge<T, Tuple3<ET, Degrees, Degrees>> value) throws Exception {     Tuple3<ET, Degrees, Degrees> degrees = value.f2.     long sourceDegree = degrees.f1.getDegree().getValue().     long targetDegree = degrees.f2.getDegree().getValue().     if (sourceDegree < targetDegree || (sourceDegree == targetDegree && value.f0.compareTo(value.f1) < 0)) {         output.f0 = value.f0.         output.f1 = value.f1.         output.f2 = forward.     } else {         output.f0 = value.f1.         output.f1 = value.f0.         output.f2 = reverse.     }     return output. }
false;public;2;41;;@Override public void reduce(Iterable<Tuple3<T, T, ByteValue>> values, Collector<Tuple4<T, T, T, ByteValue>> out) throws Exception {     int visitedCount = 0.     Iterator<Tuple3<T, T, ByteValue>> iter = values.iterator().     while (true) {         Tuple3<T, T, ByteValue> edge = iter.next().         byte bitmask = edge.f2.getValue().         output.f0 = edge.f0.         output.f2 = edge.f1.         for (int i = 0. i < visitedCount. i++) {             Tuple2<T, ByteValue> previous = visited.get(i).             output.f1 = previous.f0.             output.f3.setValue((byte) (previous.f1.getValue() | bitmask)).             // u, v, w, bitmask             out.collect(output).         }         if (!iter.hasNext()) {             break.         }         byte shiftedBitmask = (byte) (bitmask << 2).         if (visitedCount == visited.size()) {             visited.add(new Tuple2<>(edge.f1.copy(), new ByteValue(shiftedBitmask))).         } else {             Tuple2<T, ByteValue> update = visited.get(visitedCount).             edge.f1.copyTo(update.f0).             update.f1.setValue(shiftedBitmask).         }         visitedCount += 1.     } }
false;public;2;9;;@Override public Result<T> join(Tuple4<T, T, T, ByteValue> triplet, Tuple3<T, T, ByteValue> edge) throws Exception {     output.setVertexId0(triplet.f0).     output.setVertexId1(triplet.f1).     output.setVertexId2(triplet.f2).     output.setBitmask((byte) (triplet.f3.getValue() | edge.f2.getValue())).     return output. }
false;public;2;82;;@Override public void flatMap(Result<T> value, Collector<Result<T>> out) throws Exception {     T tmp.     int f0f1, f0f2, f1f2.     byte bitmask = value.getBitmask().getValue().     // 0, 1, 2     out.collect(value).     tmp = value.getVertexId0().     value.setVertexId0(value.getVertexId1()).     value.setVertexId1(tmp).     f0f1 = ((bitmask & 0b100000) >>> 1) | ((bitmask & 0b010000) << 1).     f0f2 = (bitmask & 0b001100) >>> 2.     f1f2 = (bitmask & 0b000011) << 2.     bitmask = (byte) (f0f1 | f0f2 | f1f2).     value.setBitmask(bitmask).     // 1, 0, 2     out.collect(value).     tmp = value.getVertexId1().     value.setVertexId1(value.getVertexId2()).     value.setVertexId2(tmp).     f0f1 = (bitmask & 0b110000) >>> 2.     f0f2 = (bitmask & 0b001100) << 2.     f1f2 = ((bitmask & 0b000010) >>> 1) | ((bitmask & 0b000001) << 1).     bitmask = (byte) (f0f1 | f0f2 | f1f2).     value.setBitmask(bitmask).     // 1, 2, 0     out.collect(value).     tmp = value.getVertexId0().     value.setVertexId0(value.getVertexId2()).     value.setVertexId2(tmp).     f0f1 = ((bitmask & 0b100000) >>> 5) | ((bitmask & 0b010000) >>> 3).     f0f2 = ((bitmask & 0b001000) >>> 1) | ((bitmask & 0b000100) << 1).     f1f2 = ((bitmask & 0b000010) << 3) | ((bitmask & 0b000001) << 5).     bitmask = (byte) (f0f1 | f0f2 | f1f2).     value.setBitmask(bitmask).     // 0, 2, 1     out.collect(value).     tmp = value.getVertexId0().     value.setVertexId0(value.getVertexId1()).     value.setVertexId1(tmp).     f0f1 = ((bitmask & 0b100000) >>> 1) | ((bitmask & 0b010000) << 1).     f0f2 = (bitmask & 0b001100) >>> 2.     f1f2 = (bitmask & 0b000011) << 2.     bitmask = (byte) (f0f1 | f0f2 | f1f2).     value.setBitmask(bitmask).     // 2, 0, 1     out.collect(value).     tmp = value.getVertexId1().     value.setVertexId1(value.getVertexId2()).     value.setVertexId2(tmp).     f0f1 = (bitmask & 0b110000) >>> 2.     f0f2 = (bitmask & 0b001100) << 2.     f1f2 = ((bitmask & 0b000010) >>> 1) | ((bitmask & 0b000001) << 1).     bitmask = (byte) (f0f1 | f0f2 | f1f2).     value.setBitmask(bitmask).     // 2, 1, 0     out.collect(value). }
false;public;1;32;;@Override public Result<T> map(Result<T> value) throws Exception {     // by the triangle listing algorithm we know f1 < f2     if (value.getVertexId0().compareTo(value.getVertexId1()) > 0) {         byte bitmask = value.getBitmask().getValue().         T tempVal = value.getVertexId0().         value.setVertexId0(value.getVertexId1()).         if (tempVal.compareTo(value.getVertexId2()) < 0) {             value.setVertexId1(tempVal).             int f0f1 = ((bitmask & 0b100000) >>> 1) | ((bitmask & 0b010000) << 1).             int f0f2 = (bitmask & 0b001100) >>> 2.             int f1f2 = (bitmask & 0b000011) << 2.             value.setBitmask((byte) (f0f1 | f0f2 | f1f2)).         } else {             value.setVertexId1(value.getVertexId2()).             value.setVertexId2(tempVal).             int f0f1 = (bitmask & 0b000011) << 4.             int f0f2 = ((bitmask & 0b100000) >>> 3) | ((bitmask & 0b010000) >>> 1).             int f1f2 = ((bitmask & 0b001000) >>> 3) | ((bitmask & 0b000100) >>> 1).             value.setBitmask((byte) (f0f1 | f0f2 | f1f2)).         }     }     return value. }
true;public;0;3;/**  * Get the bitmask indicating the presence of the six potential  * connecting edges.  *  * @return the edge bitmask  *  * @see EdgeOrder  */ ;/**  * Get the bitmask indicating the presence of the six potential  * connecting edges.  *  * @return the edge bitmask  *  * @see EdgeOrder  */ public ByteValue getBitmask() {     return bitmask. }
true;public;1;3;/**  * Set the bitmask indicating the presence of the six potential  * connecting edges.  *  * @param bitmask the edge bitmask  *  * @see EdgeOrder  */ ;/**  * Set the bitmask indicating the presence of the six potential  * connecting edges.  *  * @param bitmask the edge bitmask  *  * @see EdgeOrder  */ public void setBitmask(ByteValue bitmask) {     this.bitmask = bitmask. }
false;public;1;3;;public void setBitmask(byte bitmask) {     this.bitmask.setValue(bitmask). }
false;public;0;8;;@Override public String toString() {     return "(" + getVertexId0() + "," + getVertexId1() + "," + getVertexId2() + "," + bitmask + ")". }
false;public;0;11;;@Override public String toPrintableString() {     byte bitmask = getBitmask().getValue().     return "1st vertex ID: " + getVertexId0() + ", 2nd vertex ID: " + getVertexId1() + ", 3rd vertex ID: " + getVertexId2() + ", edge directions: " + getVertexId0() + maskToString(bitmask, 4) + getVertexId1() + ", " + getVertexId0() + maskToString(bitmask, 2) + getVertexId2() + ", " + getVertexId1() + maskToString(bitmask, 0) + getVertexId2(). }
false;private;2;14;;private String maskToString(byte mask, int shift) {     int edgeMask = (mask >>> shift) & 0b000011.     if (edgeMask == EdgeOrder.FORWARD.getBitmask()) {         return "->".     } else if (edgeMask == EdgeOrder.REVERSE.getBitmask()) {         return "<-".     } else if (edgeMask == EdgeOrder.MUTUAL.getBitmask()) {         return "<->".     } else {         throw new IllegalArgumentException("Bitmask is missing an edge (mask = " + mask + ", shift = " + shift + ")").     } }
false;public;0;13;;@Override public int hashCode() {     if (hasher == null) {         hasher = new MurmurHash(HASH_SEED).     }     return hasher.reset().hash(getVertexId0().hashCode()).hash(getVertexId1().hashCode()).hash(getVertexId2().hashCode()).hash(bitmask.getValue()).hash(). }
