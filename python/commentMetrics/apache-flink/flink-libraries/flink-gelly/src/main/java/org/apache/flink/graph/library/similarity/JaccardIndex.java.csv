commented;modifiers;parameterAmount;loc;comment;code
true;public;1;7;/**  * Override the default group size for the quadratic expansion of neighbor  * pairs. Small groups generate more data whereas large groups distribute  * computation less evenly among tasks.  *  * <p>The default value should be near-optimal for all use cases.  *  * @param groupSize the group size for the quadratic expansion of neighbor pairs  * @return this  */ ;/**  * Override the default group size for the quadratic expansion of neighbor  * pairs. Small groups generate more data whereas large groups distribute  * computation less evenly among tasks.  *  * <p>The default value should be near-optimal for all use cases.  *  * @param groupSize the group size for the quadratic expansion of neighbor pairs  * @return this  */ public JaccardIndex<K, VV, EV> setGroupSize(int groupSize) {     Preconditions.checkArgument(groupSize > 0, "Group size must be greater than zero").     this.groupSize = groupSize.     return this. }
true;public;2;11;/**  * Filter out Jaccard Index scores less than the given minimum fraction.  *  * @param numerator numerator of the minimum score  * @param denominator denominator of the minimum score  * @return this  * @see #setMaximumScore(int, int)  */ ;/**  * Filter out Jaccard Index scores less than the given minimum fraction.  *  * @param numerator numerator of the minimum score  * @param denominator denominator of the minimum score  * @return this  * @see #setMaximumScore(int, int)  */ public JaccardIndex<K, VV, EV> setMinimumScore(int numerator, int denominator) {     Preconditions.checkArgument(numerator >= 0, "Minimum score numerator must be non-negative").     Preconditions.checkArgument(denominator > 0, "Minimum score denominator must be greater than zero").     Preconditions.checkArgument(numerator <= denominator, "Minimum score fraction must be less than or equal to one").     this.unboundedScores = false.     this.minimumScoreNumerator = numerator.     this.minimumScoreDenominator = denominator.     return this. }
true;public;2;11;/**  * Filter out Jaccard Index scores greater than the given maximum fraction.  *  * @param numerator numerator of the maximum score  * @param denominator denominator of the maximum score  * @return this  * @see #setMinimumScore(int, int)  */ ;/**  * Filter out Jaccard Index scores greater than the given maximum fraction.  *  * @param numerator numerator of the maximum score  * @param denominator denominator of the maximum score  * @return this  * @see #setMinimumScore(int, int)  */ public JaccardIndex<K, VV, EV> setMaximumScore(int numerator, int denominator) {     Preconditions.checkArgument(numerator >= 0, "Maximum score numerator must be non-negative").     Preconditions.checkArgument(denominator > 0, "Maximum score denominator must be greater than zero").     Preconditions.checkArgument(numerator <= denominator, "Maximum score fraction must be less than or equal to one").     this.unboundedScores = false.     this.maximumScoreNumerator = numerator.     this.maximumScoreDenominator = denominator.     return this. }
true;public;1;5;/**  * By default only one result is output for each pair of vertices. When  * mirroring a second result with the vertex order flipped is output for  * each pair of vertices.  *  * @param mirrorResults whether output results should be mirrored  * @return this  */ ;/**  * By default only one result is output for each pair of vertices. When  * mirroring a second result with the vertex order flipped is output for  * each pair of vertices.  *  * @param mirrorResults whether output results should be mirrored  * @return this  */ public JaccardIndex<K, VV, EV> setMirrorResults(boolean mirrorResults) {     this.mirrorResults = mirrorResults.     return this. }
false;protected;1;15;;@Override protected boolean canMergeConfigurationWith(GraphAlgorithmWrappingBase other) {     if (!super.canMergeConfigurationWith(other)) {         return false.     }     JaccardIndex rhs = (JaccardIndex) other.     return unboundedScores == rhs.unboundedScores && minimumScoreNumerator == rhs.minimumScoreNumerator && minimumScoreDenominator == rhs.minimumScoreDenominator && maximumScoreNumerator == rhs.maximumScoreNumerator && maximumScoreDenominator == rhs.maximumScoreDenominator && mirrorResults == rhs.mirrorResults. }
false;protected;1;8;;@Override protected void mergeConfiguration(GraphAlgorithmWrappingBase other) {     super.mergeConfiguration(other).     JaccardIndex rhs = (JaccardIndex) other.     groupSize = Math.max(groupSize, rhs.groupSize). }
false;public;1;48;;/* 	 * Implementation notes: 	 * 	 * The requirement that "K extends CopyableValue<K>" can be removed when 	 *   Flink has a self-join which performs the skew distribution handled by 	 *   GenerateGroupSpans / GenerateGroups / GenerateGroupPairs. 	 */ @Override public DataSet<Result<K>> runInternal(Graph<K, VV, EV> input) throws Exception {     // s, t, d(t)     DataSet<Edge<K, Tuple2<EV, LongValue>>> neighborDegree = input.run(new EdgeTargetDegree<K, VV, EV>().setParallelism(parallelism)).     // group span, s, t, d(t)     DataSet<Tuple4<IntValue, K, K, IntValue>> groupSpans = neighborDegree.groupBy(0).sortGroup(1, Order.ASCENDING).reduceGroup(new GenerateGroupSpans<>(groupSize)).setParallelism(parallelism).name("Generate group spans").     // group, s, t, d(t)     DataSet<Tuple4<IntValue, K, K, IntValue>> groups = groupSpans.rebalance().setParallelism(parallelism).name("Rebalance").flatMap(new GenerateGroups<>()).setParallelism(parallelism).name("Generate groups").     // t, u, d(t)+d(u)     DataSet<Tuple3<K, K, IntValue>> twoPaths = groups.groupBy(0, 1).sortGroup(2, Order.ASCENDING).reduceGroup(new GenerateGroupPairs<>(groupSize)).name("Generate group pairs").     // t, u, intersection, union     DataSet<Result<K>> scores = twoPaths.groupBy(0, 1).reduceGroup(new ComputeScores<>(unboundedScores, minimumScoreNumerator, minimumScoreDenominator, maximumScoreNumerator, maximumScoreDenominator)).name("Compute scores").     if (mirrorResults) {         scores = scores.flatMap(new MirrorResult<>()).name("Mirror results").     }     return scores. }
false;public;2;27;;@Override public void reduce(Iterable<Edge<T, Tuple2<ET, LongValue>>> values, Collector<Tuple4<IntValue, T, T, IntValue>> out) throws Exception {     int groupCount = 0.     int groupSpans = 1.     groupSpansValue.setValue(groupSpans).     for (Edge<T, Tuple2<ET, LongValue>> edge : values) {         long degree = edge.f2.f1.getValue().         if (degree > Integer.MAX_VALUE) {             throw new RuntimeException("Degree overflows IntValue").         }         // group span, u, v, d(v)         output.f1 = edge.f0.         output.f2 = edge.f1.         output.f3.setValue((int) degree).         out.collect(output).         if (++groupCount == groupSize) {             groupCount = 0.             groupSpansValue.setValue(++groupSpans).         }     } }
false;public;2;10;;@Override public void flatMap(Tuple4<IntValue, T, T, IntValue> value, Collector<Tuple4<IntValue, T, T, IntValue>> out) throws Exception {     int spans = value.f0.getValue().     for (int idx = 0. idx < spans. idx++) {         value.f0.setValue(idx).         out.collect(value).     } }
false;public;2;48;;@Override public void reduce(Iterable<Tuple4<IntValue, T, T, IntValue>> values, Collector<Tuple3<T, T, IntValue>> out) throws Exception {     int visitedCount = 0.     for (Tuple4<IntValue, T, T, IntValue> edge : values) {         for (int i = 0. i < visitedCount. i++) {             Tuple3<T, T, IntValue> prior = visited.get(i).             prior.f1 = edge.f2.             int oldValue = prior.f2.getValue().             long degreeSum = oldValue + edge.f3.getValue().             if (degreeSum > Integer.MAX_VALUE) {                 throw new RuntimeException("Degree sum overflows IntValue").             }             prior.f2.setValue((int) degreeSum).             // v, w, d(v) + d(w)             out.collect(prior).             prior.f2.setValue(oldValue).         }         if (visitedCount < groupSize) {             if (!initialized) {                 initialized = true.                 for (int i = 0. i < groupSize. i++) {                     Tuple3<T, T, IntValue> tuple = new Tuple3<>().                     tuple.f0 = edge.f2.copy().                     tuple.f2 = edge.f3.copy().                     visited.add(tuple).                 }             } else {                 Tuple3<T, T, IntValue> copy = visited.get(visitedCount).                 edge.f2.copyTo(copy.f0).                 edge.f3.copyTo(copy.f2).             }             visitedCount += 1.         }     } }
false;public;2;23;;@Override public void reduce(Iterable<Tuple3<T, T, IntValue>> values, Collector<Result<T>> out) throws Exception {     int count = 0.     Tuple3<T, T, IntValue> edge = null.     for (Tuple3<T, T, IntValue> next : values) {         edge = next.         count += 1.     }     int distinctNeighbors = edge.f2.getValue() - count.     if (unboundedScores || (count * minimumScoreDenominator >= distinctNeighbors * minimumScoreNumerator && count * maximumScoreDenominator <= distinctNeighbors * maximumScoreNumerator)) {         output.setVertexId0(edge.f0).         output.setVertexId1(edge.f1).         output.setSharedNeighborCount(count).         output.setDistinctNeighborCount(distinctNeighbors).         out.collect(output).     } }
true;public;0;3;/**  * Get the shared neighbor count.  *  * @return shared neighbor count  */ ;/**  * Get the shared neighbor count.  *  * @return shared neighbor count  */ public IntValue getSharedNeighborCount() {     return sharedNeighborCount. }
true;public;1;3;/**  * Set the shared neighbor count.  *  * @param sharedNeighborCount the shared neighbor count  */ ;/**  * Set the shared neighbor count.  *  * @param sharedNeighborCount the shared neighbor count  */ public void setSharedNeighborCount(IntValue sharedNeighborCount) {     this.sharedNeighborCount = sharedNeighborCount. }
false;private;1;3;;private void setSharedNeighborCount(int sharedNeighborCount) {     this.sharedNeighborCount.setValue(sharedNeighborCount). }
true;public;0;3;/**  * Get the distinct neighbor count.  *  * @return distinct neighbor count  */ ;/**  * Get the distinct neighbor count.  *  * @return distinct neighbor count  */ public IntValue getDistinctNeighborCount() {     return distinctNeighborCount. }
true;public;1;3;/**  * Set the distinct neighbor count.  *  * @param distinctNeighborCount the distinct neighbor count  */ ;/**  * Set the distinct neighbor count.  *  * @param distinctNeighborCount the distinct neighbor count  */ public void setDistinctNeighborCount(IntValue distinctNeighborCount) {     this.distinctNeighborCount = distinctNeighborCount. }
false;private;1;3;;private void setDistinctNeighborCount(int distinctNeighborCount) {     this.distinctNeighborCount.setValue(distinctNeighborCount). }
true;public;0;3;/**  * Get the Jaccard Index score, equal to the number of shared neighbors  * of the source and target vertices divided by the number of distinct  * neighbors.  *  * @return Jaccard Index score  */ ;/**  * Get the Jaccard Index score, equal to the number of shared neighbors  * of the source and target vertices divided by the number of distinct  * neighbors.  *  * @return Jaccard Index score  */ public double getJaccardIndexScore() {     return getSharedNeighborCount().getValue() / (double) getDistinctNeighborCount().getValue(). }
false;public;0;8;;@Override public String toString() {     return "(" + getVertexId0() + "," + getVertexId1() + "," + getSharedNeighborCount() + "," + getDistinctNeighborCount() + ")". }
false;public;0;7;;@Override public String toPrintableString() {     return "Vertex IDs: (" + getVertexId0() + ", " + getVertexId1() + "), number of shared neighbors: " + getSharedNeighborCount() + ", number of distinct neighbors: " + getDistinctNeighborCount() + ", jaccard index score: " + getJaccardIndexScore(). }
false;public;1;10;;@Override public int compareTo(Result<T> o) {     // exact comparison of a/b with x/y using only integer math:     // a/b <?> x/y == a*y <?> b*x     long ay = sharedNeighborCount.getValue() * (long) o.distinctNeighborCount.getValue().     long bx = distinctNeighborCount.getValue() * (long) o.sharedNeighborCount.getValue().     return Long.compare(ay, bx). }
false;public;0;13;;@Override public int hashCode() {     if (hasher == null) {         hasher = new MurmurHash(HASH_SEED).     }     return hasher.reset().hash(getVertexId0().hashCode()).hash(getVertexId1().hashCode()).hash(sharedNeighborCount.getValue()).hash(distinctNeighborCount.getValue()).hash(). }
