commented;modifiers;parameterAmount;loc;comment;code
false;public;1;24;;@Override public DataSet<Tuple3<K, K, K>> run(Graph<K, VV, EV> input) throws Exception {     DataSet<Edge<K, EV>> edges = input.getEdges().     // annotate edges with degrees     DataSet<EdgeWithDegrees<K>> edgesWithDegrees = edges.flatMap(new EdgeDuplicator<>()).groupBy(0).sortGroup(1, Order.ASCENDING).reduceGroup(new DegreeCounter<>()).groupBy(EdgeWithDegrees.V1, EdgeWithDegrees.V2).reduce(new DegreeJoiner<>()).     // project edges by degrees     DataSet<Edge<K, NullValue>> edgesByDegree = edgesWithDegrees.map(new EdgeByDegreeProjector<>()).     // project edges by vertex id     DataSet<Edge<K, NullValue>> edgesById = edgesByDegree.map(new EdgeByIdProjector<>()).     DataSet<Tuple3<K, K, K>> triangles = edgesByDegree.groupBy(EdgeWithDegrees.V1).sortGroup(EdgeWithDegrees.V2, Order.ASCENDING).reduceGroup(new TriadBuilder<>()).join(edgesById, JoinHint.REPARTITION_HASH_SECOND).where(Triad.V2, Triad.V3).equalTo(0, 1).with(new TriadFilter<>()).     return triangles. }
false;public;2;6;;@Override public void flatMap(Edge<K, EV> edge, Collector<Edge<K, EV>> out) throws Exception {     out.collect(edge).     Edge<K, EV> reversed = edge.reverse().     out.collect(reversed). }
false;public;2;38;;@Override public void reduce(Iterable<Edge<K, EV>> edgesIter, Collector<EdgeWithDegrees<K>> out) {     Iterator<Edge<K, EV>> edges = edgesIter.iterator().     otherVertices.clear().     // get first edge     Edge<K, EV> edge = edges.next().     K groupVertex = edge.getSource().     this.otherVertices.add(edge.getTarget()).     // get all other edges (assumes edges are sorted by second vertex)     while (edges.hasNext()) {         edge = edges.next().         K otherVertex = edge.getTarget().         // collect unique vertices         if (!otherVertices.contains(otherVertex) && otherVertex != groupVertex) {             this.otherVertices.add(otherVertex).         }     }     int degree = this.otherVertices.size().     // emit edges     for (K otherVertex : this.otherVertices) {         if (groupVertex.compareTo(otherVertex) < 0) {             outputEdge.setFirstVertex(groupVertex).             outputEdge.setFirstDegree(degree).             outputEdge.setSecondVertex(otherVertex).             outputEdge.setSecondDegree(0).         } else {             outputEdge.setFirstVertex(otherVertex).             outputEdge.setFirstDegree(0).             outputEdge.setSecondVertex(groupVertex).             outputEdge.setSecondDegree(degree).         }         out.collect(outputEdge).     } }
false;public;2;15;;@Override public EdgeWithDegrees<K> reduce(EdgeWithDegrees<K> edge1, EdgeWithDegrees<K> edge2) throws Exception {     // copy first edge     outEdge.copyFrom(edge1).     // set missing degree     if (edge1.getFirstDegree() == 0 && edge1.getSecondDegree() != 0) {         outEdge.setFirstDegree(edge2.getFirstDegree()).     } else if (edge1.getFirstDegree() != 0 && edge1.getSecondDegree() == 0) {         outEdge.setSecondDegree(edge2.getSecondDegree()).     }     return outEdge. }
false;public;1;16;;@Override public Edge<K, NullValue> map(EdgeWithDegrees<K> inEdge) throws Exception {     // copy vertices to simple edge     outEdge.setSource(inEdge.getFirstVertex()).     outEdge.setTarget(inEdge.getSecondVertex()).     outEdge.setValue(NullValue.getInstance()).     // flip vertices if first degree is larger than second degree.     if (inEdge.getFirstDegree() > inEdge.getSecondDegree()) {         outEdge = outEdge.reverse().     }     // return edge     return outEdge. }
false;public;1;10;;@Override public Edge<K, NullValue> map(Edge<K, NullValue> inEdge) throws Exception {     // flip vertices if necessary     if (inEdge.getSource().compareTo(inEdge.getTarget()) > 0) {         inEdge = inEdge.reverse().     }     return inEdge. }
false;public;2;25;;@Override public void reduce(Iterable<Edge<K, NullValue>> edgesIter, Collector<Triad<K>> out) throws Exception {     final Iterator<Edge<K, NullValue>> edges = edgesIter.iterator().     // clear vertex list     vertices.clear().     // read first edge     Edge<K, NullValue> firstEdge = edges.next().     outTriad.setFirstVertex(firstEdge.getSource()).     vertices.add(firstEdge.getTarget()).     // build and emit triads     while (edges.hasNext()) {         K higherVertexId = edges.next().getTarget().         // combine vertex with all previously read vertices         for (K lowerVertexId : vertices) {             outTriad.setSecondVertex(lowerVertexId).             outTriad.setThirdVertex(higherVertexId).             out.collect(outTriad).         }         vertices.add(higherVertexId).     } }
false;public;2;4;;@Override public Tuple3<K, K, K> join(Triad<K> triad, Edge<K, NullValue> edge) throws Exception {     return new Tuple3<>(triad.getFirstVertex(), triad.getSecondVertex(), triad.getThirdVertex()). }
false;public;0;3;;public K getFirstVertex() {     return this.getField(V1). }
false;public;0;3;;public K getSecondVertex() {     return this.getField(V2). }
false;public;0;3;;public Integer getFirstDegree() {     return this.getField(D1). }
false;public;0;3;;public Integer getSecondDegree() {     return this.getField(D2). }
false;public;1;3;;public void setFirstVertex(final K vertex1) {     this.setField(vertex1, V1). }
false;public;1;3;;public void setSecondVertex(final K vertex2) {     this.setField(vertex2, V2). }
false;public;1;3;;public void setFirstDegree(final Integer degree1) {     this.setField(degree1, D1). }
false;public;1;3;;public void setSecondDegree(final Integer degree2) {     this.setField(degree2, D2). }
false;public;1;6;;public void copyFrom(final EdgeWithDegrees<K> edge) {     this.setFirstVertex(edge.getFirstVertex()).     this.setSecondVertex(edge.getSecondVertex()).     this.setFirstDegree(edge.getFirstDegree()).     this.setSecondDegree(edge.getSecondDegree()). }
false;public;0;3;;public K getFirstVertex() {     return this.getField(V1). }
false;public;0;3;;public K getSecondVertex() {     return this.getField(V2). }
false;public;0;3;;public K getThirdVertex() {     return this.getField(V3). }
false;public;1;3;;public void setFirstVertex(final K vertex1) {     this.setField(vertex1, V1). }
false;public;1;3;;public void setSecondVertex(final K vertex2) {     this.setField(vertex2, V2). }
false;public;1;3;;public void setThirdVertex(final K vertex3) {     this.setField(vertex3, V3). }
