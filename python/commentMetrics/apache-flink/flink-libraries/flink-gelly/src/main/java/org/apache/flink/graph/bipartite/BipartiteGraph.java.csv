commented;modifiers;parameterAmount;loc;comment;code
true;public,static;4;7;/**  * Create bipartite graph from datasets.  *  * @param topVertices dataset of top vertices in the graph  * @param bottomVertices dataset of bottom vertices in the graph  * @param edges dataset of edges between vertices  * @param context Flink execution context  * @return new bipartite graph created from provided datasets  */ ;/**  * Create bipartite graph from datasets.  *  * @param topVertices dataset of top vertices in the graph  * @param bottomVertices dataset of bottom vertices in the graph  * @param edges dataset of edges between vertices  * @param context Flink execution context  * @return new bipartite graph created from provided datasets  */ public static <KT, KB, VVT, VVB, EV> BipartiteGraph<KT, KB, VVT, VVB, EV> fromDataSet(DataSet<Vertex<KT, VVT>> topVertices, DataSet<Vertex<KB, VVB>> bottomVertices, DataSet<BipartiteEdge<KT, KB, EV>> edges, ExecutionEnvironment context) {     return new BipartiteGraph<>(topVertices, bottomVertices, edges, context). }
true;public;0;3;/**  * Get dataset with top vertices.  *  * @return dataset with top vertices  */ ;/**  * Get dataset with top vertices.  *  * @return dataset with top vertices  */ public DataSet<Vertex<KT, VVT>> getTopVertices() {     return topVertices. }
true;public;0;3;/**  * Get dataset with bottom vertices.  *  * @return dataset with bottom vertices  */ ;/**  * Get dataset with bottom vertices.  *  * @return dataset with bottom vertices  */ public DataSet<Vertex<KB, VVB>> getBottomVertices() {     return bottomVertices. }
true;public;0;3;/**  * Get dataset with graph edges.  *  * @return dataset with graph edges  */ ;/**  * Get dataset with graph edges.  *  * @return dataset with graph edges  */ public DataSet<BipartiteEdge<KT, KB, EV>> getEdges() {     return edges. }
true;public;0;9;/**  * Convert a bipartite graph into an undirected graph that contains only top vertices. An edge between two vertices  * in the new graph will exist only if the original bipartite graph contains a bottom vertex they are both  * connected to.  *  * <p>The simple projection performs a single join and returns edges containing the bipartite edge values.  *  * <p>Note: KT must override .equals(). This requirement may be removed in a future release.  *  * @return simple top projection of the bipartite graph  */ ;/**  * Convert a bipartite graph into an undirected graph that contains only top vertices. An edge between two vertices  * in the new graph will exist only if the original bipartite graph contains a bottom vertex they are both  * connected to.  *  * <p>The simple projection performs a single join and returns edges containing the bipartite edge values.  *  * <p>Note: KT must override .equals(). This requirement may be removed in a future release.  *  * @return simple top projection of the bipartite graph  */ public Graph<KT, VVT, Tuple2<EV, EV>> projectionTopSimple() {     DataSet<Edge<KT, Tuple2<EV, EV>>> newEdges = edges.join(edges).where(1).equalTo(1).with(new ProjectionTopSimple<>()).name("Simple top projection").     return Graph.fromDataSet(topVertices, newEdges, context). }
false;public;3;13;;@Override public void join(BipartiteEdge<KT, KB, EV> first, BipartiteEdge<KT, KB, EV> second, Collector<Edge<KT, Tuple2<EV, EV>>> out) throws Exception {     if (!first.f0.equals(second.f0)) {         edge.f0 = first.f0.         edge.f1 = second.f0.         edgeValues.f0 = first.f2.         edgeValues.f1 = second.f2.         out.collect(edge).     } }
true;public;0;9;/**  * Convert a bipartite graph into an undirected graph that contains only bottom vertices. An edge between two  * vertices in the new graph will exist only if the original bipartite graph contains a top vertex they are both  * connected to.  *  * <p>The simple projection performs a single join and returns edges containing the bipartite edge values.  *  * <p>Note: KB must override .equals(). This requirement may be removed in a future release.  *  * @return simple bottom projection of the bipartite graph  */ ;/**  * Convert a bipartite graph into an undirected graph that contains only bottom vertices. An edge between two  * vertices in the new graph will exist only if the original bipartite graph contains a top vertex they are both  * connected to.  *  * <p>The simple projection performs a single join and returns edges containing the bipartite edge values.  *  * <p>Note: KB must override .equals(). This requirement may be removed in a future release.  *  * @return simple bottom projection of the bipartite graph  */ public Graph<KB, VVB, Tuple2<EV, EV>> projectionBottomSimple() {     DataSet<Edge<KB, Tuple2<EV, EV>>> newEdges = edges.join(edges).where(0).equalTo(0).with(new ProjectionBottomSimple<>()).name("Simple bottom projection").     return Graph.fromDataSet(bottomVertices, newEdges, context). }
false;public;3;13;;@Override public void join(BipartiteEdge<KT, KB, EV> first, BipartiteEdge<KT, KB, EV> second, Collector<Edge<KB, Tuple2<EV, EV>>> out) throws Exception {     if (!first.f1.equals(second.f1)) {         edge.f0 = first.f1.         edge.f1 = second.f1.         edgeValues.f0 = first.f2.         edgeValues.f1 = second.f2.         out.collect(edge).     } }
true;public;0;11;/**  * Convert a bipartite graph into a graph that contains only top vertices. An edge between two vertices in the new  * graph will exist only if the original bipartite graph contains at least one bottom vertex they both connect to.  *  * <p>The full projection performs three joins and returns edges containing the connecting vertex ID and value,  * both top vertex values, and both bipartite edge values.  *  * <p>Note: KT must override .equals(). This requirement may be removed in a future release.  *  * @return full top projection of the bipartite graph  */ ;/**  * Convert a bipartite graph into a graph that contains only top vertices. An edge between two vertices in the new  * graph will exist only if the original bipartite graph contains at least one bottom vertex they both connect to.  *  * <p>The full projection performs three joins and returns edges containing the connecting vertex ID and value,  * both top vertex values, and both bipartite edge values.  *  * <p>Note: KT must override .equals(). This requirement may be removed in a future release.  *  * @return full top projection of the bipartite graph  */ public Graph<KT, VVT, Projection<KB, VVB, VVT, EV>> projectionTopFull() {     DataSet<Tuple5<KT, KB, EV, VVT, VVB>> edgesWithVertices = joinEdgeWithVertices().     DataSet<Edge<KT, Projection<KB, VVB, VVT, EV>>> newEdges = edgesWithVertices.join(edgesWithVertices).where(1).equalTo(1).with(new ProjectionTopFull<>()).name("Full top projection").     return Graph.fromDataSet(topVertices, newEdges, context). }
false;private;0;15;;private DataSet<Tuple5<KT, KB, EV, VVT, VVB>> joinEdgeWithVertices() {     return edges.join(topVertices, JoinHint.REPARTITION_HASH_SECOND).where(0).equalTo(0).projectFirst(0, 1, 2).<Tuple4<KT, KB, EV, VVT>>projectSecond(1).name("Edge with vertex").join(bottomVertices, JoinHint.REPARTITION_HASH_SECOND).where(1).equalTo(0).projectFirst(0, 1, 2, 3).<Tuple5<KT, KB, EV, VVT, VVB>>projectSecond(1).name("Edge with vertices"). }
false;public;3;17;;@Override public void join(Tuple5<KT, KB, EV, VVT, VVB> first, Tuple5<KT, KB, EV, VVT, VVB> second, Collector<Edge<KT, Projection<KB, VVB, VVT, EV>>> out) throws Exception {     if (!first.f0.equals(second.f0)) {         edge.f0 = first.f0.         edge.f1 = second.f0.         projection.f0 = first.f1.         projection.f1 = first.f4.         projection.f2 = first.f3.         projection.f3 = second.f3.         projection.f4 = first.f2.         projection.f5 = second.f2.         out.collect(edge).     } }
true;public;0;11;/**  * Convert a bipartite graph into a graph that contains only bottom vertices. An edge between two vertices in the  * new graph will exist only if the original bipartite graph contains at least one top vertex they both connect to.  *  * <p>The full projection performs three joins and returns edges containing the connecting vertex ID and value,  * both bottom vertex values, and both bipartite edge values.  *  * <p>Note: KB must override .equals(). This requirement may be removed in a future release.  *  * @return full bottom projection of the bipartite graph  */ ;/**  * Convert a bipartite graph into a graph that contains only bottom vertices. An edge between two vertices in the  * new graph will exist only if the original bipartite graph contains at least one top vertex they both connect to.  *  * <p>The full projection performs three joins and returns edges containing the connecting vertex ID and value,  * both bottom vertex values, and both bipartite edge values.  *  * <p>Note: KB must override .equals(). This requirement may be removed in a future release.  *  * @return full bottom projection of the bipartite graph  */ public Graph<KB, VVB, Projection<KT, VVT, VVB, EV>> projectionBottomFull() {     DataSet<Tuple5<KT, KB, EV, VVT, VVB>> edgesWithVertices = joinEdgeWithVertices().     DataSet<Edge<KB, Projection<KT, VVT, VVB, EV>>> newEdges = edgesWithVertices.join(edgesWithVertices).where(0).equalTo(0).with(new ProjectionBottomFull<>()).name("Full bottom projection").     return Graph.fromDataSet(bottomVertices, newEdges, context). }
false;public;3;17;;@Override public void join(Tuple5<KT, KB, EV, VVT, VVB> first, Tuple5<KT, KB, EV, VVT, VVB> second, Collector<Edge<KB, Projection<KT, VVT, VVB, EV>>> out) throws Exception {     if (!first.f1.equals(second.f1)) {         edge.f0 = first.f1.         edge.f1 = second.f1.         projection.f0 = first.f0.         projection.f1 = first.f3.         projection.f2 = first.f4.         projection.f3 = second.f4.         projection.f4 = first.f2.         projection.f5 = second.f2.         out.collect(edge).     } }
