commented;modifiers;parameterAmount;loc;comment;code
true;private;1;8;/**  * Initializes the array with the provided number of bytes.  *  * @param bytes initial size of the encapsulated array in bytes  */ ;/**  * Initializes the array with the provided number of bytes.  *  * @param bytes initial size of the encapsulated array in bytes  */ private void initialize(int bytes) {     int capacity = bytes / ELEMENT_LENGTH_IN_BYTES.     Preconditions.checkArgument(capacity > 0, "Requested array with zero capacity").     Preconditions.checkArgument(capacity <= MAX_ARRAY_SIZE, "Requested capacity exceeds limit of " + MAX_ARRAY_SIZE).     data = new double[capacity]. }
true;private;1;18;/**  * If the size of the array is insufficient to hold the given capacity then  * copy the array into a new, larger array.  *  * @param minCapacity minimum required number of elements  */ ;// -------------------------------------------------------------------------------------------- /**  * If the size of the array is insufficient to hold the given capacity then  * copy the array into a new, larger array.  *  * @param minCapacity minimum required number of elements  */ private void ensureCapacity(int minCapacity) {     long currentCapacity = data.length.     if (minCapacity <= currentCapacity) {         return.     }     // increase capacity by at least ~50%     long expandedCapacity = Math.max(minCapacity, currentCapacity + (currentCapacity >> 1)).     int newCapacity = (int) Math.min(MAX_ARRAY_SIZE, expandedCapacity).     if (newCapacity < minCapacity) {         // throw exception as unbounded arrays are not expected to fill         throw new RuntimeException("Requested array size " + minCapacity + " exceeds limit of " + MAX_ARRAY_SIZE).     }     data = Arrays.copyOf(data, newCapacity). }
false;public;0;13;;@Override public String toString() {     StringBuilder sb = new StringBuilder("[").     for (int idx = 0. idx < this.position. idx++) {         sb.append(data[idx]).         if (idx < position - 1) {             sb.append(",").         }     }     sb.append("]").     return sb.toString(). }
false;public;0;5;;@Override public Iterator<DoubleValue> iterator() {     iterator.reset().     return iterator. }
false;public;0;4;;@Override public boolean hasNext() {     return pos < position. }
false;public;0;5;;@Override public DoubleValue next() {     value.setValue(data[pos++]).     return value. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException("remove"). }
false;public;0;3;;public void reset() {     pos = 0. }
false;public;1;8;;// -------------------------------------------------------------------------------------------- // IOReadableWritable // -------------------------------------------------------------------------------------------- @Override public void write(DataOutputView out) throws IOException {     out.writeInt(position).     for (int i = 0. i < position. i++) {         out.writeDouble(data[i]).     } }
false;public;1;11;;@Override public void read(DataInputView in) throws IOException {     position = in.readInt().     mark = 0.     ensureCapacity(position).     for (int i = 0. i < position. i++) {         data[i] = in.readDouble().     } }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // NormalizableKey // -------------------------------------------------------------------------------------------- @Override public int getMaxNormalizedKeyLen() {     return hashValue.getMaxNormalizedKeyLen(). }
false;public;3;12;;@Override public void copyNormalizedKey(MemorySegment target, int offset, int len) {     hash.reset().     hash.hash(position).     for (int i = 0. i < position. i++) {         hash.hash(data[i]).     }     hashValue.setValue(hash.hash()).     hashValue.copyNormalizedKey(target, offset, len). }
false;public;1;15;;// -------------------------------------------------------------------------------------------- // Comparable // -------------------------------------------------------------------------------------------- @Override public int compareTo(ValueArray<DoubleValue> o) {     DoubleValueArray other = (DoubleValueArray) o.     int min = Math.min(position, other.position).     for (int i = 0. i < min. i++) {         int cmp = Double.compare(data[i], other.data[i]).         if (cmp != 0) {             return cmp.         }     }     return Integer.compare(position, other.position). }
false;public;0;11;;// -------------------------------------------------------------------------------------------- // Key // -------------------------------------------------------------------------------------------- @Override public int hashCode() {     int hash = 0.     for (int i = 0. i < position. i++) {         long bits = Double.doubleToLongBits(data[i]).         hash = 31 * hash + (int) (bits + bits >>> 32).     }     return hash. }
false;public;1;20;;@Override public boolean equals(Object obj) {     if (obj instanceof DoubleValueArray) {         DoubleValueArray other = (DoubleValueArray) obj.         if (position != other.position) {             return false.         }         for (int i = 0. i < position. i++) {             if (data[i] != other.data[i]) {                 return false.             }         }         return true.     }     return false. }
false;public;1;4;;// -------------------------------------------------------------------------------------------- // ResettableValue // -------------------------------------------------------------------------------------------- @Override public void setValue(ValueArray<DoubleValue> value) {     value.copyTo(this). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // CopyableValue // -------------------------------------------------------------------------------------------- @Override public int getBinaryLength() {     return -1. }
false;public;1;10;;@Override public void copyTo(ValueArray<DoubleValue> target) {     DoubleValueArray other = (DoubleValueArray) target.     other.position = position.     other.mark = mark.     other.ensureCapacity(position).     System.arraycopy(data, 0, other.data, 0, position). }
false;public;0;8;;@Override public ValueArray<DoubleValue> copy() {     ValueArray<DoubleValue> copy = new DoubleValueArray().     this.copyTo(copy).     return copy. }
false;public;2;4;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     copyInternal(source, target). }
false;protected,static;2;7;;protected static void copyInternal(DataInputView source, DataOutputView target) throws IOException {     int count = source.readInt().     target.writeInt(count).     int bytes = ELEMENT_LENGTH_IN_BYTES * count.     target.write(source, bytes). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // ValueArray // -------------------------------------------------------------------------------------------- @Override public int size() {     return position. }
false;public;0;8;;@Override public boolean isFull() {     if (isBounded) {         return position == data.length.     } else {         return position == MAX_ARRAY_SIZE.     } }
false;public;1;17;;@Override public boolean add(DoubleValue value) {     int newPosition = position + 1.     if (newPosition > data.length) {         if (isBounded) {             return false.         } else {             ensureCapacity(newPosition).         }     }     data[position] = value.getValue().     position = newPosition.     return true. }
false;public;1;20;;@Override public boolean addAll(ValueArray<DoubleValue> other) {     DoubleValueArray source = (DoubleValueArray) other.     int sourceSize = source.position.     int newPosition = position + sourceSize.     if (newPosition > data.length) {         if (isBounded) {             return false.         } else {             ensureCapacity(newPosition).         }     }     System.arraycopy(source.data, 0, data, position, sourceSize).     position = newPosition.     return true. }
false;public;0;4;;@Override public void clear() {     position = 0. }
false;public;0;4;;@Override public void mark() {     mark = position. }
false;public;0;4;;@Override public void reset() {     position = mark. }
