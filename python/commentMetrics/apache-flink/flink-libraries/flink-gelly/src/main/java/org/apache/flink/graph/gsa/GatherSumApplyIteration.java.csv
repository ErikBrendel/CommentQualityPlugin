commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Sets the input data set for this operator. In the case of this operator this input data set represents  * the set of vertices with their initial state.  *  * @param dataSet The input data set, which in the case of this operator represents the set of  *                vertices with their initial state.  */ ;// -------------------------------------------------------------------------------------------- // Custom Operator behavior // -------------------------------------------------------------------------------------------- /**  * Sets the input data set for this operator. In the case of this operator this input data set represents  * the set of vertices with their initial state.  *  * @param dataSet The input data set, which in the case of this operator represents the set of  *                vertices with their initial state.  */ @Override public void setInput(DataSet<Vertex<K, VV>> dataSet) {     this.vertexDataSet = dataSet. }
true;public;0;135;/**  * Computes the results of the gather-sum-apply iteration.  *  * @return The resulting DataSet  */ ;/**  * Computes the results of the gather-sum-apply iteration.  *  * @return The resulting DataSet  */ @Override public DataSet<Vertex<K, VV>> createResult() {     if (vertexDataSet == null) {         throw new IllegalStateException("The input data set has not been set.").     }     // Prepare type information     TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertexDataSet.getType()).getTypeAt(0).     TypeInformation<M> messageType = TypeExtractor.createTypeInfo(gather, GatherFunction.class, gather.getClass(), 2).     TypeInformation<Tuple2<K, M>> innerType = new TupleTypeInfo<>(keyType, messageType).     TypeInformation<Vertex<K, VV>> outputType = vertexDataSet.getType().     // check whether the numVertices option is set and, if so, compute the total number of vertices     // and set it within the gather, sum and apply functions     DataSet<LongValue> numberOfVertices = null.     if (this.configuration != null && this.configuration.isOptNumVertices()) {         try {             numberOfVertices = GraphUtils.count(this.vertexDataSet).         } catch (Exception e) {             e.printStackTrace().         }     }     // Prepare UDFs     GatherUdf<K, VV, EV, M> gatherUdf = new GatherUdf<>(gather, innerType).     SumUdf<K, VV, EV, M> sumUdf = new SumUdf<>(sum, innerType).     ApplyUdf<K, VV, EV, M> applyUdf = new ApplyUdf<>(apply, outputType).     final int[] zeroKeyPos = new int[] { 0 }.     final DeltaIteration<Vertex<K, VV>, Vertex<K, VV>> iteration = vertexDataSet.iterateDelta(vertexDataSet, maximumNumberOfIterations, zeroKeyPos).     // set up the iteration operator     if (this.configuration != null) {         iteration.name(this.configuration.getName("Gather-sum-apply iteration (" + gather + " | " + sum + " | " + apply + ")")).         iteration.parallelism(this.configuration.getParallelism()).         iteration.setSolutionSetUnManaged(this.configuration.isSolutionSetUnmanagedMemory()).         // register all aggregators         for (Map.Entry<String, Aggregator<?>> entry : this.configuration.getAggregators().entrySet()) {             iteration.registerAggregator(entry.getKey(), entry.getValue()).         }     } else {         // no configuration provided. set default name         iteration.name("Gather-sum-apply iteration (" + gather + " | " + sum + " | " + apply + ")").     }     // Prepare the neighbors     if (this.configuration != null) {         direction = this.configuration.getDirection().     }     DataSet<Tuple2<K, Neighbor<VV, EV>>> neighbors.     switch(direction) {         case OUT:             neighbors = iteration.getWorkset().join(edgeDataSet).where(0).equalTo(0).with(new ProjectKeyWithNeighborOUT<>()).             break.         case IN:             neighbors = iteration.getWorkset().join(edgeDataSet).where(0).equalTo(1).with(new ProjectKeyWithNeighborIN<>()).             break.         case ALL:             neighbors = iteration.getWorkset().join(edgeDataSet).where(0).equalTo(0).with(new ProjectKeyWithNeighborOUT<>()).union(iteration.getWorkset().join(edgeDataSet).where(0).equalTo(1).with(new ProjectKeyWithNeighborIN<>())).             break.         default:             neighbors = iteration.getWorkset().join(edgeDataSet).where(0).equalTo(0).with(new ProjectKeyWithNeighborOUT<>()).             break.     }     // Gather, sum and apply     MapOperator<Tuple2<K, Neighbor<VV, EV>>, Tuple2<K, M>> gatherMapOperator = neighbors.map(gatherUdf).     // configure map gather function with name and broadcast variables     gatherMapOperator = gatherMapOperator.name("Gather").     if (this.configuration != null) {         for (Tuple2<String, DataSet<?>> e : this.configuration.getGatherBcastVars()) {             gatherMapOperator = gatherMapOperator.withBroadcastSet(e.f1, e.f0).         }         if (this.configuration.isOptNumVertices()) {             gatherMapOperator = gatherMapOperator.withBroadcastSet(numberOfVertices, "number of vertices").         }     }     DataSet<Tuple2<K, M>> gatheredSet = gatherMapOperator.     ReduceOperator<Tuple2<K, M>> sumReduceOperator = gatheredSet.groupBy(0).reduce(sumUdf).     // configure reduce sum function with name and broadcast variables     sumReduceOperator = sumReduceOperator.name("Sum").     if (this.configuration != null) {         for (Tuple2<String, DataSet<?>> e : this.configuration.getSumBcastVars()) {             sumReduceOperator = sumReduceOperator.withBroadcastSet(e.f1, e.f0).         }         if (this.configuration.isOptNumVertices()) {             sumReduceOperator = sumReduceOperator.withBroadcastSet(numberOfVertices, "number of vertices").         }     }     DataSet<Tuple2<K, M>> summedSet = sumReduceOperator.     JoinOperator<?, ?, Vertex<K, VV>> appliedSet = summedSet.join(iteration.getSolutionSet()).where(0).equalTo(0).with(applyUdf).     // configure join apply function with name and broadcast variables     appliedSet = appliedSet.name("Apply").     if (this.configuration != null) {         for (Tuple2<String, DataSet<?>> e : this.configuration.getApplyBcastVars()) {             appliedSet = appliedSet.withBroadcastSet(e.f1, e.f0).         }         if (this.configuration.isOptNumVertices()) {             appliedSet = appliedSet.withBroadcastSet(numberOfVertices, "number of vertices").         }     }     // let the operator know that we preserve the key field     appliedSet.withForwardedFieldsFirst("0").withForwardedFieldsSecond("0").     return iteration.closeWith(appliedSet, appliedSet). }
true;public,static;5;6;/**  * Creates a new gather-sum-apply iteration operator for graphs.  *  * @param edges The edge DataSet  *  * @param gather The gather function of the GSA iteration  * @param sum The sum function of the GSA iteration  * @param apply The apply function of the GSA iteration  *  * @param maximumNumberOfIterations The maximum number of iterations executed  *  * @param <K> The type of the vertex key in the graph  * @param <VV> The type of the vertex value in the graph  * @param <EV> The type of the edge value in the graph  * @param <M> The intermediate type used by the gather, sum and apply functions  *  * @return An in stance of the gather-sum-apply graph computation operator.  */ ;/**  * Creates a new gather-sum-apply iteration operator for graphs.  *  * @param edges The edge DataSet  *  * @param gather The gather function of the GSA iteration  * @param sum The sum function of the GSA iteration  * @param apply The apply function of the GSA iteration  *  * @param maximumNumberOfIterations The maximum number of iterations executed  *  * @param <K> The type of the vertex key in the graph  * @param <VV> The type of the vertex value in the graph  * @param <EV> The type of the edge value in the graph  * @param <M> The intermediate type used by the gather, sum and apply functions  *  * @return An in stance of the gather-sum-apply graph computation operator.  */ public static <K, VV, EV, M> GatherSumApplyIteration<K, VV, EV, M> withEdges(DataSet<Edge<K, EV>> edges, GatherFunction<VV, EV, M> gather, SumFunction<VV, EV, M> sum, ApplyFunction<K, VV, M> apply, int maximumNumberOfIterations) {     return new GatherSumApplyIteration<>(gather, sum, apply, edges, maximumNumberOfIterations). }
false;public;1;5;;@Override public Tuple2<K, M> map(Tuple2<K, Neighbor<VV, EV>> neighborTuple) {     M result = this.gatherFunction.gather(neighborTuple.f1).     return new Tuple2<>(neighborTuple.f0, result). }
false;public;1;11;;@Override public void open(Configuration parameters) throws Exception {     if (getRuntimeContext().hasBroadcastVariable("number of vertices")) {         Collection<LongValue> numberOfVertices = getRuntimeContext().getBroadcastVariable("number of vertices").         this.gatherFunction.setNumberOfVertices(numberOfVertices.iterator().next().getValue()).     }     if (getIterationRuntimeContext().getSuperstepNumber() == 1) {         this.gatherFunction.init(getIterationRuntimeContext()).     }     this.gatherFunction.preSuperstep(). }
false;public;0;4;;@Override public void close() throws Exception {     this.gatherFunction.postSuperstep(). }
false;public;0;4;;@Override public TypeInformation<Tuple2<K, M>> getProducedType() {     return this.resultType. }
false;public;2;16;;@Override public Tuple2<K, M> reduce(Tuple2<K, M> arg0, Tuple2<K, M> arg1) throws Exception {     M result = this.sumFunction.sum(arg0.f1, arg1.f1).     // in ReduceDriver.run()     if (result == arg1.f1) {         M tmp = arg1.f1.         arg1.f1 = arg0.f1.         arg0.f1 = tmp.     } else {         arg0.f1 = result.     }     return arg0. }
false;public;1;11;;@Override public void open(Configuration parameters) throws Exception {     if (getRuntimeContext().hasBroadcastVariable("number of vertices")) {         Collection<LongValue> numberOfVertices = getRuntimeContext().getBroadcastVariable("number of vertices").         this.sumFunction.setNumberOfVertices(numberOfVertices.iterator().next().getValue()).     }     if (getIterationRuntimeContext().getSuperstepNumber() == 1) {         this.sumFunction.init(getIterationRuntimeContext()).     }     this.sumFunction.preSuperstep(). }
false;public;0;4;;@Override public void close() throws Exception {     this.sumFunction.postSuperstep(). }
false;public;0;4;;@Override public TypeInformation<Tuple2<K, M>> getProducedType() {     return this.resultType. }
false;public;3;6;;@Override public void join(Tuple2<K, M> newValue, final Vertex<K, VV> currentValue, final Collector<Vertex<K, VV>> out) throws Exception {     this.applyFunction.setOutput(currentValue, out).     this.applyFunction.apply(newValue.f1, currentValue.getValue()). }
false;public;1;11;;@Override public void open(Configuration parameters) throws Exception {     if (getRuntimeContext().hasBroadcastVariable("number of vertices")) {         Collection<LongValue> numberOfVertices = getRuntimeContext().getBroadcastVariable("number of vertices").         this.applyFunction.setNumberOfVertices(numberOfVertices.iterator().next().getValue()).     }     if (getIterationRuntimeContext().getSuperstepNumber() == 1) {         this.applyFunction.init(getIterationRuntimeContext()).     }     this.applyFunction.preSuperstep(). }
false;public;0;4;;@Override public void close() throws Exception {     this.applyFunction.postSuperstep(). }
false;public;0;4;;@Override public TypeInformation<Vertex<K, VV>> getProducedType() {     return this.resultType. }
false;public;3;4;;public void join(Vertex<K, VV> vertex, Edge<K, EV> edge, Collector<Tuple2<K, Neighbor<VV, EV>>> out) {     out.collect(new Tuple2<>(edge.getTarget(), new Neighbor<>(vertex.getValue(), edge.getValue()))). }
false;public;3;4;;public void join(Vertex<K, VV> vertex, Edge<K, EV> edge, Collector<Tuple2<K, Neighbor<VV, EV>>> out) {     out.collect(new Tuple2<>(edge.getSource(), new Neighbor<>(vertex.getValue(), edge.getValue()))). }
true;public;1;3;/**  * Configures this gather-sum-apply iteration with the provided parameters.  *  * @param parameters the configuration parameters  */ ;/**  * Configures this gather-sum-apply iteration with the provided parameters.  *  * @param parameters the configuration parameters  */ public void configure(GSAConfiguration parameters) {     this.configuration = parameters. }
true;public;0;3;/**  * @return the configuration parameters of this gather-sum-apply iteration  */ ;/**  * @return the configuration parameters of this gather-sum-apply iteration  */ public GSAConfiguration getIterationConfiguration() {     return this.configuration. }
