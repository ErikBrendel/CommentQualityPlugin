# id;timestamp;commentText;codeText;commentWords;codeWords
ValueArrayFactory -> @SuppressWarnings("unchecked") 	public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls, int bytes);1490973276;Produce a {@code ValueArray} for the given {@code Value} type with the_given bounded size.__@param cls {@code Value} class_@param bytes limit the array to the given number of bytes_@return {@code ValueArray} for given {@code Value} class;@SuppressWarnings("unchecked")_	public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls, int bytes) {_		if (IntValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new IntValueArray(bytes)__		} else if (LongValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new LongValueArray(bytes)__		} else if (NullValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new NullValueArray(bytes)__		} else if (StringValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new StringValueArray(bytes)__		} else {_			throw new IllegalArgumentException("Unable to create bounded ValueArray for type " + cls)__		}_	};produce,a,code,value,array,for,the,given,code,value,type,with,the,given,bounded,size,param,cls,code,value,class,param,bytes,limit,the,array,to,the,given,number,of,bytes,return,code,value,array,for,given,code,value,class;suppress,warnings,unchecked,public,static,t,value,array,t,create,value,array,class,extends,value,cls,int,bytes,if,int,value,class,is,assignable,from,cls,return,value,array,t,new,int,value,array,bytes,else,if,long,value,class,is,assignable,from,cls,return,value,array,t,new,long,value,array,bytes,else,if,null,value,class,is,assignable,from,cls,return,value,array,t,new,null,value,array,bytes,else,if,string,value,class,is,assignable,from,cls,return,value,array,t,new,string,value,array,bytes,else,throw,new,illegal,argument,exception,unable,to,create,bounded,value,array,for,type,cls
ValueArrayFactory -> @SuppressWarnings("unchecked") 	public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls, int bytes);1495819075;Produce a {@code ValueArray} for the given {@code Value} type with the_given bounded size.__@param cls {@code Value} class_@param bytes limit the array to the given number of bytes_@return {@code ValueArray} for given {@code Value} class;@SuppressWarnings("unchecked")_	public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls, int bytes) {_		if (IntValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new IntValueArray(bytes)__		} else if (LongValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new LongValueArray(bytes)__		} else if (NullValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new NullValueArray(bytes)__		} else if (StringValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new StringValueArray(bytes)__		} else {_			throw new IllegalArgumentException("Unable to create bounded ValueArray for type " + cls)__		}_	};produce,a,code,value,array,for,the,given,code,value,type,with,the,given,bounded,size,param,cls,code,value,class,param,bytes,limit,the,array,to,the,given,number,of,bytes,return,code,value,array,for,given,code,value,class;suppress,warnings,unchecked,public,static,t,value,array,t,create,value,array,class,extends,value,cls,int,bytes,if,int,value,class,is,assignable,from,cls,return,value,array,t,new,int,value,array,bytes,else,if,long,value,class,is,assignable,from,cls,return,value,array,t,new,long,value,array,bytes,else,if,null,value,class,is,assignable,from,cls,return,value,array,t,new,null,value,array,bytes,else,if,string,value,class,is,assignable,from,cls,return,value,array,t,new,string,value,array,bytes,else,throw,new,illegal,argument,exception,unable,to,create,bounded,value,array,for,type,cls
ValueArrayFactory -> @SuppressWarnings("unchecked") 	public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls, int bytes);1499282568;Produce a {@code ValueArray} for the given {@code Value} type with the_given bounded size.__@param cls {@code Value} class_@param bytes limit the array to the given number of bytes_@return {@code ValueArray} for given {@code Value} class;@SuppressWarnings("unchecked")_	public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls, int bytes) {_		if (ByteValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new ByteValueArray(bytes)__		} else if (CharValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new CharValueArray(bytes)__		} else if (DoubleValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new DoubleValueArray(bytes)__		} else if (FloatValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new FloatValueArray(bytes)__		} else if (IntValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new IntValueArray(bytes)__		} else if (LongValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new LongValueArray(bytes)__		} else if (NullValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new NullValueArray(bytes)__		} else if (ShortValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new ShortValueArray(bytes)__		} else if (StringValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new StringValueArray(bytes)__		} else {_			throw new IllegalArgumentException("Unable to create bounded ValueArray for type " + cls)__		}_	};produce,a,code,value,array,for,the,given,code,value,type,with,the,given,bounded,size,param,cls,code,value,class,param,bytes,limit,the,array,to,the,given,number,of,bytes,return,code,value,array,for,given,code,value,class;suppress,warnings,unchecked,public,static,t,value,array,t,create,value,array,class,extends,value,cls,int,bytes,if,byte,value,class,is,assignable,from,cls,return,value,array,t,new,byte,value,array,bytes,else,if,char,value,class,is,assignable,from,cls,return,value,array,t,new,char,value,array,bytes,else,if,double,value,class,is,assignable,from,cls,return,value,array,t,new,double,value,array,bytes,else,if,float,value,class,is,assignable,from,cls,return,value,array,t,new,float,value,array,bytes,else,if,int,value,class,is,assignable,from,cls,return,value,array,t,new,int,value,array,bytes,else,if,long,value,class,is,assignable,from,cls,return,value,array,t,new,long,value,array,bytes,else,if,null,value,class,is,assignable,from,cls,return,value,array,t,new,null,value,array,bytes,else,if,short,value,class,is,assignable,from,cls,return,value,array,t,new,short,value,array,bytes,else,if,string,value,class,is,assignable,from,cls,return,value,array,t,new,string,value,array,bytes,else,throw,new,illegal,argument,exception,unable,to,create,bounded,value,array,for,type,cls
ValueArrayFactory -> @SuppressWarnings("unchecked") 	public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls);1490973276;Produce a {@code ValueArray} for the given {@code Value} type.__@param cls {@code Value} class_@return {@code ValueArray} for given {@code Value} class;@SuppressWarnings("unchecked")_	public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls) {_		if (IntValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new IntValueArray()__		} else if (LongValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new LongValueArray()__		} else if (NullValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new NullValueArray()__		} else if (StringValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new StringValueArray()__		} else {_			throw new IllegalArgumentException("Unable to create unbounded ValueArray for type " + cls)__		}_	};produce,a,code,value,array,for,the,given,code,value,type,param,cls,code,value,class,return,code,value,array,for,given,code,value,class;suppress,warnings,unchecked,public,static,t,value,array,t,create,value,array,class,extends,value,cls,if,int,value,class,is,assignable,from,cls,return,value,array,t,new,int,value,array,else,if,long,value,class,is,assignable,from,cls,return,value,array,t,new,long,value,array,else,if,null,value,class,is,assignable,from,cls,return,value,array,t,new,null,value,array,else,if,string,value,class,is,assignable,from,cls,return,value,array,t,new,string,value,array,else,throw,new,illegal,argument,exception,unable,to,create,unbounded,value,array,for,type,cls
ValueArrayFactory -> @SuppressWarnings("unchecked") 	public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls);1495819075;Produce a {@code ValueArray} for the given {@code Value} type.__@param cls {@code Value} class_@return {@code ValueArray} for given {@code Value} class;@SuppressWarnings("unchecked")_	public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls) {_		if (IntValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new IntValueArray()__		} else if (LongValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new LongValueArray()__		} else if (NullValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new NullValueArray()__		} else if (StringValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new StringValueArray()__		} else {_			throw new IllegalArgumentException("Unable to create unbounded ValueArray for type " + cls)__		}_	};produce,a,code,value,array,for,the,given,code,value,type,param,cls,code,value,class,return,code,value,array,for,given,code,value,class;suppress,warnings,unchecked,public,static,t,value,array,t,create,value,array,class,extends,value,cls,if,int,value,class,is,assignable,from,cls,return,value,array,t,new,int,value,array,else,if,long,value,class,is,assignable,from,cls,return,value,array,t,new,long,value,array,else,if,null,value,class,is,assignable,from,cls,return,value,array,t,new,null,value,array,else,if,string,value,class,is,assignable,from,cls,return,value,array,t,new,string,value,array,else,throw,new,illegal,argument,exception,unable,to,create,unbounded,value,array,for,type,cls
ValueArrayFactory -> @SuppressWarnings("unchecked") 	public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls);1499282568;Produce a {@code ValueArray} for the given {@code Value} type.__@param cls {@code Value} class_@return {@code ValueArray} for given {@code Value} class;@SuppressWarnings("unchecked")_	public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls) {_		if (ByteValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new ByteValueArray()__		} else if (CharValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new CharValueArray()__		} else if (DoubleValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new DoubleValueArray()__		} else if (FloatValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new FloatValueArray()__		} else if (IntValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new IntValueArray()__		} else if (LongValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new LongValueArray()__		} else if (NullValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new NullValueArray()__		} else if (ShortValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new ShortValueArray()__		} else if (StringValue.class.isAssignableFrom(cls)) {_			return (ValueArray<T>) new StringValueArray()__		} else {_			throw new IllegalArgumentException("Unable to create unbounded ValueArray for type " + cls)__		}_	};produce,a,code,value,array,for,the,given,code,value,type,param,cls,code,value,class,return,code,value,array,for,given,code,value,class;suppress,warnings,unchecked,public,static,t,value,array,t,create,value,array,class,extends,value,cls,if,byte,value,class,is,assignable,from,cls,return,value,array,t,new,byte,value,array,else,if,char,value,class,is,assignable,from,cls,return,value,array,t,new,char,value,array,else,if,double,value,class,is,assignable,from,cls,return,value,array,t,new,double,value,array,else,if,float,value,class,is,assignable,from,cls,return,value,array,t,new,float,value,array,else,if,int,value,class,is,assignable,from,cls,return,value,array,t,new,int,value,array,else,if,long,value,class,is,assignable,from,cls,return,value,array,t,new,long,value,array,else,if,null,value,class,is,assignable,from,cls,return,value,array,t,new,null,value,array,else,if,short,value,class,is,assignable,from,cls,return,value,array,t,new,short,value,array,else,if,string,value,class,is,assignable,from,cls,return,value,array,t,new,string,value,array,else,throw,new,illegal,argument,exception,unable,to,create,unbounded,value,array,for,type,cls
