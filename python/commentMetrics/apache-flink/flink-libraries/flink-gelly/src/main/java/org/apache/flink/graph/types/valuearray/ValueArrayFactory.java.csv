commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;24;/**  * Produce a {@code ValueArray} for the given {@code Value} type.  *  * @param cls {@code Value} class  * @return {@code ValueArray} for given {@code Value} class  */ ;/**  * Produce a {@code ValueArray} for the given {@code Value} type.  *  * @param cls {@code Value} class  * @return {@code ValueArray} for given {@code Value} class  */ @SuppressWarnings("unchecked") public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls) {     if (ByteValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new ByteValueArray().     } else if (CharValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new CharValueArray().     } else if (DoubleValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new DoubleValueArray().     } else if (FloatValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new FloatValueArray().     } else if (IntValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new IntValueArray().     } else if (LongValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new LongValueArray().     } else if (NullValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new NullValueArray().     } else if (ShortValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new ShortValueArray().     } else if (StringValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new StringValueArray().     } else {         throw new IllegalArgumentException("Unable to create unbounded ValueArray for type " + cls).     } }
true;public,static;2;24;/**  * Produce a {@code ValueArray} for the given {@code Value} type with the  * given bounded size.  *  * @param cls {@code Value} class  * @param bytes limit the array to the given number of bytes  * @return {@code ValueArray} for given {@code Value} class  */ ;/**  * Produce a {@code ValueArray} for the given {@code Value} type with the  * given bounded size.  *  * @param cls {@code Value} class  * @param bytes limit the array to the given number of bytes  * @return {@code ValueArray} for given {@code Value} class  */ @SuppressWarnings("unchecked") public static <T> ValueArray<T> createValueArray(Class<? extends Value> cls, int bytes) {     if (ByteValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new ByteValueArray(bytes).     } else if (CharValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new CharValueArray(bytes).     } else if (DoubleValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new DoubleValueArray(bytes).     } else if (FloatValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new FloatValueArray(bytes).     } else if (IntValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new IntValueArray(bytes).     } else if (LongValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new LongValueArray(bytes).     } else if (NullValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new NullValueArray(bytes).     } else if (ShortValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new ShortValueArray(bytes).     } else if (StringValue.class.isAssignableFrom(cls)) {         return (ValueArray<T>) new StringValueArray(bytes).     } else {         throw new IllegalArgumentException("Unable to create bounded ValueArray for type " + cls).     } }
