commented;modifiers;parameterAmount;loc;comment;code
true;public;3;10;/**  * The parameters for recursively subdividing the adjacency matrix.  *  * <p>Setting A = B = C = 0.25 emulates the Erdős–Rényi model.  *  * <p>Graph500 uses A = 0.57, B = C = 0.19.  *  * @param a likelihood of source bit = 0, target bit = 0  * @param b likelihood of source bit = 0, target bit = 1  * @param c likelihood of source bit = 1, target bit = 0  * @return this  */ ;/**  * The parameters for recursively subdividing the adjacency matrix.  *  * <p>Setting A = B = C = 0.25 emulates the Erdős–Rényi model.  *  * <p>Graph500 uses A = 0.57, B = C = 0.19.  *  * @param a likelihood of source bit = 0, target bit = 0  * @param b likelihood of source bit = 0, target bit = 1  * @param c likelihood of source bit = 1, target bit = 0  * @return this  */ public RMatGraph<T> setConstants(float a, float b, float c) {     Preconditions.checkArgument(a >= 0.0f && b >= 0.0f && c >= 0.0f && a + b + c <= 1.0f, "RMat parameters A, B, and C must be non-negative and sum to less than or equal to one").     this.a = a.     this.b = b.     this.c = c.     return this. }
true;public;2;9;/**  * Enable and configure noise. Each edge is generated independently, but  * when noise is enabled the parameters A, B, and C are randomly increased  * or decreased, then normalized, by a fraction of the noise factor during  * the computation of each bit.  *  * @param noiseEnabled whether to enable noise perturbation  * @param noise strength of noise perturbation  * @return this  */ ;/**  * Enable and configure noise. Each edge is generated independently, but  * when noise is enabled the parameters A, B, and C are randomly increased  * or decreased, then normalized, by a fraction of the noise factor during  * the computation of each bit.  *  * @param noiseEnabled whether to enable noise perturbation  * @param noise strength of noise perturbation  * @return this  */ public RMatGraph<T> setNoise(boolean noiseEnabled, float noise) {     Preconditions.checkArgument(noise >= 0.0f && noise <= 2.0f, "RMat parameter noise must be non-negative and less than or equal to 2.0").     this.noiseEnabled = noiseEnabled.     this.noise = noise.     return this. }
false;public;0;26;;@Override public Graph<LongValue, NullValue, NullValue> generate() {     int scale = Long.SIZE - Long.numberOfLeadingZeros(vertexCount - 1).     // Edges     int cyclesPerEdge = noiseEnabled ? 5 * scale : scale.     List<BlockInfo<T>> generatorBlocks = randomGenerableFactory.getRandomGenerables(edgeCount, cyclesPerEdge).     DataSet<Edge<LongValue, NullValue>> edges = env.fromCollection(generatorBlocks).name("Random generators").rebalance().setParallelism(parallelism).name("Rebalance").flatMap(new GenerateEdges<>(vertexCount, scale, a, b, c, noiseEnabled, noise)).setParallelism(parallelism).name("RMat graph edges").     // Vertices     DataSet<Vertex<LongValue, NullValue>> vertices = GraphGeneratorUtils.vertexSet(edges, parallelism).     // Graph     return Graph.fromDataSet(vertices, edges, env). }
false;public;2;63;;@Override public void flatMap(BlockInfo<T> blockInfo, Collector<Edge<LongValue, NullValue>> out) throws Exception {     RandomGenerator rng = blockInfo.getRandomGenerable().generator().     long edgesToGenerate = blockInfo.getElementCount().     while (edgesToGenerate > 0) {         long x = 0.         long y = 0.         // matrix constants are reset for each edge         float a = this.a.         float b = this.b.         float c = this.c.         float d = this.d.         for (int bit = 0. bit < scale. bit++) {             // generated next bit for source and target             x <<= 1.             y <<= 1.             float random = rng.nextFloat().             if (random <= a) {             } else if (random <= a + b) {                 y += 1.             } else if (random <= a + b + c) {                 x += 1.             } else {                 x += 1.                 y += 1.             }             if (noiseEnabled) {                 // noise is bounded such that all parameters remain non-negative                 a *= 1.0 - noise / 2 + rng.nextFloat() * noise.                 b *= 1.0 - noise / 2 + rng.nextFloat() * noise.                 c *= 1.0 - noise / 2 + rng.nextFloat() * noise.                 d *= 1.0 - noise / 2 + rng.nextFloat() * noise.                 // normalize back to a + b + c + d = 1.0                 float norm = 1.0f / (a + b + c + d).                 a *= norm.                 b *= norm.                 c *= norm.                 // could multiply by norm, but subtract to minimize rounding error                 d = 1.0f - a - b - c.             }         }         // if vertexCount is not a power-of-2 then discard edges outside the vertex range         if (x < vertexCount && y < vertexCount) {             source.setValue(x).             target.setValue(y).             out.collect(sourceToTarget).             edgesToGenerate--.         }     } }
