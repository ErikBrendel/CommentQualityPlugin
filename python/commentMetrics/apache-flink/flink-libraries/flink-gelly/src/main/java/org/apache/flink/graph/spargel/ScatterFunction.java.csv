commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Retrieves the number of vertices in the graph.  * @return the number of vertices if the {@link org.apache.flink.graph.IterationConfiguration#setOptNumVertices(boolean)}  * option has been set. -1 otherwise.  */ ;/**  * Retrieves the number of vertices in the graph.  * @return the number of vertices if the {@link org.apache.flink.graph.IterationConfiguration#setOptNumVertices(boolean)}  * option has been set. -1 otherwise.  */ public long getNumberOfVertices() {     return numberOfVertices. }
false;;1;3;;void setNumberOfVertices(long numberOfVertices) {     this.numberOfVertices = numberOfVertices. }
true;public;0;3;/**  * Retrieves the edge direction in which messages are propagated in the scatter-gather iteration.  * @return the messaging {@link EdgeDirection}  */ ;/**  * Retrieves the edge direction in which messages are propagated in the scatter-gather iteration.  * @return the messaging {@link EdgeDirection}  */ public EdgeDirection getDirection() {     return direction. }
false;;1;3;;void setDirection(EdgeDirection direction) {     this.direction = direction. }
true;public,abstract;1;1;/**  * This method is invoked once per superstep for each vertex that was changed in that superstep.  * It needs to produce the messages that will be received by vertices in the next superstep.  *  * @param vertex The vertex that was changed.  *  * @throws Exception The computation may throw exceptions, which causes the superstep to fail.  */ ;// -------------------------------------------------------------------------------------------- // Public API Methods // -------------------------------------------------------------------------------------------- /**  * This method is invoked once per superstep for each vertex that was changed in that superstep.  * It needs to produce the messages that will be received by vertices in the next superstep.  *  * @param vertex The vertex that was changed.  *  * @throws Exception The computation may throw exceptions, which causes the superstep to fail.  */ public abstract void sendMessages(Vertex<K, VV> vertex) throws Exception.
true;public;0;1;/**  * This method is executed once per superstep before the scatter function is invoked for each vertex.  *  * @throws Exception Exceptions in the pre-superstep phase cause the superstep to fail.  */ ;/**  * This method is executed once per superstep before the scatter function is invoked for each vertex.  *  * @throws Exception Exceptions in the pre-superstep phase cause the superstep to fail.  */ public void preSuperstep() throws Exception { }
true;public;0;1;/**  * This method is executed once per superstep after the scatter function has been invoked for each vertex.  *  * @throws Exception Exceptions in the post-superstep phase cause the superstep to fail.  */ ;/**  * This method is executed once per superstep after the scatter function has been invoked for each vertex.  *  * @throws Exception Exceptions in the post-superstep phase cause the superstep to fail.  */ public void postSuperstep() throws Exception { }
true;public;0;9;/**  * Gets an {@link java.lang.Iterable} with all edges. This method is mutually exclusive with  * {@link #sendMessageToAllNeighbors(Object)} and may be called only once.  *  * <p>If the {@link EdgeDirection} is OUT (default), then this iterator contains outgoing edges.  *  * <p>If the {@link EdgeDirection} is IN, then this iterator contains incoming edges.  *  * <p>If the {@link EdgeDirection} is ALL, then this iterator contains both outgoing and incoming edges.  *  * @return An iterator with all edges.  */ ;/**  * Gets an {@link java.lang.Iterable} with all edges. This method is mutually exclusive with  * {@link #sendMessageToAllNeighbors(Object)} and may be called only once.  *  * <p>If the {@link EdgeDirection} is OUT (default), then this iterator contains outgoing edges.  *  * <p>If the {@link EdgeDirection} is IN, then this iterator contains incoming edges.  *  * <p>If the {@link EdgeDirection} is ALL, then this iterator contains both outgoing and incoming edges.  *  * @return An iterator with all edges.  */ @SuppressWarnings("unchecked") public Iterable<Edge<K, EV>> getEdges() {     if (edgesUsed) {         throw new IllegalStateException("Can use either 'getEdges()' or 'sendMessageToAllNeighbors()' exactly once.").     }     edgesUsed = true.     this.edgeIterator.set((Iterator<Edge<K, EV>>) edges).     return this.edgeIterator. }
true;public;1;42;/**  * Sends the given message to all vertices that are targets of an edge of the changed vertex.  * This method is mutually exclusive to the method {@link #getEdges()} and may be called only once.  *  * <p>If the {@link EdgeDirection} is OUT (default), the message will be sent to out-neighbors.  *  * <p>If the {@link EdgeDirection} is IN, the message will be sent to in-neighbors.  *  * <p>If the {@link EdgeDirection} is ALL, the message will be sent to all neighbors.  *  * @param m The message to send.  */ ;/**  * Sends the given message to all vertices that are targets of an edge of the changed vertex.  * This method is mutually exclusive to the method {@link #getEdges()} and may be called only once.  *  * <p>If the {@link EdgeDirection} is OUT (default), the message will be sent to out-neighbors.  *  * <p>If the {@link EdgeDirection} is IN, the message will be sent to in-neighbors.  *  * <p>If the {@link EdgeDirection} is ALL, the message will be sent to all neighbors.  *  * @param m The message to send.  */ public void sendMessageToAllNeighbors(Message m) {     if (edgesUsed) {         throw new IllegalStateException("Can use either 'getEdges()' or 'sendMessageToAllNeighbors()'" + "exactly once.").     }     edgesUsed = true.     outValue.f1 = m.     while (edges.hasNext()) {         Tuple next = (Tuple) edges.next().         /* 			 * When EdgeDirection is OUT, the edges iterator only has the out-edges 			 * of the vertex, i.e. the ones where this vertex is src. 			 * next.getField(1) gives the neighbor of the vertex running this ScatterFunction. 			 */         if (getDirection().equals(EdgeDirection.OUT)) {             outValue.f0 = next.getField(1).         } else /* 			 * When EdgeDirection is IN, the edges iterator only has the in-edges 			 * of the vertex, i.e. the ones where this vertex is trg. 			 * next.getField(10) gives the neighbor of the vertex running this ScatterFunction. 			 */         if (getDirection().equals(EdgeDirection.IN)) {             outValue.f0 = next.getField(0).         }         // When EdgeDirection is ALL, the edges iterator contains both in- and out- edges         if (getDirection().equals(EdgeDirection.ALL)) {             if (next.getField(0).equals(vertexId)) {                 // send msg to the trg                 outValue.f0 = next.getField(1).             } else {                 // send msg to the src                 outValue.f0 = next.getField(0).             }         }         out.collect(outValue).     } }
true;public;2;5;/**  * Sends the given message to the vertex identified by the given key. If the target vertex does not exist,  * the next superstep will cause an exception due to a non-deliverable message.  *  * @param target The key (id) of the target vertex to message.  * @param m The message.  */ ;/**  * Sends the given message to the vertex identified by the given key. If the target vertex does not exist,  * the next superstep will cause an exception due to a non-deliverable message.  *  * @param target The key (id) of the target vertex to message.  * @param m The message.  */ public void sendMessageTo(K target, Message m) {     outValue.f0 = target.     outValue.f1 = m.     out.collect(outValue). }
true;public;0;3;/**  * Gets the number of the superstep, starting at <tt>1</tt>.  *  * @return The number of the current superstep.  */ ;// -------------------------------------------------------------------------------------------- /**  * Gets the number of the superstep, starting at <tt>1</tt>.  *  * @return The number of the current superstep.  */ public int getSuperstepNumber() {     return this.runtimeContext.getSuperstepNumber(). }
true;public;1;3;/**  * Gets the iteration aggregator registered under the given name. The iteration aggregator combines  * all aggregates globally once per superstep and makes them available in the next superstep.  *  * @param name The name of the aggregator.  * @return The aggregator registered under this name, or null, if no aggregator was registered.  */ ;/**  * Gets the iteration aggregator registered under the given name. The iteration aggregator combines  * all aggregates globally once per superstep and makes them available in the next superstep.  *  * @param name The name of the aggregator.  * @return The aggregator registered under this name, or null, if no aggregator was registered.  */ public <T extends Aggregator<?>> T getIterationAggregator(String name) {     return this.runtimeContext.getIterationAggregator(name). }
true;public;1;3;/**  * Get the aggregated value that an aggregator computed in the previous iteration.  *  * @param name The name of the aggregator.  * @return The aggregated value of the previous iteration.  */ ;/**  * Get the aggregated value that an aggregator computed in the previous iteration.  *  * @param name The name of the aggregator.  * @return The aggregated value of the previous iteration.  */ public <T extends Value> T getPreviousIterationAggregate(String name) {     return this.runtimeContext.getPreviousIterationAggregate(name). }
true;public;1;3;/**  * Gets the broadcast data set registered under the given name. Broadcast data sets  * are available on all parallel instances of a function. They can be registered via  * {@link org.apache.flink.graph.spargel.ScatterGatherConfiguration#addBroadcastSetForScatterFunction(String, org.apache.flink.api.java.DataSet)}.  *  * @param name The name under which the broadcast set is registered.  * @return The broadcast data set.  */ ;/**  * Gets the broadcast data set registered under the given name. Broadcast data sets  * are available on all parallel instances of a function. They can be registered via  * {@link org.apache.flink.graph.spargel.ScatterGatherConfiguration#addBroadcastSetForScatterFunction(String, org.apache.flink.api.java.DataSet)}.  *  * @param name The name under which the broadcast set is registered.  * @return The broadcast data set.  */ public <T> Collection<T> getBroadcastSet(String name) {     return this.runtimeContext.getBroadcastVariable(name). }
false;;1;5;;void init(IterationRuntimeContext context) {     this.runtimeContext = context.     this.outValue = new Tuple2<>().     this.edgeIterator = new EdgesIterator<>(). }
false;;3;6;;void set(Iterator<?> edges, Collector<Tuple2<K, Message>> out, K id) {     this.edges = edges.     this.out = out.     this.vertexId = id.     this.edgesUsed = false. }
false;;1;3;;void set(Iterator<Edge<K, EV>> input) {     this.input = input. }
false;public;0;4;;@Override public boolean hasNext() {     return input.hasNext(). }
false;public;0;8;;@Override public Edge<K, EV> next() {     Edge<K, EV> next = input.next().     edge.setSource(next.f0).     edge.setTarget(next.f1).     edge.setValue(next.f2).     return edge. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public Iterator<Edge<K, EV>> iterator() {     return this. }
true;public;0;3;/**  * Retrieves the vertex in-degree (number of in-coming edges).  * @return The in-degree of this vertex  */ ;/**  * Retrieves the vertex in-degree (number of in-coming edges).  * @return The in-degree of this vertex  */ public long getInDegree() {     return inDegree. }
false;;1;3;;void setInDegree(long inDegree) {     this.inDegree = inDegree. }
true;public;0;3;/**  * Retrieve the vertex out-degree (number of out-going edges).  * @return The out-degree of this vertex  */ ;/**  * Retrieve the vertex out-degree (number of out-going edges).  * @return The out-degree of this vertex  */ public long getOutDegree() {     return outDegree. }
false;;1;3;;void setOutDegree(long outDegree) {     this.outDegree = outDegree. }
