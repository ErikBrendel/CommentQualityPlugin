commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * By default only the edge set is processed for the computation of degree.  * When this flag is set an additional join is performed against the vertex  * set in order to output vertices with an in-degree of zero.  *  * @param includeZeroDegreeVertices whether to output vertices with an  *                                  in-degree of zero  * @return this  */ ;/**  * By default only the edge set is processed for the computation of degree.  * When this flag is set an additional join is performed against the vertex  * set in order to output vertices with an in-degree of zero.  *  * @param includeZeroDegreeVertices whether to output vertices with an  *                                  in-degree of zero  * @return this  */ public VertexDegrees<K, VV, EV> setIncludeZeroDegreeVertices(boolean includeZeroDegreeVertices) {     this.includeZeroDegreeVertices.set(includeZeroDegreeVertices).     return this. }
false;protected;1;10;;@Override protected boolean canMergeConfigurationWith(GraphAlgorithmWrappingBase other) {     if (!super.canMergeConfigurationWith(other)) {         return false.     }     VertexDegrees rhs = (VertexDegrees) other.     return !includeZeroDegreeVertices.conflictsWith(rhs.includeZeroDegreeVertices). }
false;protected;1;8;;@Override protected void mergeConfiguration(GraphAlgorithmWrappingBase other) {     super.mergeConfiguration(other).     VertexDegrees rhs = (VertexDegrees) other.     includeZeroDegreeVertices.mergeWith(rhs.includeZeroDegreeVertices). }
false;public;1;32;;@Override public DataSet<Vertex<K, Degrees>> runInternal(Graph<K, VV, EV> input) throws Exception {     // s, t, bitmask     DataSet<Tuple2<K, ByteValue>> vertexWithEdgeOrder = input.getEdges().flatMap(new EmitAndFlipEdge<>()).setParallelism(parallelism).name("Emit and flip edge").groupBy(0, 1).reduceGroup(new ReduceBitmask<>()).setParallelism(parallelism).name("Reduce bitmask").     // s, d(s)     DataSet<Vertex<K, Degrees>> vertexDegrees = vertexWithEdgeOrder.groupBy(0).reduceGroup(new DegreeCount<>()).setParallelism(parallelism).name("Degree count").     if (includeZeroDegreeVertices.get()) {         vertexDegrees = input.getVertices().leftOuterJoin(vertexDegrees).where(0).equalTo(0).with(new JoinVertexWithVertexDegrees<>()).setParallelism(parallelism).name("Zero degree vertices").     }     return vertexDegrees. }
false;public;2;11;;@Override public void flatMap(Edge<T, TV> value, Collector<Tuple3<T, T, ByteValue>> out) throws Exception {     forward.f0 = value.f0.     forward.f1 = value.f1.     out.collect(forward).     reverse.f0 = value.f1.     reverse.f1 = value.f0.     out.collect(reverse). }
false;public;2;13;;@Override public void reduce(Iterable<Tuple3<T, T, ByteValue>> values, Collector<Tuple2<T, ByteValue>> out) throws Exception {     byte bitmask = 0.     for (Tuple3<T, T, ByteValue> value : values) {         output.f0 = value.f0.         bitmask |= value.f2.getValue().     }     output.f1.setValue(bitmask).     out.collect(output). }
false;public;2;30;;@Override public void reduce(Iterable<Tuple2<T, ByteValue>> values, Collector<Vertex<T, Degrees>> out) throws Exception {     long degree = 0.     long outDegree = 0.     long inDegree = 0.     for (Tuple2<T, ByteValue> edge : values) {         output.f0 = edge.f0.         byte bitmask = edge.f1.getValue().         degree++.         if (bitmask == EdgeOrder.FORWARD.getBitmask()) {             outDegree++.         } else if (bitmask == EdgeOrder.REVERSE.getBitmask()) {             inDegree++.         } else {             outDegree++.             inDegree++.         }     }     output.f1.getDegree().setValue(degree).     output.f1.getOutDegree().setValue(outDegree).     output.f1.getInDegree().setValue(inDegree).     out.collect(output). }
false;public;2;10;;@Override public Vertex<T, Degrees> join(Vertex<T, TV> vertex, Vertex<T, Degrees> vertexDegree) throws Exception {     if (vertexDegree == null) {         output.f0 = vertex.f0.         return output.     } else {         return vertexDegree.     } }
false;public;0;3;;public LongValue getDegree() {     return f0. }
false;public;0;3;;public LongValue getOutDegree() {     return f1. }
false;public;0;3;;public LongValue getInDegree() {     return f2. }
false;public;0;8;;@Override public int hashCode() {     return hasher.reset().hash(f0.getValue()).hash(f1.getValue()).hash(f2.getValue()).hash(). }
