commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * The degree can be counted from either the edge source or target IDs.  * By default the source IDs are counted. Reducing on target IDs may  * optimize the algorithm if the input edge list is sorted by target ID.  *  * @param reduceOnTargetId set to {@code true} if the input edge list  *                         is sorted by target ID  * @return this  */ ;/**  * The degree can be counted from either the edge source or target IDs.  * By default the source IDs are counted. Reducing on target IDs may  * optimize the algorithm if the input edge list is sorted by target ID.  *  * @param reduceOnTargetId set to {@code true} if the input edge list  *                         is sorted by target ID  * @return this  */ public MaximumDegree<K, VV, EV> setReduceOnTargetId(boolean reduceOnTargetId) {     this.reduceOnTargetId.set(reduceOnTargetId).     return this. }
true;public;1;5;/**  * After filtering high-degree vertices this algorithm must perform joins  * on the original graph's vertex set and on both the source and target IDs  * of the edge set. These joins can be performed without shuffling data  * over the network if the high-degree vertices are distributed by a  * broadcast-hash.  *  * @param broadcastHighDegreeVertices set to {@code true} if the high-degree  *                                    vertices should be broadcast when joining  * @return this  */ ;/**  * After filtering high-degree vertices this algorithm must perform joins  * on the original graph's vertex set and on both the source and target IDs  * of the edge set. These joins can be performed without shuffling data  * over the network if the high-degree vertices are distributed by a  * broadcast-hash.  *  * @param broadcastHighDegreeVertices set to {@code true} if the high-degree  *                                    vertices should be broadcast when joining  * @return this  */ public MaximumDegree<K, VV, EV> setBroadcastHighDegreeVertices(boolean broadcastHighDegreeVertices) {     this.broadcastHighDegreeVertices.set(broadcastHighDegreeVertices).     return this. }
false;protected;1;10;;@Override protected boolean canMergeConfigurationWith(GraphAlgorithmWrappingBase other) {     if (!super.canMergeConfigurationWith(other)) {         return false.     }     MaximumDegree rhs = (MaximumDegree) other.     return maximumDegree == rhs.maximumDegree. }
false;protected;1;9;;@Override protected void mergeConfiguration(GraphAlgorithmWrappingBase other) {     super.mergeConfiguration(other).     MaximumDegree rhs = (MaximumDegree) other.     reduceOnTargetId.mergeWith(rhs.reduceOnTargetId).     broadcastHighDegreeVertices.mergeWith(rhs.broadcastHighDegreeVertices). }
false;public;1;46;;/* 	 * Implementation notes: 	 * 	 * The three leftOuterJoin below could be implemented more efficiently 	 *   as an anti-join when available in Flink. 	 */ @Override public Graph<K, VV, EV> runInternal(Graph<K, VV, EV> input) throws Exception {     // u, d(u)     DataSet<Vertex<K, LongValue>> vertexDegree = input.run(new VertexDegree<K, VV, EV>().setReduceOnTargetId(reduceOnTargetId.get()).setParallelism(parallelism)).     // u, d(u) if d(u) > maximumDegree     DataSet<Tuple1<K>> highDegreeVertices = vertexDegree.flatMap(new DegreeFilter<>(maximumDegree)).setParallelism(parallelism).name("Filter high-degree vertices").     JoinHint joinHint = broadcastHighDegreeVertices.get() ? JoinHint.BROADCAST_HASH_SECOND : JoinHint.REPARTITION_HASH_SECOND.     // Vertices     DataSet<Vertex<K, VV>> vertices = input.getVertices().leftOuterJoin(highDegreeVertices, joinHint).where(0).equalTo(0).with(new ProjectVertex<>()).setParallelism(parallelism).name("Project low-degree vertices").     // Edges     DataSet<Edge<K, EV>> edges = input.getEdges().leftOuterJoin(highDegreeVertices, joinHint).where(reduceOnTargetId.get() ? 1 : 0).equalTo(0).with(new ProjectEdge<>()).setParallelism(parallelism).name("Project low-degree edges by " + (reduceOnTargetId.get() ? "target" : "source")).leftOuterJoin(highDegreeVertices, joinHint).where(reduceOnTargetId.get() ? 0 : 1).equalTo(0).with(new ProjectEdge<>()).setParallelism(parallelism).name("Project low-degree edges by " + (reduceOnTargetId.get() ? "source" : "target")).     // Graph     return Graph.fromDataSet(vertices, edges, input.getContext()). }
false;public;2;8;;@Override public void flatMap(Vertex<K, LongValue> value, Collector<Tuple1<K>> out) throws Exception {     if (value.f1.getValue() > maximumDegree) {         output.f0 = value.f0.         out.collect(output).     } }
false;public;3;7;;@Override public void join(Vertex<T, VT> vertex, Tuple1<T> id, Collector<Vertex<T, VT>> out) throws Exception {     if (id == null) {         out.collect(vertex).     } }
false;public;3;7;;@Override public void join(Edge<T, ET> edge, Tuple1<T> id, Collector<Edge<T, ET>> out) throws Exception {     if (id == null) {         out.collect(edge).     } }
