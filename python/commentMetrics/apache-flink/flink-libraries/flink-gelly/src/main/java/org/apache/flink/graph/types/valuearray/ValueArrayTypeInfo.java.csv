commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int getArity() {     return 1. }
false;public;0;4;;@Override public int getTotalFields() {     return 1. }
false;public;0;5;;@SuppressWarnings("unchecked") @Override public Class<ValueArray<T>> getTypeClass() {     return (Class<ValueArray<T>>) (Class<?>) ValueArray.class. }
false;public;0;4;;@Override public boolean isBasicType() {     return false. }
false;public;0;4;;@Override public boolean isTupleType() {     return false. }
false;public;0;6;;@Override public boolean isKeyType() {     Preconditions.checkNotNull(type, "TypeInformation type class is required").     return Comparable.class.isAssignableFrom(type). }
false;public;1;27;;@Override @SuppressWarnings("unchecked") public TypeSerializer<ValueArray<T>> createSerializer(ExecutionConfig executionConfig) {     Preconditions.checkNotNull(type, "TypeInformation type class is required").     if (ByteValue.class.isAssignableFrom(type)) {         return (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new ByteValueArraySerializer().     } else if (CharValue.class.isAssignableFrom(type)) {         return (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new CharValueArraySerializer().     } else if (DoubleValue.class.isAssignableFrom(type)) {         return (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new DoubleValueArraySerializer().     } else if (FloatValue.class.isAssignableFrom(type)) {         return (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new FloatValueArraySerializer().     } else if (IntValue.class.isAssignableFrom(type)) {         return (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new IntValueArraySerializer().     } else if (LongValue.class.isAssignableFrom(type)) {         return (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new LongValueArraySerializer().     } else if (NullValue.class.isAssignableFrom(type)) {         return (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new NullValueArraySerializer().     } else if (ShortValue.class.isAssignableFrom(type)) {         return (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new ShortValueArraySerializer().     } else if (StringValue.class.isAssignableFrom(type)) {         return (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new StringValueArraySerializer().     } else {         throw new InvalidTypesException("No ValueArray class exists for " + type).     } }
false;public;2;27;;@SuppressWarnings({ "unchecked", "rawtypes" }) @Override public TypeComparator<ValueArray<T>> createComparator(boolean sortOrderAscending, ExecutionConfig executionConfig) {     Preconditions.checkNotNull(type, "TypeInformation type class is required").     if (ByteValue.class.isAssignableFrom(type)) {         return (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new ByteValueArrayComparator(sortOrderAscending).     } else if (CharValue.class.isAssignableFrom(type)) {         return (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new CharValueArrayComparator(sortOrderAscending).     } else if (DoubleValue.class.isAssignableFrom(type)) {         return (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new DoubleValueArrayComparator(sortOrderAscending).     } else if (FloatValue.class.isAssignableFrom(type)) {         return (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new FloatValueArrayComparator(sortOrderAscending).     } else if (IntValue.class.isAssignableFrom(type)) {         return (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new IntValueArrayComparator(sortOrderAscending).     } else if (LongValue.class.isAssignableFrom(type)) {         return (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new LongValueArrayComparator(sortOrderAscending).     } else if (NullValue.class.isAssignableFrom(type)) {         return (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new NullValueArrayComparator(sortOrderAscending).     } else if (ShortValue.class.isAssignableFrom(type)) {         return (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new ShortValueArrayComparator(sortOrderAscending).     } else if (StringValue.class.isAssignableFrom(type)) {         return (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new StringValueArrayComparator(sortOrderAscending).     } else {         throw new InvalidTypesException("No ValueArray class exists for " + type).     } }
false;public;0;6;;@Override public Map<String, TypeInformation<?>> getGenericParameters() {     Map<String, TypeInformation<?>> m = new HashMap<>(1).     m.put("T", valueType).     return m. }
false;public;0;6;;// -------------------------------------------------------------------------------------------- @Override public int hashCode() {     Preconditions.checkNotNull(type, "TypeInformation type class is required").     return type.hashCode(). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (obj instanceof ValueArrayTypeInfo) {         @SuppressWarnings("unchecked")         ValueArrayTypeInfo<T> valueArrayTypeInfo = (ValueArrayTypeInfo<T>) obj.         return valueArrayTypeInfo.canEqual(this) && type == valueArrayTypeInfo.type.     } else {         return false.     } }
false;public;1;4;;@Override public boolean canEqual(Object obj) {     return obj instanceof ValueArrayTypeInfo. }
false;public;0;6;;@Override public String toString() {     Preconditions.checkNotNull(type, "TypeInformation type class is required").     return "ValueArrayType<" + type.getSimpleName() + ">". }
