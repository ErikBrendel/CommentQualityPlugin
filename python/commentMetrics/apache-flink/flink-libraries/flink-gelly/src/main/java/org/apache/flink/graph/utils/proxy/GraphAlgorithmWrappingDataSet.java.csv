commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;1;1;/**  * The implementation of the algorithm, renamed from {@link GraphAlgorithm#run(Graph)}.  *  * @param input the input graph  * @return the algorithm's output  * @throws Exception  */ ;/**  * The implementation of the algorithm, renamed from {@link GraphAlgorithm#run(Graph)}.  *  * @param input the input graph  * @return the algorithm's output  * @throws Exception  */ protected abstract DataSet<T> runInternal(Graph<K, VV, EV> input) throws Exception.
false;public,final;0;7;;@Override public final int hashCode() {     return new HashCodeBuilder(17, 37).append(input).append(getAlgorithmName()).toHashCode(). }
false;public,final;1;21;;@Override public final boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (obj == this) {         return true.     }     if (!GraphAlgorithmWrappingDataSet.class.isAssignableFrom(obj.getClass())) {         return false.     }     GraphAlgorithmWrappingDataSet rhs = (GraphAlgorithmWrappingDataSet) obj.     return new EqualsBuilder().append(input, rhs.input).append(getAlgorithmName(), rhs.getAlgorithmName()).isEquals(). }
false;public,final;1;37;;@Override @SuppressWarnings("unchecked") public final DataSet<T> run(Graph<K, VV, EV> input) throws Exception {     this.input = input.     if (cache.containsKey(this)) {         for (GraphAlgorithmWrappingDataSet<K, VV, EV, T> other : cache.get(this)) {             if (canMergeConfigurationWith(other)) {                 mergeConfiguration(other).                 // configuration has been merged so generate new output                 DataSet<T> output = runInternal(input).                 other.wrappingOperator.setInput(output).                 wrappingOperator = other.wrappingOperator.                 return wrappingOperator.             }         }     }     // no mergeable configuration found so generate new output     DataSet<T> output = runInternal(input).     // create a new operator to wrap the algorithm output     wrappingOperator = new NoOpOperator<>(output, output.getType()).     // cache this result     if (cache.containsKey(this)) {         cache.get(this).add(this).     } else {         cache.put(this, new ArrayList(Collections.singletonList(this))).     }     return wrappingOperator. }
