commented;modifiers;parameterAmount;loc;comment;code
true;private;1;6;/**  * Initializes the array with the provided number of bytes.  *  * @param bytes initial size of the encapsulated array in bytes  */ ;/**  * Initializes the array with the provided number of bytes.  *  * @param bytes initial size of the encapsulated array in bytes  */ private void initialize(int bytes) {     Preconditions.checkArgument(bytes > 0, "Requested array with zero capacity").     Preconditions.checkArgument(bytes <= MAX_ARRAY_SIZE, "Requested capacity exceeds limit of " + MAX_ARRAY_SIZE).     data = new byte[bytes]. }
true;private;1;18;/**  * If the size of the array is insufficient to hold the given capacity then  * copy the array into a new, larger array.  *  * @param minCapacity minimum required number of elements  */ ;// -------------------------------------------------------------------------------------------- /**  * If the size of the array is insufficient to hold the given capacity then  * copy the array into a new, larger array.  *  * @param minCapacity minimum required number of elements  */ private void ensureCapacity(int minCapacity) {     long currentCapacity = data.length.     if (minCapacity <= currentCapacity) {         return.     }     // increase capacity by at least ~50%     long expandedCapacity = Math.max(minCapacity, currentCapacity + (currentCapacity >> 1)).     int newCapacity = (int) Math.min(MAX_ARRAY_SIZE, expandedCapacity).     if (newCapacity < minCapacity) {         // throw exception as unbounded arrays are not expected to fill         throw new RuntimeException("Requested array size " + minCapacity + " exceeds limit of " + MAX_ARRAY_SIZE).     }     data = Arrays.copyOf(data, newCapacity). }
false;public;0;16;;@Override public String toString() {     StringBuilder sb = new StringBuilder("[").     String separator = "".     for (StringValue sv : this) {         sb.append(sv.getValue()).append(separator).         separator = ",".     }     sb.append("]").     return sb.toString(). }
false;public;0;5;;@Override public Iterator<StringValue> iterator() {     iterator.reset().     return iterator. }
false;public;0;4;;@Override public boolean hasNext() {     return pos < position. }
false;public;0;46;;@Override public StringValue next() {     // read length     int len = data[pos++] & 0xFF.     if (len >= HIGH_BIT) {         int shift = 7.         int curr.         len = len & 0x7F.         while ((curr = data[pos++] & 0xFF) >= HIGH_BIT) {             len |= (curr & 0x7F) << shift.             shift += 7.         }         len |= curr << shift.     }     // ensure capacity     if (len > size) {         while (size < len) {             size *= 2.         }         value = new StringValue(CharBuffer.allocate(size)).     }     // read string characters     final char[] valueData = value.getCharArray().     for (int i = 0. i < len. i++) {         int c = data[pos++] & 0xFF.         if (c >= HIGH_BIT) {             int shift = 7.             int curr.             c = c & 0x7F.             while ((curr = data[pos++] & 0xFF) >= HIGH_BIT) {                 c |= (curr & 0x7F) << shift.                 shift += 7.             }             c |= curr << shift.         }         valueData[i] = (char) c.     }     // cannot prevent allocation of new StringValue!     return value.substring(0, len). }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException("remove"). }
false;public;0;3;;public void reset() {     pos = 0. }
false;public;1;7;;// -------------------------------------------------------------------------------------------- // IOReadableWritable // -------------------------------------------------------------------------------------------- @Override public void write(DataOutputView out) throws IOException {     out.writeInt(length).     out.writeInt(position).     out.write(data, 0, position). }
false;public;1;12;;@Override public void read(DataInputView in) throws IOException {     length = in.readInt().     position = in.readInt().     markLength = 0.     markPosition = 0.     ensureCapacity(position).     in.read(data, 0, position). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // NormalizableKey // -------------------------------------------------------------------------------------------- @Override public int getMaxNormalizedKeyLen() {     return hashValue.getMaxNormalizedKeyLen(). }
false;public;3;12;;@Override public void copyNormalizedKey(MemorySegment target, int offset, int len) {     hash.reset().     hash.hash(position).     for (int i = 0. i < position. i++) {         hash.hash(data[i]).     }     hashValue.setValue(hash.hash()).     hashValue.copyNormalizedKey(target, offset, len). }
false;public;1;22;;// -------------------------------------------------------------------------------------------- // Comparable // -------------------------------------------------------------------------------------------- @Override public int compareTo(ValueArray<StringValue> o) {     StringValueArray other = (StringValueArray) o.     // sorts first on number of data in the array, then comparison between     // the first non-equal element in the arrays     int cmp = Integer.compare(position, other.position).     if (cmp != 0) {         return cmp.     }     for (int i = 0. i < position. i++) {         cmp = Byte.compare(data[i], other.data[i]).         if (cmp != 0) {             return cmp.         }     }     return 0. }
false;public;0;10;;// -------------------------------------------------------------------------------------------- // Key // -------------------------------------------------------------------------------------------- @Override public int hashCode() {     int hash = 0.     for (int i = 0. i < position. i++) {         hash = 31 * hash + data[i].     }     return hash. }
false;public;1;24;;@Override public boolean equals(Object obj) {     if (obj instanceof StringValueArray) {         StringValueArray other = (StringValueArray) obj.         if (length != other.length) {             return false.         }         if (position != other.position) {             return false.         }         for (int i = 0. i < position. i++) {             if (data[i] != other.data[i]) {                 return false.             }         }         return true.     }     return false. }
false;public;1;4;;// -------------------------------------------------------------------------------------------- // ResettableValue // -------------------------------------------------------------------------------------------- @Override public void setValue(ValueArray<StringValue> value) {     value.copyTo(this). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // CopyableValue // -------------------------------------------------------------------------------------------- @Override public int getBinaryLength() {     return -1. }
false;public;1;12;;@Override public void copyTo(ValueArray<StringValue> target) {     StringValueArray other = (StringValueArray) target.     other.length = length.     other.position = position.     other.markLength = markLength.     other.markPosition = markPosition.     other.ensureCapacity(position).     System.arraycopy(data, 0, other.data, 0, position). }
false;public;0;8;;@Override public ValueArray<StringValue> copy() {     ValueArray<StringValue> copy = new StringValueArray().     this.copyTo(copy).     return copy. }
false;public;2;4;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     copyInternal(source, target). }
false;protected,static;2;9;;protected static void copyInternal(DataInputView source, DataOutputView target) throws IOException {     int length = source.readInt().     target.writeInt(length).     int position = source.readInt().     target.writeInt(position).     target.write(source, position). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // ValueArray // -------------------------------------------------------------------------------------------- @Override public int size() {     return length. }
false;public;0;8;;@Override public boolean isFull() {     if (isBounded) {         return position >= boundedLength.     } else {         return position == MAX_ARRAY_SIZE.     } }
false;public;1;51;;@Override public boolean add(StringValue value) {     if (isBounded && position >= boundedLength) {         return false.     }     // up to five bytes storing length     if (position + 5 > data.length) {         ensureCapacity(position + 5).     }     // update local variable until serialization succeeds     int newPosition = position.     // write the length, variable-length encoded     int len = value.length().     while (len >= HIGH_BIT) {         data[newPosition++] = (byte) (len | HIGH_BIT).         len >>>= 7.     }     data[newPosition++] = (byte) len.     // write the char data, variable-length encoded     final char[] valueData = value.getCharArray().     int remainingCapacity = data.length - newPosition.     len = value.length().     for (int i = 0. i < len. i++) {         // up to three bytes storing length         if (remainingCapacity < 3) {             ensureCapacity(remainingCapacity + 3).             remainingCapacity = data.length - newPosition.         }         int c = valueData[i].         while (c >= HIGH_BIT) {             data[newPosition++] = (byte) (c | HIGH_BIT).             remainingCapacity--.             c >>>= 7.         }         data[newPosition++] = (byte) c.         remainingCapacity--.     }     length++.     position = newPosition.     return true. }
false;public;1;21;;@Override public boolean addAll(ValueArray<StringValue> other) {     StringValueArray source = (StringValueArray) other.     int sourceSize = source.position.     int newPosition = position + sourceSize.     if (newPosition > data.length) {         if (isBounded) {             return false.         } else {             ensureCapacity(newPosition).         }     }     System.arraycopy(source.data, 0, data, position, sourceSize).     length += source.length.     position = newPosition.     return true. }
false;public;0;5;;@Override public void clear() {     length = 0.     position = 0. }
false;public;0;5;;@Override public void mark() {     markLength = length.     markPosition = position. }
false;public;0;5;;@Override public void reset() {     length = markLength.     position = markPosition. }
