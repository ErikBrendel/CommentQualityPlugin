commented;modifiers;parameterAmount;loc;comment;code
true;public;1;7;/**  * Filter out Adamic-Adar scores less than the given minimum.  *  * @param score minimum score  * @return this  */ ;/**  * Filter out Adamic-Adar scores less than the given minimum.  *  * @param score minimum score  * @return this  */ public AdamicAdar<K, VV, EV> setMinimumScore(float score) {     Preconditions.checkArgument(score >= 0, "Minimum score must be non-negative").     this.minimumScore = score.     return this. }
true;public;1;7;/**  * Filter out Adamic-Adar scores less than the given ratio times the average score.  *  * @param ratio minimum ratio  * @return this  */ ;/**  * Filter out Adamic-Adar scores less than the given ratio times the average score.  *  * @param ratio minimum ratio  * @return this  */ public AdamicAdar<K, VV, EV> setMinimumRatio(float ratio) {     Preconditions.checkArgument(ratio >= 0, "Minimum ratio must be non-negative").     this.minimumRatio = ratio.     return this. }
true;public;1;5;/**  * By default only one result is output for each pair of vertices. When  * mirroring a second result with the vertex order flipped is output for  * each pair of vertices.  *  * @param mirrorResults whether output results should be mirrored  * @return this  */ ;/**  * By default only one result is output for each pair of vertices. When  * mirroring a second result with the vertex order flipped is output for  * each pair of vertices.  *  * @param mirrorResults whether output results should be mirrored  * @return this  */ public AdamicAdar<K, VV, EV> setMirrorResults(boolean mirrorResults) {     this.mirrorResults = mirrorResults.     return this. }
false;protected;1;10;;@Override protected boolean canMergeConfigurationWith(GraphAlgorithmWrappingBase other) {     if (!super.canMergeConfigurationWith(other)) {         return false.     }     AdamicAdar rhs = (AdamicAdar) other.     return minimumRatio == rhs.minimumRatio && minimumScore == rhs.minimumScore. }
false;public;1;73;;/* 	 * Implementation notes: 	 * 	 * The requirement that "K extends CopyableValue<K>" can be removed when 	 *   Flink has a self-join which performs the skew distribution handled by 	 *   GenerateGroupSpans / GenerateGroups / GenerateGroupPairs. 	 */ @Override public DataSet<Result<K>> runInternal(Graph<K, VV, EV> input) throws Exception {     // s, d(s), 1/log(d(s))     DataSet<Tuple3<K, LongValue, FloatValue>> inverseLogDegree = input.run(new VertexDegree<K, VV, EV>().setParallelism(parallelism)).map(new VertexInverseLogDegree<>()).setParallelism(parallelism).name("Vertex score").     // s, t, 1/log(d(s))     DataSet<Tuple3<K, K, FloatValue>> sourceInverseLogDegree = input.getEdges().join(inverseLogDegree, JoinHint.REPARTITION_HASH_SECOND).where(0).equalTo(0).projectFirst(0, 1).<Tuple3<K, K, FloatValue>>projectSecond(2).setParallelism(parallelism).name("Edge score").     // group span, s, t, 1/log(d(s))     DataSet<Tuple4<IntValue, K, K, FloatValue>> groupSpans = sourceInverseLogDegree.groupBy(0).sortGroup(1, Order.ASCENDING).reduceGroup(new GenerateGroupSpans<>()).setParallelism(parallelism).name("Generate group spans").     // group, s, t, 1/log(d(s))     DataSet<Tuple4<IntValue, K, K, FloatValue>> groups = groupSpans.rebalance().setParallelism(parallelism).name("Rebalance").flatMap(new GenerateGroups<>()).setParallelism(parallelism).name("Generate groups").     // t, u, 1/log(d(s)) where (s, t) and (s, u) are edges in graph     DataSet<Tuple3<K, K, FloatValue>> twoPaths = groups.groupBy(0, 1).sortGroup(2, Order.ASCENDING).reduceGroup(new GenerateGroupPairs<>()).name("Generate group pairs").     // t, u, adamic-adar score     GroupReduceOperator<Tuple3<K, K, FloatValue>, Result<K>> scores = twoPaths.groupBy(0, 1).reduceGroup(new ComputeScores<>(minimumScore, minimumRatio)).name("Compute scores").     if (minimumRatio > 0.0f) {         // total score, number of pairs of neighbors         DataSet<Tuple2<FloatValue, LongValue>> sumOfScoresAndNumberOfNeighborPairs = inverseLogDegree.map(new ComputeScoreFromVertex<>()).setParallelism(parallelism).name("Average score").sum(0).andSum(1).         scores.withBroadcastSet(sumOfScoresAndNumberOfNeighborPairs, SUM_OF_SCORES_AND_NUMBER_OF_NEIGHBOR_PAIRS).     }     if (mirrorResults) {         return scores.flatMap(new MirrorResult<>()).name("Mirror results").     } else {         return scores.     } }
false;public;1;13;;@Override public Tuple3<T, LongValue, FloatValue> map(Vertex<T, LongValue> value) throws Exception {     output.f0 = value.f0.     output.f1 = value.f1.     long degree = value.f1.getValue().     // when the degree is one the logarithm is zero so avoid dividing by this value     float inverseLogDegree = (degree == 1) ? 0.0f : 1.0f / (float) Math.log(value.f1.getValue()).     output.f2.setValue(inverseLogDegree).     return output. }
false;public;2;21;;@Override public void reduce(Iterable<Tuple3<T, T, FloatValue>> values, Collector<Tuple4<IntValue, T, T, FloatValue>> out) throws Exception {     int groupCount = 0.     int groupSpans = 1.     groupSpansValue.setValue(groupSpans).     for (Tuple3<T, T, FloatValue> edge : values) {         output.f1 = edge.f0.         output.f2 = edge.f1.         output.f3 = edge.f2.         out.collect(output).         if (++groupCount == GROUP_SIZE) {             groupCount = 0.             groupSpansValue.setValue(++groupSpans).         }     } }
false;public;2;10;;@Override public void flatMap(Tuple4<IntValue, T, T, FloatValue> value, Collector<Tuple4<IntValue, T, T, FloatValue>> out) throws Exception {     int spans = value.f0.getValue().     for (int idx = 0. idx < spans. idx++) {         value.f0.setValue(idx).         out.collect(value).     } }
false;public;2;29;;@Override public void reduce(Iterable<Tuple4<IntValue, T, T, FloatValue>> values, Collector<Tuple3<T, T, FloatValue>> out) throws Exception {     int visitedCount = 0.     for (Tuple4<IntValue, T, T, FloatValue> edge : values) {         output.f1 = edge.f2.         output.f2 = edge.f3.         for (int i = 0. i < visitedCount. i++) {             output.f0 = visited.get(i).             out.collect(output).         }         if (visitedCount < GROUP_SIZE) {             if (!initialized) {                 initialized = true.                 for (int i = 0. i < GROUP_SIZE. i++) {                     visited.add(edge.f2.copy()).                 }             } else {                 edge.f2.copyTo(visited.get(visitedCount)).             }             visitedCount += 1.         }     } }
false;public;1;10;;@Override public Tuple2<FloatValue, LongValue> map(Tuple3<T, LongValue, FloatValue> value) throws Exception {     long degree = value.f1.getValue().     long neighborPairs = degree * (degree - 1) / 2.     sumOfScores.setValue(value.f2.getValue() * neighborPairs).     numberOfNeighborPairs.setValue(neighborPairs).     return output. }
false;public;1;14;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     if (minimumRatio > 0.0f) {         Collection<Tuple2<FloatValue, LongValue>> var.         var = getRuntimeContext().getBroadcastVariable(SUM_OF_SCORES_AND_NUMBER_OF_NEIGHBOR_PAIRS).         Tuple2<FloatValue, LongValue> sumAndCount = var.iterator().next().         float averageScore = sumAndCount.f0.getValue() / sumAndCount.f1.getValue().         minimumScore = Math.max(minimumScore, averageScore * minimumRatio).     } }
false;public;2;18;;@Override public void reduce(Iterable<Tuple3<T, T, FloatValue>> values, Collector<Result<T>> out) throws Exception {     double sum = 0.     Tuple3<T, T, FloatValue> edge = null.     for (Tuple3<T, T, FloatValue> next : values) {         edge = next.         sum += next.f2.getValue().     }     if (sum >= minimumScore) {         output.setVertexId0(edge.f0).         output.setVertexId1(edge.f1).         output.setAdamicAdarScore((float) sum).         out.collect(output).     } }
true;public;0;3;/**  * Get the Adamic-Adar score, equal to the sum over common neighbors of  * the inverse logarithm of degree.  *  * @return Adamic-Adar score  */ ;/**  * Get the Adamic-Adar score, equal to the sum over common neighbors of  * the inverse logarithm of degree.  *  * @return Adamic-Adar score  */ public FloatValue getAdamicAdarScore() {     return adamicAdarScore. }
true;public;1;3;/**  * Set the Adamic-Adar score, equal to the sum over common neighbors of  * the inverse logarithm of degree.  *  * @param adamicAdarScore the Adamic-Adar score  */ ;/**  * Set the Adamic-Adar score, equal to the sum over common neighbors of  * the inverse logarithm of degree.  *  * @param adamicAdarScore the Adamic-Adar score  */ public void setAdamicAdarScore(FloatValue adamicAdarScore) {     this.adamicAdarScore = adamicAdarScore. }
false;private;1;3;;private void setAdamicAdarScore(float adamicAdarScore) {     this.adamicAdarScore.setValue(adamicAdarScore). }
false;public;0;7;;@Override public String toString() {     return "(" + getVertexId0() + "," + getVertexId1() + "," + adamicAdarScore + ")". }
false;public;0;6;;@Override public String toPrintableString() {     return "Vertex IDs: (" + getVertexId0() + ", " + getVertexId1() + "), adamic-adar score: " + adamicAdarScore. }
false;public;1;4;;@Override public int compareTo(Result<T> o) {     return Float.compare(adamicAdarScore.getValue(), o.adamicAdarScore.getValue()). }
false;public;0;12;;@Override public int hashCode() {     if (hasher == null) {         hasher = new MurmurHash(HASH_SEED).     }     return hasher.reset().hash(getVertexId0().hashCode()).hash(getVertexId1().hashCode()).hash(adamicAdarScore.getValue()).hash(). }
