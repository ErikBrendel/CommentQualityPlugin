commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public int hash(StringValueArray record) {     return record.hashCode(). }
false;public;1;4;;@Override public void setReference(StringValueArray toCompare) {     toCompare.copyTo(reference). }
false;public;1;4;;@Override public boolean equalToReference(StringValueArray candidate) {     return candidate.equals(this.reference). }
false;public;1;5;;@Override public int compareToReference(TypeComparator<StringValueArray> referencedComparator) {     int comp = ((StringValueArrayComparator) referencedComparator).reference.compareTo(reference).     return ascendingComparison ? comp : -comp. }
false;public;2;5;;@Override public int compare(StringValueArray first, StringValueArray second) {     int comp = first.compareTo(second).     return ascendingComparison ? comp : -comp. }
true;private,static;1;16;/**  * Read the length of the next serialized {@code StringValue}.  *  * @param source the input view containing the record  * @return the length of the next serialized {@code StringValue}  * @throws IOException if the input view raised an exception when reading the length  */ ;/**  * Read the length of the next serialized {@code StringValue}.  *  * @param source the input view containing the record  * @return the length of the next serialized {@code StringValue}  * @throws IOException if the input view raised an exception when reading the length  */ private static int readStringLength(DataInputView source) throws IOException {     int len = source.readByte() & 0xFF.     if (len >= HIGH_BIT) {         int shift = 7.         int curr.         len = len & 0x7F.         while ((curr = source.readByte() & 0xFF) >= HIGH_BIT) {             len |= (curr & 0x7F) << shift.             shift += 7.         }         len |= curr << shift.     }     return len. }
true;private,static;1;16;/**  * Read the next character from the serialized {@code StringValue}.  *  * @param source the input view containing the record  * @return the next {@code char} of the current serialized {@code StringValue}  * @throws IOException if the input view raised an exception when reading the length  */ ;/**  * Read the next character from the serialized {@code StringValue}.  *  * @param source the input view containing the record  * @return the next {@code char} of the current serialized {@code StringValue}  * @throws IOException if the input view raised an exception when reading the length  */ private static char readStringChar(DataInputView source) throws IOException {     int c = source.readByte() & 0xFF.     if (c >= HIGH_BIT) {         int shift = 7.         int curr.         c = c & 0x7F.         while ((curr = source.readByte() & 0xFF) >= HIGH_BIT) {             c |= (curr & 0x7F) << shift.             shift += 7.         }         c |= curr << shift.     }     return (char) c. }
false;public;2;30;;@Override public int compareSerialized(DataInputView firstSource, DataInputView secondSource) throws IOException {     int firstCount = firstSource.readInt().     int secondCount = secondSource.readInt().     int minCount = Math.min(firstCount, secondCount).     while (minCount-- > 0) {         int firstLength = readStringLength(firstSource).         int secondLength = readStringLength(secondSource).         int minLength = Math.min(firstLength, secondLength).         while (minLength-- > 0) {             char firstChar = readStringChar(firstSource).             char secondChar = readStringChar(secondSource).             int cmp = Character.compare(firstChar, secondChar).             if (cmp != 0) {                 return ascendingComparison ? cmp : -cmp.             }         }         int cmp = Integer.compare(firstLength, secondLength).         if (cmp != 0) {             return ascendingComparison ? cmp : -cmp.         }     }     int cmp = Integer.compare(firstCount, secondCount).     return ascendingComparison ? cmp : -cmp. }
false;public;0;4;;@Override public boolean supportsNormalizedKey() {     return NormalizableKey.class.isAssignableFrom(StringValueArray.class). }
false;public;0;4;;@Override public int getNormalizeKeyLen() {     return reference.getMaxNormalizedKeyLen(). }
false;public;1;4;;@Override public boolean isNormalizedKeyPrefixOnly(int keyBytes) {     return keyBytes < getNormalizeKeyLen(). }
false;public;4;4;;@Override public void putNormalizedKey(StringValueArray record, MemorySegment target, int offset, int numBytes) {     record.copyNormalizedKey(target, offset, numBytes). }
false;public;0;4;;@Override public boolean invertNormalizedKey() {     return !ascendingComparison. }
false;public;0;4;;@Override public TypeComparator<StringValueArray> duplicate() {     return new StringValueArrayComparator(ascendingComparison). }
false;public;3;5;;@Override public int extractKeys(Object record, Object[] target, int index) {     target[index] = record.     return 1. }
false;public;0;4;;@Override public TypeComparator<?>[] getFlatComparators() {     return comparators. }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // unsupported normalization // -------------------------------------------------------------------------------------------- @Override public boolean supportsSerializationWithKeyNormalization() {     return false. }
false;public;2;4;;@Override public void writeWithKeyNormalization(StringValueArray record, DataOutputView target) throws IOException {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public StringValueArray readWithKeyDenormalization(StringValueArray reuse, DataInputView source) throws IOException {     throw new UnsupportedOperationException(). }
