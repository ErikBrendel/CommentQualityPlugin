commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;4;/**  * Compare graph vertices and edges against expected values.  *  * @param graph graph under test  * @param expectedVertices vertex labels separated by semi-colons. whitespace is ignored  * @param expectedEdges edges of the form "source,target" separated by semi-colons. whitespace is ignored  * @param <K> the key type for edge and vertex identifiers  * @param <VV> the value type for vertices  * @param <EV> the value type for edges  * @throws Exception  */ ;/**  * Compare graph vertices and edges against expected values.  *  * @param graph graph under test  * @param expectedVertices vertex labels separated by semi-colons. whitespace is ignored  * @param expectedEdges edges of the form "source,target" separated by semi-colons. whitespace is ignored  * @param <K> the key type for edge and vertex identifiers  * @param <VV> the value type for vertices  * @param <EV> the value type for edges  * @throws Exception  */ public static <K, VV, EV> void compareGraph(Graph<K, VV, EV> graph, String expectedVertices, String expectedEdges) throws Exception {     compareVertices(graph, expectedVertices).     compareEdges(graph, expectedEdges). }
false;private,static;2;12;;private static <K, VV, EV> void compareVertices(Graph<K, VV, EV> graph, String expectedVertices) throws Exception {     if (expectedVertices != null) {         List<Vertex<K, VV>> vertices = graph.getVertices().collect().         List<String> resultVertices = new ArrayList<>(vertices.size()).         for (Vertex<K, VV> vertex : vertices) {             resultVertices.add(vertex.f0.toString()).         }         TestBaseUtils.compareResultAsText(resultVertices, expectedVertices.replaceAll("\\s", "").replace(".", "\n")).     } }
false;private,static;2;12;;private static <K, VV, EV> void compareEdges(Graph<K, VV, EV> graph, String expectedEdges) throws Exception {     if (expectedEdges != null) {         List<Edge<K, EV>> edges = graph.getEdges().collect().         List<String> resultEdges = new ArrayList<>(edges.size()).         for (Edge<K, EV> edge : edges) {             resultEdges.add(edge.f0.toString() + "," + edge.f1.toString()).         }         TestBaseUtils.compareResultAsText(resultEdges, expectedEdges.replaceAll("\\s", "").replace(".", "\n")).     } }
true;public,static;2;21;/**  * Verify operator parallelism.  *  * @param env the Flink execution environment.  * @param expectedParallelism expected operator parallelism  */ ;/**  * Verify operator parallelism.  *  * @param env the Flink execution environment.  * @param expectedParallelism expected operator parallelism  */ public static void verifyParallelism(ExecutionEnvironment env, int expectedParallelism) {     env.setParallelism(2 * expectedParallelism).     Optimizer compiler = new Optimizer(null, new DefaultCostEstimator(), new Configuration()).     OptimizedPlan optimizedPlan = compiler.compile(env.createProgramPlan()).     List<PlanNode> queue = new ArrayList<>().     queue.addAll(optimizedPlan.getDataSinks()).     while (queue.size() > 0) {         PlanNode node = queue.remove(queue.size() - 1).         // Data sources may have parallelism of 1, so simply check that the node         // parallelism has not been increased by setting the default parallelism         assertTrue("Wrong parallelism for " + node.toString(), node.getParallelism() <= expectedParallelism).         for (Channel channel : node.getInputs()) {             queue.add(channel.getSource()).         }     } }
