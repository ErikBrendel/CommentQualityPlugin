commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;14;;@Parameterized.Parameters(name = "ID type = {0}, Execution mode = {1}") public static Collection<Object[]> executionModes() {     List<Object[]> executionModes = new ArrayList<>().     for (String idType : new String[] { "byte", "nativeByte", "short", "nativeShort", "char", "nativeChar", "integer", "nativeInteger", "long", "nativeLong", "float", "nativeFloat", "double", "nativeDouble", "string", "nativeString" }) {         for (TestExecutionMode executionMode : TestExecutionMode.values()) {             executionModes.add(new Object[] { idType, executionMode }).         }     }     return executionModes. }
true;protected;3;4;/**  * Simpler variant of {@link #expectedOutput(String[], String)}  * that converts the {@link Checksum} to a string and ignores  * leading and trailing newlines.  *  * @param parameters algorithm, input, and output arguments  * @param expectedCount expected number of records  * @param expectedChecksum expected checksum over records  * @throws Exception on error  */ ;/**  * Simpler variant of {@link #expectedOutput(String[], String)}  * that converts the {@link Checksum} to a string and ignores  * leading and trailing newlines.  *  * @param parameters algorithm, input, and output arguments  * @param expectedCount expected number of records  * @param expectedChecksum expected checksum over records  * @throws Exception on error  */ protected void expectedChecksum(String[] parameters, long expectedCount, long expectedChecksum) throws Exception {     Checksum checksum = new Checksum(expectedCount, expectedChecksum).     expectedOutput(parameters, "\n*" + checksum.toString() + "\n*"). }
true;protected;2;7;/**  * Simpler variant of {@link #expectedOutput(String[], String)}  * that only compares the count of the number of records in standard output.  * This is intended for use for algorithms where the result cannot be  * hashed due to approximate results (typically floating point arithmetic).  *  * @param parameters algorithm, input, and output arguments  * @param records expected number of records in standard output  * @throws Exception on error  */ ;/**  * Simpler variant of {@link #expectedOutput(String[], String)}  * that only compares the count of the number of records in standard output.  * This is intended for use for algorithms where the result cannot be  * hashed due to approximate results (typically floating point arithmetic).  *  * @param parameters algorithm, input, and output arguments  * @param records expected number of records in standard output  * @throws Exception on error  */ protected void expectedCount(String[] parameters, int records) throws Exception {     String output = getSystemOutput(parameters).     // subtract the extra newline     int numberOfRecords = output.split(System.getProperty("line.separator")).length - 1.     Assert.assertEquals(records, numberOfRecords). }
true;protected;2;5;/**  * Executes the driver with the provided arguments and compares the  * standard output with the given regular expression.  *  * @param parameters algorithm, input, and output arguments  * @param expected expected standard output  * @throws Exception on error  */ ;/**  * Executes the driver with the provided arguments and compares the  * standard output with the given regular expression.  *  * @param parameters algorithm, input, and output arguments  * @param expected expected standard output  * @throws Exception on error  */ protected void expectedOutput(String[] parameters, String expected) throws Exception {     String output = getSystemOutput(parameters).     Assert.assertThat(output, RegexMatcher.matchesRegex(expected)). }
true;protected;2;18;/**  * Simpler variant of {@link #expectedOutput(String[], String)}  * that sums the hashCode() of each line of output.  *  * @param parameters algorithm, input, and output arguments  * @param expected expected checksum over lines of output  * @throws Exception on error  */ ;/**  * Simpler variant of {@link #expectedOutput(String[], String)}  * that sums the hashCode() of each line of output.  *  * @param parameters algorithm, input, and output arguments  * @param expected expected checksum over lines of output  * @throws Exception on error  */ protected void expectedOutputChecksum(String[] parameters, Checksum expected) throws Exception {     String output = getSystemOutput(parameters).     long count = 0.     long checksum = 0.     for (String line : output.split(System.getProperty("line.separator"))) {         if (line.length() > 0) {             count++.             // convert 32-bit integer to non-negative long             checksum += line.hashCode() & 0xffffffffL.         }     }     Assert.assertEquals(expected.getCount(), count).     Assert.assertEquals(expected.getChecksum(), checksum). }
true;protected;3;6;/**  * Executes the driver with the provided arguments and compares the  * exception and exception method with the given class and regular  * expression.  *  * @param parameters algorithm, input, and output arguments  * @param expected expected standard output  * @param exception expected exception  * @throws Exception on error when not matching exception  */ ;/**  * Executes the driver with the provided arguments and compares the  * exception and exception method with the given class and regular  * expression.  *  * @param parameters algorithm, input, and output arguments  * @param expected expected standard output  * @param exception expected exception  * @throws Exception on error when not matching exception  */ protected void expectedOutputFromException(String[] parameters, String expected, Class<? extends Throwable> exception) throws Exception {     expectedException.expect(exception).     expectedException.expectMessage(RegexMatcher.matchesRegex(expected)).     getSystemOutput(parameters). }
true;protected;1;6;/**  * Generate a regular expression string by quoting the input string and  * adding wildcard matchers to the beginning and end.  *  * @param input source string  * @return regex string  */ ;/**  * Generate a regular expression string by quoting the input string and  * adding wildcard matchers to the beginning and end.  *  * @param input source string  * @return regex string  */ protected String regexSubstring(String input) {     // character including line terminators     return "(?s).*" + Pattern.quote(input) + ".*". }
true;private;1;29;/**  * Capture the command-line standard output from the driver execution.  *  * @param args driver command-line arguments  * @return standard output from driver execution  * @throws Exception on error  */ ;/**  * Capture the command-line standard output from the driver execution.  *  * @param args driver command-line arguments  * @return standard output from driver execution  * @throws Exception on error  */ private String getSystemOutput(String[] args) throws Exception {     ByteArrayOutputStream output = new ByteArrayOutputStream().     // Configure object reuse mode     switch(mode) {         case CLUSTER:         case COLLECTION:             args = ArrayUtils.add(args, "--__disable_object_reuse").             break.         case CLUSTER_OBJECT_REUSE:             // object reuse is enabled by default when executing drivers             break.         default:             throw new FlinkRuntimeException("Unknown execution mode " + mode).     }     // Redirect stdout     PrintStream stdout = System.out.     System.setOut(new PrintStream(output)).     Runner.main(args).     // Restore stdout     System.setOut(stdout).     return output.toString(). }
false;public;1;4;;@Override public void describeTo(final Description description) {     description.appendText("matches regex=`" + regex + "`"). }
false;public;1;4;;@Override public boolean matchesSafely(final String string) {     return string.matches(regex). }
false;public,static;1;3;;public static RegexMatcher matchesRegex(final String regex) {     return new RegexMatcher(regex). }
