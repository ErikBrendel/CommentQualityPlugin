commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return this.getClass().getSimpleName(). }
true;public;0;3;/**  * Get the ExecutionEnvironment. The ExecutionEnvironment is only available  * after calling {@link Runner#run()}.  *  * @return the ExecutionEnvironment  */ ;/**  * Get the ExecutionEnvironment. The ExecutionEnvironment is only available  * after calling {@link Runner#run()}.  *  * @return the ExecutionEnvironment  */ public ExecutionEnvironment getExecutionEnvironment() {     return env. }
true;public;0;3;/**  * Get the result DataSet. The result is only available after calling  * {@link Runner#run()}.  *  * @return the result DataSet  */ ;/**  * Get the result DataSet. The result is only available after calling  * {@link Runner#run()}.  *  * @return the result DataSet  */ public DataSet getResult() {     return result. }
true;private,static;0;17;/**  * List available algorithms. This is displayed to the user when no valid  * algorithm is given in the program parameterization.  *  * @return usage string listing available algorithms  */ ;/**  * List available algorithms. This is displayed to the user when no valid  * algorithm is given in the program parameterization.  *  * @return usage string listing available algorithms  */ private static String getAlgorithmsListing() {     StrBuilder strBuilder = new StrBuilder().     strBuilder.appendNewLine().appendln("Select an algorithm to view usage: flink run examples/flink-gelly-examples_<version>.jar --algorithm <algorithm>").appendNewLine().appendln("Available algorithms:").     for (Driver algorithm : driverFactory) {         strBuilder.append("  ").appendFixedWidthPadRight(algorithm.getName(), 30, ' ').append(algorithm.getShortDescription()).appendNewLine().     }     return strBuilder.toString(). }
true;private,static;1;51;/**  * Display the usage for the given algorithm. This includes options for all  * compatible inputs, the selected algorithm, and outputs implemented by  * the selected algorithm.  *  * @param algorithmName unique identifier of the selected algorithm  * @return usage string for the given algorithm  */ ;/**  * Display the usage for the given algorithm. This includes options for all  * compatible inputs, the selected algorithm, and outputs implemented by  * the selected algorithm.  *  * @param algorithmName unique identifier of the selected algorithm  * @return usage string for the given algorithm  */ private static String getAlgorithmUsage(String algorithmName) {     StrBuilder strBuilder = new StrBuilder().     Driver algorithm = driverFactory.get(algorithmName).     strBuilder.appendNewLine().appendNewLine().appendln(algorithm.getLongDescription()).appendNewLine().append("usage: flink run examples/flink-gelly-examples_<version>.jar --algorithm ").append(algorithmName).append(" [algorithm options] --input <input> [input options] --output <output> [output options]").appendNewLine().appendNewLine().appendln("Available inputs:").     for (Input input : inputFactory) {         strBuilder.append("  --input ").append(input.getName()).append(" ").appendln(input.getUsage()).     }     String algorithmParameterization = algorithm.getUsage().     if (algorithmParameterization.length() > 0) {         strBuilder.appendNewLine().appendln("Algorithm configuration:").append("  ").appendln(algorithm.getUsage()).     }     strBuilder.appendNewLine().appendln("Available outputs:").     for (Output output : outputFactory) {         strBuilder.append("  --output ").append(output.getName()).append(" ").appendln(output.getUsage()).     }     return strBuilder.appendNewLine().toString(). }
true;private;1;7;/**  * Configure a runtime component. Catch {@link RuntimeException} and  * re-throw with a Flink internal exception which is processed by  * CliFrontend for display to the user.  *  * @param parameterized the component to be configured  */ ;/**  * Configure a runtime component. Catch {@link RuntimeException} and  * re-throw with a Flink internal exception which is processed by  * CliFrontend for display to the user.  *  * @param parameterized the component to be configured  */ private void parameterize(Parameterized parameterized) {     try {         parameterized.configure(parameters).     } catch (RuntimeException ex) {         throw new ProgramParametrizationException(ex.getMessage()).     } }
true;public;0;152;/**  * Setup the Flink job with the graph input, algorithm, and output.  *  * <p>To then execute the job call {@link #execute}.  *  * @return this  * @throws Exception on error  */ ;/**  * Setup the Flink job with the graph input, algorithm, and output.  *  * <p>To then execute the job call {@link #execute}.  *  * @return this  * @throws Exception on error  */ public Runner run() throws Exception {     // Set up the execution environment     env = ExecutionEnvironment.getExecutionEnvironment().     ExecutionConfig config = env.getConfig().     // should not have any non-Flink data types     config.disableForceAvro().     config.disableForceKryo().     config.setGlobalJobParameters(parameters).     parameterize(this).     // configure local parameters and throw proper exception on error     try {         this.configure(parameters).     } catch (RuntimeException ex) {         throw new ProgramParametrizationException(ex.getMessage()).     }     // integration tests run with with object reuse both disabled and enabled     if (disableObjectReuse.getValue()) {         config.disableObjectReuse().     } else {         config.enableObjectReuse().     }     // algorithm and usage     if (!parameters.has(ALGORITHM)) {         throw new ProgramParametrizationException(getAlgorithmsListing()).     }     String algorithmName = parameters.get(ALGORITHM).     algorithm = driverFactory.get(algorithmName).     if (algorithm == null) {         throw new ProgramParametrizationException("Unknown algorithm name: " + algorithmName).     }     // input and usage     if (!parameters.has(INPUT)) {         if (!parameters.has(OUTPUT)) {             // if neither input nor output is given then print algorithm usage             throw new ProgramParametrizationException(getAlgorithmUsage(algorithmName)).         }         throw new ProgramParametrizationException("No input given").     }     parameterize(algorithm).     String inputName = parameters.get(INPUT).     Input input = inputFactory.get(inputName).     if (input == null) {         throw new ProgramParametrizationException("Unknown input type: " + inputName).     }     parameterize(input).     // output and usage     if (!parameters.has(OUTPUT)) {         throw new ProgramParametrizationException("No output given").     }     String outputName = parameters.get(OUTPUT).     output = outputFactory.get(outputName).     if (output == null) {         throw new ProgramParametrizationException("Unknown output type: " + outputName).     }     parameterize(output).     // ----------------------------------------------------------------------------------------     // Create list of input and algorithm transforms     // ----------------------------------------------------------------------------------------     List<Transform> transforms = new ArrayList<>().     if (input instanceof Transformable) {         transforms.addAll(((Transformable) input).getTransformers()).     }     if (algorithm instanceof Transformable) {         transforms.addAll(((Transformable) algorithm).getTransformers()).     }     for (Transform transform : transforms) {         parameterize(transform).     }     // unused parameters     if (parameters.getUnrequestedParameters().size() > 0) {         throw new ProgramParametrizationException("Unrequested parameters: " + parameters.getUnrequestedParameters()).     }     // ----------------------------------------------------------------------------------------     // Execute     // ----------------------------------------------------------------------------------------     // Create input     Graph graph = input.create(env).     // Transform input     for (Transform transform : transforms) {         graph = (Graph) transform.transformInput(graph).     }     // Run algorithm     result = algorithm.plan(graph).     // Output     executionName = jobName.getValue() != null ? jobName.getValue() + ": " : "".     executionName += input.getIdentity() + " ⇨ " + algorithmName + " ⇨ " + output.getName().     if (transforms.size() > 0) {         // append identifiers to job name         StringBuffer buffer = new StringBuffer(executionName).append(" [").         for (Transform transform : transforms) {             buffer.append(transform.getIdentity()).         }         executionName = buffer.append("]").toString().     }     if (output == null) {         throw new ProgramParametrizationException("Unknown output type: " + outputName).     }     try {         output.configure(parameters).     } catch (RuntimeException ex) {         throw new ProgramParametrizationException(ex.getMessage()).     }     if (result != null) {         // Transform output if algorithm returned result DataSet         if (transforms.size() > 0) {             Collections.reverse(transforms).             for (Transform transform : transforms) {                 result = (DataSet) transform.transformResult(result).             }         }     }     return this. }
true;private;0;14;/**  * Execute the Flink job.  *  * @throws Exception on error  */ ;/**  * Execute the Flink job.  *  * @throws Exception on error  */ private void execute() throws Exception {     if (result == null) {         env.execute(executionName).     } else {         output.write(executionName.toString(), System.out, result).     }     System.out.println().     algorithm.printAnalytics(System.out).     if (jobDetailsPath.getValue() != null) {         writeJobDetails(env, jobDetailsPath.getValue()).     } }
true;private,static;2;32;/**  * Write the following job details as a JSON encoded file: runtime environment  * job ID, runtime, parameters, and accumulators.  *  * @param env the execution environment  * @param jobDetailsPath filesystem path to write job details  * @throws IOException on error writing to jobDetailsPath  */ ;/**  * Write the following job details as a JSON encoded file: runtime environment  * job ID, runtime, parameters, and accumulators.  *  * @param env the execution environment  * @param jobDetailsPath filesystem path to write job details  * @throws IOException on error writing to jobDetailsPath  */ private static void writeJobDetails(ExecutionEnvironment env, String jobDetailsPath) throws IOException {     JobExecutionResult result = env.getLastJobExecutionResult().     File jsonFile = new File(jobDetailsPath).     try (JsonGenerator json = new JsonFactory().createGenerator(jsonFile, JsonEncoding.UTF8)) {         json.writeStartObject().         json.writeObjectFieldStart("Apache Flink").         json.writeStringField("version", EnvironmentInformation.getVersion()).         json.writeStringField("commit ID", EnvironmentInformation.getRevisionInformation().commitId).         json.writeStringField("commit date", EnvironmentInformation.getRevisionInformation().commitDate).         json.writeEndObject().         json.writeStringField("job_id", result.getJobID().toString()).         json.writeNumberField("runtime_ms", result.getNetRuntime()).         json.writeObjectFieldStart("parameters").         for (Map.Entry<String, String> entry : env.getConfig().getGlobalJobParameters().toMap().entrySet()) {             json.writeStringField(entry.getKey(), entry.getValue()).         }         json.writeEndObject().         json.writeObjectFieldStart("accumulators").         for (Map.Entry<String, Object> entry : result.getAllAccumulatorResults().entrySet()) {             json.writeStringField(entry.getKey(), entry.getValue().toString()).         }         json.writeEndObject().         json.writeEndObject().     } }
false;public,static;1;3;;public static void main(String[] args) throws Exception {     new Runner(args).run().execute(). }
true;public;1;4;/**  * Add a class to the factory.  *  * @param cls subclass of T  * @return this  */ ;/**  * Add a class to the factory.  *  * @param cls subclass of T  * @return this  */ public ParameterizedFactory<T> addClass(Class<? extends T> cls) {     this.classes.add(cls).     return this. }
true;public;1;9;/**  * Obtain a class instance by name.  *  * @param name String matching getName()  * @return class instance or null if no matching class  */ ;/**  * Obtain a class instance by name.  *  * @param name String matching getName()  * @return class instance or null if no matching class  */ public T get(String name) {     for (T instance : this) {         if (name.equalsIgnoreCase(instance.getName())) {             return instance.         }     }     return null. }
false;public;0;4;;@Override public boolean hasNext() {     return index < classes.size(). }
false;public;0;4;;@Override public T next() {     return InstantiationUtil.instantiate(classes.get(index++)). }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;21;;@Override public Iterator<T> iterator() {     return new Iterator<T>() {          private int index.          @Override         public boolean hasNext() {             return index < classes.size().         }          @Override         public T next() {             return InstantiationUtil.instantiate(classes.get(index++)).         }          @Override         public void remove() {             throw new UnsupportedOperationException().         }     }. }
