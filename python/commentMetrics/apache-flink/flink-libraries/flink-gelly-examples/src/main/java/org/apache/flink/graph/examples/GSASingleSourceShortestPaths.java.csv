commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;30;;// -------------------------------------------------------------------------------------------- // Program // -------------------------------------------------------------------------------------------- public static void main(String[] args) throws Exception {     if (!parseParameters(args)) {         return.     }     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Edge<Long, Double>> edges = getEdgeDataSet(env).     Graph<Long, Double, Double> graph = Graph.fromDataSet(edges, new InitVertices(srcVertexId), env).     // Execute the GSA iteration     Graph<Long, Double, Double> result = graph.runGatherSumApplyIteration(new CalculateDistances(), new ChooseMinDistance(), new UpdateDistance(), maxIterations).     // Extract the vertices as the result     DataSet<Vertex<Long, Double>> singleSourceShortestPaths = result.getVertices().     // emit result     if (fileOutput) {         singleSourceShortestPaths.writeAsCsv(outputPath, "\n", ",").         // since file sinks are lazy, we trigger the execution explicitly         env.execute("GSA Single Source Shortest Paths").     } else {         singleSourceShortestPaths.print().     } }
false;public;1;8;;public Double map(Long id) {     if (id.equals(srcId)) {         return 0.0.     } else {         return Double.POSITIVE_INFINITY.     } }
false;public;1;3;;public Double gather(Neighbor<Double, Double> neighbor) {     return neighbor.getNeighborValue() + neighbor.getEdgeValue(). }
false;public;2;3;;public Double sum(Double newValue, Double currentValue) {     return Math.min(newValue, currentValue). }
false;public;2;5;;public void apply(Double newDistance, Double oldDistance) {     if (newDistance < oldDistance) {         setResult(newDistance).     } }
false;private,static;1;24;;private static boolean parseParameters(String[] args) {     if (args.length > 0) {         if (args.length != 4) {             System.err.println("Usage: GSASingleSourceShortestPaths <source vertex id>" + " <input edges path> <output path> <num iterations>").             return false.         }         fileOutput = true.         srcVertexId = Long.parseLong(args[0]).         edgesInputPath = args[1].         outputPath = args[2].         maxIterations = Integer.parseInt(args[3]).     } else {         System.out.println("Executing GSASingle Source Shortest Paths example " + "with default parameters and built-in default data.").         System.out.println("  Provide parameters to read input data from files.").         System.out.println("  See the documentation for the correct format of input files.").         System.out.println("Usage: GSASingleSourceShortestPaths <source vertex id>" + " <input edges path> <output path> <num iterations>").     }     return true. }
false;private,static;1;11;;private static DataSet<Edge<Long, Double>> getEdgeDataSet(ExecutionEnvironment env) {     if (fileOutput) {         return env.readCsvFile(edgesInputPath).fieldDelimiter("\t").lineDelimiter("\n").types(Long.class, Long.class, Double.class).map(new Tuple3ToEdgeMap<>()).     } else {         return SingleSourceShortestPathsData.getDefaultEdgeDataSet(env).     } }
false;public;0;4;;@Override public String getDescription() {     return "GSA Single Source Shortest Paths". }
