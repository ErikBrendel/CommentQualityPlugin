commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;49;;public static void main(String[] args) throws Exception {     if (!parseParameters(args)) {         return.     }     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     Edge<Long, Double> edgeToBeRemoved = getEdgeToBeRemoved().     Graph<Long, Double, Double> graph = IncrementalSSSP.getGraph(env).     // Assumption: all minimum weight paths are kept     Graph<Long, Double, Double> ssspGraph = IncrementalSSSP.getSSSPGraph(env).     // remove the edge     graph.removeEdge(edgeToBeRemoved).     // configure the iteration     ScatterGatherConfiguration parameters = new ScatterGatherConfiguration().     if (isInSSSP(edgeToBeRemoved, ssspGraph.getEdges())) {         parameters.setDirection(EdgeDirection.IN).         parameters.setOptDegrees(true).         // run the scatter-gather iteration to propagate info         Graph<Long, Double, Double> result = ssspGraph.runScatterGatherIteration(new InvalidateMessenger(edgeToBeRemoved), new VertexDistanceUpdater(), maxIterations, parameters).         DataSet<Vertex<Long, Double>> resultedVertices = result.getVertices().         // Emit results         if (fileOutput) {             resultedVertices.writeAsCsv(outputPath, "\n", ",").             env.execute("Incremental SSSP Example").         } else {             resultedVertices.print().         }     } else {         // print the vertices         if (fileOutput) {             graph.getVertices().writeAsCsv(outputPath, "\n", ",").             env.execute("Incremental SSSP Example").         } else {             graph.getVertices().print().         }     } }
false;public;0;4;;@Override public String getDescription() {     return "Incremental Single Sink Shortest Paths Example". }
false;public;1;4;;@Override public boolean filter(Edge<Long, Double> edge) throws Exception {     return edge.equals(edgeToBeRemoved). }
true;public,static;2;9;/**  * Function that verifies whether the edge to be removed is part of the SSSP or not.  * If it is, the src vertex will be invalidated.  *  * @param edgeToBeRemoved  * @param edgesInSSSP  * @return true or false  */ ;// ****************************************************************************************************************** // IncrementalSSSP METHODS // ****************************************************************************************************************** /**  * Function that verifies whether the edge to be removed is part of the SSSP or not.  * If it is, the src vertex will be invalidated.  *  * @param edgeToBeRemoved  * @param edgesInSSSP  * @return true or false  */ public static boolean isInSSSP(final Edge<Long, Double> edgeToBeRemoved, DataSet<Edge<Long, Double>> edgesInSSSP) throws Exception {     return edgesInSSSP.filter(new FilterFunction<Edge<Long, Double>>() {          @Override         public boolean filter(Edge<Long, Double> edge) throws Exception {             return edge.equals(edgeToBeRemoved).         }     }).count() > 0. }
false;public;1;17;;@Override public void sendMessages(Vertex<Long, Double> vertex) throws Exception {     if (getSuperstepNumber() == 1) {         if (vertex.getId().equals(edgeToBeRemoved.getSource())) {             // activate the edge target             sendMessageTo(edgeToBeRemoved.getSource(), Double.MAX_VALUE).         }     }     if (getSuperstepNumber() > 1) {         // invalidate all edges         for (Edge<Long, Double> edge : getEdges()) {             sendMessageTo(edge.getSource(), Double.MAX_VALUE).         }     } }
false;public;2;11;;@Override public void updateVertex(Vertex<Long, Double> vertex, MessageIterator<Double> inMessages) throws Exception {     if (inMessages.hasNext()) {         Long outDegree = getOutDegree() - 1.         // check if the vertex has another SP-Edge         if (outDegree <= 0) {             // set own value to infinity             setNewVertexValue(Double.MAX_VALUE).         }     } }
false;private,static;1;25;;private static boolean parseParameters(String[] args) {     if (args.length > 0) {         if (args.length == 8) {             fileOutput = true.             verticesInputPath = args[0].             edgesInputPath = args[1].             edgesInSSSPInputPath = args[2].             srcEdgeToBeRemoved = Long.parseLong(args[3]).             trgEdgeToBeRemoved = Long.parseLong(args[4]).             valEdgeToBeRemoved = Double.parseDouble(args[5]).             outputPath = args[6].             maxIterations = Integer.parseInt(args[7]).         } else {             System.out.println("Executing IncrementalSSSP example with default parameters and built-in default data.").             System.out.println("Provide parameters to read input data from files.").             System.out.println("See the documentation for the correct format of input files.").             System.out.println("Usage: IncrementalSSSP <vertex path> <edge path> <edges in SSSP> " + "<src id edge to be removed> <trg id edge to be removed> <val edge to be removed> " + "<output path> <max iterations>").             return false.         }     }     return true. }
false;private,static;1;8;;private static Graph<Long, Double, Double> getGraph(ExecutionEnvironment env) {     if (fileOutput) {         return Graph.fromCsvReader(verticesInputPath, edgesInputPath, env).lineDelimiterEdges("\n").types(Long.class, Double.class, Double.class).     } else {         return Graph.fromDataSet(IncrementalSSSPData.getDefaultVertexDataSet(env), IncrementalSSSPData.getDefaultEdgeDataSet(env), env).     } }
false;private,static;1;8;;private static Graph<Long, Double, Double> getSSSPGraph(ExecutionEnvironment env) {     if (fileOutput) {         return Graph.fromCsvReader(verticesInputPath, edgesInSSSPInputPath, env).lineDelimiterEdges("\n").types(Long.class, Double.class, Double.class).     } else {         return Graph.fromDataSet(IncrementalSSSPData.getDefaultVertexDataSet(env), IncrementalSSSPData.getDefaultEdgesInSSSP(env), env).     } }
false;private,static;0;7;;private static Edge<Long, Double> getEdgeToBeRemoved() {     if (fileOutput) {         return new Edge<>(srcEdgeToBeRemoved, trgEdgeToBeRemoved, valEdgeToBeRemoved).     } else {         return IncrementalSSSPData.getDefaultEdgeToBeRemoved().     } }
