commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public boolean filter(Edge<String, Integer> edge) {     return (edge.getValue() > playcountThreshold). }
false;public;1;3;;public Long map(String value) {     return 1L. }
false;public;1;4;;@Override public Tuple2<String, Long> map(Tuple2<Long, String> tuple2) throws Exception {     return new Tuple2<>(tuple2.f1, tuple2.f0). }
false;public;2;3;;public Long vertexJoin(Long vertexValue, Long inputValue) {     return inputValue. }
false;public,static;1;97;;public static void main(String[] args) throws Exception {     if (!parseParameters(args)) {         return.     }     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     /**      * Read the user-song-play triplets.      */     DataSet<Tuple3<String, String, Integer>> triplets = getUserSongTripletsData(env).     /**      * Read the mismatches dataset and extract the songIDs      */     DataSet<Tuple1<String>> mismatches = getMismatchesData(env).map(new ExtractMismatchSongIds()).     /**      * Filter out the mismatches from the triplets dataset      */     DataSet<Tuple3<String, String, Integer>> validTriplets = triplets.coGroup(mismatches).where(1).equalTo(0).with(new FilterOutMismatches()).     /**      * Create a user -> song weighted bipartite graph where the edge weights      * correspond to play counts      */     Graph<String, NullValue, Integer> userSongGraph = Graph.fromTupleDataSet(validTriplets, env).     /**      * Get the top track (most listened) for each user      */     DataSet<Tuple2<String, String>> usersWithTopTrack = userSongGraph.groupReduceOnEdges(new GetTopSongPerUser(), EdgeDirection.OUT).filter(new FilterSongNodes()).     if (fileOutput) {         usersWithTopTrack.writeAsCsv(topTracksOutputPath, "\n", "\t").     } else {         usersWithTopTrack.print().     }     /**      * Create a user-user similarity graph, based on common songs, i.e. two      * users that listen to the same song are connected. For each song, we      * create an edge between each pair of its in-neighbors.      */     DataSet<Edge<String, NullValue>> similarUsers = userSongGraph.getEdges().filter(new FilterFunction<Edge<String, Integer>>() {          public boolean filter(Edge<String, Integer> edge) {             return (edge.getValue() > playcountThreshold).         }     }).groupBy(1).reduceGroup(new CreateSimilarUserEdges()).distinct().     Graph<String, Long, NullValue> similarUsersGraph = Graph.fromDataSet(similarUsers, new MapFunction<String, Long>() {          public Long map(String value) {             return 1L.         }     }, env).getUndirected().     /**      * Detect user communities using the label propagation library method      */     // Initialize each vertex with a unique numeric label and run the label propagation algorithm     DataSet<Tuple2<String, Long>> idsWithInitialLabels = DataSetUtils.zipWithUniqueId(similarUsersGraph.getVertexIds()).map(new MapFunction<Tuple2<Long, String>, Tuple2<String, Long>>() {          @Override         public Tuple2<String, Long> map(Tuple2<Long, String> tuple2) throws Exception {             return new Tuple2<>(tuple2.f1, tuple2.f0).         }     }).     DataSet<Vertex<String, Long>> verticesWithCommunity = similarUsersGraph.joinWithVertices(idsWithInitialLabels, new VertexJoinFunction<Long, Long>() {          public Long vertexJoin(Long vertexValue, Long inputValue) {             return inputValue.         }     }).run(new LabelPropagation<>(maxIterations)).     if (fileOutput) {         verticesWithCommunity.writeAsCsv(communitiesOutputPath, "\n", "\t").         // since file sinks are lazy, we trigger the execution explicitly         env.execute().     } else {         verticesWithCommunity.print().     } }
false;public;1;5;;public Tuple1<String> map(String value) {     String[] tokens = value.split("\\s+").     String songId = tokens[1].substring(1).     return new Tuple1<>(songId). }
false;public;3;10;;public void coGroup(Iterable<Tuple3<String, String, Integer>> triplets, Iterable<Tuple1<String>> invalidSongs, Collector<Tuple3<String, String, Integer>> out) {     if (!invalidSongs.iterator().hasNext()) {         // this is a valid triplet         for (Tuple3<String, String, Integer> triplet : triplets) {             out.collect(triplet).         }     } }
false;public;1;3;;public boolean filter(Tuple2<String, String> value) throws Exception {     return !value.f1.equals(""). }
false;public;3;13;;public void iterateEdges(Vertex<String, NullValue> vertex, Iterable<Edge<String, Integer>> edges, Collector<Tuple2<String, String>> out) throws Exception {     int maxPlaycount = 0.     String topSong = "".     for (Edge<String, Integer> edge : edges) {         if (edge.getValue() > maxPlaycount) {             maxPlaycount = edge.getValue().             topSong = edge.getTarget().         }     }     out.collect(new Tuple2<>(vertex.getId(), topSong)). }
false;public;2;12;;public void reduce(Iterable<Edge<String, Integer>> edges, Collector<Edge<String, NullValue>> out) {     List<String> listeners = new ArrayList<>().     for (Edge<String, Integer> edge : edges) {         listeners.add(edge.getSource()).     }     for (int i = 0. i < listeners.size() - 1. i++) {         for (int j = i + 1. j < listeners.size(). j++) {             out.collect(new Edge<>(listeners.get(i), listeners.get(j), NullValue.getInstance())).         }     } }
false;public;0;4;;@Override public String getDescription() {     return "Music Profiles Example". }
false;private,static;1;27;;private static boolean parseParameters(String[] args) {     if (args.length > 0) {         if (args.length != 6) {             System.err.println("Usage: MusicProfiles <input user song triplets path>" + " <input song mismatches path> <output top tracks path> " + "<playcount threshold> <output communities path> <num iterations>").             return false.         }         fileOutput = true.         userSongTripletsInputPath = args[0].         mismatchesInputPath = args[1].         topTracksOutputPath = args[2].         playcountThreshold = Integer.parseInt(args[3]).         communitiesOutputPath = args[4].         maxIterations = Integer.parseInt(args[5]).     } else {         System.out.println("Executing Music Profiles example with default parameters and built-in default data.").         System.out.println("  Provide parameters to read input data from files.").         System.out.println("  See the documentation for the correct format of input files.").         System.out.println("Usage: MusicProfiles <input user song triplets path>" + " <input song mismatches path> <output top tracks path> " + "<playcount threshold> <output communities path> <num iterations>").     }     return true. }
false;private,static;1;9;;private static DataSet<Tuple3<String, String, Integer>> getUserSongTripletsData(ExecutionEnvironment env) {     if (fileOutput) {         return env.readCsvFile(userSongTripletsInputPath).lineDelimiter("\n").fieldDelimiter("\t").types(String.class, String.class, Integer.class).     } else {         return MusicProfilesData.getUserSongTriplets(env).     } }
false;private,static;1;7;;private static DataSet<String> getMismatchesData(ExecutionEnvironment env) {     if (fileOutput) {         return env.readTextFile(mismatchesInputPath).     } else {         return MusicProfilesData.getMismatches(env).     } }
