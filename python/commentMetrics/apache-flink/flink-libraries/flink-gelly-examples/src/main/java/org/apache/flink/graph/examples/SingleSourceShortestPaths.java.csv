commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;30;;public static void main(String[] args) throws Exception {     if (!parseParameters(args)) {         return.     }     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Edge<Long, Double>> edges = getEdgesDataSet(env).     Graph<Long, Double, Double> graph = Graph.fromDataSet(edges, new InitVertices(srcVertexId), env).     // Execute the scatter-gather iteration     Graph<Long, Double, Double> result = graph.runScatterGatherIteration(new MinDistanceMessenger(), new VertexDistanceUpdater(), maxIterations).     // Extract the vertices as the result     DataSet<Vertex<Long, Double>> singleSourceShortestPaths = result.getVertices().     // emit result     if (fileOutput) {         singleSourceShortestPaths.writeAsCsv(outputPath, "\n", ",").         // since file sinks are lazy, we trigger the execution explicitly         env.execute("Single Source Shortest Paths Example").     } else {         singleSourceShortestPaths.print().     } }
false;public;1;8;;public Double map(Long id) {     if (id.equals(srcId)) {         return 0.0.     } else {         return Double.POSITIVE_INFINITY.     } }
false;public;1;8;;@Override public void sendMessages(Vertex<Long, Double> vertex) {     if (vertex.getValue() < Double.POSITIVE_INFINITY) {         for (Edge<Long, Double> edge : getEdges()) {             sendMessageTo(edge.getTarget(), vertex.getValue() + edge.getValue()).         }     } }
false;public;2;15;;@Override public void updateVertex(Vertex<Long, Double> vertex, MessageIterator<Double> inMessages) {     Double minDistance = Double.MAX_VALUE.     for (double msg : inMessages) {         if (msg < minDistance) {             minDistance = msg.         }     }     if (vertex.getValue() > minDistance) {         setNewVertexValue(minDistance).     } }
false;private,static;1;24;;private static boolean parseParameters(String[] args) {     if (args.length > 0) {         if (args.length != 4) {             System.err.println("Usage: SingleSourceShortestPaths <source vertex id>" + " <input edges path> <output path> <num iterations>").             return false.         }         fileOutput = true.         srcVertexId = Long.parseLong(args[0]).         edgesInputPath = args[1].         outputPath = args[2].         maxIterations = Integer.parseInt(args[3]).     } else {         System.out.println("Executing Single Source Shortest Paths example " + "with default parameters and built-in default data.").         System.out.println("  Provide parameters to read input data from files.").         System.out.println("  See the documentation for the correct format of input files.").         System.out.println("Usage: SingleSourceShortestPaths <source vertex id>" + " <input edges path> <output path> <num iterations>").     }     return true. }
false;private,static;1;11;;private static DataSet<Edge<Long, Double>> getEdgesDataSet(ExecutionEnvironment env) {     if (fileOutput) {         return env.readCsvFile(edgesInputPath).lineDelimiter("\n").fieldDelimiter("\t").types(Long.class, Long.class, Double.class).map(new Tuple3ToEdgeMap<>()).     } else {         return SingleSourceShortestPathsData.getDefaultEdgeDataSet(env).     } }
false;public;0;4;;@Override public String getDescription() {     return "Scatter-gather Single Source Shortest Paths". }
