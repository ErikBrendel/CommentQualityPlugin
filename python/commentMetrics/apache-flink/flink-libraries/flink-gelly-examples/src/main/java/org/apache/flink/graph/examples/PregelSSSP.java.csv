commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;29;;public static void main(String[] args) throws Exception {     if (!parseParameters(args)) {         return.     }     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Edge<Long, Double>> edges = getEdgesDataSet(env).     Graph<Long, Double, Double> graph = Graph.fromDataSet(edges, new InitVertices(), env).     // Execute the vertex-centric iteration     Graph<Long, Double, Double> result = graph.runVertexCentricIteration(new SSSPComputeFunction(srcVertexId), new SSSPCombiner(), maxIterations).     // Extract the vertices as the result     DataSet<Vertex<Long, Double>> singleSourceShortestPaths = result.getVertices().     // emit result     if (fileOutput) {         singleSourceShortestPaths.writeAsCsv(outputPath, "\n", ",").         env.execute("Pregel Single Source Shortest Paths Example").     } else {         singleSourceShortestPaths.print().     } }
false;public;1;3;;public Double map(Long id) {     return Double.POSITIVE_INFINITY. }
false;public;2;15;;public void compute(Vertex<Long, Double> vertex, MessageIterator<Double> messages) {     double minDistance = (vertex.getId().equals(srcId)) ? 0d : Double.POSITIVE_INFINITY.     for (Double msg : messages) {         minDistance = Math.min(minDistance, msg).     }     if (minDistance < vertex.getValue()) {         setNewVertexValue(minDistance).         for (Edge<Long, Double> e : getEdges()) {             sendMessageTo(e.getTarget(), minDistance + e.getValue()).         }     } }
false;public;1;8;;public void combineMessages(MessageIterator<Double> messages) {     double minMessage = Double.POSITIVE_INFINITY.     for (Double msg : messages) {         minMessage = Math.min(minMessage, msg).     }     sendCombinedMessage(minMessage). }
false;private,static;1;24;;private static boolean parseParameters(String[] args) {     if (args.length > 0) {         if (args.length != 4) {             System.err.println("Usage: PregelSSSP <source vertex id>" + " <input edges path> <output path> <num iterations>").             return false.         }         fileOutput = true.         srcVertexId = Long.parseLong(args[0]).         edgesInputPath = args[1].         outputPath = args[2].         maxIterations = Integer.parseInt(args[3]).     } else {         System.out.println("Executing Pregel Single Source Shortest Paths example " + "with default parameters and built-in default data.").         System.out.println("  Provide parameters to read input data from files.").         System.out.println("  See the documentation for the correct format of input files.").         System.out.println("Usage: PregelSSSP <source vertex id>" + " <input edges path> <output path> <num iterations>").     }     return true. }
false;private,static;1;12;;private static DataSet<Edge<Long, Double>> getEdgesDataSet(ExecutionEnvironment env) {     if (fileOutput) {         return env.readCsvFile(edgesInputPath).lineDelimiter("\n").fieldDelimiter("\t").ignoreComments("%").types(Long.class, Long.class, Double.class).map(new Tuple3ToEdgeMap<>()).     } else {         return SingleSourceShortestPathsData.getDefaultEdgeDataSet(env).     } }
false;public;0;4;;@Override public String getDescription() {     return "Vertex-centric Single Source Shortest Paths". }
