commented;modifiers;parameterAmount;loc;comment;code
true;public,final;1;10;/**  * A thin wrapper layer over {@link DataStream#union(DataStream[])}.  *  * @param streams The Python DataStreams to union output with.  * @return The {@link PythonDataStream}.  */ ;/**  * A thin wrapper layer over {@link DataStream#union(DataStream[])}.  *  * @param streams The Python DataStreams to union output with.  * @return The {@link PythonDataStream}.  */ @SafeVarargs @SuppressWarnings("unchecked") public final PythonDataStream union(PythonDataStream... streams) {     ArrayList<DataStream<PyObject>> dsList = new ArrayList<>().     for (PythonDataStream ps : streams) {         dsList.add(ps.stream).     }     DataStream<PyObject>[] dsArray = new DataStream[dsList.size()].     return new PythonDataStream(stream.union(dsList.toArray(dsArray))). }
true;public;1;3;/**  * A thin wrapper layer over {@link DataStream#split(OutputSelector)}.  *  * @param output_selector The user defined {@link OutputSelector} for directing the tuples.  * @return The {@link PythonSplitStream}  */ ;/**  * A thin wrapper layer over {@link DataStream#split(OutputSelector)}.  *  * @param output_selector The user defined {@link OutputSelector} for directing the tuples.  * @return The {@link PythonSplitStream}  */ public PythonSplitStream split(OutputSelector<PyObject> output_selector) throws IOException {     return new PythonSplitStream(this.stream.split(new PythonOutputSelector(output_selector))). }
true;public;1;3;/**  * A thin wrapper layer over {@link DataStream#filter(FilterFunction)}.  *  * @param filter The FilterFunction that is called for each element of the DataStream.  * @return The filtered {@link PythonDataStream}.  */ ;/**  * A thin wrapper layer over {@link DataStream#filter(FilterFunction)}.  *  * @param filter The FilterFunction that is called for each element of the DataStream.  * @return The filtered {@link PythonDataStream}.  */ public PythonSingleOutputStreamOperator filter(FilterFunction<PyObject> filter) throws IOException {     return new PythonSingleOutputStreamOperator(stream.filter(new PythonFilterFunction(filter))). }
true;public;1;4;/**  * A thin wrapper layer over {@link DataStream#map(MapFunction)}.  *  * @param mapper The MapFunction that is called for each element of the  * DataStream.  * @return The transformed {@link PythonDataStream}.  */ ;/**  * A thin wrapper layer over {@link DataStream#map(MapFunction)}.  *  * @param mapper The MapFunction that is called for each element of the  * DataStream.  * @return The transformed {@link PythonDataStream}.  */ public PythonDataStream<SingleOutputStreamOperator<PyObject>> map(MapFunction<PyObject, PyObject> mapper) throws IOException {     return new PythonSingleOutputStreamOperator(stream.map(new PythonMapFunction(mapper))). }
true;public;1;4;/**  * A thin wrapper layer over {@link DataStream#flatMap(FlatMapFunction)}.  *  * @param flat_mapper The FlatMapFunction that is called for each element of the  * DataStream  * @return The transformed {@link PythonDataStream}.  */ ;/**  * A thin wrapper layer over {@link DataStream#flatMap(FlatMapFunction)}.  *  * @param flat_mapper The FlatMapFunction that is called for each element of the  * DataStream  * @return The transformed {@link PythonDataStream}.  */ public PythonDataStream<SingleOutputStreamOperator<PyObject>> flat_map(FlatMapFunction<PyObject, Object> flat_mapper) throws IOException {     return new PythonSingleOutputStreamOperator(stream.flatMap(new PythonFlatMapFunction(flat_mapper))). }
true;public;1;3;/**  * A thin wrapper layer over {@link DataStream#keyBy(KeySelector)}.  *  * @param selector The KeySelector to be used for extracting the key for partitioning  * @return The {@link PythonDataStream} with partitioned state (i.e. {@link PythonKeyedStream})  */ ;/**  * A thin wrapper layer over {@link DataStream#keyBy(KeySelector)}.  *  * @param selector The KeySelector to be used for extracting the key for partitioning  * @return The {@link PythonDataStream} with partitioned state (i.e. {@link PythonKeyedStream})  */ public PythonKeyedStream key_by(KeySelector<PyObject, PyKey> selector) throws IOException {     return new PythonKeyedStream(stream.keyBy(new PythonKeySelector(selector))). }
true;public;0;4;/**  * A thin wrapper layer over {@link DataStream#print()}.  */ ;/**  * A thin wrapper layer over {@link DataStream#print()}.  */ @PublicEvolving public void output() {     stream.print(). }
true;public;1;4;/**  * A thin wrapper layer over {@link DataStream#writeAsText(java.lang.String)}.  *  * @param path The path pointing to the location the text file is written to.  */ ;/**  * A thin wrapper layer over {@link DataStream#writeAsText(java.lang.String)}.  *  * @param path The path pointing to the location the text file is written to.  */ @PublicEvolving public void write_as_text(String path) {     stream.writeAsText(path). }
true;public;2;4;/**  * A thin wrapper layer over {@link DataStream#writeAsText(java.lang.String, WriteMode)}.  *  * @param path The path pointing to the location the text file is written to  * @param mode Controls the behavior for existing files. Options are  * NO_OVERWRITE and OVERWRITE.  */ ;/**  * A thin wrapper layer over {@link DataStream#writeAsText(java.lang.String, WriteMode)}.  *  * @param path The path pointing to the location the text file is written to  * @param mode Controls the behavior for existing files. Options are  * NO_OVERWRITE and OVERWRITE.  */ @PublicEvolving public void write_as_text(String path, WriteMode mode) {     stream.writeAsText(path, mode). }
true;public;3;4;/**  * A thin wrapper layer over {@link DataStream#writeToSocket(String, int, org.apache.flink.api.common.serialization.SerializationSchema)}.  *  * @param host host of the socket  * @param port port of the socket  * @param schema schema for serialization  */ ;/**  * A thin wrapper layer over {@link DataStream#writeToSocket(String, int, org.apache.flink.api.common.serialization.SerializationSchema)}.  *  * @param host host of the socket  * @param port port of the socket  * @param schema schema for serialization  */ @PublicEvolving public void write_to_socket(String host, Integer port, SerializationSchema<PyObject> schema) throws IOException {     stream.writeToSocket(host, port, new PythonSerializationSchema(schema)). }
true;public;1;4;/**  * A thin wrapper layer over {@link DataStream#addSink(SinkFunction)}.  *  * @param sink_func The object containing the sink's invoke function.  */ ;/**  * A thin wrapper layer over {@link DataStream#addSink(SinkFunction)}.  *  * @param sink_func The object containing the sink's invoke function.  */ @PublicEvolving public void add_sink(SinkFunction<PyObject> sink_func) throws IOException {     stream.addSink(new PythonSinkFunction(sink_func)). }
true;public;0;4;/**  * A thin wrapper layer over {@link DataStream#iterate()}.  *  * <p>Initiates an iterative part of the program that feeds back data streams.  * The iterative part needs to be closed by calling  * {@link PythonIterativeStream#close_with(PythonDataStream)}. The transformation of  * this IterativeStream will be the iteration head. The data stream  * given to the {@link PythonIterativeStream#close_with(PythonDataStream)} method is  * the data stream that will be fed back and used as the input for the  * iteration head. </p>  *  * <p>A common usage pattern for streaming iterations is to use output  * splitting to send a part of the closing data stream to the head. Refer to  * {@link #split(OutputSelector)} for more information.  *  * <p>The iteration edge will be partitioned the same way as the first input of  * the iteration head unless it is changed in the  * {@link PythonIterativeStream#close_with(PythonDataStream)} call.  *  * <p>By default a PythonDataStream with iteration will never terminate, but the user  * can use the maxWaitTime parameter to set a max waiting time for the  * iteration head. If no data received in the set time, the stream  * terminates.  *  * @return The iterative data stream created.  */ ;/**  * A thin wrapper layer over {@link DataStream#iterate()}.  *  * <p>Initiates an iterative part of the program that feeds back data streams.  * The iterative part needs to be closed by calling  * {@link PythonIterativeStream#close_with(PythonDataStream)}. The transformation of  * this IterativeStream will be the iteration head. The data stream  * given to the {@link PythonIterativeStream#close_with(PythonDataStream)} method is  * the data stream that will be fed back and used as the input for the  * iteration head. </p>  *  * <p>A common usage pattern for streaming iterations is to use output  * splitting to send a part of the closing data stream to the head. Refer to  * {@link #split(OutputSelector)} for more information.  *  * <p>The iteration edge will be partitioned the same way as the first input of  * the iteration head unless it is changed in the  * {@link PythonIterativeStream#close_with(PythonDataStream)} call.  *  * <p>By default a PythonDataStream with iteration will never terminate, but the user  * can use the maxWaitTime parameter to set a max waiting time for the  * iteration head. If no data received in the set time, the stream  * terminates.  *  * @return The iterative data stream created.  */ @PublicEvolving public PythonIterativeStream iterate() {     return new PythonIterativeStream(this.stream.iterate()). }
true;public;1;4;/**  * A thin wrapper layer over {@link DataStream#iterate(long)}.  *  * <p>Initiates an iterative part of the program that feeds back data streams.  * The iterative part needs to be closed by calling  * {@link PythonIterativeStream#close_with(PythonDataStream)}. The transformation of  * this IterativeStream will be the iteration head. The data stream  * given to the {@link PythonIterativeStream#close_with(PythonDataStream)} method is  * the data stream that will be fed back and used as the input for the  * iteration head.</p>  *  * <p>A common usage pattern for streaming iterations is to use output  * splitting to send a part of the closing data stream to the head. Refer to  * {@link #split(OutputSelector)} for more information.  *  * <p>The iteration edge will be partitioned the same way as the first input of  * the iteration head unless it is changed in the  * {@link PythonIterativeStream#close_with(PythonDataStream)} call.  *  * <p>By default a PythonDataStream with iteration will never terminate, but the user  * can use the maxWaitTime parameter to set a max waiting time for the  * iteration head. If no data received in the set time, the stream  * terminates.  *  * @param max_wait_time_ms Number of milliseconds to wait between inputs before shutting  * down  * @return The iterative data stream created.  */ ;/**  * A thin wrapper layer over {@link DataStream#iterate(long)}.  *  * <p>Initiates an iterative part of the program that feeds back data streams.  * The iterative part needs to be closed by calling  * {@link PythonIterativeStream#close_with(PythonDataStream)}. The transformation of  * this IterativeStream will be the iteration head. The data stream  * given to the {@link PythonIterativeStream#close_with(PythonDataStream)} method is  * the data stream that will be fed back and used as the input for the  * iteration head.</p>  *  * <p>A common usage pattern for streaming iterations is to use output  * splitting to send a part of the closing data stream to the head. Refer to  * {@link #split(OutputSelector)} for more information.  *  * <p>The iteration edge will be partitioned the same way as the first input of  * the iteration head unless it is changed in the  * {@link PythonIterativeStream#close_with(PythonDataStream)} call.  *  * <p>By default a PythonDataStream with iteration will never terminate, but the user  * can use the maxWaitTime parameter to set a max waiting time for the  * iteration head. If no data received in the set time, the stream  * terminates.  *  * @param max_wait_time_ms Number of milliseconds to wait between inputs before shutting  * down  * @return The iterative data stream created.  */ @PublicEvolving public PythonIterativeStream iterate(Long max_wait_time_ms) {     return new PythonIterativeStream(this.stream.iterate(max_wait_time_ms)). }
