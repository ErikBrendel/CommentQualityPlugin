commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected boolean skipCollectionExecution() {     return true. }
false;private,static;0;4;;private static Path getBaseTestPythonDir() {     FileSystem fs = FileSystem.getLocalFileSystem().     return new Path(fs.getWorkingDirectory(), "src/test/python/org/apache/flink/python/api"). }
false;private,static;0;3;;private static String findUtilsFile() throws Exception {     return new Path(getBaseTestPythonDir(), "utils/utils.py").toString(). }
false;private,static;0;12;;private static List<String> findTestFiles() throws Exception {     List<String> files = new ArrayList<>().     FileSystem fs = FileSystem.getLocalFileSystem().     FileStatus[] status = fs.listStatus(getBaseTestPythonDir()).     for (FileStatus f : status) {         String file = f.getPath().toString().         if (file.endsWith(".py")) {             files.add(file).         }     }     return files. }
true;private,static;2;21;/**  * Finds the python binary for the given version.  *  * @param possibleBinaries  * 		binaries to test for  * @param expectedVersionPrefix  * 		expected output prefix for <tt>&lt.binary&gt. -V</tt>, e.g. <tt>"Python 2."</tt>  *  * @return python binary or <tt>null</tt> if not supported  *  * @throws IOException  * 		if the process to test for the binaries failed to exit properly  */ ;/**  * Finds the python binary for the given version.  *  * @param possibleBinaries  * 		binaries to test for  * @param expectedVersionPrefix  * 		expected output prefix for <tt>&lt.binary&gt. -V</tt>, e.g. <tt>"Python 2."</tt>  *  * @return python binary or <tt>null</tt> if not supported  *  * @throws IOException  * 		if the process to test for the binaries failed to exit properly  */ private static String getPythonPath(String[] possibleBinaries, String expectedVersionPrefix) throws IOException {     Process process = null.     for (String python : possibleBinaries) {         try {             process = new ProcessBuilder(python, "-V").redirectErrorStream(true).start().             BufferedReader stdInput = new BufferedReader(new InputStreamReader(process.getInputStream())).             if (stdInput.readLine().startsWith(expectedVersionPrefix)) {                 return python.             }         } catch (IOException ignored) {         } finally {             if (process != null) {                 PythonStreamer.destroyProcess(process).             }         }     }     return null. }
true;private,static;0;3;/**  * Finds the binary that executes python2 programs.  *  * @return python2 binary or <tt>null</tt> if not supported  *  * @throws IOException  * 		if the process to test for the binaries failed to exit properly  */ ;/**  * Finds the binary that executes python2 programs.  *  * @return python2 binary or <tt>null</tt> if not supported  *  * @throws IOException  * 		if the process to test for the binaries failed to exit properly  */ private static String getPython2Path() throws IOException {     return getPythonPath(new String[] { "python2", "python" }, "Python 2."). }
true;private,static;0;3;/**  * Finds the binary that executes python3 programs.  *  * @return python3 binary or <tt>null</tt> if not supported  *  * @throws IOException  * 		if the process to test for the binaries failed to exit properly  */ ;/**  * Finds the binary that executes python3 programs.  *  * @return python3 binary or <tt>null</tt> if not supported  *  * @throws IOException  * 		if the process to test for the binaries failed to exit properly  */ private static String getPython3Path() throws IOException {     return getPythonPath(new String[] { "python3", "python" }, "Python 3."). }
false;protected;0;18;;@Override protected void testProgram() throws Exception {     testBoundCheck().     testNotExistingPlanFile().     testNotExistingAdditionalFile().     String python2 = getPython2Path().     if (python2 != null) {         log.info("Running python2 tests").         runTestPrograms(python2).         runArgvTestPrograms(python2).     }     String python3 = getPython3Path().     if (python3 != null) {         log.info("Running python3 tests").         runTestPrograms(python3).         runArgvTestPrograms(python3).     } }
false;private;1;9;;private void runTestPrograms(String pythonBinary) throws Exception {     String utils = findUtilsFile().     for (String file : findTestFiles()) {         log.info("Running file {}.", file).         Configuration configuration = new Configuration().         configuration.setString(PythonOptions.PYTHON_BINARY_PATH, pythonBinary).         new PythonPlanBinder(configuration).runPlan(new String[] { file, utils }).     } }
false;private;0;11;;private void testNotExistingPlanFile() throws Exception {     log.info("Running testNotExistingPlanFile.").     String utils = findUtilsFile().     String nonExistingPlan = utils + "abc".     Configuration configuration = new Configuration().     try {         new PythonPlanBinder(configuration).runPlan(new String[] { nonExistingPlan }).     } catch (FileNotFoundException expected) {     // we expect this exception to be thrown since the plan file does not exist     } }
false;private;0;12;;private void testNotExistingAdditionalFile() throws Exception {     log.info("Running testNotExistingAdditionalFile.").     String utils = findUtilsFile().     String planFile = findTestFiles().iterator().next().     String nonExistingLibrary = utils + "abc".     Configuration configuration = new Configuration().     try {         new PythonPlanBinder(configuration).runPlan(new String[] { planFile, utils, nonExistingLibrary }).     } catch (FileNotFoundException expected) {     // we expect this exception to be thrown since the plan file does not exist     } }
false;private;0;8;;private void testBoundCheck() throws Exception {     log.info("Running testBoundCheck.").     try {         new PythonPlanBinder(new Configuration()).runPlan(new String[0]).     } catch (IllegalArgumentException expected) {     // we expect this exception to be thrown since no argument was passed     } }
false;private;1;20;;private void runArgvTestPrograms(String pythonBinary) throws Exception {     log.info("Running runArgvTestPrograms.").     String utils = findUtilsFile().     {         String noArgTestPath = new Path(getBaseTestPythonDir(), "args/no_arg.py").toString().         Configuration configuration = new Configuration().         configuration.setString(PythonOptions.PYTHON_BINARY_PATH, pythonBinary).         new PythonPlanBinder(configuration).runPlan(new String[] { noArgTestPath, utils }).     }     {         String multiArgTestPath = new Path(getBaseTestPythonDir(), "args/multiple_args.py").toString().         Configuration configuration = new Configuration().         configuration.setString(PythonOptions.PYTHON_BINARY_PATH, pythonBinary).         new PythonPlanBinder(configuration).runPlan(new String[] { multiArgTestPath, utils, "-", "hello", "world" }).     } }
