commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Object getRecord() throws IOException {     return getRecord(false). }
false;public;1;3;;public Object getRecord(boolean normalize) throws IOException {     return receiver.getRecord(normalize). }
false;public;1;3;;public void sendRecord(Object record) throws IOException {     sender.sendRecord(record). }
false;public;2;3;;public void open(String tmpPath, String args) throws IOException {     startPython(tmpPath, args). }
false;private;2;19;;private void startPython(String tmpPath, String args) throws IOException {     String pythonBinaryPath = config.getString(PythonOptions.PYTHON_BINARY_PATH).     try {         Runtime.getRuntime().exec(pythonBinaryPath).     } catch (IOException ignored) {         throw new RuntimeException(pythonBinaryPath + " does not point to a valid python binary.").     }     process = Runtime.getRuntime().exec(pythonBinaryPath + " -B " + tmpPath + FLINK_PYTHON_PLAN_NAME + args).     new Thread(new StreamPrinter(process.getInputStream())).start().     new Thread(new StreamPrinter(process.getErrorStream())).start().     server = new ServerSocket(0).     server.setSoTimeout(50).     process.getOutputStream().write("plan\n".getBytes(ConfigConstants.DEFAULT_CHARSET)).     process.getOutputStream().flush(). }
false;public;0;26;;public boolean preparePlanMode() throws IOException {     try {         process.getOutputStream().write((server.getLocalPort() + "\n").getBytes(ConfigConstants.DEFAULT_CHARSET)).         process.getOutputStream().flush().     } catch (IOException ignored) {         // the python process most likely shutdown in the meantime         return false.     }     while (true) {         try {             socket = server.accept().             sender = new PythonPlanSender(socket.getOutputStream()).             receiver = new PythonPlanReceiver(socket.getInputStream()).             return true.         } catch (SocketTimeoutException ignored) {             switch(checkPythonProcessHealth()) {                 case RUNNING:                     continue.                 case STOPPED:                     return false.                 case FAILED:                     throw new RuntimeException("Plan file caused an error. Check log-files for details.").             }         }     } }
false;public;0;7;;public void finishPlanMode() {     try {         socket.close().     } catch (IOException e) {         LOG.error("Failed to close socket.", e).     } }
false;public;0;16;;public void close() {     try {         process.exitValue().     } catch (NullPointerException ignored) {     // exception occurred before process was started     } catch (IllegalThreadStateException ignored) {         // process still active         process.destroy().     } finally {         try {             if (server != null) {                 server.close().             }         } catch (IOException e) {             LOG.error("Failed to close server.", e).         }     } }
false;private;0;12;;private ProcessState checkPythonProcessHealth() {     try {         int value = process.exitValue().         if (value != 0) {             return ProcessState.FAILED.         } else {             return ProcessState.STOPPED.         }     } catch (IllegalThreadStateException ignored) {         // Process still running         return ProcessState.RUNNING.     } }
