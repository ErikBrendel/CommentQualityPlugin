commented;modifiers;parameterAmount;loc;comment;code
true;public;0;5;/**  * Starts the python script.  *  * @throws IOException  */ ;/**  * Starts the python script.  *  * @throws IOException  */ public void open() throws IOException {     server = new ServerSocket(0).     server.setSoTimeout(50).     startPython(). }
false;private;0;52;;private void startPython() throws IOException {     String tmpDir = config.getString(PythonOptions.DATA_TMP_DIR).     if (tmpDir == null) {         tmpDir = System.getProperty("java.io.tmpdir").     }     File outputFile = new File(tmpDir, envID + "_" + setID + this.function.getRuntimeContext().getIndexOfThisSubtask() + "_output").     File inputFile = new File(tmpDir, envID + "_" + setID + this.function.getRuntimeContext().getIndexOfThisSubtask() + "_input)").     sender.open(inputFile).     receiver.open(outputFile).     String path = function.getRuntimeContext().getDistributedCache().getFile(FLINK_PYTHON_DC_ID).getAbsolutePath().     String planPath = path + FLINK_PYTHON_PLAN_NAME.     String pythonBinaryPath = config.getString(PythonOptions.PYTHON_BINARY_PATH).     String arguments = config.getString(PLAN_ARGUMENTS_KEY, "").     process = Runtime.getRuntime().exec(pythonBinaryPath + " -O -B " + planPath + arguments).     outPrinter = new Thread(new StreamPrinter(process.getInputStream())).     outPrinter.start().     errorPrinter = new Thread(new StreamPrinter(process.getErrorStream(), msg)).     errorPrinter.start().     shutdownThread = ShutdownHookUtil.addShutdownHook(() -> destroyProcess(process), getClass().getSimpleName(), LOG).     OutputStream processOutput = process.getOutputStream().     processOutput.write("operator\n".getBytes(ConfigConstants.DEFAULT_CHARSET)).     processOutput.write((envID + "\n").getBytes(ConfigConstants.DEFAULT_CHARSET)).     processOutput.write((setID + "\n").getBytes(ConfigConstants.DEFAULT_CHARSET)).     processOutput.write(("" + server.getLocalPort() + "\n").getBytes(ConfigConstants.DEFAULT_CHARSET)).     processOutput.write((this.function.getRuntimeContext().getIndexOfThisSubtask() + "\n").getBytes(ConfigConstants.DEFAULT_CHARSET)).     processOutput.write(((config.getLong(PythonOptions.MMAP_FILE_SIZE) << 10) + "\n").getBytes(ConfigConstants.DEFAULT_CHARSET)).     processOutput.write((inputFile + "\n").getBytes(ConfigConstants.DEFAULT_CHARSET)).     processOutput.write((outputFile + "\n").getBytes(ConfigConstants.DEFAULT_CHARSET)).     processOutput.flush().     while (true) {         try {             socket = server.accept().             break.         } catch (SocketTimeoutException ignored) {             checkPythonProcessHealth().         }     }     in = new DataInputStream(socket.getInputStream()).     out = new DataOutputStream(socket.getOutputStream()). }
false;private;0;23;;private void checkPythonProcessHealth() {     try {         int value = process.exitValue().         try {             outPrinter.join().         } catch (InterruptedException ignored) {             outPrinter.interrupt().             Thread.interrupted().         }         try {             errorPrinter.join().         } catch (InterruptedException ignored) {             errorPrinter.interrupt().             Thread.interrupted().         }         if (value != 0) {             throw new RuntimeException("Plan file caused an error. Check log-files for details." + msg.get()).         } else {             throw new RuntimeException("Plan file exited prematurely without an error." + msg.get()).         }     } catch (IllegalThreadStateException ignored) {     // Process still running     } }
true;public;0;21;/**  * Closes this streamer.  *  * @throws IOException  */ ;/**  * Closes this streamer.  *  * @throws IOException  */ public void close() throws IOException {     Throwable throwable = null.     try {         socket.close().         sender.close().         receiver.close().     } catch (Throwable t) {         throwable = t.     }     try {         destroyProcess(process).     } catch (Throwable t) {         throwable = ExceptionUtils.firstOrSuppressed(t, throwable).     }     ShutdownHookUtil.removeShutdownHook(shutdownThread, getClass().getSimpleName(), LOG).     ExceptionUtils.tryRethrowIOException(throwable). }
false;public,static;1;21;;public static void destroyProcess(Process process) throws IOException {     try {         process.exitValue().     } catch (IllegalThreadStateException ignored) {         // process still active         if (process.getClass().getName().equals("java.lang.UNIXProcess")) {             int pid.             try {                 Field f = process.getClass().getDeclaredField("pid").                 f.setAccessible(true).                 pid = f.getInt(process).             } catch (Throwable ignore) {                 process.destroy().                 return.             }             String[] args = new String[] { "kill", "-9", String.valueOf(pid) }.             Runtime.getRuntime().exec(args).         } else {             process.destroy().         }     } }
false;protected;2;5;;protected void sendWriteNotification(int size, boolean hasNext) throws IOException {     out.writeInt(size).     out.writeByte(hasNext ? 0 : SIGNAL_LAST).     out.flush(). }
false;protected;0;4;;protected void sendReadConfirmation() throws IOException {     out.writeByte(1).     out.flush(). }
true;public,final;1;28;/**  * Sends all broadcast-variables encoded in the configuration to the external process.  *  * @param config configuration object containing broadcast-variable count and names  * @throws IOException  */ ;/**  * Sends all broadcast-variables encoded in the configuration to the external process.  *  * @param config configuration object containing broadcast-variable count and names  * @throws IOException  */ public final void sendBroadCastVariables(Configuration config) throws IOException {     try {         int broadcastCount = config.getInteger(PLANBINDER_CONFIG_BCVAR_COUNT, 0).         String[] names = new String[broadcastCount].         for (int x = 0. x < names.length. x++) {             names[x] = config.getString(PLANBINDER_CONFIG_BCVAR_NAME_PREFIX + x, null).         }         out.write(new IntSerializer().serializeWithoutTypeInfo(broadcastCount)).         StringSerializer stringSerializer = new StringSerializer().         for (String name : names) {             Iterator<byte[]> bcv = function.getRuntimeContext().<byte[]>getBroadcastVariable(name).iterator().             out.write(stringSerializer.serializeWithoutTypeInfo(name)).             while (bcv.hasNext()) {                 out.writeByte(1).                 out.write(bcv.next()).             }             out.writeByte(0).         }     } catch (SocketTimeoutException ignored) {         throw new RuntimeException("External process for task " + function.getRuntimeContext().getTaskName() + " stopped responding." + msg).     } }
