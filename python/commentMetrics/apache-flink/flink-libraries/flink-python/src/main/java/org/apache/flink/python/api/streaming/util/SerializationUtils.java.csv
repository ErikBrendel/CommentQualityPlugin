commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;50;;@SuppressWarnings("unchecked") public static <IN> Serializer<IN> getSerializer(IN value) {     String className = value.getClass().getSimpleName().toUpperCase().     if (className.startsWith("TUPLE")) {         className = "TUPLE".     }     if (className.startsWith("BYTE[]")) {         className = "BYTES".     }     SupportedTypes type = SupportedTypes.valueOf(className).     Serializer<?> serializer.     switch(type) {         case TUPLE:             serializer = new TupleSerializer((Tuple) value).             break.         case BOOLEAN:             serializer = new BooleanSerializer().             break.         case BYTE:             serializer = new ByteSerializer().             break.         case BYTES:             serializer = new BytesSerializer().             break.         case INTEGER:             serializer = new IntSerializer().             break.         case LONG:             serializer = new LongSerializer().             break.         case STRING:             serializer = new StringSerializer().             break.         case FLOAT:             serializer = new FloatSerializer().             break.         case DOUBLE:             serializer = new DoubleSerializer().             break.         case NULL:             serializer = new NullSerializer().             break.         case CUSTOMTYPEWRAPPER:             serializer = new CustomTypeWrapperSerializer((CustomTypeWrapper) value).             break.         default:             throw new IllegalArgumentException("Unsupported Type encountered: " + type).     }     return (Serializer<IN>) serializer. }
false;public;1;11;;public byte[] serialize(IN value) {     if (typeInfo == null) {         typeInfo = new byte[getTypeInfoSize()].         ByteBuffer typeBuffer = ByteBuffer.wrap(typeInfo).         putTypeInfo(typeBuffer).     }     byte[] bytes = serializeWithoutTypeInfo(value).     byte[] total = new byte[typeInfo.length + bytes.length].     ByteBuffer.wrap(total).put(typeInfo).put(bytes).     return total. }
false;public,abstract;1;1;;public abstract byte[] serializeWithoutTypeInfo(IN value).
false;protected,abstract;1;1;;protected abstract void putTypeInfo(ByteBuffer buffer).
false;protected;0;3;;protected int getTypeInfoSize() {     return 1. }
false;public;1;6;;@Override public byte[] serializeWithoutTypeInfo(CustomTypeWrapper value) {     byte[] result = new byte[4 + value.getData().length].     ByteBuffer.wrap(result).putInt(value.getData().length).put(value.getData()).     return result. }
false;public;1;4;;@Override public void putTypeInfo(ByteBuffer buffer) {     buffer.put(type). }
false;public;1;4;;@Override public byte[] serializeWithoutTypeInfo(Byte value) {     return new byte[] { value }. }
false;public;1;4;;@Override public void putTypeInfo(ByteBuffer buffer) {     buffer.put(TYPE_BYTE). }
false;public;1;4;;@Override public byte[] serializeWithoutTypeInfo(Boolean value) {     return new byte[] { (byte) (value ? 1 : 0) }. }
false;public;1;4;;@Override public void putTypeInfo(ByteBuffer buffer) {     buffer.put(TYPE_BOOLEAN). }
false;public;1;6;;@Override public byte[] serializeWithoutTypeInfo(Integer value) {     byte[] data = new byte[4].     ByteBuffer.wrap(data).putInt(value).     return data. }
false;public;1;4;;@Override public void putTypeInfo(ByteBuffer buffer) {     buffer.put(TYPE_INTEGER). }
false;public;1;6;;@Override public byte[] serializeWithoutTypeInfo(Long value) {     byte[] data = new byte[8].     ByteBuffer.wrap(data).putLong(value).     return data. }
false;public;1;4;;@Override public void putTypeInfo(ByteBuffer buffer) {     buffer.put(TYPE_LONG). }
false;public;1;7;;@Override public byte[] serializeWithoutTypeInfo(String value) {     byte[] string = value.getBytes(ConfigConstants.DEFAULT_CHARSET).     byte[] data = new byte[4 + string.length].     ByteBuffer.wrap(data).putInt(string.length).put(string).     return data. }
false;public;1;4;;@Override public void putTypeInfo(ByteBuffer buffer) {     buffer.put(TYPE_STRING). }
false;public;1;6;;@Override public byte[] serializeWithoutTypeInfo(Float value) {     byte[] data = new byte[4].     ByteBuffer.wrap(data).putFloat(value).     return data. }
false;public;1;4;;@Override public void putTypeInfo(ByteBuffer buffer) {     buffer.put(TYPE_FLOAT). }
false;public;1;6;;@Override public byte[] serializeWithoutTypeInfo(Double value) {     byte[] data = new byte[8].     ByteBuffer.wrap(data).putDouble(value).     return data. }
false;public;1;4;;@Override public void putTypeInfo(ByteBuffer buffer) {     buffer.put(TYPE_DOUBLE). }
false;public;1;4;;@Override public byte[] serializeWithoutTypeInfo(Object value) {     return new byte[0]. }
false;public;1;4;;@Override public void putTypeInfo(ByteBuffer buffer) {     buffer.put(TYPE_NULL). }
false;public;1;6;;@Override public byte[] serializeWithoutTypeInfo(byte[] value) {     byte[] data = new byte[4 + value.length].     ByteBuffer.wrap(data).putInt(value.length).put(value).     return data. }
false;public;1;4;;@Override public void putTypeInfo(ByteBuffer buffer) {     buffer.put(TYPE_BYTES). }
false;public;1;18;;@Override public byte[] serializeWithoutTypeInfo(Tuple value) {     ArrayList<byte[]> bits = new ArrayList<>().     int totalSize = 0.     for (int x = 0. x < serializer.length. x++) {         byte[] bit = serializer[x].serializeWithoutTypeInfo(value.getField(x)).         bits.add(bit).         totalSize += bit.length.     }     int pointer = 0.     byte[] data = new byte[totalSize].     for (byte[] bit : bits) {         System.arraycopy(bit, 0, data, pointer, bit.length).         pointer += bit.length.     }     return data. }
false;public;1;7;;@Override public void putTypeInfo(ByteBuffer buffer) {     buffer.put((byte) serializer.length).     for (Serializer<Object> s : serializer) {         s.putTypeInfo(buffer).     } }
false;public;0;8;;@Override public int getTypeInfoSize() {     int size = 1.     for (Serializer<Object> s : serializer) {         size += s.getTypeInfoSize().     }     return size. }
