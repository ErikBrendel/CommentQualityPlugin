commented;modifiers;parameterAmount;loc;comment;code
true;public,final;3;49;/**  * Sends all values contained in both iterators to the external process and collects all results.  *  * @param iterator1 first input stream  * @param iterator2 second input stream  * @param c         collector  */ ;/**  * Sends all values contained in both iterators to the external process and collects all results.  *  * @param iterator1 first input stream  * @param iterator2 second input stream  * @param c         collector  */ public final void streamBufferWithGroups(Iterator<IN1> iterator1, Iterator<IN2> iterator2, Collector<OUT> c) {     SingleElementPushBackIterator<IN1> i1 = new SingleElementPushBackIterator<>(iterator1).     SingleElementPushBackIterator<IN2> i2 = new SingleElementPushBackIterator<>(iterator2).     try {         int size.         if (i1.hasNext() || i2.hasNext()) {             while (true) {                 int sig = in.readInt().                 switch(sig) {                     case SIGNAL_BUFFER_REQUEST_G0:                         if (i1.hasNext()) {                             size = sender.sendBuffer1(i1).                             sendWriteNotification(size, i1.hasNext()).                         }                         break.                     case SIGNAL_BUFFER_REQUEST_G1:                         if (i2.hasNext()) {                             size = sender.sendBuffer2(i2).                             sendWriteNotification(size, i2.hasNext()).                         }                         break.                     case SIGNAL_FINISHED:                         return.                     case SIGNAL_ERROR:                         try {                             outPrinter.join().                         } catch (InterruptedException e) {                             outPrinter.interrupt().                         }                         try {                             errorPrinter.join().                         } catch (InterruptedException e) {                             errorPrinter.interrupt().                         }                         throw new RuntimeException("External process for task " + function.getRuntimeContext().getTaskName() + " terminated prematurely due to an error." + msg).                     default:                         receiver.collectBuffer(c, sig).                         sendReadConfirmation().                         break.                 }             }         }     } catch (SocketTimeoutException ignored) {         throw new RuntimeException("External process for task " + function.getRuntimeContext().getTaskName() + " stopped responding." + msg).     } catch (Exception e) {         throw new RuntimeException("Critical failure for task " + function.getRuntimeContext().getTaskName() + ". " + msg.get(), e).     } }
