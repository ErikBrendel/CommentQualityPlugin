commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;8;;@Override public final Map<String, String> requiredContext() {     final Map<String, String> context = new HashMap<>().     context.put(FormatDescriptorValidator.FORMAT_TYPE, type).     context.put(FormatDescriptorValidator.FORMAT_PROPERTY_VERSION, version).     context.putAll(requiredFormatContext()).     return context. }
false;public,final;0;4;;@Override public final boolean supportsSchemaDerivation() {     return supportsSchemaDerivation. }
false;public,final;0;23;;@Override public final List<String> supportedProperties() {     final List<String> properties = new ArrayList<>().     if (supportsSchemaDerivation) {         properties.add(FormatDescriptorValidator.FORMAT_DERIVE_SCHEMA).         // schema         properties.add(SCHEMA + ".#." + SCHEMA_TYPE).         properties.add(SCHEMA + ".#." + SCHEMA_NAME).         properties.add(SCHEMA + ".#." + SCHEMA_FROM).         // time attributes         properties.add(SCHEMA + ".#." + SCHEMA_PROCTIME).         properties.add(SCHEMA + ".#." + ROWTIME_TIMESTAMPS_TYPE).         properties.add(SCHEMA + ".#." + ROWTIME_TIMESTAMPS_FROM).         properties.add(SCHEMA + ".#." + ROWTIME_TIMESTAMPS_CLASS).         properties.add(SCHEMA + ".#." + ROWTIME_TIMESTAMPS_SERIALIZED).         properties.add(SCHEMA + ".#." + ROWTIME_WATERMARKS_TYPE).         properties.add(SCHEMA + ".#." + ROWTIME_WATERMARKS_CLASS).         properties.add(SCHEMA + ".#." + ROWTIME_WATERMARKS_SERIALIZED).         properties.add(SCHEMA + ".#." + ROWTIME_WATERMARKS_DELAY).     }     properties.addAll(supportedFormatProperties()).     return properties. }
true;protected;0;3;/**  * Format specific context.  *  * <p>This method can be used if format type and a property version is not enough.  */ ;/**  * Format specific context.  *  * <p>This method can be used if format type and a property version is not enough.  */ protected Map<String, String> requiredFormatContext() {     return Collections.emptyMap(). }
true;protected;0;3;/**  * Format specific supported properties.  *  * <p>This method can be used if schema derivation is not enough.  */ ;/**  * Format specific supported properties.  *  * <p>This method can be used if schema derivation is not enough.  */ protected List<String> supportedFormatProperties() {     return Collections.emptyList(). }
true;public,static;1;34;/**  * Finds the table schema that can be used for a format schema (without time attributes).  */ ;// -------------------------------------------------------------------------------------------- /**  * Finds the table schema that can be used for a format schema (without time attributes).  */ public static TableSchema deriveSchema(Map<String, String> properties) {     final DescriptorProperties descriptorProperties = new DescriptorProperties().     descriptorProperties.putProperties(properties).     final TableSchema.Builder builder = TableSchema.builder().     final TableSchema baseSchema = descriptorProperties.getTableSchema(SCHEMA).     for (int i = 0. i < baseSchema.getFieldCount(). i++) {         final String fieldName = baseSchema.getFieldNames()[i].         final TypeInformation<?> fieldType = baseSchema.getFieldTypes()[i].         final boolean isProctime = descriptorProperties.getOptionalBoolean(SCHEMA + '.' + i + '.' + SCHEMA_PROCTIME).orElse(false).         final String timestampKey = SCHEMA + '.' + i + '.' + ROWTIME_TIMESTAMPS_TYPE.         final boolean isRowtime = descriptorProperties.containsKey(timestampKey).         if (!isProctime && !isRowtime) {             // check for aliasing             final String aliasName = descriptorProperties.getOptionalString(SCHEMA + '.' + i + '.' + SCHEMA_FROM).orElse(fieldName).             builder.field(aliasName, fieldType).         } else // only use the rowtime attribute if it references a field         if (isRowtime && descriptorProperties.isValue(timestampKey, ROWTIME_TIMESTAMPS_TYPE_VALUE_FROM_FIELD)) {             final String aliasName = descriptorProperties.getString(SCHEMA + '.' + i + '.' + ROWTIME_TIMESTAMPS_FROM).             builder.field(aliasName, fieldType).         }     }     return builder.build(). }
