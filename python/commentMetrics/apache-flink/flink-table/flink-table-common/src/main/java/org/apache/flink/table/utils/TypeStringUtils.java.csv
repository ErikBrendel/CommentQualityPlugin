commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;85;;public static String writeTypeInfo(TypeInformation<?> typeInfo) {     if (typeInfo.equals(Types.STRING)) {         return VARCHAR.     } else if (typeInfo.equals(Types.BOOLEAN)) {         return BOOLEAN.     } else if (typeInfo.equals(Types.BYTE)) {         return TINYINT.     } else if (typeInfo.equals(Types.SHORT)) {         return SMALLINT.     } else if (typeInfo.equals(Types.INT)) {         return INT.     } else if (typeInfo.equals(Types.LONG)) {         return BIGINT.     } else if (typeInfo.equals(Types.FLOAT)) {         return FLOAT.     } else if (typeInfo.equals(Types.DOUBLE)) {         return DOUBLE.     } else if (typeInfo.equals(Types.BIG_DEC)) {         return DECIMAL.     } else if (typeInfo.equals(Types.SQL_DATE)) {         return DATE.     } else if (typeInfo.equals(Types.SQL_TIME)) {         return TIME.     } else if (typeInfo.equals(Types.SQL_TIMESTAMP)) {         return TIMESTAMP.     } else if (typeInfo instanceof RowTypeInfo) {         final RowTypeInfo rt = (RowTypeInfo) typeInfo.         final String[] fieldNames = rt.getFieldNames().         final TypeInformation<?>[] fieldTypes = rt.getFieldTypes().         final StringBuilder result = new StringBuilder().         result.append(ROW).         result.append('<').         for (int i = 0. i < fieldNames.length. i++) {             // escape field name if it contains delimiters             if (containsDelimiter(fieldNames[i])) {                 result.append('`').                 result.append(fieldNames[i].replace("`", "``")).                 result.append('`').             } else {                 result.append(fieldNames[i]).             }             result.append(' ').             result.append(writeTypeInfo(fieldTypes[i])).             if (i < fieldNames.length - 1) {                 result.append(", ").             }         }         result.append('>').         return result.toString().     } else if (typeInfo instanceof GenericTypeInfo) {         return ANY + '<' + typeInfo.getTypeClass().getName() + '>'.     } else if (typeInfo instanceof PojoTypeInfo) {         // we only support very simple POJOs that only contain extracted fields         // (not manually specified)         TypeInformation<?> extractedPojo.         try {             extractedPojo = TypeExtractor.createTypeInfo(typeInfo.getTypeClass()).         } catch (InvalidTypesException e) {             extractedPojo = null.         }         if (extractedPojo == null || !typeInfo.equals(extractedPojo)) {             throw new TableException("A string representation for custom POJO types is not supported yet.").         }         return POJO + '<' + typeInfo.getTypeClass().getName() + '>'.     } else if (typeInfo instanceof PrimitiveArrayTypeInfo) {         final PrimitiveArrayTypeInfo arrayTypeInfo = (PrimitiveArrayTypeInfo) typeInfo.         return PRIMITIVE_ARRAY + '<' + writeTypeInfo(arrayTypeInfo.getComponentType()) + '>'.     } else if (typeInfo instanceof ObjectArrayTypeInfo) {         final ObjectArrayTypeInfo arrayTypeInfo = (ObjectArrayTypeInfo) typeInfo.         return OBJECT_ARRAY + '<' + writeTypeInfo(arrayTypeInfo.getComponentInfo()) + '>'.     } else if (typeInfo instanceof MultisetTypeInfo) {         final MultisetTypeInfo multisetTypeInfo = (MultisetTypeInfo) typeInfo.         return MULTISET + '<' + writeTypeInfo(multisetTypeInfo.getElementTypeInfo()) + '>'.     } else if (typeInfo instanceof MapTypeInfo) {         final MapTypeInfo mapTypeInfo = (MapTypeInfo) typeInfo.         final String keyTypeInfo = writeTypeInfo(mapTypeInfo.getKeyTypeInfo()).         final String valueTypeInfo = writeTypeInfo(mapTypeInfo.getValueTypeInfo()).         return MAP + '<' + keyTypeInfo + ", " + valueTypeInfo + '>'.     } else {         return ANY + '<' + typeInfo.getTypeClass().getName() + ", " + EncodingUtils.encodeObjectToString(typeInfo) + '>'.     } }
false;public,static;1;5;;public static TypeInformation<?> readTypeInfo(String typeString) {     final List<Token> tokens = tokenize(typeString).     final TokenConverter converter = new TokenConverter(typeString, tokens).     return converter.convert(). }
false;private,static;1;9;;// -------------------------------------------------------------------------------------------- private static boolean containsDelimiter(String string) {     final char[] charArray = string.toCharArray().     for (char c : charArray) {         if (isDelimiter(c)) {             return true.         }     }     return false. }
false;private,static;1;4;;private static boolean isDelimiter(char character) {     return Character.isWhitespace(character) || character == ',' || character == '<' || character == '>' || character == '(' || character == ')'. }
false;private,static;1;37;;private static List<Token> tokenize(String typeString) {     final char[] chars = typeString.toCharArray().     final List<Token> tokens = new ArrayList<>().     for (int cursor = 0. cursor < chars.length. cursor++) {         char curChar = chars[cursor].         if (curChar == '<' || curChar == '(') {             tokens.add(new Token(TokenType.BEGIN, Character.toString(curChar), cursor)).         } else if (curChar == '>' || curChar == ')') {             tokens.add(new Token(TokenType.END, Character.toString(curChar), cursor)).         } else if (curChar == ',') {             tokens.add(new Token(TokenType.SEPARATOR, Character.toString(curChar), cursor)).         } else if (!Character.isWhitespace(curChar)) {             // parse literal             final StringBuilder literal = new StringBuilder().             boolean isEscaped = false.             while (cursor < chars.length && (!isDelimiter(chars[cursor]) || isEscaped)) {                 curChar = chars[cursor++].                 if (!isEscaped && curChar == '`') {                     isEscaped = true.                 } else if (isEscaped && curChar == '`' && cursor < chars.length && chars[cursor] == '`') {                     // escaped backtick using "`Hello `` World`"                     cursor++.                     literal.append(curChar).                 } else if (isEscaped && curChar == '`') {                     break.                 } else {                     literal.append(curChar).                 }             }             cursor -= 1.             tokens.add(new Token(TokenType.LITERAL, literal.toString(), cursor)).         }     }     return tokens. }
false;public;0;9;;public TypeInformation<?> convert() {     nextToken(TokenType.LITERAL).     final TypeInformation<?> typeInfo = convertType().     if (hasRemainingTokens()) {         nextToken().         throw parsingError("Unexpected token: " + token().literal).     }     return typeInfo. }
false;private;0;52;;private TypeInformation<?> convertType() {     final TypeInformation<?> typeInfo.     switch(token().literal) {         case VARCHAR:         case STRING:             return Types.STRING.         case BOOLEAN:             return Types.BOOLEAN.         case TINYINT:         case BYTE:             return Types.BYTE.         case SMALLINT:         case SHORT:             return Types.SHORT.         case INT:             return Types.INT.         case BIGINT:         case LONG:             return Types.LONG.         case FLOAT:             return Types.FLOAT.         case DOUBLE:             return Types.DOUBLE.         case DECIMAL:             return Types.BIG_DEC.         case DATE:         case SQL_DATE:             return Types.SQL_DATE.         case TIMESTAMP:         case SQL_TIMESTAMP:             return Types.SQL_TIMESTAMP.         case TIME:         case SQL_TIME:             return Types.SQL_TIME.         case ROW:             return convertRow().         case ANY:             return convertAny().         case POJO:             return convertPojo().         case MAP:             return convertMap().         case MULTISET:             return convertMultiset().         case PRIMITIVE_ARRAY:             return convertPrimitiveArray().         case OBJECT_ARRAY:             return convertObjectArray().         default:             throw parsingError("Unsupported type: " + token().literal).     } }
false;private;0;44;;private TypeInformation<?> convertRow() {     nextToken(TokenType.BEGIN).     // check if ROW<INT, INT> or ROW<name INT, other INT>     if (isNextToken(2, TokenType.LITERAL)) {         // named row         final List<String> names = new ArrayList<>().         final List<TypeInformation<?>> types = new ArrayList<>().         while (hasRemainingTokens()) {             nextToken(TokenType.LITERAL).             names.add(token().literal).             nextToken(TokenType.LITERAL).             types.add(convertType()).             if (isNextToken(1, TokenType.END)) {                 break.             }             nextToken(TokenType.SEPARATOR).         }         nextToken(TokenType.END).         return Types.ROW_NAMED(names.toArray(new String[0]), types.toArray(new TypeInformation<?>[0])).     } else {         // unnamed row         final List<TypeInformation<?>> types = new ArrayList<>().         while (hasRemainingTokens()) {             nextToken(TokenType.LITERAL).             types.add(convertType()).             if (isNextToken(1, TokenType.END)) {                 break.             }             nextToken(TokenType.SEPARATOR).         }         nextToken(TokenType.END).         return Types.ROW(types.toArray(new TypeInformation<?>[0])).     } }
false;private;0;33;;private TypeInformation<?> convertAny() {     nextToken(TokenType.BEGIN).     // check if ANY(class) or ANY(class, serialized)     if (isNextToken(2, TokenType.SEPARATOR)) {         // any type information         nextToken(TokenType.LITERAL).         final String className = token().literal.         nextToken(TokenType.SEPARATOR).         nextToken(TokenType.LITERAL).         final String serialized = token().literal.         nextToken(TokenType.END).         final Class<?> clazz = EncodingUtils.loadClass(className).         final TypeInformation<?> typeInfo = EncodingUtils.decodeStringToObject(serialized, TypeInformation.class).         if (!clazz.equals(typeInfo.getTypeClass())) {             throw new ValidationException("Class '" + clazz + "' does no correspond to serialized data.").         }         return typeInfo.     } else {         // generic type information         nextToken(TokenType.LITERAL).         final String className = token().literal.         nextToken(TokenType.END).         final Class<?> clazz = EncodingUtils.loadClass(className).         return Types.GENERIC(clazz).     } }
false;private;0;11;;private TypeInformation<?> convertPojo() {     nextToken(TokenType.BEGIN).     nextToken(TokenType.LITERAL).     final String className = token().literal.     nextToken(TokenType.END).     final Class<?> clazz = EncodingUtils.loadClass(className).     return Types.POJO(clazz). }
false;private;0;15;;private TypeInformation<?> convertMap() {     nextToken(TokenType.BEGIN).     nextToken(TokenType.LITERAL).     final TypeInformation<?> keyTypeInfo = convertType().     nextToken(TokenType.SEPARATOR).     nextToken(TokenType.LITERAL).     final TypeInformation<?> valueTypeInfo = convertType().     nextToken(TokenType.END).     return Types.MAP(keyTypeInfo, valueTypeInfo). }
false;private;0;10;;private TypeInformation<?> convertMultiset() {     nextToken(TokenType.BEGIN).     nextToken(TokenType.LITERAL).     final TypeInformation<?> elementTypeInfo = convertType().     nextToken(TokenType.END).     return new MultisetTypeInfo<>(elementTypeInfo). }
false;private;0;10;;private TypeInformation<?> convertPrimitiveArray() {     nextToken(TokenType.BEGIN).     nextToken(TokenType.LITERAL).     final TypeInformation<?> elementTypeInfo = convertType().     nextToken(TokenType.END).     return Types.PRIMITIVE_ARRAY(elementTypeInfo). }
false;private;0;10;;private TypeInformation<?> convertObjectArray() {     nextToken(TokenType.BEGIN).     nextToken(TokenType.LITERAL).     final TypeInformation<?> elementTypeInfo = convertType().     nextToken(TokenType.END).     return Types.OBJECT_ARRAY(elementTypeInfo). }
false;private;1;7;;private void nextToken(TokenType type) {     nextToken().     final Token nextToken = tokens.get(currentToken).     if (nextToken.type != type) {         throw parsingError(type.name() + " expected but was " + nextToken.type + '.').     } }
false;private;0;7;;private void nextToken() {     this.currentToken++.     if (currentToken >= tokens.size()) {         throw parsingError("Unexpected end.").     }     lastValidToken = this.currentToken - 1. }
false;private;2;4;;private boolean isNextToken(int lookAhead, TokenType type) {     return currentToken + lookAhead < tokens.size() && tokens.get(currentToken + lookAhead).type == type. }
false;private;0;6;;private int lastCursor() {     if (lastValidToken < 0) {         return 0.     }     return tokens.get(lastValidToken).cursorPosition + 1. }
false;private;1;4;;private ValidationException parsingError(String cause) {     throw new ValidationException("Could not parse type information at position " + lastCursor() + ": " + cause + "\n" + "Input type string: " + inputString). }
false;private;0;3;;private Token token() {     return tokens.get(currentToken). }
false;private;0;3;;private boolean hasRemainingTokens() {     return currentToken + 1 < tokens.size(). }
