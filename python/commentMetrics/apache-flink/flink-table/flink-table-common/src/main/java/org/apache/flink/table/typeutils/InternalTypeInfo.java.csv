commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isBasicType() {     throw new UnsupportedOperationException("This type is for internal use only."). }
false;public;0;4;;@Override public boolean isTupleType() {     throw new UnsupportedOperationException("This type is for internal use only."). }
false;public;0;4;;@Override public int getArity() {     throw new UnsupportedOperationException("This type is for internal use only."). }
false;public;0;4;;@Override public int getTotalFields() {     throw new UnsupportedOperationException("This type is for internal use only."). }
false;public;0;4;;@Override public Class<T> getTypeClass() {     return clazz. }
false;public;0;4;;@Override public boolean isKeyType() {     throw new UnsupportedOperationException("This type is for internal use only."). }
false;public;1;4;;@Override public TypeSerializer<T> createSerializer(ExecutionConfig config) {     throw new UnsupportedOperationException("This type is for internal use only."). }
false;public;2;6;;@Override public TypeComparator<T> createComparator(boolean sortOrderAscending, ExecutionConfig executionConfig) {     throw new UnsupportedOperationException("This type is for internal use only."). }
false;public;0;4;;// ---------------------------------------------------------------------------------------------- @Override public int hashCode() {     return Objects.hash(clazz). }
false;public,abstract;1;1;;public abstract boolean canEqual(Object obj).
false;public;1;9;;@Override public boolean equals(Object obj) {     if (obj instanceof InternalTypeInfo) {         InternalTypeInfo other = (InternalTypeInfo) obj.         return other.canEqual(this) && this.clazz.equals(other.clazz).     } else {         return false.     } }
false;public;0;4;;@Override public String toString() {     return getClass().getSimpleName(). }
