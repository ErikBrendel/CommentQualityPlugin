commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns a deep copy of the table schema.  */ ;/**  * Returns a deep copy of the table schema.  */ public TableSchema copy() {     return new TableSchema(fieldNames.clone(), fieldTypes.clone()). }
true;public;0;3;/**  * Returns all field type information as an array.  */ ;/**  * Returns all field type information as an array.  */ public TypeInformation<?>[] getFieldTypes() {     return fieldTypes. }
true;public;1;6;/**  * Returns the specified type information for the given field index.  *  * @param fieldIndex the index of the field  */ ;/**  * Returns the specified type information for the given field index.  *  * @param fieldIndex the index of the field  */ public Optional<TypeInformation<?>> getFieldType(int fieldIndex) {     if (fieldIndex < 0 || fieldIndex >= fieldTypes.length) {         return Optional.empty().     }     return Optional.of(fieldTypes[fieldIndex]). }
true;public;1;6;/**  * Returns the specified type information for the given field name.  *  * @param fieldName the name of the field  */ ;/**  * Returns the specified type information for the given field name.  *  * @param fieldName the name of the field  */ public Optional<TypeInformation<?>> getFieldType(String fieldName) {     if (fieldNameToIndex.containsKey(fieldName)) {         return Optional.of(fieldTypes[fieldNameToIndex.get(fieldName)]).     }     return Optional.empty(). }
true;public;0;3;/**  * Returns the number of fields.  */ ;/**  * Returns the number of fields.  */ public int getFieldCount() {     return fieldNames.length. }
true;public;0;3;/**  * Returns all field names as an array.  */ ;/**  * Returns all field names as an array.  */ public String[] getFieldNames() {     return fieldNames. }
true;public;1;6;/**  * Returns the specified name for the given field index.  *  * @param fieldIndex the index of the field  */ ;/**  * Returns the specified name for the given field index.  *  * @param fieldIndex the index of the field  */ public Optional<String> getFieldName(int fieldIndex) {     if (fieldIndex < 0 || fieldIndex >= fieldNames.length) {         return Optional.empty().     }     return Optional.of(fieldNames[fieldIndex]). }
true;public;0;4;/**  * @deprecated Use {@link TableSchema#getFieldTypes()} instead. Can be dropped after 1.7.  */ ;/**  * @deprecated Use {@link TableSchema#getFieldTypes()} instead. Can be dropped after 1.7.  */ @Deprecated public TypeInformation<?>[] getTypes() {     return getFieldTypes(). }
true;public;0;4;/**  * @deprecated Use {@link TableSchema#getFieldNames()} instead. Can be dropped after 1.7.  */ ;/**  * @deprecated Use {@link TableSchema#getFieldNames()} instead. Can be dropped after 1.7.  */ @Deprecated public String[] getColumnNames() {     return getFieldNames(). }
true;public;0;3;/**  * Converts a table schema into a (nested) type information describing a {@link Row}.  */ ;/**  * Converts a table schema into a (nested) type information describing a {@link Row}.  */ public TypeInformation<Row> toRowType() {     return Types.ROW_NAMED(fieldNames, fieldTypes). }
false;public;0;9;;@Override public String toString() {     final StringBuilder sb = new StringBuilder().     sb.append("root\n").     for (int i = 0. i < fieldNames.length. i++) {         sb.append(" |-- ").append(fieldNames[i]).append(": ").append(fieldTypes[i]).append('\n').     }     return sb.toString(). }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     TableSchema schema = (TableSchema) o.     return Arrays.equals(fieldNames, schema.fieldNames) && Arrays.equals(fieldTypes, schema.fieldTypes). }
false;public;0;6;;@Override public int hashCode() {     int result = Arrays.hashCode(fieldNames).     result = 31 * result + Arrays.hashCode(fieldTypes).     return result. }
true;public,static;1;17;/**  * Creates a table schema from a {@link TypeInformation} instance. If the type information is  * a {@link CompositeType}, the field names and types for the composite type are used to  * construct the {@link TableSchema} instance. Otherwise, a table schema with a single field  * is created. The field name is "f0" and the field type the provided type.  *  * @param typeInfo The {@link TypeInformation} from which the table schema is generated.  * @return The table schema that was generated from the given {@link TypeInformation}.  */ ;/**  * Creates a table schema from a {@link TypeInformation} instance. If the type information is  * a {@link CompositeType}, the field names and types for the composite type are used to  * construct the {@link TableSchema} instance. Otherwise, a table schema with a single field  * is created. The field name is "f0" and the field type the provided type.  *  * @param typeInfo The {@link TypeInformation} from which the table schema is generated.  * @return The table schema that was generated from the given {@link TypeInformation}.  */ public static TableSchema fromTypeInfo(TypeInformation<?> typeInfo) {     if (typeInfo instanceof CompositeType<?>) {         final CompositeType<?> compositeType = (CompositeType<?>) typeInfo.         // get field names and types from composite type         final String[] fieldNames = compositeType.getFieldNames().         final TypeInformation<?>[] fieldTypes = new TypeInformation[fieldNames.length].         for (int i = 0. i < fieldTypes.length. i++) {             fieldTypes[i] = compositeType.getTypeAt(i).         }         return new TableSchema(fieldNames, fieldTypes).     } else {         // create table schema with a single field named "f0" of the given type.         return new TableSchema(new String[] { ATOMIC_TYPE_FIELD_NAME }, new TypeInformation<?>[] { typeInfo }).     } }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
true;public;2;7;/**  * Add a field with name and type. The call order of this method determines the order  * of fields in the schema.  */ ;/**  * Add a field with name and type. The call order of this method determines the order  * of fields in the schema.  */ public Builder field(String name, TypeInformation<?> type) {     Preconditions.checkNotNull(name).     Preconditions.checkNotNull(type).     fieldNames.add(name).     fieldTypes.add(type).     return this. }
true;public;0;5;/**  * Returns a {@link TableSchema} instance.  */ ;/**  * Returns a {@link TableSchema} instance.  */ public TableSchema build() {     return new TableSchema(fieldNames.toArray(new String[0]), fieldTypes.toArray(new TypeInformation<?>[0])). }
