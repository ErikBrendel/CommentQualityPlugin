commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;8;;public static BinaryString fromString(String str) {     if (str == null) {         return null.     } else {         byte[] bytes = str.getBytes().         return new BinaryString(new MemorySegment[] { MemorySegmentFactory.wrap(bytes) }, 0, bytes.length).     } }
false;public;0;6;;@Override public String toString() {     byte[] bytes = BinaryStringUtil.allocateReuseBytes(sizeInBytes).     SegmentsUtil.copyToBytes(segments, offset, bytes, 0, sizeInBytes).     return new String(bytes, 0, sizeInBytes). }
true;static;4;18;/**  * Get binary string, if len less than 8, will be include in variablePartOffsetAndLen.  *  * <p>If len is less than 8, its binary format is:  * 1bit mark(1) = 1, 7bits len, and 7bytes data.  *  * <p>If len is greater or equal to 8, its binary format is:  * 1bit mark(1) = 0, 31bits offset, and 4bytes len.  * Data is stored in variable-length part.  *  * <p>Note: Need to consider the ByteOrder.  *  * @param baseOffset base offset of composite binary format.  * @param fieldOffset absolute start offset of 'variablePartOffsetAndLen'.  * @param variablePartOffsetAndLen a long value, real data or offset and len.  */ ;/**  * Get binary string, if len less than 8, will be include in variablePartOffsetAndLen.  *  * <p>If len is less than 8, its binary format is:  * 1bit mark(1) = 1, 7bits len, and 7bytes data.  *  * <p>If len is greater or equal to 8, its binary format is:  * 1bit mark(1) = 0, 31bits offset, and 4bytes len.  * Data is stored in variable-length part.  *  * <p>Note: Need to consider the ByteOrder.  *  * @param baseOffset base offset of composite binary format.  * @param fieldOffset absolute start offset of 'variablePartOffsetAndLen'.  * @param variablePartOffsetAndLen a long value, real data or offset and len.  */ static BinaryString readBinaryStringFieldFromSegments(MemorySegment[] segments, int baseOffset, int fieldOffset, long variablePartOffsetAndLen) {     long mark = variablePartOffsetAndLen & HIGHEST_FIRST_BIT.     if (mark == 0) {         final int subOffset = (int) (variablePartOffsetAndLen >> 32).         final int len = (int) variablePartOffsetAndLen.         return new BinaryString(segments, baseOffset + subOffset, len).     } else {         int len = (int) ((variablePartOffsetAndLen & HIGHEST_SECOND_TO_EIGHTH_BIT) >>> 56).         if (SegmentsUtil.LITTLE_ENDIAN) {             return new BinaryString(segments, fieldOffset, len).         } else {             // fieldOffset + 1 to skip header.             return new BinaryString(segments, fieldOffset + 1, len).         }     } }
