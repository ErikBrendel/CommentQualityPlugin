commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;3;1;/**  * Set offset and size to fix len part.  */ ;/**  * Set offset and size to fix len part.  */ protected abstract void setOffsetAndSize(int pos, int offset, long size).
true;protected,abstract;1;1;/**  *  Get field offset.  */ ;/**  *  Get field offset.  */ protected abstract int getFieldOffset(int pos).
true;protected,abstract;0;1;/**  * After grow, need point to new memory.  */ ;/**  * After grow, need point to new memory.  */ protected abstract void afterGrow().
true;public;2;11;/**  * See {@link BinaryString#readBinaryStringFieldFromSegments}.  */ ;/**  * See {@link BinaryString#readBinaryStringFieldFromSegments}.  */ @Override public void writeString(int pos, BinaryString input) {     int len = input.getSizeInBytes().     if (len <= 7) {         byte[] bytes = BinaryStringUtil.allocateReuseBytes(len).         SegmentsUtil.copyToBytes(input.getSegments(), input.getOffset(), bytes, 0, len).         writeBytesToFixLenPart(segment, getFieldOffset(pos), bytes, len).     } else {         writeSegmentsToVarLenPart(pos, input.getSegments(), input.getOffset(), len).     } }
false;public;2;4;;@Override public void writeArray(int pos, BinaryArray input) {     writeSegmentsToVarLenPart(pos, input.getSegments(), input.getOffset(), input.getSizeInBytes()). }
false;public;2;4;;@Override public void writeMap(int pos, BinaryMap input) {     writeSegmentsToVarLenPart(pos, input.getSegments(), input.getOffset(), input.getSizeInBytes()). }
false;private;1;5;;private void zeroOutPaddingBytes(int numBytes) {     if ((numBytes & 0x07) > 0) {         segment.putLong(cursor + ((numBytes >> 3) << 3), 0L).     } }
false;private;1;6;;private void ensureCapacity(int neededSize) {     final int length = cursor + neededSize.     if (segment.size() < length) {         grow(length).     } }
false;private;4;19;;private void writeSegmentsToVarLenPart(int pos, MemorySegment[] segments, int offset, int size) {     final int roundedSize = roundNumberOfBytesToNearestWord(size).     // grow the global buffer before writing data.     ensureCapacity(roundedSize).     zeroOutPaddingBytes(size).     if (segments.length == 1) {         segments[0].copyTo(offset, segment, cursor, size).     } else {         writeMultiSegmentsToVarLenPart(segments, offset, size).     }     setOffsetAndSize(pos, cursor, size).     // move the cursor forward.     cursor += roundedSize. }
false;private;3;18;;private void writeMultiSegmentsToVarLenPart(MemorySegment[] segments, int offset, int size) {     // Write the bytes to the variable length portion.     int needCopy = size.     int fromOffset = offset.     int toOffset = cursor.     for (MemorySegment sourceSegment : segments) {         int remain = sourceSegment.size() - fromOffset.         if (remain > 0) {             int copySize = remain > needCopy ? needCopy : remain.             sourceSegment.copyTo(fromOffset, segment, toOffset, copySize).             needCopy -= copySize.             toOffset += copySize.             fromOffset = 0.         } else {             fromOffset -= sourceSegment.size().         }     } }
true;private;1;9;/**  * Increases the capacity to ensure that it can hold at least the  * minimum capacity argument.  */ ;/**  * Increases the capacity to ensure that it can hold at least the  * minimum capacity argument.  */ private void grow(int minCapacity) {     int oldCapacity = segment.size().     int newCapacity = oldCapacity + (oldCapacity >> 1).     if (newCapacity - minCapacity < 0) {         newCapacity = minCapacity.     }     segment = MemorySegmentFactory.wrap(Arrays.copyOf(segment.getArray(), newCapacity)).     afterGrow(). }
false;protected,static;1;8;;protected static int roundNumberOfBytesToNearestWord(int numBytes) {     int remainder = numBytes & 0x07.     if (remainder == 0) {         return numBytes.     } else {         return numBytes + (8 - remainder).     } }
false;private,static;4;18;;private static void writeBytesToFixLenPart(MemorySegment segment, int fieldOffset, byte[] bytes, int len) {     // first bit is 1, other bits is len     long firstByte = len | 0x80.     // real data     long sevenBytes = 0L.     if (BinaryRow.LITTLE_ENDIAN) {         for (int i = 0. i < len. i++) {             sevenBytes |= ((0x00000000000000FFL & bytes[i]) << (i * 8L)).         }     } else {         for (int i = 0. i < len. i++) {             sevenBytes |= ((0x00000000000000FFL & bytes[i]) << ((6 - i) * 8L)).         }     }     final long offsetAndSize = (firstByte << 56) | sevenBytes.     segment.putLong(fieldOffset, offsetAndSize). }
