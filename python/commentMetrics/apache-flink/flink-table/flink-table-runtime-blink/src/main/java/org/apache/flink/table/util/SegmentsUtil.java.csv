commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;3;/**  * Copy segments to a new byte[].  *  * @param segments Source segments.  * @param offset Source segments offset.  * @param numBytes the number bytes to copy.  */ ;/**  * Copy segments to a new byte[].  *  * @param segments Source segments.  * @param offset Source segments offset.  * @param numBytes the number bytes to copy.  */ public static byte[] copyToBytes(MemorySegment[] segments, int offset, int numBytes) {     return copyToBytes(segments, offset, new byte[numBytes], 0, numBytes). }
true;public,static;5;9;/**  * Copy segments to target byte[].  *  * @param segments Source segments.  * @param offset Source segments offset.  * @param bytes target byte[].  * @param bytesOffset target byte[] offset.  * @param numBytes the number bytes to copy.  */ ;/**  * Copy segments to target byte[].  *  * @param segments Source segments.  * @param offset Source segments offset.  * @param bytes target byte[].  * @param bytesOffset target byte[] offset.  * @param numBytes the number bytes to copy.  */ public static byte[] copyToBytes(MemorySegment[] segments, int offset, byte[] bytes, int bytesOffset, int numBytes) {     if (inFirstSegment(segments, offset, numBytes)) {         segments[0].get(offset, bytes, bytesOffset, numBytes).     } else {         copyMultiSegmentsToBytes(segments, offset, bytes, bytesOffset, numBytes).     }     return bytes. }
false;private,static;5;21;;private static void copyMultiSegmentsToBytes(MemorySegment[] segments, int offset, byte[] bytes, int bytesOffset, int numBytes) {     int remainSize = numBytes.     for (MemorySegment segment : segments) {         int remain = segment.size() - offset.         if (remain > 0) {             int nCopy = Math.min(remain, remainSize).             segment.get(offset, bytes, numBytes - remainSize + bytesOffset, nCopy).             remainSize -= nCopy.             // next new segment.             offset = 0.             if (remainSize == 0) {                 return.             }         } else {             // remain is negative, let's advance to next segment             // now the offset = offset - segmentSize (-remain)             offset = -remain.         }     } }
false;public,static;5;9;;public static void copyToUnsafe(MemorySegment[] segments, int offset, Object target, int pointer, int numBytes) {     if (inFirstSegment(segments, offset, numBytes)) {         segments[0].copyToUnsafe(offset, target, pointer, numBytes).     } else {         copyMultiSegmentsToUnsafe(segments, offset, target, pointer, numBytes).     } }
false;private,static;5;22;;private static void copyMultiSegmentsToUnsafe(MemorySegment[] segments, int offset, Object target, int pointer, int numBytes) {     int remainSize = numBytes.     for (MemorySegment segment : segments) {         int remain = segment.size() - offset.         if (remain > 0) {             int nCopy = Math.min(remain, remainSize).             segment.copyToUnsafe(offset, target, numBytes - remainSize + pointer, nCopy).             remainSize -= nCopy.             // next new segment.             offset = 0.             if (remainSize == 0) {                 return.             }         } else {             // remain is negative, let's advance to next segment             // now the offset = offset - segmentSize (-remain)             offset = -remain.         }     } }
true;public,static;5;9;/**  * Equals two memory segments regions.  *  * @param segments1 Segments 1  * @param offset1 Offset of segments1 to start equaling  * @param segments2 Segments 2  * @param offset2 Offset of segments2 to start equaling  * @param len Length of the equaled memory region  *  * @return true if equal, false otherwise  */ ;/**  * Equals two memory segments regions.  *  * @param segments1 Segments 1  * @param offset1 Offset of segments1 to start equaling  * @param segments2 Segments 2  * @param offset2 Offset of segments2 to start equaling  * @param len Length of the equaled memory region  *  * @return true if equal, false otherwise  */ public static boolean equals(MemorySegment[] segments1, int offset1, MemorySegment[] segments2, int offset2, int len) {     if (inFirstSegment(segments1, offset1, len) && inFirstSegment(segments2, offset2, len)) {         return segments1[0].equalTo(segments2[0], offset1, offset2, len).     } else {         return equalsMultiSegments(segments1, offset1, segments2, offset2, len).     } }
false;static;5;37;;@VisibleForTesting static boolean equalsMultiSegments(MemorySegment[] segments1, int offset1, MemorySegment[] segments2, int offset2, int len) {     if (len == 0) {         // quick way and avoid segSize is zero.         return true.     }     int segSize1 = segments1[0].size().     int segSize2 = segments2[0].size().     // find first segIndex and segOffset of segments.     int segIndex1 = offset1 / segSize1.     int segIndex2 = offset2 / segSize2.     // equal to %     int segOffset1 = offset1 - segSize1 * segIndex1.     // equal to %     int segOffset2 = offset2 - segSize2 * segIndex2.     while (len > 0) {         int equalLen = Math.min(Math.min(len, segSize1 - segOffset1), segSize2 - segOffset2).         if (!segments1[segIndex1].equalTo(segments2[segIndex2], segOffset1, segOffset2, equalLen)) {             return false.         }         len -= equalLen.         segOffset1 += equalLen.         if (segOffset1 == segSize1) {             segOffset1 = 0.             segIndex1++.         }         segOffset2 += equalLen.         if (segOffset2 == segSize2) {             segOffset2 = 0.             segIndex2++.         }     }     return true. }
true;private,static;3;3;/**  * Is it just in first MemorySegment, we use quick way to do something.  */ ;/**  * Is it just in first MemorySegment, we use quick way to do something.  */ private static boolean inFirstSegment(MemorySegment[] segments, int offset, int numBytes) {     return numBytes + offset <= segments[0].size(). }
true;public,static;3;6;/**  * unset bit.  *  * @param segment target segment.  * @param baseOffset bits base offset.  * @param index bit index from base offset.  */ ;/**  * unset bit.  *  * @param segment target segment.  * @param baseOffset bits base offset.  * @param index bit index from base offset.  */ public static void bitUnSet(MemorySegment segment, int baseOffset, int index) {     int offset = baseOffset + ((index & BIT_BYTE_POSITION_MASK) >>> 3).     byte current = segment.get(offset).     current &= ~(1 << (index & BIT_BYTE_INDEX_MASK)).     segment.put(offset, current). }
true;public,static;3;6;/**  * set bit.  *  * @param segment target segment.  * @param baseOffset bits base offset.  * @param index bit index from base offset.  */ ;/**  * set bit.  *  * @param segment target segment.  * @param baseOffset bits base offset.  * @param index bit index from base offset.  */ public static void bitSet(MemorySegment segment, int baseOffset, int index) {     int offset = baseOffset + ((index & BIT_BYTE_POSITION_MASK) >>> 3).     byte current = segment.get(offset).     current |= (1 << (index & BIT_BYTE_INDEX_MASK)).     segment.put(offset, current). }
true;public,static;3;5;/**  * read bit.  *  * @param segment target segment.  * @param baseOffset bits base offset.  * @param index bit index from base offset.  */ ;/**  * read bit.  *  * @param segment target segment.  * @param baseOffset bits base offset.  * @param index bit index from base offset.  */ public static boolean bitGet(MemorySegment segment, int baseOffset, int index) {     int offset = baseOffset + ((index & BIT_BYTE_POSITION_MASK) >>> 3).     byte current = segment.get(offset).     return (current & (1 << (index & BIT_BYTE_INDEX_MASK))) != 0. }
true;public,static;3;11;/**  * unset bit from segments.  *  * @param segments target segments.  * @param baseOffset bits base offset.  * @param index bit index from base offset.  */ ;/**  * unset bit from segments.  *  * @param segments target segments.  * @param baseOffset bits base offset.  * @param index bit index from base offset.  */ public static void bitUnSet(MemorySegment[] segments, int baseOffset, int index) {     if (segments.length == 1) {         MemorySegment segment = segments[0].         int offset = baseOffset + ((index & BIT_BYTE_POSITION_MASK) >>> 3).         byte current = segment.get(offset).         current &= ~(1 << (index & BIT_BYTE_INDEX_MASK)).         segment.put(offset, current).     } else {         bitUnSetMultiSegments(segments, baseOffset, index).     } }
false;private,static;3;11;;private static void bitUnSetMultiSegments(MemorySegment[] segments, int baseOffset, int index) {     int offset = baseOffset + ((index & BIT_BYTE_POSITION_MASK) >>> 3).     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     MemorySegment segment = segments[segIndex].     byte current = segment.get(segOffset).     current &= ~(1 << (index & BIT_BYTE_INDEX_MASK)).     segment.put(segOffset, current). }
true;public,static;3;11;/**  * set bit from segments.  *  * @param segments target segments.  * @param baseOffset bits base offset.  * @param index bit index from base offset.  */ ;/**  * set bit from segments.  *  * @param segments target segments.  * @param baseOffset bits base offset.  * @param index bit index from base offset.  */ public static void bitSet(MemorySegment[] segments, int baseOffset, int index) {     if (segments.length == 1) {         int offset = baseOffset + ((index & BIT_BYTE_POSITION_MASK) >>> 3).         MemorySegment segment = segments[0].         byte current = segment.get(offset).         current |= (1 << (index & BIT_BYTE_INDEX_MASK)).         segment.put(offset, current).     } else {         bitSetMultiSegments(segments, baseOffset, index).     } }
false;private,static;3;11;;private static void bitSetMultiSegments(MemorySegment[] segments, int baseOffset, int index) {     int offset = baseOffset + ((index & BIT_BYTE_POSITION_MASK) >>> 3).     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     MemorySegment segment = segments[segIndex].     byte current = segment.get(segOffset).     current |= (1 << (index & BIT_BYTE_INDEX_MASK)).     segment.put(segOffset, current). }
true;public,static;3;5;/**  * read bit from segments.  *  * @param segments target segments.  * @param baseOffset bits base offset.  * @param index bit index from base offset.  */ ;/**  * read bit from segments.  *  * @param segments target segments.  * @param baseOffset bits base offset.  * @param index bit index from base offset.  */ public static boolean bitGet(MemorySegment[] segments, int baseOffset, int index) {     int offset = baseOffset + ((index & BIT_BYTE_POSITION_MASK) >>> 3).     byte current = getByte(segments, offset).     return (current & (1 << (index & BIT_BYTE_INDEX_MASK))) != 0. }
true;public,static;2;7;/**  * get boolean from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * get boolean from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static boolean getBoolean(MemorySegment[] segments, int offset) {     if (inFirstSegment(segments, offset, 1)) {         return segments[0].getBoolean(offset).     } else {         return getBooleanMultiSegments(segments, offset).     } }
false;private,static;2;6;;private static boolean getBooleanMultiSegments(MemorySegment[] segments, int offset) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     return segments[segIndex].getBoolean(segOffset). }
true;public,static;3;7;/**  * set boolean from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * set boolean from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static void setBoolean(MemorySegment[] segments, int offset, boolean value) {     if (inFirstSegment(segments, offset, 1)) {         segments[0].putBoolean(offset, value).     } else {         setBooleanMultiSegments(segments, offset, value).     } }
false;private,static;3;6;;private static void setBooleanMultiSegments(MemorySegment[] segments, int offset, boolean value) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     segments[segIndex].putBoolean(segOffset, value). }
true;public,static;2;7;/**  * get byte from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * get byte from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static byte getByte(MemorySegment[] segments, int offset) {     if (inFirstSegment(segments, offset, 1)) {         return segments[0].get(offset).     } else {         return getByteMultiSegments(segments, offset).     } }
false;private,static;2;6;;private static byte getByteMultiSegments(MemorySegment[] segments, int offset) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     return segments[segIndex].get(segOffset). }
true;public,static;3;7;/**  * set byte from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * set byte from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static void setByte(MemorySegment[] segments, int offset, byte value) {     if (inFirstSegment(segments, offset, 1)) {         segments[0].put(offset, value).     } else {         setByteMultiSegments(segments, offset, value).     } }
false;private,static;3;6;;private static void setByteMultiSegments(MemorySegment[] segments, int offset, byte value) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     segments[segIndex].put(segOffset, value). }
true;public,static;2;7;/**  * get int from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * get int from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static int getInt(MemorySegment[] segments, int offset) {     if (inFirstSegment(segments, offset, 4)) {         return segments[0].getInt(offset).     } else {         return getIntMultiSegments(segments, offset).     } }
false;private,static;2;11;;private static int getIntMultiSegments(MemorySegment[] segments, int offset) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     if (segOffset < segSize - 3) {         return segments[segIndex].getInt(segOffset).     } else {         return getIntSlowly(segments, segSize, segIndex, segOffset).     } }
false;private,static;4;19;;private static int getIntSlowly(MemorySegment[] segments, int segSize, int segNum, int segOffset) {     MemorySegment segment = segments[segNum].     int ret = 0.     for (int i = 0. i < 4. i++) {         if (segOffset == segSize) {             segment = segments[++segNum].             segOffset = 0.         }         int unsignedByte = segment.get(segOffset) & 0xff.         if (LITTLE_ENDIAN) {             ret |= (unsignedByte << (i * 8)).         } else {             ret |= (unsignedByte << ((3 - i) * 8)).         }         segOffset++.     }     return ret. }
true;public,static;3;7;/**  * set int from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * set int from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static void setInt(MemorySegment[] segments, int offset, int value) {     if (inFirstSegment(segments, offset, 4)) {         segments[0].putInt(offset, value).     } else {         setIntMultiSegments(segments, offset, value).     } }
false;private,static;3;11;;private static void setIntMultiSegments(MemorySegment[] segments, int offset, int value) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     if (segOffset < segSize - 3) {         segments[segIndex].putInt(segOffset, value).     } else {         setIntSlowly(segments, segSize, segIndex, segOffset, value).     } }
false;private,static;5;18;;private static void setIntSlowly(MemorySegment[] segments, int segSize, int segNum, int segOffset, int value) {     MemorySegment segment = segments[segNum].     for (int i = 0. i < 4. i++) {         if (segOffset == segSize) {             segment = segments[++segNum].             segOffset = 0.         }         int unsignedByte.         if (LITTLE_ENDIAN) {             unsignedByte = value >> (i * 8).         } else {             unsignedByte = value >> ((3 - i) * 8).         }         segment.put(segOffset, (byte) unsignedByte).         segOffset++.     } }
true;public,static;2;7;/**  * get long from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * get long from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static long getLong(MemorySegment[] segments, int offset) {     if (inFirstSegment(segments, offset, 8)) {         return segments[0].getLong(offset).     } else {         return getLongMultiSegments(segments, offset).     } }
false;private,static;2;11;;private static long getLongMultiSegments(MemorySegment[] segments, int offset) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     if (segOffset < segSize - 7) {         return segments[segIndex].getLong(segOffset).     } else {         return getLongSlowly(segments, segSize, segIndex, segOffset).     } }
false;private,static;4;19;;private static long getLongSlowly(MemorySegment[] segments, int segSize, int segNum, int segOffset) {     MemorySegment segment = segments[segNum].     long ret = 0.     for (int i = 0. i < 8. i++) {         if (segOffset == segSize) {             segment = segments[++segNum].             segOffset = 0.         }         long unsignedByte = segment.get(segOffset) & 0xff.         if (LITTLE_ENDIAN) {             ret |= (unsignedByte << (i * 8)).         } else {             ret |= (unsignedByte << ((7 - i) * 8)).         }         segOffset++.     }     return ret. }
true;public,static;3;7;/**  * set long from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * set long from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static void setLong(MemorySegment[] segments, int offset, long value) {     if (inFirstSegment(segments, offset, 8)) {         segments[0].putLong(offset, value).     } else {         setLongMultiSegments(segments, offset, value).     } }
false;private,static;3;11;;private static void setLongMultiSegments(MemorySegment[] segments, int offset, long value) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     if (segOffset < segSize - 7) {         segments[segIndex].putLong(segOffset, value).     } else {         setLongSlowly(segments, segSize, segIndex, segOffset, value).     } }
false;private,static;5;18;;private static void setLongSlowly(MemorySegment[] segments, int segSize, int segNum, int segOffset, long value) {     MemorySegment segment = segments[segNum].     for (int i = 0. i < 8. i++) {         if (segOffset == segSize) {             segment = segments[++segNum].             segOffset = 0.         }         long unsignedByte.         if (LITTLE_ENDIAN) {             unsignedByte = value >> (i * 8).         } else {             unsignedByte = value >> ((7 - i) * 8).         }         segment.put(segOffset, (byte) unsignedByte).         segOffset++.     } }
true;public,static;2;7;/**  * get short from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * get short from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static short getShort(MemorySegment[] segments, int offset) {     if (inFirstSegment(segments, offset, 2)) {         return segments[0].getShort(offset).     } else {         return getShortMultiSegments(segments, offset).     } }
false;private,static;2;11;;private static short getShortMultiSegments(MemorySegment[] segments, int offset) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     if (segOffset < segSize - 1) {         return segments[segIndex].getShort(segOffset).     } else {         return (short) getTwoByteSlowly(segments, segSize, segIndex, segOffset).     } }
true;public,static;3;7;/**  * set short from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * set short from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static void setShort(MemorySegment[] segments, int offset, short value) {     if (inFirstSegment(segments, offset, 2)) {         segments[0].putShort(offset, value).     } else {         setShortMultiSegments(segments, offset, value).     } }
false;private,static;3;11;;private static void setShortMultiSegments(MemorySegment[] segments, int offset, short value) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     if (segOffset < segSize - 1) {         segments[segIndex].putShort(segOffset, value).     } else {         setTwoByteSlowly(segments, segSize, segIndex, segOffset, value, value >> 8).     } }
true;public,static;2;7;/**  * get float from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * get float from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static float getFloat(MemorySegment[] segments, int offset) {     if (inFirstSegment(segments, offset, 4)) {         return segments[0].getFloat(offset).     } else {         return getFloatMultiSegments(segments, offset).     } }
false;private,static;2;11;;private static float getFloatMultiSegments(MemorySegment[] segments, int offset) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     if (segOffset < segSize - 3) {         return segments[segIndex].getFloat(segOffset).     } else {         return Float.intBitsToFloat(getIntSlowly(segments, segSize, segIndex, segOffset)).     } }
true;public,static;3;7;/**  * set float from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * set float from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static void setFloat(MemorySegment[] segments, int offset, float value) {     if (inFirstSegment(segments, offset, 4)) {         segments[0].putFloat(offset, value).     } else {         setFloatMultiSegments(segments, offset, value).     } }
false;private,static;3;11;;private static void setFloatMultiSegments(MemorySegment[] segments, int offset, float value) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     if (segOffset < segSize - 3) {         segments[segIndex].putFloat(segOffset, value).     } else {         setIntSlowly(segments, segSize, segIndex, segOffset, Float.floatToRawIntBits(value)).     } }
true;public,static;2;7;/**  * get double from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * get double from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static double getDouble(MemorySegment[] segments, int offset) {     if (inFirstSegment(segments, offset, 8)) {         return segments[0].getDouble(offset).     } else {         return getDoubleMultiSegments(segments, offset).     } }
false;private,static;2;11;;private static double getDoubleMultiSegments(MemorySegment[] segments, int offset) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     if (segOffset < segSize - 7) {         return segments[segIndex].getDouble(segOffset).     } else {         return Double.longBitsToDouble(getLongSlowly(segments, segSize, segIndex, segOffset)).     } }
true;public,static;3;7;/**  * set double from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * set double from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static void setDouble(MemorySegment[] segments, int offset, double value) {     if (inFirstSegment(segments, offset, 8)) {         segments[0].putDouble(offset, value).     } else {         setDoubleMultiSegments(segments, offset, value).     } }
false;private,static;3;11;;private static void setDoubleMultiSegments(MemorySegment[] segments, int offset, double value) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     if (segOffset < segSize - 7) {         segments[segIndex].putDouble(segOffset, value).     } else {         setLongSlowly(segments, segSize, segIndex, segOffset, Double.doubleToRawLongBits(value)).     } }
true;public,static;2;7;/**  * get char from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * get char from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static char getChar(MemorySegment[] segments, int offset) {     if (inFirstSegment(segments, offset, 2)) {         return segments[0].getChar(offset).     } else {         return getCharMultiSegments(segments, offset).     } }
false;private,static;2;11;;private static char getCharMultiSegments(MemorySegment[] segments, int offset) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     if (segOffset < segSize - 1) {         return segments[segIndex].getChar(segOffset).     } else {         return (char) getTwoByteSlowly(segments, segSize, segIndex, segOffset).     } }
false;private,static;4;19;;private static int getTwoByteSlowly(MemorySegment[] segments, int segSize, int segNum, int segOffset) {     MemorySegment segment = segments[segNum].     int ret = 0.     for (int i = 0. i < 2. i++) {         if (segOffset == segSize) {             segment = segments[++segNum].             segOffset = 0.         }         int unsignedByte = segment.get(segOffset) & 0xff.         if (LITTLE_ENDIAN) {             ret |= (unsignedByte << (i * 8)).         } else {             ret |= (unsignedByte << ((1 - i) * 8)).         }         segOffset++.     }     return ret. }
true;public,static;3;7;/**  * set char from segments.  *  * @param segments target segments.  * @param offset value offset.  */ ;/**  * set char from segments.  *  * @param segments target segments.  * @param offset value offset.  */ public static void setChar(MemorySegment[] segments, int offset, char value) {     if (inFirstSegment(segments, offset, 2)) {         segments[0].putChar(offset, value).     } else {         setCharMultiSegments(segments, offset, value).     } }
false;private,static;3;11;;private static void setCharMultiSegments(MemorySegment[] segments, int offset, char value) {     int segSize = segments[0].size().     int segIndex = offset / segSize.     // equal to %     int segOffset = offset - segIndex * segSize.     if (segOffset < segSize - 3) {         segments[segIndex].putChar(segOffset, value).     } else {         setTwoByteSlowly(segments, segSize, segIndex, segOffset, value, value >> 8).     } }
false;private,static;6;11;;private static void setTwoByteSlowly(MemorySegment[] segments, int segSize, int segNum, int segOffset, int b1, int b2) {     MemorySegment segment = segments[segNum].     segment.put(segOffset, (byte) (LITTLE_ENDIAN ? b1 : b2)).     segOffset++.     if (segOffset == segSize) {         segment = segments[++segNum].         segOffset = 0.     }     segment.put(segOffset, (byte) (LITTLE_ENDIAN ? b2 : b1)). }
