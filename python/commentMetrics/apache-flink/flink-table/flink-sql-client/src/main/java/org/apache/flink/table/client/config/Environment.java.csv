commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Map<String, TableEntry> getTables() {     return tables. }
false;public;1;12;;public void setTables(List<Map<String, Object>> tables) {     this.tables = new LinkedHashMap<>(tables.size()).     tables.forEach(config -> {         final TableEntry table = TableEntry.create(config).         if (this.tables.containsKey(table.getName())) {             throw new SqlClientException("Cannot create table '" + table.getName() + "' because a table with this name is already registered.").         }         this.tables.put(table.getName(), table).     }). }
false;public;0;3;;public Map<String, FunctionEntry> getFunctions() {     return functions. }
false;public;1;12;;public void setFunctions(List<Map<String, Object>> functions) {     this.functions = new HashMap<>(functions.size()).     functions.forEach(config -> {         final FunctionEntry function = FunctionEntry.create(config).         if (this.functions.containsKey(function.getName())) {             throw new SqlClientException("Cannot create function '" + function.getName() + "' because a function with this name is already registered.").         }         this.functions.put(function.getName(), function).     }). }
false;public;1;3;;public void setExecution(Map<String, Object> config) {     this.execution = ExecutionEntry.create(config). }
false;public;0;3;;public ExecutionEntry getExecution() {     return execution. }
false;public;1;3;;public void setDeployment(Map<String, Object> config) {     this.deployment = DeploymentEntry.create(config). }
false;public;0;3;;public DeploymentEntry getDeployment() {     return deployment. }
false;public;0;19;;@Override public String toString() {     final StringBuilder sb = new StringBuilder().     sb.append("===================== Tables =====================\n").     tables.forEach((name, table) -> {         sb.append("- ").append(TableEntry.TABLES_NAME).append(": ").append(name).append("\n").         table.asMap().forEach((k, v) -> sb.append("  ").append(k).append(": ").append(v).append('\n')).     }).     sb.append("=================== Functions ====================\n").     functions.forEach((name, function) -> {         sb.append("- ").append(FunctionEntry.FUNCTIONS_NAME).append(": ").append(name).append("\n").         function.asMap().forEach((k, v) -> sb.append("  ").append(k).append(": ").append(v).append('\n')).     }).     sb.append("=================== Execution ====================\n").     execution.asTopLevelMap().forEach((k, v) -> sb.append(k).append(": ").append(v).append('\n')).     sb.append("=================== Deployment ===================\n").     deployment.asTopLevelMap().forEach((k, v) -> sb.append(k).append(": ").append(v).append('\n')).     return sb.toString(). }
true;public,static;1;7;/**  * Parses an environment file from an URL.  */ ;// -------------------------------------------------------------------------------------------- /**  * Parses an environment file from an URL.  */ public static Environment parse(URL url) throws IOException {     try {         return new ConfigUtil.LowerCaseYamlMapper().readValue(url, Environment.class).     } catch (JsonMappingException e) {         throw new SqlClientException("Could not parse environment file. Cause: " + e.getMessage()).     } }
true;public,static;1;7;/**  * Parses an environment file from an String.  */ ;/**  * Parses an environment file from an String.  */ public static Environment parse(String content) throws IOException {     try {         return new ConfigUtil.LowerCaseYamlMapper().readValue(content, Environment.class).     } catch (JsonMappingException e) {         throw new SqlClientException("Could not parse environment file. Cause: " + e.getMessage()).     } }
true;public,static;2;21;/**  * Merges two environments. The properties of the first environment might be overwritten by the second one.  */ ;/**  * Merges two environments. The properties of the first environment might be overwritten by the second one.  */ public static Environment merge(Environment env1, Environment env2) {     final Environment mergedEnv = new Environment().     // merge tables     final Map<String, TableEntry> tables = new LinkedHashMap<>(env1.getTables()).     tables.putAll(env2.getTables()).     mergedEnv.tables = tables.     // merge functions     final Map<String, FunctionEntry> functions = new HashMap<>(env1.getFunctions()).     functions.putAll(env2.getFunctions()).     mergedEnv.functions = functions.     // merge execution properties     mergedEnv.execution = ExecutionEntry.merge(env1.getExecution(), env2.getExecution()).     // merge deployment properties     mergedEnv.deployment = DeploymentEntry.merge(env1.getDeployment(), env2.getDeployment()).     return mergedEnv. }
true;public,static;3;21;/**  * Enriches an environment with new/modified properties or views and returns the new instance.  */ ;/**  * Enriches an environment with new/modified properties or views and returns the new instance.  */ public static Environment enrich(Environment env, Map<String, String> properties, Map<String, ViewEntry> views) {     final Environment enrichedEnv = new Environment().     // merge tables     enrichedEnv.tables = new LinkedHashMap<>(env.getTables()).     enrichedEnv.tables.putAll(views).     // merge functions     enrichedEnv.functions = new HashMap<>(env.getFunctions()).     // enrich execution properties     enrichedEnv.execution = ExecutionEntry.enrich(env.execution, properties).     // enrich deployment properties     enrichedEnv.deployment = DeploymentEntry.enrich(env.deployment, properties).     return enrichedEnv. }
