commented;modifiers;parameterAmount;loc;comment;code
false;public,static;3;3;;public static void repeatChar(AttributedStringBuilder sb, char c, int count) {     IntStream.range(0, count).forEach(i -> sb.append(c)). }
false;public,static;3;10;;public static void normalizeColumn(AttributedStringBuilder sb, String col, int maxWidth) {     // limit column content     if (col.length() > maxWidth) {         sb.append(col, 0, maxWidth - 1).         sb.append('~').     } else {         repeatChar(sb, ' ', maxWidth - col.length()).         sb.append(col).     } }
false;public,static;2;31;;public static List<AttributedString> formatTwoLineHelpOptions(int width, List<Tuple2<String, String>> options) {     final AttributedStringBuilder line1 = new AttributedStringBuilder().     final AttributedStringBuilder line2 = new AttributedStringBuilder().     // we assume that every options has not more than 11 characters (+ key and space)     final int columns = (int) Math.ceil(((double) options.size()) / 2).     final int space = (width - CliStrings.DEFAULT_MARGIN.length() - columns * 13) / columns.     final Iterator<Tuple2<String, String>> iter = options.iterator().     while (iter.hasNext()) {         // first line         Tuple2<String, String> option = iter.next().         line1.style(AttributedStyle.DEFAULT.inverse()).         line1.append(option.f0).         line1.style(AttributedStyle.DEFAULT).         line1.append(' ').         line1.append(option.f1).         repeatChar(line1, ' ', (11 - option.f1.length()) + space).         // second line         if (iter.hasNext()) {             option = iter.next().             line2.style(AttributedStyle.DEFAULT.inverse()).             line2.append(option.f0).             line2.style(AttributedStyle.DEFAULT).             line2.append(' ').             line2.append(option.f1).             repeatChar(line2, ' ', (11 - option.f1.length()) + space).         }     }     return Arrays.asList(line1.toAttributedString(), line2.toAttributedString()). }
false;public,static;1;12;;public static String[] rowToString(Row row) {     final String[] fields = new String[row.getArity()].     for (int i = 0. i < row.getArity(). i++) {         final Object field = row.getField(i).         if (field == null) {             fields[i] = CliStrings.NULL_COLUMN.         } else {             fields[i] = field.toString().         }     }     return fields. }
false;public,static;1;7;;public static String[] typesToString(TypeInformation<?>[] types) {     final String[] typesAsString = new String[types.length].     for (int i = 0. i < types.length. i++) {         typesAsString[i] = types[i].toString().     }     return typesAsString. }
