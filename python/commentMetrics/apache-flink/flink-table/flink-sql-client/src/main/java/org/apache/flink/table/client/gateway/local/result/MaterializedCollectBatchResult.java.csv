commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isMaterialized() {     return true. }
false;public;0;4;;@Override public TypeInformation<Row> getOutputType() {     return outputType. }
false;public;1;5;;@Override public void startRetrieval(ProgramDeployer<C> deployer) {     this.deployer = deployer.     retrievalThread.start(). }
false;public;0;4;;@Override public TableSink<?> getTableSink() {     return tableSink. }
false;public;0;4;;@Override public void close() {     retrievalThread.interrupt(). }
false;public;1;9;;@Override public List<Row> retrievePage(int page) {     synchronized (resultLock) {         if (page <= 0 || page > pageCount) {             throw new SqlExecutionException("Invalid page '" + page + "'.").         }         return resultTable.subList(pageSize * (page - 1), Math.min(resultTable.size(), page * pageSize)).     } }
false;public;1;23;;@Override public TypedResult<Integer> snapshot(int pageSize) {     synchronized (resultLock) {         // wait for a result         if (retrievalThread.isAlive() && null == resultTable) {             return TypedResult.empty().         } else // the job finished with an exception         if (executionException != null) {             throw executionException.         } else // are retrieved dynamically         if (!snapshotted) {             snapshotted = true.             this.pageSize = pageSize.             pageCount = Math.max(1, (int) Math.ceil(((double) resultTable.size() / pageSize))).             return TypedResult.payload(pageCount).         } else {             return TypedResult.endOfStream().         }     } }
false;public;0;20;;@Override public void run() {     try {         deployer.run().         final JobExecutionResult result = deployer.fetchExecutionResult().         final ArrayList<byte[]> accResult = result.getAccumulatorResult(accumulatorName).         if (accResult == null) {             throw new SqlExecutionException("The accumulator could not retrieve the result.").         }         final List<Row> resultTable = SerializedListAccumulator.deserializeList(accResult, tableSink.getSerializer()).         // sets the result table all at once         synchronized (resultLock) {             MaterializedCollectBatchResult.this.resultTable = resultTable.         }     } catch (ClassNotFoundException | IOException e) {         executionException = new SqlExecutionException("Serialization error while deserializing collected data.", e).     } catch (SqlExecutionException e) {         executionException = e.     } }
