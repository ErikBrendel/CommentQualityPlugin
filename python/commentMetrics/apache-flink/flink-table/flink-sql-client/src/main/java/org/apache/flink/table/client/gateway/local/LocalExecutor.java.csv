commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public void start() { // nothing to do yet }
false;public;1;9;;@Override public Map<String, String> getSessionProperties(SessionContext session) throws SqlExecutionException {     final Environment env = getOrCreateExecutionContext(session).getMergedEnvironment().     final Map<String, String> properties = new HashMap<>().     properties.putAll(env.getExecution().asTopLevelMap()).     properties.putAll(env.getDeployment().asTopLevelMap()).     return properties. }
false;public;1;7;;@Override public List<String> listTables(SessionContext session) throws SqlExecutionException {     final TableEnvironment tableEnv = getOrCreateExecutionContext(session).createEnvironmentInstance().getTableEnvironment().     return Arrays.asList(tableEnv.listTables()). }
false;public;1;7;;@Override public List<String> listUserDefinedFunctions(SessionContext session) throws SqlExecutionException {     final TableEnvironment tableEnv = getOrCreateExecutionContext(session).createEnvironmentInstance().getTableEnvironment().     return Arrays.asList(tableEnv.listUserDefinedFunctions()). }
false;public;2;12;;@Override public TableSchema getTableSchema(SessionContext session, String name) throws SqlExecutionException {     final TableEnvironment tableEnv = getOrCreateExecutionContext(session).createEnvironmentInstance().getTableEnvironment().     try {         return tableEnv.scan(name).getSchema().     } catch (Throwable t) {         // catch everything such that the query does not crash the executor         throw new SqlExecutionException("No table with this name could be found.", t).     } }
false;public;2;17;;@Override public String explainStatement(SessionContext session, String statement) throws SqlExecutionException {     final ExecutionContext<?> context = getOrCreateExecutionContext(session).     final TableEnvironment tableEnv = context.createEnvironmentInstance().getTableEnvironment().     // translate     try {         final Table table = createTable(tableEnv, statement).         // explanation requires an optimization step that might reference UDFs during code compilation         return context.wrapClassLoader(() -> tableEnv.explain(table)).     } catch (Throwable t) {         // catch everything such that the query does not crash the executor         throw new SqlExecutionException("Invalid SQL statement.", t).     } }
false;public;3;16;;@Override public List<String> completeStatement(SessionContext session, String statement, int position) {     final TableEnvironment tableEnv = getOrCreateExecutionContext(session).createEnvironmentInstance().getTableEnvironment().     try {         return Arrays.asList(tableEnv.getCompletionHints(statement, position)).     } catch (Throwable t) {         // catch everything such that the query does not crash the executor         if (LOG.isDebugEnabled()) {             LOG.debug("Could not complete statement at " + position + ":" + statement, t).         }         return Collections.emptyList().     } }
false;public;2;5;;@Override public ResultDescriptor executeQuery(SessionContext session, String query) throws SqlExecutionException {     final ExecutionContext<?> context = getOrCreateExecutionContext(session).     return executeQueryInternal(context, query). }
false;public;2;12;;@Override public TypedResult<List<Tuple2<Boolean, Row>>> retrieveResultChanges(SessionContext session, String resultId) throws SqlExecutionException {     final DynamicResult<?> result = resultStore.getResult(resultId).     if (result == null) {         throw new SqlExecutionException("Could not find a result with result identifier '" + resultId + "'.").     }     if (result.isMaterialized()) {         throw new SqlExecutionException("Invalid result retrieval mode.").     }     return ((ChangelogResult<?>) result).retrieveChanges(). }
false;public;3;11;;@Override public TypedResult<Integer> snapshotResult(SessionContext session, String resultId, int pageSize) throws SqlExecutionException {     final DynamicResult<?> result = resultStore.getResult(resultId).     if (result == null) {         throw new SqlExecutionException("Could not find a result with result identifier '" + resultId + "'.").     }     if (!result.isMaterialized()) {         throw new SqlExecutionException("Invalid result retrieval mode.").     }     return ((MaterializedResult<?>) result).snapshot(pageSize). }
false;public;2;11;;@Override public List<Row> retrieveResultPage(String resultId, int page) throws SqlExecutionException {     final DynamicResult<?> result = resultStore.getResult(resultId).     if (result == null) {         throw new SqlExecutionException("Could not find a result with result identifier '" + resultId + "'.").     }     if (!result.isMaterialized()) {         throw new SqlExecutionException("Invalid result retrieval mode.").     }     return ((MaterializedResult<?>) result).retrievePage(page). }
false;public;2;5;;@Override public void cancelQuery(SessionContext session, String resultId) throws SqlExecutionException {     final ExecutionContext<?> context = getOrCreateExecutionContext(session).     cancelQueryInternal(context, resultId). }
false;public;2;5;;@Override public ProgramTargetDescriptor executeUpdate(SessionContext session, String statement) throws SqlExecutionException {     final ExecutionContext<?> context = getOrCreateExecutionContext(session).     return executeUpdateInternal(context, statement). }
false;public;1;5;;@Override public void validateSession(SessionContext session) throws SqlExecutionException {     // throws exceptions if an environment cannot be created with the given session context     getOrCreateExecutionContext(session).createEnvironmentInstance(). }
false;public;1;10;;@Override public void stop(SessionContext session) {     resultStore.getResults().forEach((resultId) -> {         try {             cancelQuery(session, resultId).         } catch (Throwable t) {         // ignore any throwable to keep the clean up running         }     }). }
false;private;2;39;;// -------------------------------------------------------------------------------------------- private <T> void cancelQueryInternal(ExecutionContext<T> context, String resultId) {     final DynamicResult<T> result = resultStore.getResult(resultId).     if (result == null) {         throw new SqlExecutionException("Could not find a result with result identifier '" + resultId + "'.").     }     // stop retrieval and remove the result     LOG.info("Cancelling job {} and result retrieval.", resultId).     result.close().     resultStore.removeResult(resultId).     // stop Flink job     try (final ClusterDescriptor<T> clusterDescriptor = context.createClusterDescriptor()) {         ClusterClient<T> clusterClient = null.         try {             // retrieve existing cluster             clusterClient = clusterDescriptor.retrieve(context.getClusterId()).             try {                 clusterClient.cancel(new JobID(StringUtils.hexStringToByte(resultId))).             } catch (Throwable t) {             // the job might has finished earlier             }         } catch (Exception e) {             throw new SqlExecutionException("Could not retrieve or create a cluster.", e).         } finally {             try {                 if (clusterClient != null) {                     clusterClient.shutdown().                 }             } catch (Exception e) {             // ignore             }         }     } catch (SqlExecutionException e) {         throw e.     } catch (Exception e) {         throw new SqlExecutionException("Could not locate a cluster.", e).     } }
false;private;2;28;;private <C> ProgramTargetDescriptor executeUpdateInternal(ExecutionContext<C> context, String statement) {     final ExecutionContext.EnvironmentInstance envInst = context.createEnvironmentInstance().     applyUpdate(context, envInst.getTableEnvironment(), envInst.getQueryConfig(), statement).     // create job graph with dependencies     final String jobName = context.getSessionContext().getName() + ": " + statement.     final JobGraph jobGraph.     try {         jobGraph = envInst.createJobGraph(jobName).     } catch (Throwable t) {         // catch everything such that the statement does not crash the executor         throw new SqlExecutionException("Invalid SQL statement.", t).     }     // create execution     final BasicResult<C> result = new BasicResult<>().     final ProgramDeployer<C> deployer = new ProgramDeployer<>(context, jobName, jobGraph, result, false).     // blocking deployment     deployer.run().     return ProgramTargetDescriptor.of(result.getClusterId(), jobGraph.getJobID(), result.getWebInterfaceUrl()). }
false;private;2;46;;private <C> ResultDescriptor executeQueryInternal(ExecutionContext<C> context, String query) {     final ExecutionContext.EnvironmentInstance envInst = context.createEnvironmentInstance().     // create table     final Table table = createTable(envInst.getTableEnvironment(), query).     // initialize result     final DynamicResult<C> result = resultStore.createResult(context.getMergedEnvironment(), removeTimeAttributes(table.getSchema()), envInst.getExecutionConfig()).     // create job graph with dependencies     final String jobName = context.getSessionContext().getName() + ": " + query.     final JobGraph jobGraph.     try {         // writing to a sink requires an optimization step that might reference UDFs during code compilation         context.wrapClassLoader(() -> {             table.writeToSink(result.getTableSink(), envInst.getQueryConfig()).             return null.         }).         jobGraph = envInst.createJobGraph(jobName).     } catch (Throwable t) {         // the result needs to be closed as long as         // it not stored in the result store         result.close().         // catch everything such that the query does not crash the executor         throw new SqlExecutionException("Invalid SQL query.", t).     }     // store the result with a unique id (the job id for now)     final String resultId = jobGraph.getJobID().toString().     resultStore.storeResult(resultId, result).     // create execution     final ProgramDeployer<C> deployer = new ProgramDeployer<>(context, jobName, jobGraph, result, true).     // start result retrieval     result.startRetrieval(deployer).     return new ResultDescriptor(resultId, removeTimeAttributes(table.getSchema()), result.isMaterialized()). }
true;private;2;9;/**  * Creates a table using the given query in the given table environment.  */ ;/**  * Creates a table using the given query in the given table environment.  */ private Table createTable(TableEnvironment tableEnv, String selectQuery) {     // parse and validate query     try {         return tableEnv.sqlQuery(selectQuery).     } catch (Throwable t) {         // catch everything such that the query does not crash the executor         throw new SqlExecutionException("Invalid SQL statement.", t).     } }
true;private;4;13;/**  * Applies the given update statement to the given table environment with query configuration.  */ ;/**  * Applies the given update statement to the given table environment with query configuration.  */ private <C> void applyUpdate(ExecutionContext<C> context, TableEnvironment tableEnv, QueryConfig queryConfig, String updateStatement) {     // parse and validate statement     try {         // update statement requires an optimization step that might reference UDFs during code compilation         context.wrapClassLoader(() -> {             tableEnv.sqlUpdate(updateStatement, queryConfig).             return null.         }).     } catch (Throwable t) {         // catch everything such that the statement does not crash the executor         throw new SqlExecutionException("Invalid SQL update statement.", t).     } }
true;private,synchronized;1;12;/**  * Creates or reuses the execution context.  */ ;/**  * Creates or reuses the execution context.  */ private synchronized ExecutionContext<?> getOrCreateExecutionContext(SessionContext session) throws SqlExecutionException {     if (executionContext == null || !executionContext.getSessionContext().equals(session)) {         try {             executionContext = new ExecutionContext<>(defaultEnvironment, session, dependencies, flinkConfig, commandLineOptions, commandLines).         } catch (Throwable t) {             // catch everything such that a configuration does not crash the executor             throw new SqlExecutionException("Could not create execution context.", t).         }     }     return executionContext. }
false;private,static;2;40;;// -------------------------------------------------------------------------------------------- private static List<URL> discoverDependencies(List<URL> jars, List<URL> libraries) {     final List<URL> dependencies = new ArrayList<>().     try {         // find jar files         for (URL url : jars) {             JobWithJars.checkJarFile(url).             dependencies.add(url).         }         // find jar files in library directories         for (URL libUrl : libraries) {             final File dir = new File(libUrl.toURI()).             if (!dir.isDirectory()) {                 throw new SqlClientException("Directory expected: " + dir).             } else if (!dir.canRead()) {                 throw new SqlClientException("Directory cannot be read: " + dir).             }             final File[] files = dir.listFiles().             if (files == null) {                 throw new SqlClientException("Directory cannot be read: " + dir).             }             for (File f : files) {                 // only consider jars                 if (f.isFile() && f.getAbsolutePath().toLowerCase().endsWith(".jar")) {                     final URL url = f.toURI().toURL().                     JobWithJars.checkJarFile(url).                     dependencies.add(url).                 }             }         }     } catch (Exception e) {         throw new SqlClientException("Could not load all required JAR files.", e).     }     if (LOG.isDebugEnabled()) {         LOG.debug("Using the following dependencies: {}", dependencies).     }     return dependencies. }
false;private,static;1;9;;private static Options collectCommandLineOptions(List<CustomCommandLine<?>> commandLines) {     final Options customOptions = new Options().     for (CustomCommandLine<?> customCommandLine : commandLines) {         customCommandLine.addRunOptions(customOptions).     }     return CliFrontendParser.mergeOptions(CliFrontendParser.getRunCommandOptions(), customOptions). }
false;private,static;1;14;;private static TableSchema removeTimeAttributes(TableSchema schema) {     final TableSchema.Builder builder = TableSchema.builder().     for (int i = 0. i < schema.getFieldCount(). i++) {         final TypeInformation<?> type = schema.getFieldTypes()[i].         final TypeInformation<?> convertedType.         if (FlinkTypeFactory.isTimeIndicatorType(type)) {             convertedType = Types.SQL_TIMESTAMP.         } else {             convertedType = type.         }         builder.field(schema.getFieldNames()[i], convertedType).     }     return builder.build(). }
