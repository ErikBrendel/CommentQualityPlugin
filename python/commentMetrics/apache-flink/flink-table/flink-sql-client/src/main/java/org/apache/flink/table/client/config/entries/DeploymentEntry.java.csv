commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;6;;@Override protected void validate(DescriptorProperties properties) {     properties.validateLong(DEPLOYMENT_RESPONSE_TIMEOUT, true, 0).     properties.validateString(DEPLOYMENT_GATEWAY_ADDRESS, true, 0).     properties.validateInt(DEPLOYMENT_GATEWAY_PORT, true, 0, 65535). }
false;public;0;4;;public long getResponseTimeout() {     return properties.getOptionalLong(DEPLOYMENT_RESPONSE_TIMEOUT).orElseGet(() -> useDefaultValue(DEPLOYMENT_RESPONSE_TIMEOUT, 10000L)). }
false;public;0;4;;public String getGatewayAddress() {     return properties.getOptionalString(DEPLOYMENT_GATEWAY_ADDRESS).orElseGet(() -> useDefaultValue(DEPLOYMENT_GATEWAY_ADDRESS, "")). }
false;public;0;4;;public int getGatewayPort() {     return properties.getOptionalInt(DEPLOYMENT_GATEWAY_PORT).orElseGet(() -> useDefaultValue(DEPLOYMENT_GATEWAY_PORT, 0)). }
true;public;1;30;/**  * Parses the given command line options from the deployment properties. Ignores properties  * that are not defined by options.  */ ;/**  * Parses the given command line options from the deployment properties. Ignores properties  * that are not defined by options.  */ public CommandLine getCommandLine(Options commandLineOptions) throws Exception {     final List<String> args = new ArrayList<>().     properties.asMap().forEach((k, v) -> {         // only add supported options         if (commandLineOptions.hasOption(k)) {             final Option o = commandLineOptions.getOption(k).             final String argument = "--" + o.getLongOpt().             // options without args             if (!o.hasArg()) {                 final Boolean flag = Boolean.parseBoolean(v).                 // add key only                 if (flag) {                     args.add(argument).                 }             } else // add key and value             if (!o.hasArgs()) {                 args.add(argument).                 args.add(v).             } else // options with multiple args are not supported yet             {                 throw new IllegalArgumentException("Option '" + o + "' is not supported yet.").             }         }     }).     return CliFrontendParser.parse(commandLineOptions, args.toArray(new String[args.size()]), true). }
false;private;2;4;;private <V> V useDefaultValue(String key, V defaultValue) {     LOG.info("Property '{}.{}' not specified. Using default value: {}", DEPLOYMENT_ENTRY, key, defaultValue).     return defaultValue. }
false;public;0;3;;public Map<String, String> asTopLevelMap() {     return properties.asPrefixedMap(DEPLOYMENT_ENTRY + '.'). }
false;public,static;1;3;;// -------------------------------------------------------------------------------------------- public static DeploymentEntry create(Map<String, Object> config) {     return new DeploymentEntry(ConfigUtil.normalizeYaml(config)). }
true;public,static;2;9;/**  * Merges two deployments entries. The properties of the first deployment entry might be  * overwritten by the second one.  */ ;/**  * Merges two deployments entries. The properties of the first deployment entry might be  * overwritten by the second one.  */ public static DeploymentEntry merge(DeploymentEntry deployment1, DeploymentEntry deployment2) {     final Map<String, String> mergedProperties = new HashMap<>(deployment1.asMap()).     mergedProperties.putAll(deployment2.asMap()).     final DescriptorProperties properties = new DescriptorProperties(true).     properties.putProperties(mergedProperties).     return new DeploymentEntry(properties). }
true;public,static;2;15;/**  * Creates a new deployment entry enriched with additional properties that are prefixed with  * {@link Environment#DEPLOYMENT_ENTRY}.  */ ;/**  * Creates a new deployment entry enriched with additional properties that are prefixed with  * {@link Environment#DEPLOYMENT_ENTRY}.  */ public static DeploymentEntry enrich(DeploymentEntry deployment, Map<String, String> prefixedProperties) {     final Map<String, String> enrichedProperties = new HashMap<>(deployment.asMap()).     prefixedProperties.forEach((k, v) -> {         final String normalizedKey = k.toLowerCase().         if (k.startsWith(DEPLOYMENT_ENTRY + '.')) {             enrichedProperties.put(normalizedKey.substring(DEPLOYMENT_ENTRY.length() + 1), v).         }     }).     final DescriptorProperties properties = new DescriptorProperties(true).     properties.putProperties(enrichedProperties).     return new DeploymentEntry(properties). }
