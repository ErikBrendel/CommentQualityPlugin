commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Terminal getTerminal() {     return terminal. }
false;public;0;3;;public SessionContext getContext() {     return context. }
false;public;0;9;;public void clearTerminal() {     if (isPlainTerminal()) {         for (int i = 0. i < 200. i++) {             // large number of empty lines             terminal.writer().println().         }     } else {         terminal.puts(InfoCmp.Capability.clear_screen).     } }
false;public;0;5;;public boolean isPlainTerminal() {     // e.g. IntelliJ IDEA terminal supports only a plain terminal     return terminal.getWidth() == 0 && terminal.getHeight() == 0. }
false;public;0;6;;public int getWidth() {     if (isPlainTerminal()) {         return PLAIN_TERMINAL_WIDTH.     }     return terminal.getWidth(). }
false;public;0;6;;public int getHeight() {     if (isPlainTerminal()) {         return PLAIN_TERMINAL_HEIGHT.     }     return terminal.getHeight(). }
false;public;0;3;;public Executor getExecutor() {     return executor. }
true;public;0;31;/**  * Opens the interactive CLI shell.  */ ;/**  * Opens the interactive CLI shell.  */ public void open() {     isRunning = true.     // print welcome     terminal.writer().append(CliStrings.MESSAGE_WELCOME).     // begin reading loop     while (isRunning) {         // make some space to previous command         terminal.writer().append("\n").         terminal.flush().         final String line.         try {             line = lineReader.readLine(prompt, null, (MaskingCallback) null, null).         } catch (UserInterruptException e) {             // user cancelled line with Ctrl+C             continue.         } catch (EndOfFileException | IOError e) {             // user cancelled application with Ctrl+D or kill             break.         } catch (Throwable t) {             throw new SqlClientException("Could not read from command line.", t).         }         if (line == null) {             continue.         }         final Optional<SqlCommandCall> cmdCall = parseCommand(line).         cmdCall.ifPresent(this::callCommand).     } }
true;public;0;7;/**  * Closes the CLI instance.  */ ;/**  * Closes the CLI instance.  */ public void close() {     try {         terminal.close().     } catch (IOException e) {         throw new SqlClientException("Unable to close terminal.", e).     } }
true;public;1;17;/**  * Submits a SQL update statement and prints status information and/or errors on the terminal.  *  * @param statement SQL update statement  * @return flag to indicate if the submission was successful or not  */ ;/**  * Submits a SQL update statement and prints status information and/or errors on the terminal.  *  * @param statement SQL update statement  * @return flag to indicate if the submission was successful or not  */ public boolean submitUpdate(String statement) {     terminal.writer().println(CliStrings.messageInfo(CliStrings.MESSAGE_WILL_EXECUTE).toAnsi()).     terminal.writer().println(new AttributedString(statement).toString()).     terminal.flush().     final Optional<SqlCommandCall> parsedStatement = parseCommand(statement).     // only support INSERT INTO     return parsedStatement.map(cmdCall -> {         switch(cmdCall.command) {             case INSERT_INTO:                 return callInsertInto(cmdCall).             default:                 printError(CliStrings.MESSAGE_UNSUPPORTED_SQL).                 return false.         }     }).orElse(false). }
false;private;1;7;;// -------------------------------------------------------------------------------------------- private Optional<SqlCommandCall> parseCommand(String line) {     final Optional<SqlCommandCall> parsedLine = SqlCommandParser.parse(line).     if (!parsedLine.isPresent()) {         printError(CliStrings.MESSAGE_UNKNOWN_SQL).     }     return parsedLine. }
false;private;1;48;;private void callCommand(SqlCommandCall cmdCall) {     switch(cmdCall.command) {         case QUIT:             callQuit().             break.         case CLEAR:             callClear().             break.         case RESET:             callReset().             break.         case SET:             callSet(cmdCall).             break.         case HELP:             callHelp().             break.         case SHOW_TABLES:             callShowTables().             break.         case SHOW_FUNCTIONS:             callShowFunctions().             break.         case DESCRIBE:             callDescribe(cmdCall).             break.         case EXPLAIN:             callExplain(cmdCall).             break.         case SELECT:             callSelect(cmdCall).             break.         case INSERT_INTO:             callInsertInto(cmdCall).             break.         case CREATE_VIEW:             callCreateView(cmdCall).             break.         case DROP_VIEW:             callDropView(cmdCall).             break.         case SOURCE:             callSource(cmdCall).             break.         default:             throw new SqlClientException("Unsupported command: " + cmdCall.command).     } }
false;private;0;4;;private void callQuit() {     printInfo(CliStrings.MESSAGE_QUIT).     isRunning = false. }
false;private;0;3;;private void callClear() {     clearTerminal(). }
false;private;0;4;;private void callReset() {     context.resetSessionProperties().     printInfo(CliStrings.MESSAGE_RESET). }
false;private;1;28;;private void callSet(SqlCommandCall cmdCall) {     // show all properties     if (cmdCall.operands.length == 0) {         final Map<String, String> properties.         try {             properties = executor.getSessionProperties(context).         } catch (SqlExecutionException e) {             printExecutionException(e).             return.         }         if (properties.isEmpty()) {             terminal.writer().println(CliStrings.messageInfo(CliStrings.MESSAGE_EMPTY).toAnsi()).         } else {             properties.entrySet().stream().map((e) -> e.getKey() + "=" + e.getValue()).sorted().forEach((p) -> terminal.writer().println(p)).         }     } else // set a property     {         context.setSessionProperty(cmdCall.operands[0], cmdCall.operands[1]).         terminal.writer().println(CliStrings.messageInfo(CliStrings.MESSAGE_SET).toAnsi()).     }     terminal.flush(). }
false;private;0;4;;private void callHelp() {     terminal.writer().println(CliStrings.MESSAGE_HELP).     terminal.flush(). }
false;private;0;15;;private void callShowTables() {     final List<String> tables.     try {         tables = executor.listTables(context).     } catch (SqlExecutionException e) {         printExecutionException(e).         return.     }     if (tables.isEmpty()) {         terminal.writer().println(CliStrings.messageInfo(CliStrings.MESSAGE_EMPTY).toAnsi()).     } else {         tables.forEach((v) -> terminal.writer().println(v)).     }     terminal.flush(). }
false;private;0;15;;private void callShowFunctions() {     final List<String> functions.     try {         functions = executor.listUserDefinedFunctions(context).     } catch (SqlExecutionException e) {         printExecutionException(e).         return.     }     if (functions.isEmpty()) {         terminal.writer().println(CliStrings.messageInfo(CliStrings.MESSAGE_EMPTY).toAnsi()).     } else {         functions.forEach((v) -> terminal.writer().println(v)).     }     terminal.flush(). }
false;private;1;11;;private void callDescribe(SqlCommandCall cmdCall) {     final TableSchema schema.     try {         schema = executor.getTableSchema(context, cmdCall.operands[0]).     } catch (SqlExecutionException e) {         printExecutionException(e).         return.     }     terminal.writer().println(schema.toString()).     terminal.flush(). }
false;private;1;11;;private void callExplain(SqlCommandCall cmdCall) {     final String explanation.     try {         explanation = executor.explainStatement(context, cmdCall.operands[0]).     } catch (SqlExecutionException e) {         printExecutionException(e).         return.     }     terminal.writer().println(explanation).     terminal.flush(). }
false;private;1;25;;private void callSelect(SqlCommandCall cmdCall) {     final ResultDescriptor resultDesc.     try {         resultDesc = executor.executeQuery(context, cmdCall.operands[0]).     } catch (SqlExecutionException e) {         printExecutionException(e).         return.     }     final CliResultView view.     if (resultDesc.isMaterialized()) {         view = new CliTableResultView(this, resultDesc).     } else {         view = new CliChangelogResultView(this, resultDesc).     }     // enter view     try {         view.open().         // view left         printInfo(CliStrings.MESSAGE_RESULT_QUIT).     } catch (SqlExecutionException e) {         printExecutionException(e).     } }
false;private;1;14;;private boolean callInsertInto(SqlCommandCall cmdCall) {     printInfo(CliStrings.MESSAGE_SUBMITTING_STATEMENT).     try {         final ProgramTargetDescriptor programTarget = executor.executeUpdate(context, cmdCall.operands[0]).         terminal.writer().println(CliStrings.messageInfo(CliStrings.MESSAGE_STATEMENT_SUBMITTED).toAnsi()).         terminal.writer().println(programTarget.toString()).         terminal.flush().     } catch (SqlExecutionException e) {         printExecutionException(e).         return false.     }     return true. }
false;private;1;21;;private void callCreateView(SqlCommandCall cmdCall) {     final String name = cmdCall.operands[0].     final String query = cmdCall.operands[1].     final ViewEntry previousView = context.getViews().get(name).     if (previousView != null) {         printExecutionError(CliStrings.MESSAGE_VIEW_ALREADY_EXISTS).         return.     }     try {         // perform and validate change         context.addView(ViewEntry.create(name, query)).         executor.validateSession(context).         printInfo(CliStrings.MESSAGE_VIEW_CREATED).     } catch (SqlExecutionException e) {         // rollback change         context.removeView(name).         printExecutionException(e).     } }
false;private;1;20;;private void callDropView(SqlCommandCall cmdCall) {     final String name = cmdCall.operands[0].     final ViewEntry view = context.getViews().get(name).     if (view == null) {         printExecutionError(CliStrings.MESSAGE_VIEW_NOT_FOUND).         return.     }     try {         // perform and validate change         context.removeView(name).         executor.validateSession(context).         printInfo(CliStrings.MESSAGE_VIEW_REMOVED).     } catch (SqlExecutionException e) {         // rollback change         context.addView(view).         printExecutionException(CliStrings.MESSAGE_VIEW_NOT_REMOVED, e).     } }
false;private;1;28;;private void callSource(SqlCommandCall cmdCall) {     final String pathString = cmdCall.operands[0].     // load file     final String stmt.     try {         final Path path = Paths.get(pathString).         byte[] encoded = Files.readAllBytes(path).         stmt = new String(encoded, Charset.defaultCharset()).     } catch (IOException e) {         printExecutionException(e).         return.     }     // limit the output a bit     if (stmt.length() > SOURCE_MAX_SIZE) {         printExecutionError(CliStrings.MESSAGE_MAX_SIZE_EXCEEDED).         return.     }     terminal.writer().println(CliStrings.messageInfo(CliStrings.MESSAGE_WILL_EXECUTE).toAnsi()).     terminal.writer().println(new AttributedString(stmt).toString()).     terminal.flush().     // try to run it     final Optional<SqlCommandCall> call = parseCommand(stmt).     call.ifPresent(this::callCommand). }
false;private;1;3;;// -------------------------------------------------------------------------------------------- private void printExecutionException(Throwable t) {     printExecutionException(null, t). }
false;private;2;9;;private void printExecutionException(String message, Throwable t) {     final String finalMessage.     if (message == null) {         finalMessage = CliStrings.MESSAGE_SQL_EXECUTION_ERROR.     } else {         finalMessage = CliStrings.MESSAGE_SQL_EXECUTION_ERROR + ' ' + message.     }     printException(finalMessage, t). }
false;private;1;4;;private void printExecutionError(String message) {     terminal.writer().println(CliStrings.messageError(CliStrings.MESSAGE_SQL_EXECUTION_ERROR, message).toAnsi()).     terminal.flush(). }
false;private;2;5;;private void printException(String message, Throwable t) {     LOG.warn(message, t).     terminal.writer().println(CliStrings.messageError(message, t).toAnsi()).     terminal.flush(). }
false;private;1;4;;private void printError(String message) {     terminal.writer().println(CliStrings.messageError(message).toAnsi()).     terminal.flush(). }
false;private;1;4;;private void printInfo(String message) {     terminal.writer().println(CliStrings.messageInfo(message).toAnsi()).     terminal.flush(). }
false;private,static;0;9;;// -------------------------------------------------------------------------------------------- private static Terminal createDefaultTerminal() {     try {         return TerminalBuilder.builder().name(CliStrings.CLI_NAME).build().     } catch (IOException e) {         throw new SqlClientException("Error opening command line interface.", e).     } }
