commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;// -------------------------------------------------------------------------------------------- @Override protected void init() { // nothing to do }
false;protected;0;21;;@Override protected KeyMap<InputOperation> getKeys() {     final KeyMap<InputOperation> keys = new KeyMap<>().     keys.setUnicode(INSERT).     // make ESC quicker     keys.setAmbiguousTimeout(200).     for (char i = 32. i < 256. i++) {         keys.bind(INSERT, Character.toString(i)).     }     keys.bind(LEFT, key(client.getTerminal(), Capability.key_left)).     keys.bind(RIGHT, key(client.getTerminal(), Capability.key_right)).     keys.bind(BACKSPACE, del()).     if (client.isPlainTerminal()) {         keys.bind(ENTER, "\r", "$").         keys.bind(QUIT, key(client.getTerminal(), Capability.key_exit), "!").     } else {         keys.bind(ENTER, "\r").         keys.bind(QUIT, esc()).     }     return keys. }
false;protected;2;23;;@Override protected void evaluate(InputOperation operation, String binding) {     switch(operation) {         case QUIT:             close().             break.         case INSERT:             insert(binding).             break.         case ENTER:             submit().             break.         case LEFT:             moveCursorLeft().             break.         case RIGHT:             moveCursorRight().             break.         case BACKSPACE:             deleteLeft().             break.     } }
false;protected;0;4;;@Override protected String getTitle() {     return CliStrings.INPUT_TITLE. }
false;protected;0;4;;@Override protected List<AttributedString> computeHeaderLines() {     return Collections.emptyList(). }
false;protected;0;4;;@Override protected List<AttributedString> computeFooterLines() {     return Collections.singletonList(CliStrings.INPUT_HELP). }
false;protected;0;4;;@Override protected List<AttributedString> computeMainHeaderLines() {     return Collections.emptyList(). }
false;protected;0;38;;@Override protected List<AttributedString> computeMainLines() {     final List<AttributedString> lines = new ArrayList<>().     // space     IntStream.range(0, getVisibleMainHeight() / 2 - 2).forEach((i) -> lines.add(AttributedString.EMPTY)).     // title     lines.add(new AttributedString(CliStrings.DEFAULT_MARGIN + inputTitle)).     // input line     final AttributedStringBuilder inputLine = new AttributedStringBuilder().     inputLine.append(CliStrings.DEFAULT_MARGIN + "> ").     final String input = currentInput.toString().     // add string left of cursor     inputLine.append(currentInput.substring(0, cursorPos)).     inputLine.style(AttributedStyle.DEFAULT.inverse().blink()).     if (cursorPos < input.length()) {         inputLine.append(input.charAt(cursorPos)).         inputLine.style(AttributedStyle.DEFAULT).         inputLine.append(input.substring(cursorPos + 1, input.length())).     } else {         // show the cursor at the end         inputLine.append(' ').     }     lines.add(inputLine.toAttributedString()).     // isError     if (isError) {         final AttributedStringBuilder errorLine = new AttributedStringBuilder().         errorLine.style(AttributedStyle.DEFAULT.foreground(AttributedStyle.RED)).         errorLine.append(CliStrings.DEFAULT_MARGIN + CliStrings.INPUT_ERROR).         lines.add(AttributedString.EMPTY).         lines.add(errorLine.toAttributedString()).     }     return lines. }
false;protected;0;4;;@Override protected void cleanUp() { // nothing to do }
false;private;1;7;;// -------------------------------------------------------------------------------------------- private void insert(String binding) {     currentInput.insert(cursorPos, binding).     cursorPos += binding.length().     // reset view     resetMainPart(). }
false;private;0;9;;private void deleteLeft() {     if (cursorPos > 0) {         currentInput.deleteCharAt(cursorPos - 1).         cursorPos--.     }     // reset view     resetMainPart(). }
false;private;0;8;;private void moveCursorLeft() {     if (cursorPos > 0) {         cursorPos--.     }     // reset view     resetMainPart(). }
false;private;0;8;;private void moveCursorRight() {     if (cursorPos < currentInput.length()) {         cursorPos++.     }     // reset view     resetMainPart(). }
false;private;0;18;;private void submit() {     isError = false.     final String s = currentInput.toString().     // input cancelled     if (s.isEmpty()) {         close().     } else // validate and return     if (validation.apply(s)) {         close(s).     } else // show error     {         isError = true.         // reset view         resetMainPart().     } }
