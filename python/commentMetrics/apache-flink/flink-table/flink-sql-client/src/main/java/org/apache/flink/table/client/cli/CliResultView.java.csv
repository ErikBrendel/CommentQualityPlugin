commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;10;;// -------------------------------------------------------------------------------------------- protected void increaseRefreshInterval() {     refreshInterval = Math.min(REFRESH_INTERVALS.size() - 1, refreshInterval + 1).     // reset view     resetAllParts().     synchronized (refreshThread) {         refreshThread.notify().     } }
false;protected;1;10;;protected void decreaseRefreshInterval(int minInterval) {     refreshInterval = Math.max(minInterval, refreshInterval - 1).     // reset view     resetAllParts().     synchronized (refreshThread) {         refreshThread.notify().     } }
false;protected;0;21;;protected void selectRowUp() {     final int visibleRowTop = offsetY.     if (selectedRow == NO_ROW_SELECTED) {         if (!getMainLines().isEmpty()) {             // most bottom visible row             selectedRow = Math.min(getMainLines().size(), offsetY + getVisibleMainHeight()) - 1.         }     } else // in visible area     if (selectedRow > visibleRowTop) {         selectedRow = selectedRow - 1.     } else // not visible, scrolling needed     {         selectedRow = Math.max(0, selectedRow - 1).         scrollUp().     }     // reset view     resetMainPart(). }
false;protected;0;18;;protected void selectRowDown() {     final int visibleRowBottom = Math.min(getMainLines().size(), offsetY + getVisibleMainHeight()) - 1.     if (selectedRow == NO_ROW_SELECTED) {         selectedRow = offsetY.     } else // in visible area     if (visibleRowBottom >= 0 && selectedRow < visibleRowBottom) {         selectedRow = selectedRow + 1.     } else // not visible, scrolling needed     {         selectedRow = Math.min(Math.max(0, getMainLines().size() - 1), selectedRow + 1).         scrollDown().     }     // reset view     resetMainPart(). }
false;protected;0;11;;protected void openRow() {     if (selectedRow == NO_ROW_SELECTED) {         return.     }     final CliRowView view = new CliRowView(client, resultDescriptor.getResultSchema().getFieldNames(), CliUtils.typesToString(resultDescriptor.getResultSchema().getFieldTypes()), getRow(results.get(selectedRow))).     // enter view     view.open(). }
false;protected;1;8;;protected void stopRetrieval(boolean cleanUpQuery) {     // stop retrieval     refreshThread.cleanUpQuery = cleanUpQuery.     refreshThread.isRunning = false.     synchronized (refreshThread) {         refreshThread.notify().     } }
false;protected;0;3;;protected boolean isRetrieving() {     return refreshThread.isRunning. }
false;protected,abstract;0;1;;// -------------------------------------------------------------------------------------------- protected abstract void refresh().
false;protected,abstract;1;1;;protected abstract int computeColumnWidth(int idx).
false;protected,abstract;1;1;;protected abstract String[] getRow(String[] resultRow).
false;protected;0;4;;// -------------------------------------------------------------------------------------------- @Override protected void init() {     refreshThread.start(). }
false;protected;0;37;;@Override protected List<AttributedString> computeMainLines() {     final List<AttributedString> lines = new ArrayList<>().     int lineIdx = 0.     for (String[] line : results) {         final AttributedStringBuilder row = new AttributedStringBuilder().         // highlight selected row         if (lineIdx == selectedRow) {             row.style(AttributedStyle.DEFAULT.inverse()).         }         for (int colIdx = 0. colIdx < line.length. colIdx++) {             final String col = line[colIdx].             final int columnWidth = computeColumnWidth(colIdx).             row.append(' ').             // both inverse and bold together do not work correctly             if (previousResults != null && lineIdx != selectedRow && refreshThread.isRunning && (lineIdx >= previousResults.size() || !col.equals(previousResults.get(lineIdx)[colIdx]))) {                 row.style(AttributedStyle.BOLD).                 normalizeColumn(row, col, columnWidth).                 row.style(AttributedStyle.DEFAULT).             } else {                 normalizeColumn(row, col, columnWidth).             }         }         lines.add(row.toAttributedString()).         lineIdx++.     }     return lines. }
false;protected;0;4;;@Override protected void cleanUp() {     stopRetrieval(true). }
false;public;0;61;;@Override public void run() {     while (isRunning) {         final long interval = REFRESH_INTERVALS.get(refreshInterval).f1.         if (interval >= 0) {             // refresh according to specified interval             if (interval > 0) {                 synchronized (RefreshThread.this) {                     if (isRunning) {                         try {                             RefreshThread.this.wait(interval).                         } catch (InterruptedException e) {                             continue.                         }                     }                 }             }             synchronized (CliResultView.this) {                 refresh().                 // do the display only every 100 ms (even in fastest mode)                 if (System.currentTimeMillis() - lastUpdatedResults > 100) {                     if (CliResultView.this.isRunning()) {                         display().                     }                     lastUpdatedResults = System.currentTimeMillis().                 }             }         } else {             // keep the thread running but without refreshing             synchronized (RefreshThread.this) {                 if (isRunning) {                     try {                         RefreshThread.this.wait(100).                     } catch (InterruptedException e) {                     // continue                     }                 }             }         }     }     // final display     synchronized (CliResultView.this) {         if (CliResultView.this.isRunning()) {             display().         }     }     if (cleanUpQuery) {         // cancel table program         try {             // the cancellation happens in the refresh thread in order to keep the main thread             // responsive at all times. esp. if the cluster is not available             client.getExecutor().cancelQuery(client.getContext(), resultDescriptor.getResultId()).         } catch (SqlExecutionException e) {         // ignore further exceptions         }     } }
