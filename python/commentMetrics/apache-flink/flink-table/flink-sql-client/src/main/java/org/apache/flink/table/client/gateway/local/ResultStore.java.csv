commented;modifiers;parameterAmount;loc;comment;code
true;public;3;28;/**  * Creates a result. Might start threads or opens sockets so every created result must be closed.  */ ;/**  * Creates a result. Might start threads or opens sockets so every created result must be closed.  */ public <T> DynamicResult<T> createResult(Environment env, TableSchema schema, ExecutionConfig config) {     final TypeInformation<Row> outputType = Types.ROW_NAMED(schema.getFieldNames(), schema.getFieldTypes()).     if (env.getExecution().isStreamingExecution()) {         // determine gateway address (and port if possible)         final InetAddress gatewayAddress = getGatewayAddress(env.getDeployment()).         final int gatewayPort = getGatewayPort(env.getDeployment()).         if (env.getExecution().isChangelogMode()) {             return new ChangelogCollectStreamResult<>(outputType, config, gatewayAddress, gatewayPort).         } else {             return new MaterializedCollectStreamResult<>(outputType, config, gatewayAddress, gatewayPort, env.getExecution().getMaxTableResultRows()).         }     } else {         // Batch Execution         if (!env.getExecution().isTableMode()) {             throw new SqlExecutionException("Results of batch queries can only be served in table mode.").         }         return new MaterializedCollectBatchResult<>(outputType, config).     } }
false;public;2;3;;public void storeResult(String resultId, DynamicResult result) {     results.put(resultId, result). }
false;public;1;4;;@SuppressWarnings("unchecked") public <T> DynamicResult<T> getResult(String resultId) {     return (DynamicResult<T>) results.get(resultId). }
false;public;1;3;;public void removeResult(String resultId) {     results.remove(resultId). }
false;public;0;3;;public List<String> getResults() {     return new ArrayList<>(results.keySet()). }
false;private;1;4;;// -------------------------------------------------------------------------------------------- private int getGatewayPort(DeploymentEntry deploy) {     // try to get address from deployment configuration     return deploy.getGatewayPort(). }
false;private;1;36;;private InetAddress getGatewayAddress(DeploymentEntry deploy) {     // try to get address from deployment configuration     final String address = deploy.getGatewayAddress().     // use manually defined address     if (!address.isEmpty()) {         try {             return InetAddress.getByName(address).         } catch (UnknownHostException e) {             throw new SqlClientException("Invalid gateway address '" + address + "' for result retrieval.", e).         }     } else {         // TODO cache this         // try to get the address by communicating to JobManager         final String jobManagerAddress = flinkConfig.getString(JobManagerOptions.ADDRESS).         final int jobManagerPort = flinkConfig.getInteger(JobManagerOptions.PORT).         if (jobManagerAddress != null && !jobManagerAddress.isEmpty()) {             try {                 return ConnectionUtils.findConnectingAddress(new InetSocketAddress(jobManagerAddress, jobManagerPort), deploy.getResponseTimeout(), 400).             } catch (Exception e) {                 throw new SqlClientException("Could not determine address of the gateway for result retrieval " + "by connecting to the job manager. Please specify the gateway address manually.", e).             }         } else {             try {                 return InetAddress.getLocalHost().             } catch (UnknownHostException e) {                 throw new SqlClientException("Could not determine address of the gateway for result retrieval. " + "Please specify the gateway address manually.", e).             }         }     } }
