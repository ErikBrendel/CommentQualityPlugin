commented;modifiers;parameterAmount;loc;comment;code
false;public;0;58;;public void open() {     isRunning = true.     inputThread = Thread.currentThread().     // prepare terminal     final Tuple2<Attributes, Map<Signal, SignalHandler>> prev = prepareTerminal().     ensureTerminalFullScreen().     updateSize().     init().     synchronized (this) {         display().     }     final KeyMap<OP> keys = getKeys().     while (isRunning) {         final OP operation.         try {             operation = keyReader.readBinding(keys, null, true).         } catch (IOError e) {             break.         }         // refresh loop         if (operation == null) {             continue.         }         synchronized (this) {             try {                 evaluate(operation, keyReader.getLastBinding()).             } catch (SqlExecutionException e) {                 // in case the evaluate method did not use the close method                 close(e).             }             if (isRunning) {                 // ensure full-screen again in case a sub-view has been opened in evaluate                 ensureTerminalFullScreen().                 display().             }         }     }     cleanUp().     // clean terminal     restoreTerminal(prev).     unsetTerminalFullScreen().     if (executionException != null) {         throw executionException.     } }
false;public;0;3;;public OUT getResult() {     return result. }
false;protected;0;3;;// -------------------------------------------------------------------------------------------- protected boolean isRunning() {     return isRunning. }
false;protected;0;9;;protected void close() {     if (isRunning) {         isRunning = false.         // break the input loop if this method is called from another thread         if (Thread.currentThread() != inputThread) {             inputThread.interrupt().         }     } }
false;protected;1;4;;protected void close(SqlExecutionException e) {     executionException = e.     close(). }
false;protected;1;4;;protected void close(OUT result) {     this.result = result.     isRunning = false. }
false;protected;0;63;;protected void display() {     // cache     final List<AttributedString> headerLines = getHeaderLines().     final List<AttributedString> mainHeaderLines = getMainHeaderLines().     final List<AttributedString> mainLines = getMainLines().     final List<AttributedString> footerLines = getFooterLines().     final int visibleMainHeight = getVisibleMainHeight().     final int totalMainWidth = getTotalMainWidth().     // create output     client.clearTerminal().     final List<String> lines = new ArrayList<>().     // title part     client.getTerminal().writer().println(computeTitleLine().toAnsi()).     // header part     headerLines.forEach(l -> client.getTerminal().writer().println(l.toAnsi())).     // update vertical offset     if (visibleMainHeight > mainLines.size()) {         // enough space         offsetY = 0.     } else {         // bound offset         offsetY = Math.min(mainLines.size() - visibleMainHeight, offsetY).     }     // update horizontal offset     if (width > totalMainWidth) {         // enough space         offsetX = 0.     } else {         // bound offset         offsetX = Math.min(totalMainWidth - width, offsetX).     }     // create window     final List<AttributedString> windowedMainLines = mainLines.subList(offsetY, Math.min(mainLines.size(), offsetY + visibleMainHeight)).     // print window     Stream.concat(mainHeaderLines.stream(), windowedMainLines.stream()).forEach(l -> {         if (offsetX < l.length()) {             final AttributedString windowX = l.substring(offsetX, Math.min(l.length(), offsetX + width)).             client.getTerminal().writer().println(windowX.toAnsi()).         } else {             // nothing to show for this line             client.getTerminal().writer().println().         }     }).     // footer part     final int emptyHeight = // -1 = title     height - 1 - headerLines.size() - windowedMainLines.size() - mainHeaderLines.size() - footerLines.size().     // padding     IntStream.range(0, emptyHeight).forEach(i -> client.getTerminal().writer().println()).     // footer     IntStream.range(0, footerLines.size()).forEach((i) -> {         final AttributedString l = footerLines.get(i).         if (i == footerLines.size() - 1) {             client.getTerminal().writer().print(l.toAnsi()).         } else {             client.getTerminal().writer().println(l.toAnsi()).         }     }).     client.getTerminal().flush(). }
false;protected;0;5;;protected void scrollLeft() {     if (offsetX > 0) {         offsetX -= 1.     } }
false;protected;0;6;;protected void scrollRight() {     final int maxOffset = Math.max(0, getTotalMainWidth() - width).     if (offsetX < maxOffset) {         offsetX += 1.     } }
false;protected;0;5;;protected void scrollUp() {     if (offsetY > 0) {         offsetY -= 1.     } }
false;protected;0;3;;protected void scrollDown() {     scrollDown(1). }
false;protected;1;4;;protected void scrollDown(int n) {     final int maxOffset = Math.max(0, getMainLines().size() - getVisibleMainHeight()).     offsetY = Math.min(maxOffset, offsetY + n). }
false;protected;0;5;;protected int getVisibleMainHeight() {     // -1 = title line     return height - 1 - getHeaderLines().size() - getMainHeaderLines().size() - getFooterLines().size(). }
false;protected;0;6;;protected List<AttributedString> getHeaderLines() {     if (headerLines == null) {         headerLines = computeHeaderLines().     }     return headerLines. }
false;protected;0;7;;protected List<AttributedString> getMainHeaderLines() {     if (mainHeaderLines == null) {         mainHeaderLines = computeMainHeaderLines().         totalMainWidth = computeTotalMainWidth().     }     return mainHeaderLines. }
false;protected;0;7;;protected List<AttributedString> getMainLines() {     if (mainLines == null) {         mainLines = computeMainLines().         totalMainWidth = computeTotalMainWidth().     }     return mainLines. }
false;protected;0;6;;protected List<AttributedString> getFooterLines() {     if (footerLines == null) {         footerLines = computeFooterLines().     }     return footerLines. }
false;protected;0;6;;protected int getTotalMainWidth() {     if (totalMainWidth <= 0) {         totalMainWidth = computeTotalMainWidth().     }     return totalMainWidth. }
false;protected;0;6;;protected AttributedString getTitleLine() {     if (titleLine == null) {         titleLine = computeTitleLine().     }     return titleLine. }
true;protected;0;8;/**  * Must be called when values in one or more parts have changed.  */ ;/**  * Must be called when values in one or more parts have changed.  */ protected void resetAllParts() {     titleLine = null.     headerLines = null.     mainHeaderLines = null.     mainLines = null.     footerLines = null.     totalMainWidth = 0. }
true;protected;0;5;/**  * Must be called when values in the main part (main header or main) have changed.  */ ;/**  * Must be called when values in the main part (main header or main) have changed.  */ protected void resetMainPart() {     mainHeaderLines = null.     mainLines = null.     totalMainWidth = 0. }
false;protected;0;3;;protected int getWidth() {     return width. }
false;protected;0;3;;protected int getHeight() {     return height. }
false;private;0;6;;// -------------------------------------------------------------------------------------------- private void updateSize() {     width = client.getWidth().     height = client.getHeight().     totalMainWidth = width.     resetAllParts(). }
false;private;0;6;;private void ensureTerminalFullScreen() {     final Terminal terminal = client.getTerminal().     terminal.puts(Capability.enter_ca_mode).     terminal.puts(Capability.keypad_xmit).     terminal.puts(Capability.cursor_invisible). }
false;private;0;26;;private Tuple2<Attributes, Map<Signal, SignalHandler>> prepareTerminal() {     final Terminal terminal = client.getTerminal().     final Attributes prevAttributes = terminal.getAttributes().     // adopted from org.jline.builtins.Nano     // see also https://en.wikibooks.org/wiki/Serial_Programming/termios#Basic_Configuration_of_a_Serial_Interface     // no line processing     // canonical mode off, echo off, echo newline off, extended input processing off     Attributes newAttr = new Attributes(prevAttributes).     newAttr.setLocalFlags(EnumSet.of(LocalFlag.ICANON, LocalFlag.ECHO, LocalFlag.IEXTEN), false).     // turn off input processing     newAttr.setInputFlags(EnumSet.of(Attributes.InputFlag.IXON, Attributes.InputFlag.ICRNL, Attributes.InputFlag.INLCR), false).     // one input byte is enough to return from read, inter-character timer off     newAttr.setControlChar(Attributes.ControlChar.VMIN, 1).     newAttr.setControlChar(Attributes.ControlChar.VTIME, 0).     newAttr.setControlChar(Attributes.ControlChar.VINTR, 0).     terminal.setAttributes(newAttr).     final Map<Signal, SignalHandler> prevSignals = new HashMap<>().     prevSignals.put(Signal.WINCH, terminal.handle(Signal.WINCH, this::handleSignal)).     prevSignals.put(Signal.INT, terminal.handle(Signal.INT, this::handleSignal)).     prevSignals.put(Signal.QUIT, terminal.handle(Signal.QUIT, this::handleSignal)).     return Tuple2.of(prevAttributes, prevSignals). }
false;private;1;6;;private void restoreTerminal(Tuple2<Attributes, Map<Signal, SignalHandler>> prev) {     final Terminal terminal = client.getTerminal().     terminal.setAttributes(prev.f0).     prev.f1.forEach(terminal::handle). }
false;private;0;7;;private void unsetTerminalFullScreen() {     final Terminal terminal = client.getTerminal().     terminal.puts(Capability.exit_ca_mode).     terminal.puts(Capability.keypad_local).     terminal.puts(Capability.cursor_visible). }
false;private;0;7;;private int computeTotalMainWidth() {     final List<AttributedString> mainLines = getMainLines().     final List<AttributedString> mainHeaderLines = getMainHeaderLines().     final int max1 = mainLines.stream().mapToInt(AttributedString::length).max().orElse(0).     final int max2 = mainHeaderLines.stream().mapToInt(AttributedString::length).max().orElse(0).     return Math.max(max1, max2). }
false;private;0;11;;private AttributedString computeTitleLine() {     final String title = getTitle().     final AttributedStringBuilder titleLine = new AttributedStringBuilder().     titleLine.style(AttributedStyle.INVERSE).     final int totalMargin = width - title.length().     final int margin = totalMargin / 2.     repeatChar(titleLine, ' ', margin).     titleLine.append(title).     repeatChar(titleLine, ' ', margin + (totalMargin % 2)).     return titleLine.toAttributedString(). }
false;private;1;18;;private void handleSignal(Signal signal) {     synchronized (this) {         switch(signal) {             case INT:                 close(new SqlExecutionException("Forced interrupt.")).                 break.             case QUIT:                 close(new SqlExecutionException("Forced cancellation.")).                 break.             case WINCH:                 updateSize().                 if (isRunning) {                     display().                 }                 break.         }     } }
true;protected,abstract;0;1;/**  * Starts threads if necessary.  */ ;// -------------------------------------------------------------------------------------------- /**  * Starts threads if necessary.  */ protected abstract void init().
false;protected,abstract;0;1;;protected abstract KeyMap<OP> getKeys().
false;protected,abstract;2;1;;protected abstract void evaluate(OP operation, String binding).
false;protected,abstract;0;1;;protected abstract String getTitle().
false;protected,abstract;0;1;;protected abstract List<AttributedString> computeHeaderLines().
false;protected,abstract;0;1;;protected abstract List<AttributedString> computeMainHeaderLines().
false;protected,abstract;0;1;;protected abstract List<AttributedString> computeMainLines().
false;protected,abstract;0;1;;protected abstract List<AttributedString> computeFooterLines().
false;protected,abstract;0;1;;protected abstract void cleanUp().
