commented;modifiers;parameterAmount;loc;comment;code
false;public;3;24;;public void complete(LineReader reader, ParsedLine line, List<Candidate> candidates) {     String statement = line.line().     // remove '.' at the end     if (statement.endsWith(".")) {         statement = statement.substring(0, statement.length() - 1).     }     // handle SQL client specific commands     final String statementNormalized = statement.toUpperCase().trim().     for (String commandHint : COMMAND_HINTS) {         if (commandHint.startsWith(statementNormalized) && line.cursor() < commandHint.length()) {             candidates.add(createCandidate(commandHint)).         }     }     // fallback to Table API hinting     try {         executor.completeStatement(context, statement, line.cursor()).forEach(hint -> candidates.add(createCandidate(hint))).     } catch (SqlExecutionException e) {         LOG.debug("Could not complete statement at " + line.cursor() + ":" + statement, e).     } }
false;private;1;3;;private Candidate createCandidate(String hint) {     return new Candidate(AttributedString.stripAnsi(hint), hint, null, null, null, null, true). }
false;private,static;0;14;;private static String[] getCommandHints() {     final SqlCommandParser.SqlCommand[] commands = SqlCommandParser.SqlCommand.values().     final String[] hints = new String[commands.length].     for (int i = 0. i < commands.length. i++) {         final SqlCommandParser.SqlCommand command = commands[i].         // add final "." for convenience if no operands can follow         if (command.hasOperands()) {             hints[i] = command.toString().         } else {             hints[i] = command.toString() + ".".         }     }     return hints. }
