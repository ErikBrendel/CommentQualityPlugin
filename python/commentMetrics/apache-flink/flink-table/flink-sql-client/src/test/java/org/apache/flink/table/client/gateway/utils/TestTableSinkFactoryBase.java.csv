commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public Map<String, String> requiredContext() {     final Map<String, String> context = new HashMap<>().     context.put(UPDATE_MODE(), UPDATE_MODE_VALUE_APPEND()).     context.put(CONNECTOR_TYPE, type).     return context. }
false;public;0;11;;@Override public List<String> supportedProperties() {     final List<String> properties = new ArrayList<>().     properties.add("connector." + testProperty).     properties.add(SCHEMA() + ".#." + SCHEMA_TYPE()).     properties.add(SCHEMA() + ".#." + SCHEMA_NAME()).     properties.add(SCHEMA() + ".#." + ROWTIME_TIMESTAMPS_TYPE()).     properties.add(SCHEMA() + ".#." + ROWTIME_TIMESTAMPS_FROM()).     properties.add(SCHEMA() + ".#." + ROWTIME_WATERMARKS_TYPE()).     return properties. }
false;public;1;8;;@Override public StreamTableSink<Row> createStreamTableSink(Map<String, String> properties) {     final DescriptorProperties params = new DescriptorProperties(true).     params.putProperties(properties).     return new TestTableSink(SchemaValidator.deriveTableSinkSchema(params), properties.get(testProperty)). }
false;public;0;3;;public String getProperty() {     return property. }
false;public;0;4;;@Override public TypeInformation<Row> getOutputType() {     return Types.ROW(schema.getFieldNames(), schema.getFieldTypes()). }
false;public;0;4;;@Override public String[] getFieldNames() {     return schema.getFieldNames(). }
false;public;0;4;;@Override public TypeInformation<?>[] getFieldTypes() {     return schema.getFieldTypes(). }
false;public;2;4;;@Override public TableSink<Row> configure(String[] fieldNames, TypeInformation<?>[] fieldTypes) {     return new TestTableSink(new TableSchema(fieldNames, fieldTypes), property). }
false;public;1;4;;@Override public void emitDataStream(DataStream<Row> dataStream) { // do nothing }
