commented;modifiers;parameterAmount;loc;comment;code
true;static;1;5;/**  * Closes the specified channel after all queued write requests are flushed.  */ ;/**  * Closes the specified channel after all queued write requests are flushed.  */ static void closeOnFlush(Channel channel) {     if (channel.isConnected()) {         channel.write(ChannelBuffers.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE).     } }
false;public;0;6;;public void closeConnections() {     for (Map.Entry<Channel, Channel> entry : sourceToTargetChannels.entrySet()) {         // target channel is closed on source's channel channelClosed even         entry.getKey().close().     } }
false;public;2;35;;@Override public void channelOpen(ChannelHandlerContext context, ChannelStateEvent event) throws Exception {     // Suspend incoming traffic until connected to the remote host.     final Channel sourceChannel = event.getChannel().     sourceChannel.setReadable(false).     boolean isBlocked = blocked.get().     LOG.debug("Attempt to open proxy channel from [{}] to [{}:{}] in state [blocked = {}]", sourceChannel.getLocalAddress(), remoteHost, remotePort, isBlocked).     if (isBlocked) {         sourceChannel.close().         return.     }     // Start the connection attempt.     ClientBootstrap targetConnectionBootstrap = new ClientBootstrap(channelFactory).     targetConnectionBootstrap.getPipeline().addLast(TARGET_CHANNEL_HANDLER_NAME, new TargetChannelHandler(event.getChannel(), blocked)).     ChannelFuture connectFuture = targetConnectionBootstrap.connect(new InetSocketAddress(remoteHost, remotePort)).     sourceToTargetChannels.put(sourceChannel, connectFuture.getChannel()).     connectFuture.addListener(future -> {         if (future.isSuccess()) {             // Connection attempt succeeded:             // Begin to accept incoming traffic.             sourceChannel.setReadable(true).         } else {             // Close the connection if the connection attempt has failed.             sourceChannel.close().         }     }). }
false;public;2;13;;@Override public void messageReceived(ChannelHandlerContext context, MessageEvent event) throws Exception {     if (blocked.get()) {         return.     }     ChannelBuffer msg = (ChannelBuffer) event.getMessage().     Channel targetChannel = sourceToTargetChannels.get(event.getChannel()).     if (targetChannel == null) {         throw new IllegalStateException("Could not find a target channel for the source channel").     }     targetChannel.write(msg). }
false;public;2;10;;@Override public void channelClosed(ChannelHandlerContext context, ChannelStateEvent event) throws Exception {     Channel targetChannel = sourceToTargetChannels.get(event.getChannel()).     if (targetChannel == null) {         return.     }     closeOnFlush(targetChannel).     sourceToTargetChannels.remove(event.getChannel()).     onClose.accept(this). }
false;public;2;5;;@Override public void exceptionCaught(ChannelHandlerContext context, ExceptionEvent event) throws Exception {     LOG.error("Closing communication channel because of an exception", event.getCause()).     closeOnFlush(event.getChannel()). }
false;public;2;8;;@Override public void messageReceived(ChannelHandlerContext context, MessageEvent event) throws Exception {     if (blocked.get()) {         return.     }     ChannelBuffer msg = (ChannelBuffer) event.getMessage().     sourceChannel.write(msg). }
false;public;2;4;;@Override public void channelClosed(ChannelHandlerContext context, ChannelStateEvent event) throws Exception {     closeOnFlush(sourceChannel). }
false;public;2;5;;@Override public void exceptionCaught(ChannelHandlerContext context, ExceptionEvent event) throws Exception {     LOG.error("Closing communication channel because of an exception", event.getCause()).     closeOnFlush(event.getChannel()). }
