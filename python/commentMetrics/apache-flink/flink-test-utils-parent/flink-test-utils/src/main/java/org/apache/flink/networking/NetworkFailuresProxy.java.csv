commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;public ChannelPipeline getPipeline() throws Exception {     ChannelPipeline pipeline = Channels.pipeline().     // synchronized for a race between blocking and creating new handlers     synchronized (networkFailureHandlers) {         NetworkFailureHandler failureHandler = new NetworkFailureHandler(blocked, networkFailureHandler -> networkFailureHandlers.remove(networkFailureHandler), channelFactory, remoteHost, remotePort).         networkFailureHandlers.add(failureHandler).         pipeline.addLast(NETWORK_FAILURE_HANDLER_NAME, failureHandler).     }     return pipeline. }
true;public;0;3;/**  * @return local port on which {@link NetworkFailuresProxy} is listening.  */ ;/**  * @return local port on which {@link NetworkFailuresProxy} is listening.  */ public int getLocalPort() {     return ((InetSocketAddress) channel.getLocalAddress()).getPort(). }
true;public;0;3;/**  * Blocks all ongoing traffic, closes all ongoing and closes any new incoming connections.  */ ;/**  * Blocks all ongoing traffic, closes all ongoing and closes any new incoming connections.  */ public void blockTraffic() {     setTrafficBlocked(true). }
true;public;0;3;/**  * Resumes normal communication.  */ ;/**  * Resumes normal communication.  */ public void unblockTraffic() {     setTrafficBlocked(false). }
false;public;0;4;;@Override public void close() throws Exception {     channel.close(). }
false;private;1;11;;private void setTrafficBlocked(boolean blocked) {     this.blocked.set(blocked).     if (blocked) {         // synchronized for a race between blocking and creating new handlers         synchronized (networkFailureHandlers) {             for (NetworkFailureHandler failureHandler : networkFailureHandlers) {                 failureHandler.closeConnections().             }         }     } }
