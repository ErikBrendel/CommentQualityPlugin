commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setNumberOfTestRepetitions(int numberOfTestRepetitions) {     this.numberOfTestRepetitions = numberOfTestRepetitions. }
false;public;0;3;;public int getParallelism() {     return isCollectionExecution ? 1 : miniClusterResource.getNumberSlots(). }
false;public;0;3;;public JobExecutionResult getLatestExecutionResult() {     return this.latestExecutionResult. }
false;public;0;3;;public boolean isCollectionExecution() {     return isCollectionExecution. }
false;protected,abstract;0;1;;// -------------------------------------------------------------------------------------------- // Methods to create the test program and for pre- and post- test work // -------------------------------------------------------------------------------------------- protected abstract void testProgram() throws Exception.
false;protected;0;1;;protected void preSubmit() throws Exception { }
false;protected;0;1;;protected void postSubmit() throws Exception { }
false;protected;0;3;;protected boolean skipCollectionExecution() {     return false. }
false;public;0;47;;// -------------------------------------------------------------------------------------------- // Test entry point // -------------------------------------------------------------------------------------------- @Test public void testJobWithObjectReuse() throws Exception {     isCollectionExecution = false.     // pre-submit     try {         preSubmit().     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         Assert.fail("Pre-submit work caused an error: " + e.getMessage()).     }     // This only works because the underlying ExecutionEnvironment is a TestEnvironment     // We should fix that we are able to get access to the latest execution result from a different     // execution environment and how the object reuse mode is enabled     TestEnvironment env = miniClusterResource.getTestEnvironment().     env.getConfig().enableObjectReuse().     // Possibly run the test multiple times     for (int i = 0. i < numberOfTestRepetitions. i++) {         // call the test program         try {             testProgram().             this.latestExecutionResult = env.getLastJobExecutionResult().         } catch (Exception e) {             System.err.println(e.getMessage()).             e.printStackTrace().             Assert.fail("Error while calling the test program: " + e.getMessage()).         }         Assert.assertNotNull("The test program never triggered an execution.", this.latestExecutionResult).     }     // post-submit     try {         postSubmit().     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         Assert.fail("Post-submit work caused an error: " + e.getMessage()).     } }
false;public;0;47;;@Test public void testJobWithoutObjectReuse() throws Exception {     isCollectionExecution = false.     // pre-submit     try {         preSubmit().     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         Assert.fail("Pre-submit work caused an error: " + e.getMessage()).     }     // This only works because the underlying ExecutionEnvironment is a TestEnvironment     // We should fix that we are able to get access to the latest execution result from a different     // execution environment and how the object reuse mode is enabled     ExecutionEnvironment env = miniClusterResource.getTestEnvironment().     env.getConfig().disableObjectReuse().     // Possibly run the test multiple times     for (int i = 0. i < numberOfTestRepetitions. i++) {         // call the test program         try {             testProgram().             this.latestExecutionResult = env.getLastJobExecutionResult().         } catch (Exception e) {             System.err.println(e.getMessage()).             e.printStackTrace().             Assert.fail("Error while calling the test program: " + e.getMessage()).         }         Assert.assertNotNull("The test program never triggered an execution.", this.latestExecutionResult).     }     // post-submit     try {         postSubmit().     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         Assert.fail("Post-submit work caused an error: " + e.getMessage()).     } }
false;public;0;49;;@Test public void testJobCollectionExecution() throws Exception {     // check if collection execution should be skipped.     if (this.skipCollectionExecution()) {         return.     }     isCollectionExecution = true.     // pre-submit     try {         preSubmit().     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         Assert.fail("Pre-submit work caused an error: " + e.getMessage()).     }     // prepare the test environment     CollectionTestEnvironment env = new CollectionTestEnvironment().     env.setAsContext().     // call the test program     try {         testProgram().         this.latestExecutionResult = env.getLastJobExecutionResult().     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         Assert.fail("Error while calling the test program: " + e.getMessage()).     } finally {         miniClusterResource.getTestEnvironment().setAsContext().     }     Assert.assertNotNull("The test program never triggered an execution.", this.latestExecutionResult).     // post-submit     try {         postSubmit().     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         Assert.fail("Post-submit work caused an error: " + e.getMessage()).     } }
