commented;modifiers;parameterAmount;loc;comment;code
false;public;0;14;;@Test public void releaseToZeroRefCounterShouldDeleteTheFile() throws IOException {     final File newFile = new File(temporaryFolder.getRoot(), ".tmp_" + UUID.randomUUID()).     final OutputStream out = Files.newOutputStream(newFile.toPath(), StandardOpenOption.CREATE_NEW).     RefCountedFile fileUnderTest = RefCountedFile.newFile(newFile, out).     verifyTheFileIsStillThere().     fileUnderTest.release().     try (Stream<Path> files = Files.list(temporaryFolder.getRoot().toPath())) {         Assert.assertEquals(0L, files.count()).     } }
false;public;0;28;;@Test public void retainsShouldRequirePlusOneReleasesToDeleteTheFile() throws IOException {     final File newFile = new File(temporaryFolder.getRoot(), ".tmp_" + UUID.randomUUID()).     final OutputStream out = Files.newOutputStream(newFile.toPath(), StandardOpenOption.CREATE_NEW).     // the reference counter always starts with 1 (not 0). This is why we need +1 releases     RefCountedFile fileUnderTest = RefCountedFile.newFile(newFile, out).     verifyTheFileIsStillThere().     fileUnderTest.retain().     fileUnderTest.retain().     Assert.assertEquals(3, fileUnderTest.getReferenceCounter()).     fileUnderTest.release().     Assert.assertEquals(2, fileUnderTest.getReferenceCounter()).     verifyTheFileIsStillThere().     fileUnderTest.release().     Assert.assertEquals(1, fileUnderTest.getReferenceCounter()).     verifyTheFileIsStillThere().     fileUnderTest.release().     // the file is deleted now     try (Stream<Path> files = Files.list(temporaryFolder.getRoot().toPath())) {         Assert.assertEquals(0L, files.count()).     } }
false;public;0;9;;@Test public void writeShouldSucceed() throws IOException {     byte[] content = bytesOf("hello world").     final RefCountedFile fileUnderTest = getClosedRefCountedFileWithContent(content).     long fileLength = fileUnderTest.getLength().     Assert.assertEquals(content.length, fileLength). }
false;public;0;5;;@Test public void closeShouldNotReleaseReference() throws IOException {     getClosedRefCountedFileWithContent("hello world").     verifyTheFileIsStillThere(). }
false;public;0;6;;@Test(expected = IOException.class) public void writeAfterCloseShouldThrowException() throws IOException {     final RefCountedFile fileUnderTest = getClosedRefCountedFileWithContent("hello world").     byte[] content = bytesOf("Hello Again").     fileUnderTest.write(content, 0, content.length). }
false;public;0;5;;@Test(expected = IOException.class) public void flushAfterCloseShouldThrowException() throws IOException {     final RefCountedFile fileUnderTest = getClosedRefCountedFileWithContent("hello world").     fileUnderTest.flush(). }
false;private;0;5;;// ------------------------------------- Utilities ------------------------------------- private void verifyTheFileIsStillThere() throws IOException {     try (Stream<Path> files = Files.list(temporaryFolder.getRoot().toPath())) {         Assert.assertEquals(1L, files.count()).     } }
false;private;1;3;;private RefCountedFile getClosedRefCountedFileWithContent(String content) throws IOException {     return getClosedRefCountedFileWithContent(bytesOf(content)). }
false;private;1;11;;private RefCountedFile getClosedRefCountedFileWithContent(byte[] content) throws IOException {     final File newFile = new File(temporaryFolder.getRoot(), ".tmp_" + UUID.randomUUID()).     final OutputStream out = Files.newOutputStream(newFile.toPath(), StandardOpenOption.CREATE_NEW).     final RefCountedFile fileUnderTest = RefCountedFile.newFile(newFile, out).     fileUnderTest.write(content, 0, content.length).     fileUnderTest.closeStream().     return fileUnderTest. }
false;private,static;1;3;;private static byte[] bytesOf(String str) {     return str.getBytes(StandardCharsets.UTF_8). }
