commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;@Before public void beforeTest() throws IOException {     fileProvider = new TestFileProvider(TEMP_FOLDER).     multipartUploadUnderTest = new TestMultipartUpload(fileProvider).     RefCountedBufferingFileStream fileStream = RefCountedBufferingFileStream.openNew(fileProvider).     streamUnderTest = new S3RecoverableFsDataOutputStream(multipartUploadUnderTest, fileProvider, fileStream, USER_DEFINED_MIN_PART_SIZE, 0L). }
false;public;0;9;;@Test public void simpleUsage() throws IOException {     streamUnderTest.write(bytesOf("hello world")).     RecoverableFsDataOutputStream.Committer committer = streamUnderTest.closeForCommit().     committer.commit().     assertThat(multipartUploadUnderTest, hasContent(bytesOf("hello world"))). }
false;public;0;7;;@Test public void noWritesShouldResolveInAnEmptyFile() throws IOException {     RecoverableFsDataOutputStream.Committer committer = streamUnderTest.closeForCommit().     committer.commit().     assertThat(multipartUploadUnderTest, hasContent(new byte[0])). }
false;public;0;8;;@Test public void closingWithoutCommittingDiscardsTheData() throws IOException {     streamUnderTest.write(bytesOf("hello world")).     streamUnderTest.close().     assertThat(multipartUploadUnderTest, hasContent(bytesOf(""))). }
false;public;0;10;;@Test public void twoWritesAreConcatenated() throws IOException {     streamUnderTest.write(bytesOf("hello")).     streamUnderTest.write(bytesOf(" ")).     streamUnderTest.write(bytesOf("world")).     streamUnderTest.closeForCommit().commit().     assertThat(multipartUploadUnderTest, hasContent(bytesOf("hello world"))). }
false;public;0;11;;@Test public void writeLargeFile() throws IOException {     List<byte[]> testDataBuffers = createRandomLargeTestDataBuffers().     for (byte[] buffer : testDataBuffers) {         streamUnderTest.write(buffer).     }     streamUnderTest.closeForCommit().commit().     assertThat(multipartUploadUnderTest, hasContent(testDataBuffers)). }
false;public;0;11;;@Test public void simpleRecovery() throws IOException {     streamUnderTest.write(bytesOf("hello")).     streamUnderTest.persist().     streamUnderTest = reopenStreamUnderTestAfterRecovery().     streamUnderTest.closeForCommit().commit().     assertThat(multipartUploadUnderTest, hasContent(bytesOf("hello"))). }
false;public;0;16;;@Test public void multiplePersistsDoesNotIntroduceJunk() throws IOException {     streamUnderTest.write(bytesOf("hello")).     streamUnderTest.persist().     streamUnderTest.persist().     streamUnderTest.persist().     streamUnderTest.persist().     streamUnderTest.write(bytesOf(" ")).     streamUnderTest.write(bytesOf("world")).     streamUnderTest.closeForCommit().commit().     assertThat(multipartUploadUnderTest, hasContent(bytesOf("hello world"))). }
false;public;0;20;;@Test public void multipleWritesAndPersists() throws IOException {     streamUnderTest.write(bytesOf("a")).     streamUnderTest.persist().     streamUnderTest.write(bytesOf("b")).     streamUnderTest.persist().     streamUnderTest.write(bytesOf("c")).     streamUnderTest.persist().     streamUnderTest.write(bytesOf("d")).     streamUnderTest.persist().     streamUnderTest.write(bytesOf("e")).     streamUnderTest.closeForCommit().commit().     assertThat(multipartUploadUnderTest, hasContent(bytesOf("abcde"))). }
false;public;0;12;;@Test public void multipleWritesAndPersistsWithBigChunks() throws IOException {     List<byte[]> testDataBuffers = createRandomLargeTestDataBuffers().     for (byte[] buffer : testDataBuffers) {         streamUnderTest.write(buffer).         streamUnderTest.persist().     }     streamUnderTest.closeForCommit().commit().     assertThat(multipartUploadUnderTest, hasContent(testDataBuffers)). }
false;public;0;13;;@Test public void addDataAfterRecovery() throws IOException {     streamUnderTest.write(bytesOf("hello")).     streamUnderTest.persist().     streamUnderTest = reopenStreamUnderTestAfterRecovery().     streamUnderTest.write(bytesOf(" ")).     streamUnderTest.write(bytesOf("world")).     streamUnderTest.closeForCommit().commit().     assertThat(multipartUploadUnderTest, hasContent(bytesOf("hello world"))). }
false;public;0;14;;@Test public void discardingUnpersistedNotYetUploadedData() throws IOException {     streamUnderTest.write(bytesOf("hello")).     streamUnderTest.persist().     streamUnderTest.write(bytesOf("goodbye")).     streamUnderTest = reopenStreamUnderTestAfterRecovery().     streamUnderTest.write(bytesOf(" world")).     streamUnderTest.closeForCommit().commit().     assertThat(multipartUploadUnderTest, hasContent(bytesOf("hello world"))). }
false;public;0;13;;@Test public void discardingUnpersistedUploadedData() throws IOException {     streamUnderTest.write(bytesOf("hello")).     streamUnderTest.persist().     streamUnderTest.write(randomBuffer(RefCountedBufferingFileStream.BUFFER_SIZE + 1)).     streamUnderTest = reopenStreamUnderTestAfterRecovery().     streamUnderTest.write(bytesOf(" world")).     streamUnderTest.closeForCommit().commit().     assertThat(multipartUploadUnderTest, hasContent(bytesOf("hello world"))). }
false;public;0;4;;@Test public void commitEmptyStreamShouldBeSuccessful() throws IOException {     streamUnderTest.closeForCommit().commit(). }
false;public;0;5;;@Test(expected = IOException.class) public void closeForCommitOnClosedStreamShouldFail() throws IOException {     streamUnderTest.closeForCommit().commit().     streamUnderTest.closeForCommit().commit(). }
false;private;0;15;;// ------------------------------------------------------------------------------------------------------------ // Utils // ------------------------------------------------------------------------------------------------------------ private S3RecoverableFsDataOutputStream reopenStreamUnderTestAfterRecovery() throws IOException {     final long bytesBeforeCurrentPart = multipartUploadUnderTest.numBytes.     final Optional<File> incompletePart = multipartUploadUnderTest.getIncompletePart().     RefCountedBufferingFileStream fileStream = RefCountedBufferingFileStream.restore(fileProvider, incompletePart.get()).     multipartUploadUnderTest.discardUnpersistedData().     return new S3RecoverableFsDataOutputStream(multipartUploadUnderTest, fileProvider, fileStream, USER_DEFINED_MIN_PART_SIZE, bytesBeforeCurrentPart). }
false;private,static;0;16;;private static List<byte[]> createRandomLargeTestDataBuffers() {     final List<byte[]> testData = new ArrayList<>().     final SplittableRandom random = new SplittableRandom().     long totalSize = 0L.     int expectedSize = (int) random.nextLong(USER_DEFINED_MIN_PART_SIZE * 5L, USER_DEFINED_MIN_PART_SIZE * 100L).     while (totalSize < expectedSize) {         int len = random.nextInt(0, (int) (2L * USER_DEFINED_MIN_PART_SIZE)).         byte[] buffer = randomBuffer(random, len).         totalSize += buffer.length.         testData.add(buffer).     }     return testData. }
false;private,static;1;4;;private static byte[] randomBuffer(int len) {     final SplittableRandom random = new SplittableRandom().     return randomBuffer(random, len). }
false;private,static;2;7;;private static byte[] randomBuffer(SplittableRandom random, int len) {     byte[] buffer = new byte[len].     for (int i = 0. i < buffer.length. i++) {         buffer[i] = (byte) (random.nextInt() & 0xFF).     }     return buffer. }
false;private,static;1;3;;private static byte[] bytesOf(String str) {     return str.getBytes(StandardCharsets.UTF_8). }
false;private,static;1;7;;private static byte[] readFileContents(RefCountedFSOutputStream file) throws IOException {     final byte[] content = new byte[MathUtils.checkedDownCast(file.getPos())].     File inputFile = file.getInputFile().     long bytesRead = new FileInputStream(inputFile).read(content, 0, MathUtils.checkedDownCast(inputFile.length())).     Assert.assertEquals(file.getPos(), bytesRead).     return content. }
false;protected;1;7;;@Override protected boolean matchesSafely(TestMultipartUpload testMultipartUpload) {     return Arrays.equals(testMultipartUpload.getPublishedContents(), expectedContent). }
false;public;1;6;;@Override public void describeTo(Description description) {     description.appendText("a TestMultipartUpload with contents='").appendValue(expectedContent).appendText("'"). }
false;private,static;1;18;;// ------------------------------------------------------------------------------------------------------------ // Matchers // ------------------------------------------------------------------------------------------------------------ private static TypeSafeMatcher<TestMultipartUpload> hasContent(final byte[] expectedContent) {     return new TypeSafeMatcher<TestMultipartUpload>() {          @Override         protected boolean matchesSafely(TestMultipartUpload testMultipartUpload) {             return Arrays.equals(testMultipartUpload.getPublishedContents(), expectedContent).         }          @Override         public void describeTo(Description description) {             description.appendText("a TestMultipartUpload with contents='").appendValue(expectedContent).appendText("'").         }     }. }
false;protected;1;7;;@Override protected boolean matchesSafely(TestMultipartUpload testMultipartUpload) {     return Arrays.equals(testMultipartUpload.getPublishedContents(), expectedContent). }
false;public;1;6;;@Override public void describeTo(Description description) {     description.appendText("a TestMultipartUpload with contents='").appendValue(expectedContent).appendText("'"). }
false;private,static;1;26;;private static TypeSafeMatcher<TestMultipartUpload> hasContent(final Collection<byte[]> expectedContents) throws IOException {     ByteArrayOutputStream stream = new ByteArrayOutputStream().     for (byte[] c : expectedContents) {         stream.write(c).     }     byte[] expectedContent = stream.toByteArray().     return new TypeSafeMatcher<TestMultipartUpload>() {          @Override         protected boolean matchesSafely(TestMultipartUpload testMultipartUpload) {             return Arrays.equals(testMultipartUpload.getPublishedContents(), expectedContent).         }          @Override         public void describeTo(Description description) {             description.appendText("a TestMultipartUpload with contents='").appendValue(expectedContent).appendText("'").         }     }. }
false;public;0;3;;public void discardUnpersistedData() {     uploadedContent = uploadedContent.subList(0, lastPersistedIndex). }
false;public;0;14;;@Override public Optional<File> getIncompletePart() {     if (!uncompleted.isPresent()) {         return Optional.empty().     }     byte[] uncompletedBytes = uncompleted.get().     try {         File uncompletedTempFile = fileProvider.apply(null).getFile().         Files.write(uncompletedTempFile.toPath(), uncompletedBytes).         return Optional.of(uncompletedTempFile).     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;public;0;6;;@Override public void commit() throws IOException {     published = getPublishedContents().     uploadedContent.clear().     lastPersistedIndex = 0. }
false;public;0;6;;@Override public void commitAfterRecovery() throws IOException {     if (published.length == 0) {         commit().     } }
false;public;0;4;;@Override public RecoverableWriter.CommitRecoverable getRecoverable() {     return null. }
false;public;0;25;;@Override public RecoverableFsDataOutputStream.Committer snapshotAndGetCommitter() throws IOException {     lastPersistedIndex = uploadedContent.size().     return new RecoverableFsDataOutputStream.Committer() {          @Override         public void commit() throws IOException {             published = getPublishedContents().             uploadedContent.clear().             lastPersistedIndex = 0.         }          @Override         public void commitAfterRecovery() throws IOException {             if (published.length == 0) {                 commit().             }         }          @Override         public RecoverableWriter.CommitRecoverable getRecoverable() {             return null.         }     }. }
false;public;1;11;;@Override public RecoverableWriter.ResumeRecoverable snapshotAndGetRecoverable(RefCountedFSOutputStream incompletePartFile) throws IOException {     lastPersistedIndex = uploadedContent.size().     if (incompletePartFile.getPos() >= 0L) {         byte[] bytes = readFileContents(incompletePartFile).         uncompleted = Optional.of(bytes).     }     return null. }
false;public;1;7;;@Override public void uploadPart(RefCountedFSOutputStream file) throws IOException {     numParts++.     numBytes += file.getPos().     uploadedContent.add(readFileContents(file)). }
false;public;0;10;;public byte[] getPublishedContents() {     for (int i = 0. i < lastPersistedIndex. i++) {         try {             publishedContents.write(uploadedContent.get(i)).         } catch (IOException e) {             throw new RuntimeException(e).         }     }     return publishedContents.toByteArray(). }
false;public;0;7;;@Override public String toString() {     return "TestMultipartUpload{" + "contents=" + Arrays.toString(published) + '}'. }
false;public;1;17;;@Override public RefCountedFile apply(@Nullable File file) throws IOException {     while (true) {         try {             if (file == null) {                 final File newFile = new File(folder.getRoot(), ".tmp_" + UUID.randomUUID()).                 final OutputStream out = Files.newOutputStream(newFile.toPath(), StandardOpenOption.CREATE_NEW).                 return RefCountedFile.newFile(newFile, out).             } else {                 final OutputStream out = Files.newOutputStream(file.toPath(), StandardOpenOption.APPEND).                 return RefCountedFile.restoredFile(file, out, file.length()).             }         } catch (FileAlreadyExistsException e) {         // fall through the loop and retry         }     } }
