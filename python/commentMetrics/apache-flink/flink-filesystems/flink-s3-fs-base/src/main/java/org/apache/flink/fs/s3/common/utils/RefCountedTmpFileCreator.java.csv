commented;modifiers;parameterAmount;loc;comment;code
true;public;1;19;/**  * Gets the next temp file and stream to temp file.  * This creates the temp file atomically, making sure no previous file is overwritten.  *  * <p>This method is safe against concurrent use.  *  * @return A pair of temp file and output stream to that temp file.  * @throws IOException Thrown, if the stream to the temp file could not be opened.  */ ;/**  * Gets the next temp file and stream to temp file.  * This creates the temp file atomically, making sure no previous file is overwritten.  *  * <p>This method is safe against concurrent use.  *  * @return A pair of temp file and output stream to that temp file.  * @throws IOException Thrown, if the stream to the temp file could not be opened.  */ @Override public RefCountedFile apply(File file) throws IOException {     final File directory = tempDirectories[nextIndex()].     while (true) {         try {             if (file == null) {                 final File newFile = new File(directory, ".tmp_" + UUID.randomUUID()).                 final OutputStream out = Files.newOutputStream(newFile.toPath(), StandardOpenOption.CREATE_NEW).                 return RefCountedFile.newFile(newFile, out).             } else {                 final OutputStream out = Files.newOutputStream(file.toPath(), StandardOpenOption.APPEND).                 return RefCountedFile.restoredFile(file, out, file.length()).             }         } catch (FileAlreadyExistsException ignored) {         // fall through the loop and retry         }     } }
false;private;0;13;;private int nextIndex() {     int currIndex, newIndex.     do {         currIndex = next.get().         newIndex = currIndex + 1.         if (newIndex == tempDirectories.length) {             newIndex = 0.         }     } while (!next.compareAndSet(currIndex, newIndex)).     return currIndex. }
false;public,static;1;3;;public static RefCountedTmpFileCreator inDirectories(File... tmpDirectories) {     return new RefCountedTmpFileCreator(tmpDirectories). }
