commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public File getFile() {     return file. }
false;public;0;3;;public OffsetAwareOutputStream getStream() {     return stream. }
false;public;0;3;;public long getLength() {     return stream.getLength(). }
false;public;3;6;;public void write(byte[] b, int off, int len) throws IOException {     requireOpened().     if (len > 0) {         stream.write(b, off, len).     } }
false;public;0;4;;public void flush() throws IOException {     requireOpened().     stream.flush(). }
false;public;0;6;;public void closeStream() {     if (!closed) {         IOUtils.closeQuietly(stream).         closed = true.     } }
false;public;0;4;;@Override public void retain() {     references.incrementAndGet(). }
false;public;0;7;;@Override public boolean release() {     if (references.decrementAndGet() == 0) {         return tryClose().     }     return false. }
false;private;0;9;;private boolean tryClose() {     try {         Files.deleteIfExists(file.toPath()).         return true.     } catch (Throwable t) {         ExceptionUtils.rethrowIfFatalError(t).     }     return false. }
false;private;0;5;;private void requireOpened() throws IOException {     if (closed) {         throw new IOException("Stream closed.").     } }
false;;0;4;;@VisibleForTesting int getReferenceCounter() {     return references.get(). }
false;public,static;2;5;;// ------------------------------ Factory methods for initializing a temporary file ------------------------------ public static RefCountedFile newFile(final File file, final OutputStream currentOut) throws IOException {     return new RefCountedFile(file, currentOut, 0L). }
false;public,static;3;6;;public static RefCountedFile restoredFile(final File file, final OutputStream currentOut, final long bytesInCurrentPart) {     return new RefCountedFile(file, currentOut, bytesInCurrentPart). }
