commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public File getInputFile() {     return currentTmpFile.getFile(). }
false;public;0;4;;@Override public long getPos() {     return currentTmpFile.getLength() + positionInBuffer. }
false;public;1;10;;@Override public void write(int b) throws IOException {     if (positionInBuffer >= buffer.length) {         flush().     }     requireOpen().     buffer[positionInBuffer++] = (byte) b. }
false;public;3;18;;@Override public void write(byte[] b, int off, int len) throws IOException {     if (len >= buffer.length) {         // circumvent the internal buffer for large writes         flush().         currentTmpFile.write(b, off, len).         return.     }     requireOpen().     if (len > buffer.length - positionInBuffer) {         flush().     }     System.arraycopy(b, off, buffer, positionInBuffer, len).     positionInBuffer += len. }
false;public;0;6;;@Override public void flush() throws IOException {     currentTmpFile.write(buffer, 0, positionInBuffer).     currentTmpFile.flush().     positionInBuffer = 0. }
false;public;0;5;;@Override public void sync() throws IOException {     throw new UnsupportedOperationException("S3RecoverableFsDataOutputStream cannot sync state to S3. " + "Use persist() to create a persistent recoverable intermediate point."). }
false;public;0;4;;@Override public boolean isClosed() throws IOException {     return closed. }
false;public;0;7;;@Override public void close() {     if (!closed) {         currentTmpFile.closeStream().         closed = true.     } }
false;public;0;4;;@Override public void retain() {     currentTmpFile.retain(). }
false;public;0;4;;@Override public boolean release() {     return currentTmpFile.release(). }
false;private;0;5;;private void requireOpen() throws IOException {     if (closed) {         throw new IOException("Stream closed.").     } }
false;public;0;9;;@Override public String toString() {     return "Reference Counted File with {" + "path=\'" + currentTmpFile.getFile().toPath().toAbsolutePath() + "\'" + ", size=" + getPos() + ", reference counter=" + currentTmpFile.getReferenceCounter() + ", closed=" + closed + '}'. }
false;;0;4;;@VisibleForTesting int getPositionInBuffer() {     return positionInBuffer. }
false;public;0;4;;@VisibleForTesting public int getReferenceCounter() {     return currentTmpFile.getReferenceCounter(). }
false;public,static;1;7;;// ------------------------- Factory Methods ------------------------- public static RefCountedBufferingFileStream openNew(final FunctionWithException<File, RefCountedFile, IOException> tmpFileProvider) throws IOException {     return new RefCountedBufferingFileStream(tmpFileProvider.apply(null), BUFFER_SIZE). }
false;public,static;2;8;;public static RefCountedBufferingFileStream restore(final FunctionWithException<File, RefCountedFile, IOException> tmpFileProvider, final File initialTmpFile) throws IOException {     return new RefCountedBufferingFileStream(tmpFileProvider.apply(initialTmpFile), BUFFER_SIZE). }
