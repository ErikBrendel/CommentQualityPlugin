commented;modifiers;parameterAmount;loc;comment;code
true;public;1;15;/**  * Adds a part to the uploads without any size limitations.  *  * <p>This method is non-blocking and does not wait for the part upload to complete.  *  * @param file The file with the part data.  *  * @throws IOException If this method throws an exception, the RecoverableS3MultiPartUpload  *                     should not be used any more, but recovered instead.  */ ;/**  * Adds a part to the uploads without any size limitations.  *  * <p>This method is non-blocking and does not wait for the part upload to complete.  *  * @param file The file with the part data.  *  * @throws IOException If this method throws an exception, the RecoverableS3MultiPartUpload  *                     should not be used any more, but recovered instead.  */ @Override public void uploadPart(RefCountedFSOutputStream file) throws IOException {     // this is to guarantee that nobody is     // writing to the file we are uploading.     checkState(file.isClosed()).     final CompletableFuture<PartETag> future = new CompletableFuture<>().     uploadsInProgress.add(future).     final long partLength = file.getPos().     currentUploadInfo.registerNewPart(partLength).     // keep the file while the async upload still runs     file.retain().     uploadThreadPool.execute(new UploadTask(s3AccessHelper, currentUploadInfo, file, future)). }
false;public;0;4;;@Override public Optional<File> getIncompletePart() {     return currentUploadInfo.getIncompletePart(). }
false;public;0;11;;@Override public S3Committer snapshotAndGetCommitter() throws IOException {     final S3Recoverable snapshot = snapshotAndGetRecoverable(null).     return new S3Committer(s3AccessHelper, snapshot.getObjectName(), snapshot.uploadId(), snapshot.parts(), snapshot.numBytesInParts()). }
true;public;1;21;/**  * Creates a snapshot of this MultiPartUpload, from which the upload can be resumed.  *  * <p>Data buffered locally which is less than  * {@link org.apache.flink.fs.s3.common.FlinkS3FileSystem#S3_MULTIPART_MIN_PART_SIZE S3_MULTIPART_MIN_PART_SIZE},  * and cannot be uploaded as part of the MPU and set to S3 as independent objects.  *  * <p>This implementation currently blocks until all part uploads are complete and returns  * a completed future.  */ ;/**  * Creates a snapshot of this MultiPartUpload, from which the upload can be resumed.  *  * <p>Data buffered locally which is less than  * {@link org.apache.flink.fs.s3.common.FlinkS3FileSystem#S3_MULTIPART_MIN_PART_SIZE S3_MULTIPART_MIN_PART_SIZE},  * and cannot be uploaded as part of the MPU and set to S3 as independent objects.  *  * <p>This implementation currently blocks until all part uploads are complete and returns  * a completed future.  */ @Override public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException {     final String incompletePartObjectName = safelyUploadSmallPart(incompletePartFile).     // make sure all other uploads are complete     // this currently makes the method blocking,     // to be made non-blocking in the future     awaitPendingPartsUpload().     final String objectName = currentUploadInfo.getObjectName().     final String uploadId = currentUploadInfo.getUploadId().     final List<PartETag> completedParts = currentUploadInfo.getCopyOfEtagsOfCompleteParts().     final long sizeInBytes = currentUploadInfo.getExpectedSizeInBytes().     if (incompletePartObjectName == null) {         return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes).     } else {         return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes, incompletePartObjectName, incompletePartFile.getPos()).     } }
false;private;1;18;;@Nullable private String safelyUploadSmallPart(@Nullable RefCountedFSOutputStream file) throws IOException {     if (file == null || file.getPos() == 0L) {         return null.     }     // first, upload the trailing data file. during that time, other in-progress uploads may complete.     final String incompletePartObjectName = createIncompletePartObjectName().     file.retain().     try {         s3AccessHelper.putObject(incompletePartObjectName, file.getInputFile()).     } finally {         file.release().     }     return incompletePartObjectName. }
false;static;1;17;;// ------------------------------------------------------------------------ // utils // ------------------------------------------------------------------------ @VisibleForTesting static String createIncompletePartObjectNamePrefix(String objectName) {     checkNotNull(objectName).     final int lastSlash = objectName.lastIndexOf('/').     final String parent.     final String child.     if (lastSlash == -1) {         parent = "".         child = objectName.     } else {         parent = objectName.substring(0, lastSlash + 1).         child = objectName.substring(lastSlash + 1).     }     return parent + (child.isEmpty() ? "" : '_') + child + "_tmp_". }
false;private;0;3;;private String createIncompletePartObjectName() {     return namePrefixForTempObjects + UUID.randomUUID().toString(). }
false;private;0;10;;private void awaitPendingPartsUpload() throws IOException {     checkState(currentUploadInfo.getRemainingParts() == uploadsInProgress.size()).     while (currentUploadInfo.getRemainingParts() > 0) {         CompletableFuture<PartETag> next = uploadsInProgress.peekFirst().         PartETag nextPart = awaitPendingPartUploadToComplete(next).         currentUploadInfo.registerCompletePart(nextPart).         uploadsInProgress.removeFirst().     } }
false;private;1;14;;private PartETag awaitPendingPartUploadToComplete(CompletableFuture<PartETag> upload) throws IOException {     final PartETag completedUploadEtag.     try {         completedUploadEtag = upload.get().     } catch (InterruptedException e) {         Thread.currentThread().interrupt().         throw new IOException("Interrupted while waiting for part uploads to complete").     } catch (ExecutionException e) {         throw new IOException("Uploading parts failed", e.getCause()).     }     return completedUploadEtag. }
false;public,static;3;16;;// ------------------------------------------------------------------------ // factory methods // ------------------------------------------------------------------------ public static RecoverableMultiPartUploadImpl newUpload(final S3AccessHelper s3AccessHelper, final Executor uploadThreadPool, final String objectName) throws IOException {     final String multiPartUploadId = s3AccessHelper.startMultiPartUpload(objectName).     return new RecoverableMultiPartUploadImpl(s3AccessHelper, uploadThreadPool, multiPartUploadId, objectName, new ArrayList<>(), 0L, Optional.empty()). }
false;public,static;7;19;;public static RecoverableMultiPartUploadImpl recoverUpload(final S3AccessHelper s3AccessHelper, final Executor uploadThreadPool, final String multipartUploadId, final String objectName, final List<PartETag> partsSoFar, final long numBytesSoFar, final Optional<File> incompletePart) {     return new RecoverableMultiPartUploadImpl(s3AccessHelper, uploadThreadPool, multipartUploadId, objectName, new ArrayList<>(partsSoFar), numBytesSoFar, incompletePart). }
false;public;0;11;;@Override public void run() {     try {         final UploadPartResult result = s3AccessHelper.uploadPart(objectName, uploadId, partNumber, file.getInputFile(), file.getPos()).         future.complete(new PartETag(result.getPartNumber(), result.getETag())).         file.release().     } catch (Throwable t) {         future.completeExceptionally(t).     } }
