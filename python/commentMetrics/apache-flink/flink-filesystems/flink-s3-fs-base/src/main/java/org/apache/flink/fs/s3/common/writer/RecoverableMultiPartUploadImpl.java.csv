# id;timestamp;commentText;codeText;commentWords;codeWords
RecoverableMultiPartUploadImpl -> @Override 	public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException;1539271394;Creates a snapshot of this MultiPartUpload, from which the upload can be resumed.__<p>Data buffered locally which is less than_{@link org.apache.flink.fs.s3.common.FlinkS3FileSystem#S3_MULTIPART_MIN_PART_SIZE S3_MULTIPART_MIN_PART_SIZE},_and cannot be uploaded as part of the MPU and set to S3 as independent objects.__<p>This implementation currently blocks until all part uploads are complete and returns_a completed future.;@Override_	public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException {__		final String incompletePartObjectName = safelyUploadSmallPart(incompletePartFile)___		_		_		_		awaitPendingPartsUpload()___		final String objectName = currentUploadInfo.getObjectName()__		final String uploadId = currentUploadInfo.getUploadId()__		final List<PartETag> completedParts = currentUploadInfo.getCopyOfEtagsOfCompleteParts()__		final long sizeInBytes = currentUploadInfo.getExpectedSizeInBytes()___		if (incompletePartObjectName == null) {_			return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes)__		} else {_			return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes, incompletePartObjectName, incompletePartFile.getPos())__		}_	};creates,a,snapshot,of,this,multi,part,upload,from,which,the,upload,can,be,resumed,p,data,buffered,locally,which,is,less,than,link,org,apache,flink,fs,s3,common,flink,s3file,system,and,cannot,be,uploaded,as,part,of,the,mpu,and,set,to,s3,as,independent,objects,p,this,implementation,currently,blocks,until,all,part,uploads,are,complete,and,returns,a,completed,future;override,public,s3recoverable,snapshot,and,get,recoverable,nullable,final,ref,counted,fsoutput,stream,incomplete,part,file,throws,ioexception,final,string,incomplete,part,object,name,safely,upload,small,part,incomplete,part,file,await,pending,parts,upload,final,string,object,name,current,upload,info,get,object,name,final,string,upload,id,current,upload,info,get,upload,id,final,list,part,etag,completed,parts,current,upload,info,get,copy,of,etags,of,complete,parts,final,long,size,in,bytes,current,upload,info,get,expected,size,in,bytes,if,incomplete,part,object,name,null,return,new,s3recoverable,object,name,upload,id,completed,parts,size,in,bytes,else,return,new,s3recoverable,object,name,upload,id,completed,parts,size,in,bytes,incomplete,part,object,name,incomplete,part,file,get,pos
RecoverableMultiPartUploadImpl -> @Override 	public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException;1543940454;Creates a snapshot of this MultiPartUpload, from which the upload can be resumed.__<p>Data buffered locally which is less than_{@link org.apache.flink.fs.s3.common.FlinkS3FileSystem#S3_MULTIPART_MIN_PART_SIZE S3_MULTIPART_MIN_PART_SIZE},_and cannot be uploaded as part of the MPU and set to S3 as independent objects.__<p>This implementation currently blocks until all part uploads are complete and returns_a completed future.;@Override_	public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException {__		final String incompletePartObjectName = safelyUploadSmallPart(incompletePartFile)___		_		_		_		awaitPendingPartsUpload()___		final String objectName = currentUploadInfo.getObjectName()__		final String uploadId = currentUploadInfo.getUploadId()__		final List<PartETag> completedParts = currentUploadInfo.getCopyOfEtagsOfCompleteParts()__		final long sizeInBytes = currentUploadInfo.getExpectedSizeInBytes()___		if (incompletePartObjectName == null) {_			return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes)__		} else {_			return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes, incompletePartObjectName, incompletePartFile.getPos())__		}_	};creates,a,snapshot,of,this,multi,part,upload,from,which,the,upload,can,be,resumed,p,data,buffered,locally,which,is,less,than,link,org,apache,flink,fs,s3,common,flink,s3file,system,and,cannot,be,uploaded,as,part,of,the,mpu,and,set,to,s3,as,independent,objects,p,this,implementation,currently,blocks,until,all,part,uploads,are,complete,and,returns,a,completed,future;override,public,s3recoverable,snapshot,and,get,recoverable,nullable,final,ref,counted,fsoutput,stream,incomplete,part,file,throws,ioexception,final,string,incomplete,part,object,name,safely,upload,small,part,incomplete,part,file,await,pending,parts,upload,final,string,object,name,current,upload,info,get,object,name,final,string,upload,id,current,upload,info,get,upload,id,final,list,part,etag,completed,parts,current,upload,info,get,copy,of,etags,of,complete,parts,final,long,size,in,bytes,current,upload,info,get,expected,size,in,bytes,if,incomplete,part,object,name,null,return,new,s3recoverable,object,name,upload,id,completed,parts,size,in,bytes,else,return,new,s3recoverable,object,name,upload,id,completed,parts,size,in,bytes,incomplete,part,object,name,incomplete,part,file,get,pos
RecoverableMultiPartUploadImpl -> @Override 	public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException;1543940462;Creates a snapshot of this MultiPartUpload, from which the upload can be resumed.__<p>Data buffered locally which is less than_{@link org.apache.flink.fs.s3.common.FlinkS3FileSystem#S3_MULTIPART_MIN_PART_SIZE S3_MULTIPART_MIN_PART_SIZE},_and cannot be uploaded as part of the MPU and set to S3 as independent objects.__<p>This implementation currently blocks until all part uploads are complete and returns_a completed future.;@Override_	public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException {__		final String incompletePartObjectName = safelyUploadSmallPart(incompletePartFile)___		_		_		_		awaitPendingPartsUpload()___		final String objectName = currentUploadInfo.getObjectName()__		final String uploadId = currentUploadInfo.getUploadId()__		final List<PartETag> completedParts = currentUploadInfo.getCopyOfEtagsOfCompleteParts()__		final long sizeInBytes = currentUploadInfo.getExpectedSizeInBytes()___		if (incompletePartObjectName == null) {_			return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes)__		} else {_			return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes, incompletePartObjectName, incompletePartFile.getPos())__		}_	};creates,a,snapshot,of,this,multi,part,upload,from,which,the,upload,can,be,resumed,p,data,buffered,locally,which,is,less,than,link,org,apache,flink,fs,s3,common,flink,s3file,system,and,cannot,be,uploaded,as,part,of,the,mpu,and,set,to,s3,as,independent,objects,p,this,implementation,currently,blocks,until,all,part,uploads,are,complete,and,returns,a,completed,future;override,public,s3recoverable,snapshot,and,get,recoverable,nullable,final,ref,counted,fsoutput,stream,incomplete,part,file,throws,ioexception,final,string,incomplete,part,object,name,safely,upload,small,part,incomplete,part,file,await,pending,parts,upload,final,string,object,name,current,upload,info,get,object,name,final,string,upload,id,current,upload,info,get,upload,id,final,list,part,etag,completed,parts,current,upload,info,get,copy,of,etags,of,complete,parts,final,long,size,in,bytes,current,upload,info,get,expected,size,in,bytes,if,incomplete,part,object,name,null,return,new,s3recoverable,object,name,upload,id,completed,parts,size,in,bytes,else,return,new,s3recoverable,object,name,upload,id,completed,parts,size,in,bytes,incomplete,part,object,name,incomplete,part,file,get,pos
RecoverableMultiPartUploadImpl -> @Override 	public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException;1543940468;Creates a snapshot of this MultiPartUpload, from which the upload can be resumed.__<p>Data buffered locally which is less than_{@link org.apache.flink.fs.s3.common.FlinkS3FileSystem#S3_MULTIPART_MIN_PART_SIZE S3_MULTIPART_MIN_PART_SIZE},_and cannot be uploaded as part of the MPU and set to S3 as independent objects.__<p>This implementation currently blocks until all part uploads are complete and returns_a completed future.;@Override_	public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException {__		final String incompletePartObjectName = safelyUploadSmallPart(incompletePartFile)___		_		_		_		awaitPendingPartsUpload()___		final String objectName = currentUploadInfo.getObjectName()__		final String uploadId = currentUploadInfo.getUploadId()__		final List<PartETag> completedParts = currentUploadInfo.getCopyOfEtagsOfCompleteParts()__		final long sizeInBytes = currentUploadInfo.getExpectedSizeInBytes()___		if (incompletePartObjectName == null) {_			return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes)__		} else {_			return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes, incompletePartObjectName, incompletePartFile.getPos())__		}_	};creates,a,snapshot,of,this,multi,part,upload,from,which,the,upload,can,be,resumed,p,data,buffered,locally,which,is,less,than,link,org,apache,flink,fs,s3,common,flink,s3file,system,and,cannot,be,uploaded,as,part,of,the,mpu,and,set,to,s3,as,independent,objects,p,this,implementation,currently,blocks,until,all,part,uploads,are,complete,and,returns,a,completed,future;override,public,s3recoverable,snapshot,and,get,recoverable,nullable,final,ref,counted,fsoutput,stream,incomplete,part,file,throws,ioexception,final,string,incomplete,part,object,name,safely,upload,small,part,incomplete,part,file,await,pending,parts,upload,final,string,object,name,current,upload,info,get,object,name,final,string,upload,id,current,upload,info,get,upload,id,final,list,part,etag,completed,parts,current,upload,info,get,copy,of,etags,of,complete,parts,final,long,size,in,bytes,current,upload,info,get,expected,size,in,bytes,if,incomplete,part,object,name,null,return,new,s3recoverable,object,name,upload,id,completed,parts,size,in,bytes,else,return,new,s3recoverable,object,name,upload,id,completed,parts,size,in,bytes,incomplete,part,object,name,incomplete,part,file,get,pos
RecoverableMultiPartUploadImpl -> @Override 	public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException;1543940476;Creates a snapshot of this MultiPartUpload, from which the upload can be resumed.__<p>Data buffered locally which is less than_{@link org.apache.flink.fs.s3.common.FlinkS3FileSystem#S3_MULTIPART_MIN_PART_SIZE S3_MULTIPART_MIN_PART_SIZE},_and cannot be uploaded as part of the MPU and set to S3 as independent objects.__<p>This implementation currently blocks until all part uploads are complete and returns_a completed future.;@Override_	public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException {__		final String incompletePartObjectName = safelyUploadSmallPart(incompletePartFile)___		_		_		_		awaitPendingPartsUpload()___		final String objectName = currentUploadInfo.getObjectName()__		final String uploadId = currentUploadInfo.getUploadId()__		final List<PartETag> completedParts = currentUploadInfo.getCopyOfEtagsOfCompleteParts()__		final long sizeInBytes = currentUploadInfo.getExpectedSizeInBytes()___		if (incompletePartObjectName == null) {_			return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes)__		} else {_			return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes, incompletePartObjectName, incompletePartFile.getPos())__		}_	};creates,a,snapshot,of,this,multi,part,upload,from,which,the,upload,can,be,resumed,p,data,buffered,locally,which,is,less,than,link,org,apache,flink,fs,s3,common,flink,s3file,system,and,cannot,be,uploaded,as,part,of,the,mpu,and,set,to,s3,as,independent,objects,p,this,implementation,currently,blocks,until,all,part,uploads,are,complete,and,returns,a,completed,future;override,public,s3recoverable,snapshot,and,get,recoverable,nullable,final,ref,counted,fsoutput,stream,incomplete,part,file,throws,ioexception,final,string,incomplete,part,object,name,safely,upload,small,part,incomplete,part,file,await,pending,parts,upload,final,string,object,name,current,upload,info,get,object,name,final,string,upload,id,current,upload,info,get,upload,id,final,list,part,etag,completed,parts,current,upload,info,get,copy,of,etags,of,complete,parts,final,long,size,in,bytes,current,upload,info,get,expected,size,in,bytes,if,incomplete,part,object,name,null,return,new,s3recoverable,object,name,upload,id,completed,parts,size,in,bytes,else,return,new,s3recoverable,object,name,upload,id,completed,parts,size,in,bytes,incomplete,part,object,name,incomplete,part,file,get,pos
RecoverableMultiPartUploadImpl -> @Override 	public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException;1547635808;Creates a snapshot of this MultiPartUpload, from which the upload can be resumed.__<p>Data buffered locally which is less than_{@link org.apache.flink.fs.s3.common.FlinkS3FileSystem#S3_MULTIPART_MIN_PART_SIZE S3_MULTIPART_MIN_PART_SIZE},_and cannot be uploaded as part of the MPU and set to S3 as independent objects.__<p>This implementation currently blocks until all part uploads are complete and returns_a completed future.;@Override_	public S3Recoverable snapshotAndGetRecoverable(@Nullable final RefCountedFSOutputStream incompletePartFile) throws IOException {__		final String incompletePartObjectName = safelyUploadSmallPart(incompletePartFile)___		_		_		_		awaitPendingPartsUpload()___		final String objectName = currentUploadInfo.getObjectName()__		final String uploadId = currentUploadInfo.getUploadId()__		final List<PartETag> completedParts = currentUploadInfo.getCopyOfEtagsOfCompleteParts()__		final long sizeInBytes = currentUploadInfo.getExpectedSizeInBytes()___		if (incompletePartObjectName == null) {_			return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes)__		} else {_			return new S3Recoverable(objectName, uploadId, completedParts, sizeInBytes, incompletePartObjectName, incompletePartFile.getPos())__		}_	};creates,a,snapshot,of,this,multi,part,upload,from,which,the,upload,can,be,resumed,p,data,buffered,locally,which,is,less,than,link,org,apache,flink,fs,s3,common,flink,s3file,system,and,cannot,be,uploaded,as,part,of,the,mpu,and,set,to,s3,as,independent,objects,p,this,implementation,currently,blocks,until,all,part,uploads,are,complete,and,returns,a,completed,future;override,public,s3recoverable,snapshot,and,get,recoverable,nullable,final,ref,counted,fsoutput,stream,incomplete,part,file,throws,ioexception,final,string,incomplete,part,object,name,safely,upload,small,part,incomplete,part,file,await,pending,parts,upload,final,string,object,name,current,upload,info,get,object,name,final,string,upload,id,current,upload,info,get,upload,id,final,list,part,etag,completed,parts,current,upload,info,get,copy,of,etags,of,complete,parts,final,long,size,in,bytes,current,upload,info,get,expected,size,in,bytes,if,incomplete,part,object,name,null,return,new,s3recoverable,object,name,upload,id,completed,parts,size,in,bytes,else,return,new,s3recoverable,object,name,upload,id,completed,parts,size,in,bytes,incomplete,part,object,name,incomplete,part,file,get,pos
RecoverableMultiPartUploadImpl -> @Override 	public void uploadPart(RefCountedFSOutputStream file) throws IOException;1539271394;Adds a part to the uploads without any size limitations.__<p>This method is non-blocking and does not wait for the part upload to complete.__@param file The file with the part data.__@throws IOException If this method throws an exception, the RecoverableS3MultiPartUpload_should not be used any more, but recovered instead.;@Override_	public void uploadPart(RefCountedFSOutputStream file) throws IOException {_		_		_		checkState(file.isClosed())___		final CompletableFuture<PartETag> future = new CompletableFuture<>()__		uploadsInProgress.add(future)___		final long partLength = file.getPos()__		currentUploadInfo.registerNewPart(partLength)___		file.retain()_ _		uploadThreadPool.execute(new UploadTask(s3MPUploader, currentUploadInfo, file, future))__	};adds,a,part,to,the,uploads,without,any,size,limitations,p,this,method,is,non,blocking,and,does,not,wait,for,the,part,upload,to,complete,param,file,the,file,with,the,part,data,throws,ioexception,if,this,method,throws,an,exception,the,recoverable,s3multi,part,upload,should,not,be,used,any,more,but,recovered,instead;override,public,void,upload,part,ref,counted,fsoutput,stream,file,throws,ioexception,check,state,file,is,closed,final,completable,future,part,etag,future,new,completable,future,uploads,in,progress,add,future,final,long,part,length,file,get,pos,current,upload,info,register,new,part,part,length,file,retain,upload,thread,pool,execute,new,upload,task,s3mpuploader,current,upload,info,file,future
RecoverableMultiPartUploadImpl -> @Override 	public void uploadPart(RefCountedFSOutputStream file) throws IOException;1543940454;Adds a part to the uploads without any size limitations.__<p>This method is non-blocking and does not wait for the part upload to complete.__@param file The file with the part data.__@throws IOException If this method throws an exception, the RecoverableS3MultiPartUpload_should not be used any more, but recovered instead.;@Override_	public void uploadPart(RefCountedFSOutputStream file) throws IOException {_		_		_		checkState(file.isClosed())___		final CompletableFuture<PartETag> future = new CompletableFuture<>()__		uploadsInProgress.add(future)___		final long partLength = file.getPos()__		currentUploadInfo.registerNewPart(partLength)___		file.retain()_ _		uploadThreadPool.execute(new UploadTask(s3AccessHelper, currentUploadInfo, file, future))__	};adds,a,part,to,the,uploads,without,any,size,limitations,p,this,method,is,non,blocking,and,does,not,wait,for,the,part,upload,to,complete,param,file,the,file,with,the,part,data,throws,ioexception,if,this,method,throws,an,exception,the,recoverable,s3multi,part,upload,should,not,be,used,any,more,but,recovered,instead;override,public,void,upload,part,ref,counted,fsoutput,stream,file,throws,ioexception,check,state,file,is,closed,final,completable,future,part,etag,future,new,completable,future,uploads,in,progress,add,future,final,long,part,length,file,get,pos,current,upload,info,register,new,part,part,length,file,retain,upload,thread,pool,execute,new,upload,task,s3access,helper,current,upload,info,file,future
RecoverableMultiPartUploadImpl -> @Override 	public void uploadPart(RefCountedFSOutputStream file) throws IOException;1543940462;Adds a part to the uploads without any size limitations.__<p>This method is non-blocking and does not wait for the part upload to complete.__@param file The file with the part data.__@throws IOException If this method throws an exception, the RecoverableS3MultiPartUpload_should not be used any more, but recovered instead.;@Override_	public void uploadPart(RefCountedFSOutputStream file) throws IOException {_		_		_		checkState(file.isClosed())___		final CompletableFuture<PartETag> future = new CompletableFuture<>()__		uploadsInProgress.add(future)___		final long partLength = file.getPos()__		currentUploadInfo.registerNewPart(partLength)___		file.retain()_ _		uploadThreadPool.execute(new UploadTask(s3AccessHelper, currentUploadInfo, file, future))__	};adds,a,part,to,the,uploads,without,any,size,limitations,p,this,method,is,non,blocking,and,does,not,wait,for,the,part,upload,to,complete,param,file,the,file,with,the,part,data,throws,ioexception,if,this,method,throws,an,exception,the,recoverable,s3multi,part,upload,should,not,be,used,any,more,but,recovered,instead;override,public,void,upload,part,ref,counted,fsoutput,stream,file,throws,ioexception,check,state,file,is,closed,final,completable,future,part,etag,future,new,completable,future,uploads,in,progress,add,future,final,long,part,length,file,get,pos,current,upload,info,register,new,part,part,length,file,retain,upload,thread,pool,execute,new,upload,task,s3access,helper,current,upload,info,file,future
RecoverableMultiPartUploadImpl -> @Override 	public void uploadPart(RefCountedFSOutputStream file) throws IOException;1543940468;Adds a part to the uploads without any size limitations.__<p>This method is non-blocking and does not wait for the part upload to complete.__@param file The file with the part data.__@throws IOException If this method throws an exception, the RecoverableS3MultiPartUpload_should not be used any more, but recovered instead.;@Override_	public void uploadPart(RefCountedFSOutputStream file) throws IOException {_		_		_		checkState(file.isClosed())___		final CompletableFuture<PartETag> future = new CompletableFuture<>()__		uploadsInProgress.add(future)___		final long partLength = file.getPos()__		currentUploadInfo.registerNewPart(partLength)___		file.retain()_ _		uploadThreadPool.execute(new UploadTask(s3AccessHelper, currentUploadInfo, file, future))__	};adds,a,part,to,the,uploads,without,any,size,limitations,p,this,method,is,non,blocking,and,does,not,wait,for,the,part,upload,to,complete,param,file,the,file,with,the,part,data,throws,ioexception,if,this,method,throws,an,exception,the,recoverable,s3multi,part,upload,should,not,be,used,any,more,but,recovered,instead;override,public,void,upload,part,ref,counted,fsoutput,stream,file,throws,ioexception,check,state,file,is,closed,final,completable,future,part,etag,future,new,completable,future,uploads,in,progress,add,future,final,long,part,length,file,get,pos,current,upload,info,register,new,part,part,length,file,retain,upload,thread,pool,execute,new,upload,task,s3access,helper,current,upload,info,file,future
RecoverableMultiPartUploadImpl -> @Override 	public void uploadPart(RefCountedFSOutputStream file) throws IOException;1543940476;Adds a part to the uploads without any size limitations.__<p>This method is non-blocking and does not wait for the part upload to complete.__@param file The file with the part data.__@throws IOException If this method throws an exception, the RecoverableS3MultiPartUpload_should not be used any more, but recovered instead.;@Override_	public void uploadPart(RefCountedFSOutputStream file) throws IOException {_		_		_		checkState(file.isClosed())___		final CompletableFuture<PartETag> future = new CompletableFuture<>()__		uploadsInProgress.add(future)___		final long partLength = file.getPos()__		currentUploadInfo.registerNewPart(partLength)___		file.retain()_ _		uploadThreadPool.execute(new UploadTask(s3AccessHelper, currentUploadInfo, file, future))__	};adds,a,part,to,the,uploads,without,any,size,limitations,p,this,method,is,non,blocking,and,does,not,wait,for,the,part,upload,to,complete,param,file,the,file,with,the,part,data,throws,ioexception,if,this,method,throws,an,exception,the,recoverable,s3multi,part,upload,should,not,be,used,any,more,but,recovered,instead;override,public,void,upload,part,ref,counted,fsoutput,stream,file,throws,ioexception,check,state,file,is,closed,final,completable,future,part,etag,future,new,completable,future,uploads,in,progress,add,future,final,long,part,length,file,get,pos,current,upload,info,register,new,part,part,length,file,retain,upload,thread,pool,execute,new,upload,task,s3access,helper,current,upload,info,file,future
RecoverableMultiPartUploadImpl -> @Override 	public void uploadPart(RefCountedFSOutputStream file) throws IOException;1547635808;Adds a part to the uploads without any size limitations.__<p>This method is non-blocking and does not wait for the part upload to complete.__@param file The file with the part data.__@throws IOException If this method throws an exception, the RecoverableS3MultiPartUpload_should not be used any more, but recovered instead.;@Override_	public void uploadPart(RefCountedFSOutputStream file) throws IOException {_		_		_		checkState(file.isClosed())___		final CompletableFuture<PartETag> future = new CompletableFuture<>()__		uploadsInProgress.add(future)___		final long partLength = file.getPos()__		currentUploadInfo.registerNewPart(partLength)___		file.retain()_ _		uploadThreadPool.execute(new UploadTask(s3AccessHelper, currentUploadInfo, file, future))__	};adds,a,part,to,the,uploads,without,any,size,limitations,p,this,method,is,non,blocking,and,does,not,wait,for,the,part,upload,to,complete,param,file,the,file,with,the,part,data,throws,ioexception,if,this,method,throws,an,exception,the,recoverable,s3multi,part,upload,should,not,be,used,any,more,but,recovered,instead;override,public,void,upload,part,ref,counted,fsoutput,stream,file,throws,ioexception,check,state,file,is,closed,final,completable,future,part,etag,future,new,completable,future,uploads,in,progress,add,future,final,long,part,length,file,get,pos,current,upload,info,register,new,part,part,length,file,retain,upload,thread,pool,execute,new,upload,task,s3access,helper,current,upload,info,file,future
