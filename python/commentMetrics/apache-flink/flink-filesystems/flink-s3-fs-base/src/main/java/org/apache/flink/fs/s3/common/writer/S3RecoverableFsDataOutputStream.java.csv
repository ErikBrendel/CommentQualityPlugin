commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;// ------------------------------------------------------------------------ // stream methods // ------------------------------------------------------------------------ @Override public void write(int b) throws IOException {     fileStream.write(b). }
false;public;3;5;;@Override public void write(byte[] b, int off, int len) throws IOException {     fileStream.write(b, off, len).     openNewPartIfNecessary(userDefinedMinPartSize). }
false;public;0;5;;@Override public void flush() throws IOException {     fileStream.flush().     openNewPartIfNecessary(userDefinedMinPartSize). }
false;public;0;4;;@Override public long getPos() throws IOException {     return bytesBeforeCurrentPart + fileStream.getPos(). }
false;public;0;4;;@Override public void sync() throws IOException {     fileStream.sync(). }
false;public;0;11;;@Override public void close() throws IOException {     lock().     try {         fileStream.flush().     } finally {         IOUtils.closeQuietly(fileStream).         fileStream.release().         unlock().     } }
false;public;0;16;;// ------------------------------------------------------------------------ // recoverable stream methods // ------------------------------------------------------------------------ @Override public RecoverableWriter.ResumeRecoverable persist() throws IOException {     lock().     try {         fileStream.flush().         openNewPartIfNecessary(userDefinedMinPartSize).         return upload.snapshotAndGetRecoverable(fileStream).     } finally {         unlock().     } }
false;public;0;11;;@Override public Committer closeForCommit() throws IOException {     lock().     try {         closeAndUploadPart().         return upload.snapshotAndGetCommitter().     } finally {         unlock().     } }
false;private;1;11;;// ------------------------------------------------------------------------ // S3 // ------------------------------------------------------------------------ private void openNewPartIfNecessary(long sizeThreshold) throws IOException {     final long fileLength = fileStream.getPos().     if (fileLength >= sizeThreshold) {         lock().         try {             uploadCurrentAndOpenNewPart(fileLength).         } finally {             unlock().         }     } }
false;private;1;7;;private void uploadCurrentAndOpenNewPart(long fileLength) throws IOException {     bytesBeforeCurrentPart += fileLength.     closeAndUploadPart().     // initialize a new temp file     fileStream = RefCountedBufferingFileStream.openNew(tmpFileProvider). }
false;private;0;8;;private void closeAndUploadPart() throws IOException {     fileStream.flush().     fileStream.close().     if (fileStream.getPos() > 0L) {         upload.uploadPart(fileStream).     }     fileStream.release(). }
false;private;0;9;;// ------------------------------------------------------------------------ // locking // ------------------------------------------------------------------------ private void lock() throws IOException {     try {         lock.lockInterruptibly().     } catch (InterruptedException e) {         Thread.currentThread().interrupt().         throw new IOException("interrupted").     } }
false;private;0;3;;private void unlock() {     lock.unlock(). }
false;public,static;3;16;;// ------------------------------------------------------------------------ // factory methods // ------------------------------------------------------------------------ public static S3RecoverableFsDataOutputStream newStream(final RecoverableMultiPartUpload upload, final FunctionWithException<File, RefCountedFile, IOException> tmpFileCreator, final long userDefinedMinPartSize) throws IOException {     checkArgument(userDefinedMinPartSize >= S3_MULTIPART_MIN_PART_SIZE).     final RefCountedBufferingFileStream fileStream = boundedBufferingFileStream(tmpFileCreator, Optional.empty()).     return new S3RecoverableFsDataOutputStream(upload, tmpFileCreator, fileStream, userDefinedMinPartSize, 0L). }
false;public,static;4;19;;public static S3RecoverableFsDataOutputStream recoverStream(final RecoverableMultiPartUpload upload, final FunctionWithException<File, RefCountedFile, IOException> tmpFileCreator, final long userDefinedMinPartSize, final long bytesBeforeCurrentPart) throws IOException {     checkArgument(userDefinedMinPartSize >= S3_MULTIPART_MIN_PART_SIZE).     final RefCountedBufferingFileStream fileStream = boundedBufferingFileStream(tmpFileCreator, upload.getIncompletePart()).     return new S3RecoverableFsDataOutputStream(upload, tmpFileCreator, fileStream, userDefinedMinPartSize, bytesBeforeCurrentPart). }
false;private,static;2;11;;private static RefCountedBufferingFileStream boundedBufferingFileStream(final FunctionWithException<File, RefCountedFile, IOException> tmpFileCreator, final Optional<File> incompletePart) throws IOException {     if (!incompletePart.isPresent()) {         return RefCountedBufferingFileStream.openNew(tmpFileCreator).     }     final File file = incompletePart.get().     return RefCountedBufferingFileStream.restore(tmpFileCreator, file). }
