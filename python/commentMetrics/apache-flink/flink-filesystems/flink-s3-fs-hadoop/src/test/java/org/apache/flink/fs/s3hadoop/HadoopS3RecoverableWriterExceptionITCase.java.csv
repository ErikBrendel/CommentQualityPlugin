commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;22;;@BeforeClass public static void checkCredentialsAndSetup() throws IOException {     // check whether credentials exist     S3TestCredentials.assumeCredentialsAvailable().     basePath = new Path(S3TestCredentials.getTestBucketUri() + "tests-" + UUID.randomUUID()).     // initialize configuration with valid credentials     final Configuration conf = new Configuration().     conf.setString("s3.access.key", S3TestCredentials.getS3AccessKey()).     conf.setString("s3.secret.key", S3TestCredentials.getS3SecretKey()).     conf.setLong(PART_UPLOAD_MIN_SIZE, PART_UPLOAD_MIN_SIZE_VALUE).     conf.setInteger(MAX_CONCURRENT_UPLOADS, MAX_CONCURRENT_UPLOADS_VALUE).     final String defaultTmpDir = TEMP_FOLDER.getRoot().getAbsolutePath() + "s3_tmp_dir".     conf.setString(CoreOptions.TMP_DIRS, defaultTmpDir).     FileSystem.initialize(conf).     skipped = false. }
false;public,static;0;7;;@AfterClass public static void cleanUp() throws Exception {     if (!skipped) {         getFileSystem().delete(basePath, true).     }     FileSystem.initialize(new Configuration()). }
false;public;0;13;;@Before public void prepare() throws Exception {     basePathForTest = new Path(basePath, StringUtils.getRandomString(RND, 16, 16, 'a', 'z')).     final String defaultTmpDir = getFileSystem().getLocalTmpDir().     final java.nio.file.Path path = Paths.get(defaultTmpDir).     if (!Files.exists(path)) {         Files.createDirectory(path).     } }
false;public;0;4;;@After public void cleanup() throws Exception {     getFileSystem().delete(basePathForTest, true). }
false;private,static;0;6;;private static FlinkS3FileSystem getFileSystem() throws Exception {     if (fileSystem == null) {         fileSystem = (FlinkS3FileSystem) FileSystem.get(basePath.toUri()).     }     return fileSystem. }
false;public;0;10;;@Test(expected = IOException.class) public void testExceptionWritingAfterCloseForCommit() throws Exception {     final Path path = new Path(basePathForTest, "part-0").     final RecoverableFsDataOutputStream stream = getFileSystem().createRecoverableWriter().open(path).     stream.write(testData1.getBytes(StandardCharsets.UTF_8)).     stream.closeForCommit().getRecoverable().     stream.write(testData2.getBytes(StandardCharsets.UTF_8)). }
false;public;0;16;;// IMPORTANT FOR THE FOLLOWING TWO TESTS: // These tests illustrate a difference in the user-perceived behavior of the different writers. // In HDFS this will fail when trying to recover the stream while here is will fail at "commit", i.e. // when we try to "publish" the multipart upload and we realize that the MPU is no longer active. @Test(expected = IOException.class) public void testResumeAfterCommit() throws Exception {     final RecoverableWriter writer = getFileSystem().createRecoverableWriter().     final Path path = new Path(basePathForTest, "part-0").     final RecoverableFsDataOutputStream stream = writer.open(path).     stream.write(testData1.getBytes(StandardCharsets.UTF_8)).     final RecoverableWriter.ResumeRecoverable recoverable = stream.persist().     stream.write(testData2.getBytes(StandardCharsets.UTF_8)).     stream.closeForCommit().commit().     final RecoverableFsDataOutputStream recoveredStream = writer.recover(recoverable).     recoveredStream.closeForCommit().commit(). }
false;public;0;24;;@Test(expected = IOException.class) public void testResumeWithWrongOffset() throws Exception {     // this is a rather unrealistic scenario, but it is to trigger     // truncation of the file and try to resume with missing data.     final RecoverableWriter writer = getFileSystem().createRecoverableWriter().     final Path path = new Path(basePathForTest, "part-0").     final RecoverableFsDataOutputStream stream = writer.open(path).     stream.write(testData1.getBytes(StandardCharsets.UTF_8)).     final RecoverableWriter.ResumeRecoverable recoverable1 = stream.persist().     stream.write(testData2.getBytes(StandardCharsets.UTF_8)).     final RecoverableWriter.ResumeRecoverable recoverable2 = stream.persist().     stream.write(testData3.getBytes(StandardCharsets.UTF_8)).     final RecoverableFsDataOutputStream recoveredStream = writer.recover(recoverable1).     recoveredStream.closeForCommit().commit().     // this should throw an exception     final RecoverableFsDataOutputStream newRecoveredStream = writer.recover(recoverable2).     newRecoveredStream.closeForCommit().commit(). }
