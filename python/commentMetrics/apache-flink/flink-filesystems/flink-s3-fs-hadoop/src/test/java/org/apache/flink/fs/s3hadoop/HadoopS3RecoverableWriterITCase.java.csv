commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;22;;@BeforeClass public static void checkCredentialsAndSetup() throws IOException {     // check whether credentials exist     S3TestCredentials.assumeCredentialsAvailable().     basePath = new Path(S3TestCredentials.getTestBucketUri() + "tests-" + UUID.randomUUID()).     // initialize configuration with valid credentials     final Configuration conf = new Configuration().     conf.setString("s3.access.key", S3TestCredentials.getS3AccessKey()).     conf.setString("s3.secret.key", S3TestCredentials.getS3SecretKey()).     conf.setLong(PART_UPLOAD_MIN_SIZE, PART_UPLOAD_MIN_SIZE_VALUE).     conf.setInteger(MAX_CONCURRENT_UPLOADS, MAX_CONCURRENT_UPLOADS_VALUE).     final String defaultTmpDir = TEMP_FOLDER.getRoot().getAbsolutePath() + "s3_tmp_dir".     conf.setString(CoreOptions.TMP_DIRS, defaultTmpDir).     FileSystem.initialize(conf).     skipped = false. }
false;public,static;0;7;;@AfterClass public static void cleanUp() throws Exception {     if (!skipped) {         getFileSystem().delete(basePath, true).     }     FileSystem.initialize(new Configuration()). }
false;public;0;8;;@Before public void prepare() throws Exception {     basePathForTest = new Path(basePath, StringUtils.getRandomString(RND, 16, 16, 'a', 'z')).     cleanupLocalDir(). }
false;private;0;18;;private void cleanupLocalDir() throws Exception {     final String defaultTmpDir = getFileSystem().getLocalTmpDir().     final java.nio.file.Path defaultTmpPath = Paths.get(defaultTmpDir).     if (Files.exists(defaultTmpPath)) {         try (Stream<java.nio.file.Path> files = Files.list(defaultTmpPath)) {             files.forEach(p -> {                 try {                     Files.delete(p).                 } catch (IOException e) {                     e.printStackTrace().                 }             }).         }     } else {         Files.createDirectory(defaultTmpPath).     } }
false;public;0;15;;@After public void cleanupAndCheckTmpCleanup() throws Exception {     final String defaultTmpDir = getFileSystem().getLocalTmpDir().     final java.nio.file.Path localTmpDir = Paths.get(defaultTmpDir).     // delete local tmp dir.     Assert.assertTrue(Files.exists(localTmpDir)).     try (Stream<java.nio.file.Path> files = Files.list(localTmpDir)) {         Assert.assertEquals(0L, files.count()).     }     Files.delete(localTmpDir).     // delete also S3 dir.     getFileSystem().delete(basePathForTest, true). }
false;private,static;0;6;;private static FlinkS3FileSystem getFileSystem() throws Exception {     if (fileSystem == null) {         fileSystem = (FlinkS3FileSystem) FileSystem.get(basePath.toUri()).     }     return fileSystem. }
false;public;0;9;;// ----------------------- Test Normal Execution ----------------------- @Test public void testCloseWithNoData() throws Exception {     final RecoverableWriter writer = getRecoverableWriter().     final Path path = new Path(basePathForTest, "part-0").     final RecoverableFsDataOutputStream stream = writer.open(path).     stream.closeForCommit().commit(). }
false;public;0;11;;@Test public void testCommitAfterNormalClose() throws Exception {     final RecoverableWriter writer = getRecoverableWriter().     final Path path = new Path(basePathForTest, "part-0").     final RecoverableFsDataOutputStream stream = writer.open(path).     stream.write(bytesOf(testData1)).     stream.closeForCommit().commit().     Assert.assertEquals(testData1, getContentsOfFile(path)). }
false;public;0;14;;@Test public void testCommitAfterPersist() throws Exception {     final RecoverableWriter writer = getRecoverableWriter().     final Path path = new Path(basePathForTest, "part-0").     final RecoverableFsDataOutputStream stream = writer.open(path).     stream.write(bytesOf(testData1)).     stream.persist().     stream.write(bytesOf(testData2)).     stream.closeForCommit().commit().     Assert.assertEquals(testData1 + testData2, getContentsOfFile(path)). }
false;public;0;21;;@Test(expected = FileNotFoundException.class) public void testCleanupRecoverableState() throws Exception {     final RecoverableWriter writer = getRecoverableWriter().     final Path path = new Path(basePathForTest, "part-0").     final RecoverableFsDataOutputStream stream = writer.open(path).     stream.write(bytesOf(testData1)).     S3Recoverable recoverable = (S3Recoverable) stream.persist().     stream.closeForCommit().commit().     // still the data is there as we have not deleted them from the tmp object     final String content = getContentsOfFile(new Path('/' + recoverable.incompleteObjectName())).     Assert.assertEquals(testData1, content).     boolean successfullyDeletedState = writer.cleanupRecoverableState(recoverable).     Assert.assertTrue(successfullyDeletedState).     // this should throw the exception as we deleted the file.     getContentsOfFile(new Path('/' + recoverable.incompleteObjectName())). }
false;public;0;21;;@Test public void testCallingDeleteObjectTwiceDoesNotThroughException() throws Exception {     final RecoverableWriter writer = getRecoverableWriter().     final Path path = new Path(basePathForTest, "part-0").     final RecoverableFsDataOutputStream stream = writer.open(path).     stream.write(bytesOf(testData1)).     S3Recoverable recoverable = (S3Recoverable) stream.persist().     stream.closeForCommit().commit().     // still the data is there as we have not deleted them from the tmp object     final String content = getContentsOfFile(new Path('/' + recoverable.incompleteObjectName())).     Assert.assertEquals(testData1, content).     boolean successfullyDeletedState = writer.cleanupRecoverableState(recoverable).     Assert.assertTrue(successfullyDeletedState).     boolean unsuccessfulDeletion = writer.cleanupRecoverableState(recoverable).     Assert.assertFalse(unsuccessfulDeletion). }
false;public;0;30;;// ----------------------- Test Recovery ----------------------- @Test public void testCommitAfterRecovery() throws Exception {     final Path path = new Path(basePathForTest, "part-0").     final RecoverableWriter initWriter = getRecoverableWriter().     final RecoverableFsDataOutputStream stream = initWriter.open(path).     stream.write(bytesOf(testData1)).     stream.persist().     stream.persist().     // and write some more data     stream.write(bytesOf(testData2)).     final RecoverableWriter.CommitRecoverable recoverable = stream.closeForCommit().getRecoverable().     final byte[] serializedRecoverable = initWriter.getCommitRecoverableSerializer().serialize(recoverable).     // get a new serializer from a new writer to make sure that no pre-initialized state leaks in.     final RecoverableWriter newWriter = getRecoverableWriter().     final SimpleVersionedSerializer<RecoverableWriter.CommitRecoverable> deserializer = newWriter.getCommitRecoverableSerializer().     final RecoverableWriter.CommitRecoverable recoveredRecoverable = deserializer.deserialize(deserializer.getVersion(), serializedRecoverable).     final RecoverableFsDataOutputStream.Committer committer = newWriter.recoverForCommit(recoveredRecoverable).     committer.commitAfterRecovery().     Assert.assertEquals(testData1 + testData2, getContentsOfFile(path)). }
false;public;0;6;;@Test public void testRecoverWithEmptyState() throws Exception {     testResumeAfterMultiplePersistWithSmallData(INIT_EMPTY_PERSIST, testData3). }
false;public;0;6;;@Test public void testRecoverWithState() throws Exception {     testResumeAfterMultiplePersistWithSmallData(INTERM_WITH_STATE_PERSIST, testData1 + testData3). }
false;public;0;6;;@Test public void testRecoverFromIntermWithoutAdditionalState() throws Exception {     testResumeAfterMultiplePersistWithSmallData(INTERM_WITH_NO_ADDITIONAL_STATE_PERSIST, testData1 + testData3). }
false;public;0;6;;@Test public void testRecoverAfterMultiplePersistsState() throws Exception {     testResumeAfterMultiplePersistWithSmallData(FINAL_WITH_EXTRA_STATE, testData1 + testData2 + testData3). }
false;public;0;6;;@Test public void testRecoverWithStateWithMultiPart() throws Exception {     testResumeAfterMultiplePersistWithMultiPartUploads(INTERM_WITH_STATE_PERSIST, bigDataChunk + bigDataChunk). }
false;public;0;6;;@Test public void testRecoverFromIntermWithoutAdditionalStateWithMultiPart() throws Exception {     testResumeAfterMultiplePersistWithMultiPartUploads(INTERM_WITH_NO_ADDITIONAL_STATE_PERSIST, bigDataChunk + bigDataChunk). }
false;public;0;6;;@Test public void testRecoverAfterMultiplePersistsStateWithMultiPart() throws Exception {     testResumeAfterMultiplePersistWithMultiPartUploads(FINAL_WITH_EXTRA_STATE, bigDataChunk + bigDataChunk + bigDataChunk). }
false;private;2;11;;private void testResumeAfterMultiplePersistWithSmallData(final String persistName, final String expectedFinalContents) throws Exception {     testResumeAfterMultiplePersist(persistName, expectedFinalContents, testData1, testData2, testData3). }
false;private;2;11;;private void testResumeAfterMultiplePersistWithMultiPartUploads(final String persistName, final String expectedFinalContents) throws Exception {     testResumeAfterMultiplePersist(persistName, expectedFinalContents, bigDataChunk, bigDataChunk, bigDataChunk). }
false;private;5;40;;private void testResumeAfterMultiplePersist(final String persistName, final String expectedFinalContents, final String firstItemToWrite, final String secondItemToWrite, final String thirdItemToWrite) throws Exception {     final Path path = new Path(basePathForTest, "part-0").     final RecoverableWriter initWriter = getRecoverableWriter().     final Map<String, RecoverableWriter.ResumeRecoverable> recoverables = new HashMap<>(4).     try (final RecoverableFsDataOutputStream stream = initWriter.open(path)) {         recoverables.put(INIT_EMPTY_PERSIST, stream.persist()).         stream.write(bytesOf(firstItemToWrite)).         recoverables.put(INTERM_WITH_STATE_PERSIST, stream.persist()).         recoverables.put(INTERM_WITH_NO_ADDITIONAL_STATE_PERSIST, stream.persist()).         // and write some more data         stream.write(bytesOf(secondItemToWrite)).         recoverables.put(FINAL_WITH_EXTRA_STATE, stream.persist()).     }     final SimpleVersionedSerializer<RecoverableWriter.ResumeRecoverable> serializer = initWriter.getResumeRecoverableSerializer().     final byte[] serializedRecoverable = serializer.serialize(recoverables.get(persistName)).     // get a new serializer from a new writer to make sure that no pre-initialized state leaks in.     final RecoverableWriter newWriter = getRecoverableWriter().     final SimpleVersionedSerializer<RecoverableWriter.ResumeRecoverable> deserializer = newWriter.getResumeRecoverableSerializer().     final RecoverableWriter.ResumeRecoverable recoveredRecoverable = deserializer.deserialize(serializer.getVersion(), serializedRecoverable).     final RecoverableFsDataOutputStream recoveredStream = newWriter.recover(recoveredRecoverable).     recoveredStream.write(bytesOf(thirdItemToWrite)).     recoveredStream.closeForCommit().commit().     Assert.assertEquals(expectedFinalContents, getContentsOfFile(path)). }
false;private;1;13;;// -------------------------- Test Utilities -------------------------- private String getContentsOfFile(Path path) throws Exception {     final StringBuilder builder = new StringBuilder().     try (FSDataInputStream inStream = getFileSystem().open(path).         BufferedReader reader = new BufferedReader(new InputStreamReader(inStream))) {         String line.         while ((line = reader.readLine()) != null) {             builder.append(line).         }     }     return builder.toString(). }
false;private,static;2;11;;// ----------------------- Test utilities ----------------------- private static String createBigDataChunk(String pattern, long size) {     final StringBuilder stringBuilder = new StringBuilder().     int sampleLength = bytesOf(pattern).length.     int repeats = MathUtils.checkedDownCast(size) / sampleLength + 100.     for (int i = 0. i < repeats. i++) {         stringBuilder.append(pattern).     }     return stringBuilder.toString(). }
false;private,static;1;3;;private static byte[] bytesOf(String str) {     return str.getBytes(StandardCharsets.UTF_8). }
false;private;0;3;;private RecoverableWriter getRecoverableWriter() throws Exception {     return getFileSystem().createRecoverableWriter(). }
