commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int getVersion() {     return 1. }
false;public;1;16;;@Override public byte[] serialize(HadoopFsRecoverable obj) throws IOException {     final byte[] targetFileBytes = obj.targetFile().toString().getBytes(CHARSET).     final byte[] tempFileBytes = obj.tempFile().toString().getBytes(CHARSET).     final byte[] targetBytes = new byte[20 + targetFileBytes.length + tempFileBytes.length].     ByteBuffer bb = ByteBuffer.wrap(targetBytes).order(ByteOrder.LITTLE_ENDIAN).     bb.putInt(MAGIC_NUMBER).     bb.putLong(obj.offset()).     bb.putInt(targetFileBytes.length).     bb.putInt(tempFileBytes.length).     bb.put(targetFileBytes).     bb.put(tempFileBytes).     return targetBytes. }
false;public;2;9;;@Override public HadoopFsRecoverable deserialize(int version, byte[] serialized) throws IOException {     switch(version) {         case 1:             return deserializeV1(serialized).         default:             throw new IOException("Unrecognized version or corrupt state: " + version).     } }
false;private,static;1;19;;private static HadoopFsRecoverable deserializeV1(byte[] serialized) throws IOException {     final ByteBuffer bb = ByteBuffer.wrap(serialized).order(ByteOrder.LITTLE_ENDIAN).     if (bb.getInt() != MAGIC_NUMBER) {         throw new IOException("Corrupt data: Unexpected magic number.").     }     final long offset = bb.getLong().     final byte[] targetFileBytes = new byte[bb.getInt()].     final byte[] tempFileBytes = new byte[bb.getInt()].     bb.get(targetFileBytes).     bb.get(tempFileBytes).     final String targetPath = new String(targetFileBytes, CHARSET).     final String tempPath = new String(tempFileBytes, CHARSET).     return new HadoopFsRecoverable(new Path(targetPath), new Path(tempPath), offset). }
