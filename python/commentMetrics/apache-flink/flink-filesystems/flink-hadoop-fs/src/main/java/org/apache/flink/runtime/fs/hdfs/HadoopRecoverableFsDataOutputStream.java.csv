commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void write(int b) throws IOException {     out.write(b). }
false;public;3;4;;@Override public void write(byte[] b, int off, int len) throws IOException {     out.write(b, off, len). }
false;public;0;4;;@Override public void flush() throws IOException {     out.hflush(). }
false;public;0;5;;@Override public void sync() throws IOException {     out.hflush().     out.hsync(). }
false;public;0;4;;@Override public long getPos() throws IOException {     return out.getPos(). }
false;public;0;5;;@Override public ResumeRecoverable persist() throws IOException {     sync().     return new HadoopFsRecoverable(targetFile, tempFile, getPos()). }
false;public;0;6;;@Override public Committer closeForCommit() throws IOException {     final long pos = getPos().     close().     return new HadoopFsCommitter(fs, new HadoopFsRecoverable(targetFile, tempFile, pos)). }
false;public;0;4;;@Override public void close() throws IOException {     out.close(). }
false;private,static;3;23;;// ------------------------------------------------------------------------ // Reflection utils for truncation // These are needed to compile against Hadoop versions before // Hadoop 2.7, which have no truncation calls for HDFS. // ------------------------------------------------------------------------ private static void safelyTruncateFile(final FileSystem fileSystem, final Path path, final HadoopFsRecoverable recoverable) throws IOException {     ensureTruncateInitialized().     waitUntilLeaseIsRevoked(fileSystem, path).     // truncate back and append     boolean truncated.     try {         truncated = truncate(fileSystem, path, recoverable.offset()).     } catch (Exception e) {         throw new IOException("Problem while truncating file: " + path, e).     }     if (!truncated) {         // Truncate did not complete immediately, we must wait for         // the operation to complete and release the lease.         waitUntilLeaseIsRevoked(fileSystem, path).     } }
false;private,static;0;17;;private static void ensureTruncateInitialized() throws FlinkRuntimeException {     if (truncateHandle == null) {         Method truncateMethod.         try {             truncateMethod = FileSystem.class.getMethod("truncate", Path.class, long.class).         } catch (NoSuchMethodException e) {             throw new FlinkRuntimeException("Could not find a public truncate method on the Hadoop File System.").         }         if (!Modifier.isPublic(truncateMethod.getModifiers())) {             throw new FlinkRuntimeException("Could not find a public truncate method on the Hadoop File System.").         }         truncateHandle = truncateMethod.     } }
false;private,static;3;19;;private static boolean truncate(final FileSystem hadoopFs, final Path file, final long length) throws IOException {     if (truncateHandle != null) {         try {             return (Boolean) truncateHandle.invoke(hadoopFs, file, length).         } catch (InvocationTargetException e) {             ExceptionUtils.rethrowIOException(e.getTargetException()).         } catch (Throwable t) {             throw new IOException("Truncation of file failed because of access/linking problems with Hadoop's truncate call. " + "This is most likely a dependency conflict or class loading problem.").         }     } else {         throw new IllegalStateException("Truncation handle has not been initialized").     }     return false. }
false;public;0;27;;@Override public void commit() throws IOException {     final Path src = recoverable.tempFile().     final Path dest = recoverable.targetFile().     final long expectedLength = recoverable.offset().     final FileStatus srcStatus.     try {         srcStatus = fs.getFileStatus(src).     } catch (IOException e) {         throw new IOException("Cannot clean commit: Staging file does not exist.").     }     if (srcStatus.getLen() != expectedLength) {         // this is not the "clean" case         throw new IOException("Cannot clean commit: File has trailing junk data.").     }     try {         fs.rename(src, dest).     } catch (IOException e) {         throw new IOException("Committing file by rename failed: " + src + " to " + dest, e).     } }
false;public;0;43;;@Override public void commitAfterRecovery() throws IOException {     final Path src = recoverable.tempFile().     final Path dest = recoverable.targetFile().     final long expectedLength = recoverable.offset().     FileStatus srcStatus = null.     try {         srcStatus = fs.getFileStatus(src).     } catch (FileNotFoundException e) {     // status remains null     } catch (IOException e) {         throw new IOException("Committing during recovery failed: Could not access status of source file.").     }     if (srcStatus != null) {         if (srcStatus.getLen() > expectedLength) {             // can happen if we go from persist to recovering for commit directly             // truncate the trailing junk away             safelyTruncateFile(fs, src, recoverable).         }         // rename to final location (if it exists, overwrite it)         try {             fs.rename(src, dest).         } catch (IOException e) {             throw new IOException("Committing file by rename failed: " + src + " to " + dest, e).         }     } else if (!fs.exists(dest)) {     // neither exists - that can be a sign of     // - (1) a serious problem (file system loss of data)     // - (2) a recovery of a savepoint that is some time old and the users     // removed the files in the meantime.     // TODO how to handle this?     // We probably need an option for users whether this should log,     // or result in an exception or unrecoverable exception     } }
false;public;0;4;;@Override public CommitRecoverable getRecoverable() {     return recoverable. }
true;private,static;2;22;/**  * Called when resuming execution after a failure and waits until the lease  * of the file we are resuming is free.  *  * <p>The lease of the file we are resuming writing/committing to may still  * belong to the process that failed previously and whose state we are  * recovering.  *  * @param path The path to the file we want to resume writing to.  */ ;/**  * Called when resuming execution after a failure and waits until the lease  * of the file we are resuming is free.  *  * <p>The lease of the file we are resuming writing/committing to may still  * belong to the process that failed previously and whose state we are  * recovering.  *  * @param path The path to the file we want to resume writing to.  */ private static boolean waitUntilLeaseIsRevoked(final FileSystem fs, final Path path) throws IOException {     Preconditions.checkState(fs instanceof DistributedFileSystem).     final DistributedFileSystem dfs = (DistributedFileSystem) fs.     dfs.recoverLease(path).     final Deadline deadline = Deadline.now().plus(Duration.ofMillis(LEASE_TIMEOUT)).     final StopWatch sw = new StopWatch().     sw.start().     boolean isClosed = dfs.isFileClosed(path).     while (!isClosed && deadline.hasTimeLeft()) {         try {             Thread.sleep(500L).         } catch (InterruptedException e1) {             throw new IOException("Recovering the lease failed: ", e1).         }         isClosed = dfs.isFileClosed(path).     }     return isClosed. }
