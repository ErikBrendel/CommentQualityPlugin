# id;timestamp;commentText;codeText;commentWords;codeWords
HadoopRecoverableFsDataOutputStream -> private boolean waitUntilLeaseIsRevoked(final Path path) throws IOException;1531689536;Called when resuming execution after a failure and waits until the lease_of the file we are resuming is free.__<p>The lease of the file we are resuming writing/committing to may still_belong to the process that failed previously and whose state we are_recovering.__@param path The path to the file we want to resume writing to.;private boolean waitUntilLeaseIsRevoked(final Path path) throws IOException {_		Preconditions.checkState(fs instanceof DistributedFileSystem)___		final DistributedFileSystem dfs = (DistributedFileSystem) fs__		dfs.recoverLease(path)__		boolean isclosed = dfs.isFileClosed(path)___		final StopWatch sw = new StopWatch()__		sw.start()___		while (!isclosed) {_			if (sw.getTime() > LEASE_TIMEOUT) {_				break__			}__			try {_				Thread.sleep(500L)__			} catch (InterruptedException e1) {_				_			}_			isclosed = dfs.isFileClosed(path)__		}_		return isclosed__	};called,when,resuming,execution,after,a,failure,and,waits,until,the,lease,of,the,file,we,are,resuming,is,free,p,the,lease,of,the,file,we,are,resuming,writing,committing,to,may,still,belong,to,the,process,that,failed,previously,and,whose,state,we,are,recovering,param,path,the,path,to,the,file,we,want,to,resume,writing,to;private,boolean,wait,until,lease,is,revoked,final,path,path,throws,ioexception,preconditions,check,state,fs,instanceof,distributed,file,system,final,distributed,file,system,dfs,distributed,file,system,fs,dfs,recover,lease,path,boolean,isclosed,dfs,is,file,closed,path,final,stop,watch,sw,new,stop,watch,sw,start,while,isclosed,if,sw,get,time,break,try,thread,sleep,500l,catch,interrupted,exception,e1,isclosed,dfs,is,file,closed,path,return,isclosed
HadoopRecoverableFsDataOutputStream -> private boolean waitUntilLeaseIsRevoked(final Path path) throws IOException;1531689637;Called when resuming execution after a failure and waits until the lease_of the file we are resuming is free.__<p>The lease of the file we are resuming writing/committing to may still_belong to the process that failed previously and whose state we are_recovering.__@param path The path to the file we want to resume writing to.;private boolean waitUntilLeaseIsRevoked(final Path path) throws IOException {_		Preconditions.checkState(fs instanceof DistributedFileSystem)___		final DistributedFileSystem dfs = (DistributedFileSystem) fs__		dfs.recoverLease(path)___		final Deadline deadline = Deadline.now().plus(Duration.ofMillis(LEASE_TIMEOUT))___		final StopWatch sw = new StopWatch()__		sw.start()___		boolean isClosed = dfs.isFileClosed(path)__		while (!isClosed && deadline.hasTimeLeft()) {_			try {_				Thread.sleep(500L)__			} catch (InterruptedException e1) {_				throw new IOException("Recovering the lease failed: ", e1)__			}_			isClosed = dfs.isFileClosed(path)__		}_		return isClosed__	};called,when,resuming,execution,after,a,failure,and,waits,until,the,lease,of,the,file,we,are,resuming,is,free,p,the,lease,of,the,file,we,are,resuming,writing,committing,to,may,still,belong,to,the,process,that,failed,previously,and,whose,state,we,are,recovering,param,path,the,path,to,the,file,we,want,to,resume,writing,to;private,boolean,wait,until,lease,is,revoked,final,path,path,throws,ioexception,preconditions,check,state,fs,instanceof,distributed,file,system,final,distributed,file,system,dfs,distributed,file,system,fs,dfs,recover,lease,path,final,deadline,deadline,deadline,now,plus,duration,of,millis,final,stop,watch,sw,new,stop,watch,sw,start,boolean,is,closed,dfs,is,file,closed,path,while,is,closed,deadline,has,time,left,try,thread,sleep,500l,catch,interrupted,exception,e1,throw,new,ioexception,recovering,the,lease,failed,e1,is,closed,dfs,is,file,closed,path,return,is,closed
HadoopRecoverableFsDataOutputStream -> private boolean waitUntilLeaseIsRevoked(final Path path) throws IOException;1549270958;Called when resuming execution after a failure and waits until the lease_of the file we are resuming is free.__<p>The lease of the file we are resuming writing/committing to may still_belong to the process that failed previously and whose state we are_recovering.__@param path The path to the file we want to resume writing to.;private boolean waitUntilLeaseIsRevoked(final Path path) throws IOException {_		Preconditions.checkState(fs instanceof DistributedFileSystem)___		final DistributedFileSystem dfs = (DistributedFileSystem) fs__		dfs.recoverLease(path)___		final Deadline deadline = Deadline.now().plus(Duration.ofMillis(LEASE_TIMEOUT))___		final StopWatch sw = new StopWatch()__		sw.start()___		boolean isClosed = dfs.isFileClosed(path)__		while (!isClosed && deadline.hasTimeLeft()) {_			try {_				Thread.sleep(500L)__			} catch (InterruptedException e1) {_				throw new IOException("Recovering the lease failed: ", e1)__			}_			isClosed = dfs.isFileClosed(path)__		}_		return isClosed__	};called,when,resuming,execution,after,a,failure,and,waits,until,the,lease,of,the,file,we,are,resuming,is,free,p,the,lease,of,the,file,we,are,resuming,writing,committing,to,may,still,belong,to,the,process,that,failed,previously,and,whose,state,we,are,recovering,param,path,the,path,to,the,file,we,want,to,resume,writing,to;private,boolean,wait,until,lease,is,revoked,final,path,path,throws,ioexception,preconditions,check,state,fs,instanceof,distributed,file,system,final,distributed,file,system,dfs,distributed,file,system,fs,dfs,recover,lease,path,final,deadline,deadline,deadline,now,plus,duration,of,millis,final,stop,watch,sw,new,stop,watch,sw,start,boolean,is,closed,dfs,is,file,closed,path,while,is,closed,deadline,has,time,left,try,thread,sleep,500l,catch,interrupted,exception,e1,throw,new,ioexception,recovering,the,lease,failed,e1,is,closed,dfs,is,file,closed,path,return,is,closed
