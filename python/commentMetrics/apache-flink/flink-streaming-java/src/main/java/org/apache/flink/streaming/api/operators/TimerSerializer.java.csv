commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;10;;private static int computeTotalByteLength(TypeSerializer<?> keySerializer, TypeSerializer<?> namespaceSerializer) {     if (keySerializer.getLength() >= 0 && namespaceSerializer.getLength() >= 0) {         // timestamp + key + namespace         return Long.BYTES + keySerializer.getLength() + namespaceSerializer.getLength().     } else {         return -1.     } }
false;public;0;4;;@Override public boolean isImmutableType() {     return immutableType. }
false;public;0;19;;@Override public TimerSerializer<K, N> duplicate() {     final TypeSerializer<K> keySerializerDuplicate = keySerializer.duplicate().     final TypeSerializer<N> namespaceSerializerDuplicate = namespaceSerializer.duplicate().     if (keySerializerDuplicate == keySerializer && namespaceSerializerDuplicate == namespaceSerializer) {         // all delegate serializers seem stateless, so this is also stateless.         return this.     } else {         // at least one delegate serializer seems to be stateful, so we return a new instance.         return new TimerSerializer<>(keySerializerDuplicate, namespaceSerializerDuplicate, length, immutableType).     } }
false;public;0;7;;@Override public TimerHeapInternalTimer<K, N> createInstance() {     return new TimerHeapInternalTimer<>(0L, keySerializer.createInstance(), namespaceSerializer.createInstance()). }
false;public;1;15;;@Override public TimerHeapInternalTimer<K, N> copy(TimerHeapInternalTimer<K, N> from) {     K keyDuplicate.     N namespaceDuplicate.     if (isImmutableType()) {         keyDuplicate = from.getKey().         namespaceDuplicate = from.getNamespace().     } else {         keyDuplicate = keySerializer.copy(from.getKey()).         namespaceDuplicate = namespaceSerializer.copy(from.getNamespace()).     }     return new TimerHeapInternalTimer<>(from.getTimestamp(), keyDuplicate, namespaceDuplicate). }
false;public;2;4;;@Override public TimerHeapInternalTimer<K, N> copy(TimerHeapInternalTimer<K, N> from, TimerHeapInternalTimer<K, N> reuse) {     return copy(from). }
false;public;0;4;;@Override public int getLength() {     return length. }
false;public;2;6;;@Override public void serialize(TimerHeapInternalTimer<K, N> record, DataOutputView target) throws IOException {     target.writeLong(MathUtils.flipSignBit(record.getTimestamp())).     keySerializer.serialize(record.getKey(), target).     namespaceSerializer.serialize(record.getNamespace(), target). }
false;public;1;7;;@Override public TimerHeapInternalTimer<K, N> deserialize(DataInputView source) throws IOException {     long timestamp = MathUtils.flipSignBit(source.readLong()).     K key = keySerializer.deserialize(source).     N namespace = namespaceSerializer.deserialize(source).     return new TimerHeapInternalTimer<>(timestamp, key, namespace). }
false;public;2;6;;@Override public TimerHeapInternalTimer<K, N> deserialize(TimerHeapInternalTimer<K, N> reuse, DataInputView source) throws IOException {     return deserialize(source). }
false;public;2;6;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     target.writeLong(source.readLong()).     keySerializer.copy(source, target).     namespaceSerializer.copy(source, target). }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     TimerSerializer<?, ?> that = (TimerSerializer<?, ?>) o.     return Objects.equals(keySerializer, that.keySerializer) && Objects.equals(namespaceSerializer, that.namespaceSerializer). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(keySerializer, namespaceSerializer). }
false;public;0;4;;@Override public TimerSerializerSnapshot<K, N> snapshotConfiguration() {     return new TimerSerializerSnapshot<>(this). }
false;public;0;4;;@Nonnull public TypeSerializer<K> getKeySerializer() {     return keySerializer. }
false;public;0;4;;@Nonnull public TypeSerializer<N> getNamespaceSerializer() {     return namespaceSerializer. }
false;private,static;2;8;;private static TypeSerializer<?>[] init(@Nonnull TypeSerializer<?> keySerializer, @Nonnull TypeSerializer<?> namespaceSerializer) {     TypeSerializer<?>[] timerSerializers = new TypeSerializer[2].     timerSerializers[KEY_SERIALIZER_SNAPSHOT_INDEX] = keySerializer.     timerSerializers[NAMESPACE_SERIALIZER_SNAPSHOT_INDEX] = namespaceSerializer.     return timerSerializers. }
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
false;public;1;15;;@Override public TypeSerializerSchemaCompatibility<TimerHeapInternalTimer<K, N>> resolveSchemaCompatibility(TypeSerializer<TimerHeapInternalTimer<K, N>> newSerializer) {     final TypeSerializerSnapshot<?>[] nestedSnapshots = getNestedSerializersAndConfigs().stream().map(t -> t.f1).toArray(TypeSerializerSnapshot[]::new).     return CompositeTypeSerializerUtil.delegateCompatibilityCheckToNewSnapshot(newSerializer, new TimerSerializerSnapshot<>(), nestedSnapshots). }
