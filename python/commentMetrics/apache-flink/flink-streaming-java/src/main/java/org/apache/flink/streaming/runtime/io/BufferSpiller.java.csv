commented;modifiers;parameterAmount;loc;comment;code
true;public;1;29;/**  * Adds a buffer or event to the sequence of spilled buffers and events.  *  * @param boe The buffer or event to add and spill.  * @throws IOException Thrown, if the buffer of event could not be spilled.  */ ;/**  * Adds a buffer or event to the sequence of spilled buffers and events.  *  * @param boe The buffer or event to add and spill.  * @throws IOException Thrown, if the buffer of event could not be spilled.  */ @Override public void add(BufferOrEvent boe) throws IOException {     try {         ByteBuffer contents.         if (boe.isBuffer()) {             Buffer buf = boe.getBuffer().             contents = buf.getNioBufferReadable().         } else {             contents = EventSerializer.toSerializedEvent(boe.getEvent()).         }         headBuffer.clear().         headBuffer.putInt(boe.getChannelIndex()).         headBuffer.putInt(contents.remaining()).         headBuffer.put((byte) (boe.isBuffer() ? 0 : 1)).         headBuffer.flip().         bytesWritten += (headBuffer.remaining() + contents.remaining()).         FileUtils.writeCompletely(currentChannel, headBuffer).         FileUtils.writeCompletely(currentChannel, contents).     } finally {         if (boe.isBuffer()) {             boe.getBuffer().recycleBuffer().         }     } }
true;public;0;4;/**  * NOTE: The BufferOrEventSequences created by this method all reuse the same reading memory  * (to reduce overhead) and can consequently not be read concurrently with each other.  *  * <p>To create a sequence that can be read concurrently with the previous BufferOrEventSequence,  * use the {@link #rollOverWithoutReusingResources()} ()} method.  *  * @return The readable sequence of spilled buffers and events, or 'null', if nothing was added.  * @throws IOException Thrown, if the readable sequence could not be created, or no new spill  *                     file could be created.  */ ;/**  * NOTE: The BufferOrEventSequences created by this method all reuse the same reading memory  * (to reduce overhead) and can consequently not be read concurrently with each other.  *  * <p>To create a sequence that can be read concurrently with the previous BufferOrEventSequence,  * use the {@link #rollOverWithoutReusingResources()} ()} method.  *  * @return The readable sequence of spilled buffers and events, or 'null', if nothing was added.  * @throws IOException Thrown, if the readable sequence could not be created, or no new spill  *                     file could be created.  */ @Override public BufferOrEventSequence rollOverReusingResources() throws IOException {     return rollOver(false). }
true;public;0;4;/**  * The BufferOrEventSequence returned by this method is safe for concurrent consumption with  * any previously returned sequence.  *  * @return The readable sequence of spilled buffers and events, or 'null', if nothing was added.  * @throws IOException Thrown, if the readable sequence could not be created, or no new spill  *                     file could be created.  */ ;/**  * The BufferOrEventSequence returned by this method is safe for concurrent consumption with  * any previously returned sequence.  *  * @return The readable sequence of spilled buffers and events, or 'null', if nothing was added.  * @throws IOException Thrown, if the readable sequence could not be created, or no new spill  *                     file could be created.  */ @Override public BufferOrEventSequence rollOverWithoutReusingResources() throws IOException {     return rollOver(true). }
false;private;1;24;;private BufferOrEventSequence rollOver(boolean newBuffer) throws IOException {     if (bytesWritten == 0) {         return null.     }     ByteBuffer buf.     if (newBuffer) {         buf = ByteBuffer.allocateDirect(READ_BUFFER_SIZE).         buf.order(ByteOrder.LITTLE_ENDIAN).     } else {         buf = readBuffer.     }     // create a reader for the spilled data     currentChannel.position(0L).     SpilledBufferOrEventSequence seq = new SpilledBufferOrEventSequence(currentSpillFile, currentChannel, buf, pageSize).     // create ourselves a new spill file     createSpillingChannel().     bytesWritten = 0L.     return seq. }
true;public;0;7;/**  * Cleans up the current spilling channel and file.  *  * <p>Does not clean up the SpilledBufferOrEventSequences generated by calls to  * {@link #rollOver(boolean false)}.  *  * @throws IOException Thrown if channel closing or file deletion fail.  */ ;/**  * Cleans up the current spilling channel and file.  *  * <p>Does not clean up the SpilledBufferOrEventSequences generated by calls to  * {@link #rollOver(boolean false)}.  *  * @throws IOException Thrown if channel closing or file deletion fail.  */ @Override public void close() throws IOException {     currentChannel.close().     if (!currentSpillFile.delete()) {         throw new IOException("Cannot delete spill file").     } }
true;public;0;4;/**  * Gets the number of bytes written in the current spill file.  *  * @return the number of bytes written in the current spill file  */ ;/**  * Gets the number of bytes written in the current spill file.  *  * @return the number of bytes written in the current spill file  */ @Override public long getBytesBlocked() {     return bytesWritten. }
false;;0;3;;// ------------------------------------------------------------------------ // For testing // ------------------------------------------------------------------------ File getCurrentSpillFile() {     return currentSpillFile. }
false;;0;3;;FileChannel getCurrentChannel() {     return currentChannel. }
false;private;0;5;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ @SuppressWarnings("resource") private void createSpillingChannel() throws IOException {     currentSpillFile = new File(tempDir, spillFilePrefix + (fileCounter++) + ".buffer").     currentChannel = new RandomAccessFile(currentSpillFile, "rw").getChannel(). }
true;public;0;8;/**  * This method needs to be called before the first call to {@link #getNext()}.  * Otherwise the results of {@link #getNext()} are not predictable.  */ ;/**  * This method needs to be called before the first call to {@link #getNext()}.  * Otherwise the results of {@link #getNext()} are not predictable.  */ @Override public void open() {     if (!opened) {         opened = true.         buffer.position(0).         buffer.limit(0).     } }
false;public;0;86;;@Override public BufferOrEvent getNext() throws IOException {     if (buffer.remaining() < HEADER_LENGTH) {         buffer.compact().         while (buffer.position() < HEADER_LENGTH) {             if (fileChannel.read(buffer) == -1) {                 if (buffer.position() == 0) {                     // no trailing data                     return null.                 } else {                     throw new IOException("Found trailing incomplete buffer or event").                 }             }         }         buffer.flip().     }     final int channel = buffer.getInt().     final int length = buffer.getInt().     final boolean isBuffer = buffer.get() == 0.     if (isBuffer) {         // deserialize buffer         if (length > pageSize) {             throw new IOException(String.format("Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize)).         }         MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize).         int segPos = 0.         int bytesRemaining = length.         while (true) {             int toCopy = Math.min(buffer.remaining(), bytesRemaining).             if (toCopy > 0) {                 seg.put(segPos, buffer, toCopy).                 segPos += toCopy.                 bytesRemaining -= toCopy.             }             if (bytesRemaining == 0) {                 break.             } else {                 buffer.clear().                 if (fileChannel.read(buffer) == -1) {                     throw new IOException("Found trailing incomplete buffer").                 }                 buffer.flip().             }         }         Buffer buf = new NetworkBuffer(seg, FreeingBufferRecycler.INSTANCE).         buf.setSize(length).         return new BufferOrEvent(buf, channel).     } else {         // deserialize event         if (length > buffer.capacity() - HEADER_LENGTH) {             throw new IOException("Event is too large").         }         if (buffer.remaining() < length) {             buffer.compact().             while (buffer.position() < length) {                 if (fileChannel.read(buffer) == -1) {                     throw new IOException("Found trailing incomplete event").                 }             }             buffer.flip().         }         int oldLimit = buffer.limit().         buffer.limit(buffer.position() + length).         AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader()).         buffer.limit(oldLimit).         return new BufferOrEvent(evt, channel).     } }
false;public;0;7;;@Override public void cleanup() throws IOException {     fileChannel.close().     if (!file.delete()) {         throw new IOException("Cannot remove temp file for stream alignment writer").     } }
false;public;0;4;;@Override public long size() {     return size. }
