commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Configuration getConfiguration() {     return config. }
false;public;1;3;;// ------------------------------------------------------------------------ // Configured Properties // ------------------------------------------------------------------------ public void setVertexID(Integer vertexID) {     config.setInteger(VERTEX_NAME, vertexID). }
false;public;0;3;;public Integer getVertexID() {     return config.getInteger(VERTEX_NAME, -1). }
false;public;1;3;;public void setTimeCharacteristic(TimeCharacteristic characteristic) {     config.setInteger(TIME_CHARACTERISTIC, characteristic.ordinal()). }
false;public;0;8;;public TimeCharacteristic getTimeCharacteristic() {     int ordinal = config.getInteger(TIME_CHARACTERISTIC, -1).     if (ordinal >= 0) {         return TimeCharacteristic.values()[ordinal].     } else {         throw new CorruptConfigurationException("time characteristic is not set").     } }
false;public;1;3;;public void setTypeSerializerIn1(TypeSerializer<?> serializer) {     setTypeSerializer(TYPE_SERIALIZER_IN_1, serializer). }
false;public;1;3;;public void setTypeSerializerIn2(TypeSerializer<?> serializer) {     setTypeSerializer(TYPE_SERIALIZER_IN_2, serializer). }
false;public;1;3;;public void setTypeSerializerOut(TypeSerializer<?> serializer) {     setTypeSerializer(TYPE_SERIALIZER_OUT_1, serializer). }
false;public;2;3;;public void setTypeSerializerSideOut(OutputTag<?> outputTag, TypeSerializer<?> serializer) {     setTypeSerializer(TYPE_SERIALIZER_SIDEOUT_PREFIX + outputTag.getId(), serializer). }
false;public;1;7;;public <T> TypeSerializer<T> getTypeSerializerIn1(ClassLoader cl) {     try {         return InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_IN_1, cl).     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate serializer.", e).     } }
false;public;1;7;;public <T> TypeSerializer<T> getTypeSerializerIn2(ClassLoader cl) {     try {         return InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_IN_2, cl).     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate serializer.", e).     } }
false;public;1;7;;public <T> TypeSerializer<T> getTypeSerializerOut(ClassLoader cl) {     try {         return InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_OUT_1, cl).     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate serializer.", e).     } }
false;public;2;8;;public <T> TypeSerializer<T> getTypeSerializerSideOut(OutputTag<?> outputTag, ClassLoader cl) {     Preconditions.checkNotNull(outputTag, "Side output id must not be null.").     try {         return InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_SIDEOUT_PREFIX + outputTag.getId(), cl).     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate serializer.", e).     } }
false;private;2;7;;private void setTypeSerializer(String key, TypeSerializer<?> typeWrapper) {     try {         InstantiationUtil.writeObjectToConfig(typeWrapper, this.config, key).     } catch (IOException e) {         throw new StreamTaskException("Could not serialize type serializer.", e).     } }
false;public;1;3;;public void setBufferTimeout(long timeout) {     config.setLong(BUFFER_TIMEOUT, timeout). }
false;public;0;3;;public long getBufferTimeout() {     return config.getLong(BUFFER_TIMEOUT, DEFAULT_TIMEOUT). }
false;public;0;3;;public boolean isFlushAlwaysEnabled() {     return getBufferTimeout() == 0. }
false;public;1;12;;public void setStreamOperator(StreamOperator<?> operator) {     if (operator != null) {         config.setClass(USER_FUNCTION, operator.getClass()).         try {             InstantiationUtil.writeObjectToConfig(operator, this.config, SERIALIZEDUDF).         } catch (IOException e) {             throw new StreamTaskException("Cannot serialize operator object " + operator.getClass() + ".", e).         }     } }
false;public;1;20;;public <T extends StreamOperator<?>> T getStreamOperator(ClassLoader cl) {     try {         return InstantiationUtil.readObjectFromConfig(this.config, SERIALIZEDUDF, cl).     } catch (ClassNotFoundException e) {         String classLoaderInfo = ClassLoaderUtil.getUserCodeClassLoaderInfo(cl).         boolean loadableDoubleCheck = ClassLoaderUtil.validateClassLoadable(e, cl).         String exceptionMessage = "Cannot load user class: " + e.getMessage() + "\nClassLoader info: " + classLoaderInfo + (loadableDoubleCheck ? "\nClass was actually found in classloader - deserialization issue." : "\nClass not resolvable through given classloader.").         throw new StreamTaskException(exceptionMessage, e).     } catch (Exception e) {         throw new StreamTaskException("Cannot instantiate user function.", e).     } }
false;public;1;7;;public void setOutputSelectors(List<OutputSelector<?>> outputSelectors) {     try {         InstantiationUtil.writeObjectToConfig(outputSelectors, this.config, OUTPUT_SELECTOR_WRAPPER).     } catch (IOException e) {         throw new StreamTaskException("Could not serialize output selectors", e).     } }
false;public;1;10;;public <T> List<OutputSelector<T>> getOutputSelectors(ClassLoader userCodeClassloader) {     try {         List<OutputSelector<T>> selectors = InstantiationUtil.readObjectFromConfig(this.config, OUTPUT_SELECTOR_WRAPPER, userCodeClassloader).         return selectors == null ? Collections.<OutputSelector<T>>emptyList() : selectors.     } catch (Exception e) {         throw new StreamTaskException("Could not read output selectors", e).     } }
false;public;1;3;;public void setIterationId(String iterationId) {     config.setString(ITERATION_ID, iterationId). }
false;public;0;3;;public String getIterationId() {     return config.getString(ITERATION_ID, ""). }
false;public;1;3;;public void setIterationWaitTime(long time) {     config.setLong(ITERATON_WAIT, time). }
false;public;0;3;;public long getIterationWaitTime() {     return config.getLong(ITERATON_WAIT, 0). }
false;public;1;3;;public void setNumberOfInputs(int numberOfInputs) {     config.setInteger(NUMBER_OF_INPUTS, numberOfInputs). }
false;public;0;3;;public int getNumberOfInputs() {     return config.getInteger(NUMBER_OF_INPUTS, 0). }
false;public;1;3;;public void setNumberOfOutputs(int numberOfOutputs) {     config.setInteger(NUMBER_OF_OUTPUTS, numberOfOutputs). }
false;public;0;3;;public int getNumberOfOutputs() {     return config.getInteger(NUMBER_OF_OUTPUTS, 0). }
false;public;1;7;;public void setNonChainedOutputs(List<StreamEdge> outputvertexIDs) {     try {         InstantiationUtil.writeObjectToConfig(outputvertexIDs, this.config, NONCHAINED_OUTPUTS).     } catch (IOException e) {         throw new StreamTaskException("Cannot serialize non chained outputs.", e).     } }
false;public;1;8;;public List<StreamEdge> getNonChainedOutputs(ClassLoader cl) {     try {         List<StreamEdge> nonChainedOutputs = InstantiationUtil.readObjectFromConfig(this.config, NONCHAINED_OUTPUTS, cl).         return nonChainedOutputs == null ? new ArrayList<StreamEdge>() : nonChainedOutputs.     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate non chained outputs.", e).     } }
false;public;1;7;;public void setChainedOutputs(List<StreamEdge> chainedOutputs) {     try {         InstantiationUtil.writeObjectToConfig(chainedOutputs, this.config, CHAINED_OUTPUTS).     } catch (IOException e) {         throw new StreamTaskException("Cannot serialize chained outputs.", e).     } }
false;public;1;8;;public List<StreamEdge> getChainedOutputs(ClassLoader cl) {     try {         List<StreamEdge> chainedOutputs = InstantiationUtil.readObjectFromConfig(this.config, CHAINED_OUTPUTS, cl).         return chainedOutputs == null ? new ArrayList<StreamEdge>() : chainedOutputs.     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate chained outputs.", e).     } }
false;public;1;7;;public void setOutEdges(List<StreamEdge> outEdges) {     try {         InstantiationUtil.writeObjectToConfig(outEdges, this.config, OUT_STREAM_EDGES).     } catch (IOException e) {         throw new StreamTaskException("Cannot serialize outward edges.", e).     } }
false;public;1;8;;public List<StreamEdge> getOutEdges(ClassLoader cl) {     try {         List<StreamEdge> outEdges = InstantiationUtil.readObjectFromConfig(this.config, OUT_STREAM_EDGES, cl).         return outEdges == null ? new ArrayList<StreamEdge>() : outEdges.     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate outputs.", e).     } }
false;public;1;7;;public void setInPhysicalEdges(List<StreamEdge> inEdges) {     try {         InstantiationUtil.writeObjectToConfig(inEdges, this.config, IN_STREAM_EDGES).     } catch (IOException e) {         throw new StreamTaskException("Cannot serialize inward edges.", e).     } }
false;public;1;8;;public List<StreamEdge> getInPhysicalEdges(ClassLoader cl) {     try {         List<StreamEdge> inEdges = InstantiationUtil.readObjectFromConfig(this.config, IN_STREAM_EDGES, cl).         return inEdges == null ? new ArrayList<StreamEdge>() : inEdges.     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate inputs.", e).     } }
false;public;1;3;;// --------------------- checkpointing ----------------------- public void setCheckpointingEnabled(boolean enabled) {     config.setBoolean(CHECKPOINTING_ENABLED, enabled). }
false;public;0;3;;public boolean isCheckpointingEnabled() {     return config.getBoolean(CHECKPOINTING_ENABLED, false). }
false;public;1;3;;public void setCheckpointMode(CheckpointingMode mode) {     config.setInteger(CHECKPOINT_MODE, mode.ordinal()). }
false;public;0;8;;public CheckpointingMode getCheckpointMode() {     int ordinal = config.getInteger(CHECKPOINT_MODE, -1).     if (ordinal >= 0) {         return CheckpointingMode.values()[ordinal].     } else {         return DEFAULT_CHECKPOINTING_MODE.     } }
false;public;1;7;;public void setOutEdgesInOrder(List<StreamEdge> outEdgeList) {     try {         InstantiationUtil.writeObjectToConfig(outEdgeList, this.config, EDGES_IN_ORDER).     } catch (IOException e) {         throw new StreamTaskException("Could not serialize outputs in order.", e).     } }
false;public;1;8;;public List<StreamEdge> getOutEdgesInOrder(ClassLoader cl) {     try {         List<StreamEdge> outEdgesInOrder = InstantiationUtil.readObjectFromConfig(this.config, EDGES_IN_ORDER, cl).         return outEdgesInOrder == null ? new ArrayList<StreamEdge>() : outEdgesInOrder.     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate outputs in order.", e).     } }
false;public;1;8;;public void setTransitiveChainedTaskConfigs(Map<Integer, StreamConfig> chainedTaskConfigs) {     try {         InstantiationUtil.writeObjectToConfig(chainedTaskConfigs, this.config, CHAINED_TASK_CONFIG).     } catch (IOException e) {         throw new StreamTaskException("Could not serialize configuration.", e).     } }
false;public;1;8;;public Map<Integer, StreamConfig> getTransitiveChainedTaskConfigs(ClassLoader cl) {     try {         Map<Integer, StreamConfig> confs = InstantiationUtil.readObjectFromConfig(this.config, CHAINED_TASK_CONFIG, cl).         return confs == null ? new HashMap<Integer, StreamConfig>() : confs.     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate configuration.", e).     } }
false;public;1;6;;public Map<Integer, StreamConfig> getTransitiveChainedTaskConfigsWithSelf(ClassLoader cl) {     // TODO: could this logic be moved to the user of #setTransitiveChainedTaskConfigs() ?     Map<Integer, StreamConfig> chainedTaskConfigs = getTransitiveChainedTaskConfigs(cl).     chainedTaskConfigs.put(getVertexID(), this).     return chainedTaskConfigs. }
false;public;1;3;;public void setOperatorID(OperatorID operatorID) {     this.config.setBytes(OPERATOR_ID, operatorID.getBytes()). }
false;public;0;4;;public OperatorID getOperatorID() {     byte[] operatorIDBytes = config.getBytes(OPERATOR_ID, null).     return new OperatorID(Preconditions.checkNotNull(operatorIDBytes)). }
false;public;1;3;;public void setOperatorName(String name) {     this.config.setString(OPERATOR_NAME, name). }
false;public;0;3;;public String getOperatorName() {     return this.config.getString(OPERATOR_NAME, null). }
false;public;1;3;;public void setChainIndex(int index) {     this.config.setInteger(CHAIN_INDEX, index). }
false;public;0;3;;public int getChainIndex() {     return this.config.getInteger(CHAIN_INDEX, 0). }
false;public;1;9;;// ------------------------------------------------------------------------ // State backend // ------------------------------------------------------------------------ public void setStateBackend(StateBackend backend) {     if (backend != null) {         try {             InstantiationUtil.writeObjectToConfig(backend, this.config, STATE_BACKEND).         } catch (Exception e) {             throw new StreamTaskException("Could not serialize stateHandle provider.", e).         }     } }
false;public;1;7;;public StateBackend getStateBackend(ClassLoader cl) {     try {         return InstantiationUtil.readObjectFromConfig(this.config, STATE_BACKEND, cl).     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate statehandle provider.", e).     } }
false;public;0;3;;public byte[] getSerializedStateBackend() {     return this.config.getBytes(STATE_BACKEND, null). }
false;public;2;7;;public void setStatePartitioner(int input, KeySelector<?, ?> partitioner) {     try {         InstantiationUtil.writeObjectToConfig(partitioner, this.config, STATE_PARTITIONER + input).     } catch (IOException e) {         throw new StreamTaskException("Could not serialize state partitioner.", e).     } }
false;public;2;7;;public KeySelector<?, Serializable> getStatePartitioner(int input, ClassLoader cl) {     try {         return InstantiationUtil.readObjectFromConfig(this.config, STATE_PARTITIONER + input, cl).     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate state partitioner.", e).     } }
false;public;1;7;;public void setStateKeySerializer(TypeSerializer<?> serializer) {     try {         InstantiationUtil.writeObjectToConfig(serializer, this.config, STATE_KEY_SERIALIZER).     } catch (IOException e) {         throw new StreamTaskException("Could not serialize state key serializer.", e).     } }
false;public;1;7;;public <K> TypeSerializer<K> getStateKeySerializer(ClassLoader cl) {     try {         return InstantiationUtil.readObjectFromConfig(this.config, STATE_KEY_SERIALIZER, cl).     } catch (Exception e) {         throw new StreamTaskException("Could not instantiate state key serializer from task config.", e).     } }
false;public;0;3;;// ------------------------------------------------------------------------ // Miscellaneous // ------------------------------------------------------------------------ public void setChainStart() {     config.setBoolean(IS_CHAINED_VERTEX, true). }
false;public;0;3;;public boolean isChainStart() {     return config.getBoolean(IS_CHAINED_VERTEX, false). }
false;public;0;3;;public void setChainEnd() {     config.setBoolean(CHAIN_END, true). }
false;public;0;3;;public boolean isChainEnd() {     return config.getBoolean(CHAIN_END, false). }
false;public;0;35;;@Override public String toString() {     ClassLoader cl = getClass().getClassLoader().     StringBuilder builder = new StringBuilder().     builder.append("\n=======================").     builder.append("Stream Config").     builder.append("=======================").     builder.append("\nNumber of non-chained inputs: ").append(getNumberOfInputs()).     builder.append("\nNumber of non-chained outputs: ").append(getNumberOfOutputs()).     builder.append("\nOutput names: ").append(getNonChainedOutputs(cl)).     builder.append("\nPartitioning:").     for (StreamEdge output : getNonChainedOutputs(cl)) {         int outputname = output.getTargetId().         builder.append("\n\t").append(outputname).append(": ").append(output.getPartitioner()).     }     builder.append("\nChained subtasks: ").append(getChainedOutputs(cl)).     try {         builder.append("\nOperator: ").append(getStreamOperator(cl).getClass().getSimpleName()).     } catch (Exception e) {         builder.append("\nOperator: Missing").     }     builder.append("\nBuffer timeout: ").append(getBufferTimeout()).     builder.append("\nState Monitoring: ").append(isCheckpointingEnabled()).     if (isChainStart() && getChainedOutputs(cl).size() > 0) {         builder.append("\n\n\n---------------------\nChained task configs\n---------------------\n").         builder.append(getTransitiveChainedTaskConfigs(cl)).     }     return builder.toString(). }
