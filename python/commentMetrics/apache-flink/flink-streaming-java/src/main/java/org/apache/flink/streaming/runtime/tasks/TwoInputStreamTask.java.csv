commented;modifiers;parameterAmount;loc;comment;code
false;public;0;50;;@Override public void init() throws Exception {     StreamConfig configuration = getConfiguration().     ClassLoader userClassLoader = getUserCodeClassLoader().     TypeSerializer<IN1> inputDeserializer1 = configuration.getTypeSerializerIn1(userClassLoader).     TypeSerializer<IN2> inputDeserializer2 = configuration.getTypeSerializerIn2(userClassLoader).     int numberOfInputs = configuration.getNumberOfInputs().     ArrayList<InputGate> inputList1 = new ArrayList<InputGate>().     ArrayList<InputGate> inputList2 = new ArrayList<InputGate>().     List<StreamEdge> inEdges = configuration.getInPhysicalEdges(userClassLoader).     for (int i = 0. i < numberOfInputs. i++) {         int inputType = inEdges.get(i).getTypeNumber().         InputGate reader = getEnvironment().getInputGate(i).         switch(inputType) {             case 1:                 inputList1.add(reader).                 break.             case 2:                 inputList2.add(reader).                 break.             default:                 throw new RuntimeException("Invalid input type number: " + inputType).         }     }     this.inputProcessor = new StreamTwoInputProcessor<>(inputList1, inputList2, inputDeserializer1, inputDeserializer2, this, configuration.getCheckpointMode(), getCheckpointLock(), getEnvironment().getIOManager(), getEnvironment().getTaskManagerInfo().getConfiguration(), getStreamStatusMaintainer(), this.headOperator, getEnvironment().getMetricGroup().getIOMetricGroup(), input1WatermarkGauge, input2WatermarkGauge).     headOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, minInputWatermarkGauge).     headOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_1_WATERMARK, input1WatermarkGauge).     headOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_2_WATERMARK, input2WatermarkGauge).     // wrap watermark gauge since registered metrics must be unique     getEnvironment().getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, minInputWatermarkGauge::getValue). }
false;protected;0;9;;@Override protected void run() throws Exception {     // cache processor reference on the stack, to make the code more JIT friendly     final StreamTwoInputProcessor<IN1, IN2> inputProcessor = this.inputProcessor.     while (running && inputProcessor.processInput()) {     // all the work happens in the "processInput" method     } }
false;protected;0;6;;@Override protected void cleanup() throws Exception {     if (inputProcessor != null) {         inputProcessor.cleanup().     } }
false;protected;0;4;;@Override protected void cancelTask() {     running = false. }
