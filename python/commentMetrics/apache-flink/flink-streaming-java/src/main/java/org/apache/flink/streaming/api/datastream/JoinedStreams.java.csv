commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * Specifies a {@link KeySelector} for elements from the first input.  *  * @param keySelector The KeySelector to be used for extracting the key for partitioning.  */ ;/**  * Specifies a {@link KeySelector} for elements from the first input.  *  * @param keySelector The KeySelector to be used for extracting the key for partitioning.  */ public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector) {     requireNonNull(keySelector).     final TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType()).     return where(keySelector, keyType). }
true;public;2;5;/**  * Specifies a {@link KeySelector} for elements from the first input with explicit type information for the key type.  *  * @param keySelector The KeySelector to be used for extracting the first input's key for partitioning.  * @param keyType The type information describing the key type.  */ ;/**  * Specifies a {@link KeySelector} for elements from the first input with explicit type information for the key type.  *  * @param keySelector The KeySelector to be used for extracting the first input's key for partitioning.  * @param keyType The type information describing the key type.  */ public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType) {     requireNonNull(keySelector).     requireNonNull(keyType).     return new Where<>(input1.clean(keySelector), keyType). }
true;public;1;5;/**  * Specifies a {@link KeySelector} for elements from the second input.  *  * @param keySelector The KeySelector to be used for extracting the second input's key for partitioning.  */ ;/**  * Specifies a {@link KeySelector} for elements from the second input.  *  * @param keySelector The KeySelector to be used for extracting the second input's key for partitioning.  */ public EqualTo equalTo(KeySelector<T2, KEY> keySelector) {     requireNonNull(keySelector).     final TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType()).     return equalTo(keySelector, otherKey). }
true;public;2;11;/**  * Specifies a {@link KeySelector} for elements from the second input with explicit type information for the key type.  *  * @param keySelector The KeySelector to be used for extracting the second input's key for partitioning.  * @param keyType The type information describing the key type.  */ ;/**  * Specifies a {@link KeySelector} for elements from the second input with explicit type information for the key type.  *  * @param keySelector The KeySelector to be used for extracting the second input's key for partitioning.  * @param keyType The type information describing the key type.  */ public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType) {     requireNonNull(keySelector).     requireNonNull(keyType).     if (!keyType.equals(this.keyType)) {         throw new IllegalArgumentException("The keys for the two inputs are not equal: " + "first key = " + this.keyType + " , second key = " + keyType).     }     return new EqualTo(input2.clean(keySelector)). }
true;public;1;4;/**  * Specifies the window on which the join operation works.  */ ;/**  * Specifies the window on which the join operation works.  */ @PublicEvolving public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {     return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null, null). }
true;public;1;5;/**  * Sets the {@code Trigger} that should be used to trigger window emission.  */ ;/**  * Sets the {@code Trigger} that should be used to trigger window emission.  */ @PublicEvolving public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {     return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, windowAssigner, newTrigger, evictor, allowedLateness). }
true;public;1;5;/**  * Sets the {@code Evictor} that should be used to evict elements from a window before emission.  *  * <p>Note: When using an evictor window performance will degrade significantly, since  * pre-aggregation of window results cannot be used.  */ ;/**  * Sets the {@code Evictor} that should be used to evict elements from a window before emission.  *  * <p>Note: When using an evictor window performance will degrade significantly, since  * pre-aggregation of window results cannot be used.  */ @PublicEvolving public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {     return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, windowAssigner, trigger, newEvictor, allowedLateness). }
true;public;1;5;/**  * Sets the time by which elements are allowed to be late.  * @see WindowedStream#allowedLateness(Time)  */ ;/**  * Sets the time by which elements are allowed to be late.  * @see WindowedStream#allowedLateness(Time)  */ @PublicEvolving public WithWindow<T1, T2, KEY, W> allowedLateness(Time newLateness) {     return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, windowAssigner, trigger, evictor, newLateness). }
true;public;1;15;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p>Note: This method's return type does not support setting an operator-specific parallelism.  * Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(JoinFunction)}  * method to set an operator-specific parallelism.  */ ;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p>Note: This method's return type does not support setting an operator-specific parallelism.  * Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(JoinFunction)}  * method to set an operator-specific parallelism.  */ public <T> DataStream<T> apply(JoinFunction<T1, T2, T> function) {     TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(function, JoinFunction.class, 0, 1, 2, TypeExtractor.NO_INDEX, input1.getType(), input2.getType(), "Join", false).     return apply(function, resultType). }
true;public;1;5;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p><b>Note:</b> This is a temporary workaround while the {@link #apply(JoinFunction)}  * method has the wrong return type and hence does not allow one to set an operator-specific  * parallelism  *  * @deprecated This method will be removed once the {@link #apply(JoinFunction)} method is fixed  *             in the next major version of Flink (2.0).  */ ;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p><b>Note:</b> This is a temporary workaround while the {@link #apply(JoinFunction)}  * method has the wrong return type and hence does not allow one to set an operator-specific  * parallelism  *  * @deprecated This method will be removed once the {@link #apply(JoinFunction)} method is fixed  *             in the next major version of Flink (2.0).  */ @PublicEvolving @Deprecated public <T> SingleOutputStreamOperator<T> with(JoinFunction<T1, T2, T> function) {     return (SingleOutputStreamOperator<T>) apply(function). }
true;public;2;15;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p>Note: This method's return type does not support setting an operator-specific parallelism.  * Due to binary backwards compatibility, this cannot be altered. Use the  * {@link #with(JoinFunction, TypeInformation)}, method to set an operator-specific parallelism.  */ ;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p>Note: This method's return type does not support setting an operator-specific parallelism.  * Due to binary backwards compatibility, this cannot be altered. Use the  * {@link #with(JoinFunction, TypeInformation)}, method to set an operator-specific parallelism.  */ public <T> DataStream<T> apply(FlatJoinFunction<T1, T2, T> function, TypeInformation<T> resultType) {     // clean the closure     function = input1.getExecutionEnvironment().clean(function).     coGroupedWindowedStream = input1.coGroup(input2).where(keySelector1).equalTo(keySelector2).window(windowAssigner).trigger(trigger).evictor(evictor).allowedLateness(allowedLateness).     return coGroupedWindowedStream.apply(new FlatJoinCoGroupFunction<>(function), resultType). }
true;public;2;5;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p><b>Note:</b> This is a temporary workaround while the {@link #apply(JoinFunction, TypeInformation)}  * method has the wrong return type and hence does not allow one to set an operator-specific  * parallelism  *  * @deprecated This method will be replaced by {@link #apply(FlatJoinFunction, TypeInformation)} in Flink 2.0.  * So use the {@link #apply(FlatJoinFunction, TypeInformation)} in the future.  */ ;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p><b>Note:</b> This is a temporary workaround while the {@link #apply(JoinFunction, TypeInformation)}  * method has the wrong return type and hence does not allow one to set an operator-specific  * parallelism  *  * @deprecated This method will be replaced by {@link #apply(FlatJoinFunction, TypeInformation)} in Flink 2.0.  * So use the {@link #apply(FlatJoinFunction, TypeInformation)} in the future.  */ @PublicEvolving @Deprecated public <T> SingleOutputStreamOperator<T> with(FlatJoinFunction<T1, T2, T> function, TypeInformation<T> resultType) {     return (SingleOutputStreamOperator<T>) apply(function, resultType). }
true;public;1;15;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p>Note: This method's return type does not support setting an operator-specific parallelism.  * Due to binary backwards compatibility, this cannot be altered. Use the  * {@link #with(FlatJoinFunction)}, method to set an operator-specific parallelism.  */ ;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p>Note: This method's return type does not support setting an operator-specific parallelism.  * Due to binary backwards compatibility, this cannot be altered. Use the  * {@link #with(FlatJoinFunction)}, method to set an operator-specific parallelism.  */ public <T> DataStream<T> apply(FlatJoinFunction<T1, T2, T> function) {     TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(function, FlatJoinFunction.class, 0, 1, 2, new int[] { 2, 0 }, input1.getType(), input2.getType(), "Join", false).     return apply(function, resultType). }
true;public;1;5;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p><b>Note:</b> This is a temporary workaround while the {@link #apply(FlatJoinFunction)}  * method has the wrong return type and hence does not allow one to set an operator-specific  * parallelism.  *  * @deprecated This method will be removed once the {@link #apply(FlatJoinFunction)}  *             method is fixed in the next major version of Flink (2.0).  */ ;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p><b>Note:</b> This is a temporary workaround while the {@link #apply(FlatJoinFunction)}  * method has the wrong return type and hence does not allow one to set an operator-specific  * parallelism.  *  * @deprecated This method will be removed once the {@link #apply(FlatJoinFunction)}  *             method is fixed in the next major version of Flink (2.0).  */ @PublicEvolving @Deprecated public <T> SingleOutputStreamOperator<T> with(FlatJoinFunction<T1, T2, T> function) {     return (SingleOutputStreamOperator<T>) apply(function). }
true;public;2;15;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p>Note: This method's return type does not support setting an operator-specific parallelism.  * Due to binary backwards compatibility, this cannot be altered. Use the  * {@link #with(JoinFunction, TypeInformation)}, method to set an operator-specific parallelism.  */ ;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p>Note: This method's return type does not support setting an operator-specific parallelism.  * Due to binary backwards compatibility, this cannot be altered. Use the  * {@link #with(JoinFunction, TypeInformation)}, method to set an operator-specific parallelism.  */ public <T> DataStream<T> apply(JoinFunction<T1, T2, T> function, TypeInformation<T> resultType) {     // clean the closure     function = input1.getExecutionEnvironment().clean(function).     coGroupedWindowedStream = input1.coGroup(input2).where(keySelector1).equalTo(keySelector2).window(windowAssigner).trigger(trigger).evictor(evictor).allowedLateness(allowedLateness).     return coGroupedWindowedStream.apply(new JoinCoGroupFunction<>(function), resultType). }
true;public;2;5;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p><b>Note:</b> This is a temporary workaround while the {@link #apply(FlatJoinFunction, TypeInformation)}  * method has the wrong return type and hence does not allow one to set an operator-specific  * parallelism  *  * @deprecated This method will be removed once the {@link #apply(JoinFunction, TypeInformation)}  *             method is fixed in the next major version of Flink (2.0).  */ ;/**  * Completes the join operation with the user function that is executed  * for each combination of elements with the same key in a window.  *  * <p><b>Note:</b> This is a temporary workaround while the {@link #apply(FlatJoinFunction, TypeInformation)}  * method has the wrong return type and hence does not allow one to set an operator-specific  * parallelism  *  * @deprecated This method will be removed once the {@link #apply(JoinFunction, TypeInformation)}  *             method is fixed in the next major version of Flink (2.0).  */ @PublicEvolving @Deprecated public <T> SingleOutputStreamOperator<T> with(JoinFunction<T1, T2, T> function, TypeInformation<T> resultType) {     return (SingleOutputStreamOperator<T>) apply(function, resultType). }
false;;0;4;;@VisibleForTesting Time getAllowedLateness() {     return allowedLateness. }
false;;0;4;;@VisibleForTesting CoGroupedStreams.WithWindow<T1, T2, KEY, W> getCoGroupedWindowedStream() {     return coGroupedWindowedStream. }
false;public;3;8;;@Override public void coGroup(Iterable<T1> first, Iterable<T2> second, Collector<T> out) throws Exception {     for (T1 val1 : first) {         for (T2 val2 : second) {             out.collect(wrappedFunction.join(val1, val2)).         }     } }
false;public;3;8;;@Override public void coGroup(Iterable<T1> first, Iterable<T2> second, Collector<T> out) throws Exception {     for (T1 val1 : first) {         for (T2 val2 : second) {             wrappedFunction.join(val1, val2, out).         }     } }
