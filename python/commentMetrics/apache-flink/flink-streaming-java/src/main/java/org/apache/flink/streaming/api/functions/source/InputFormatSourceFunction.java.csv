commented;modifiers;parameterAmount;loc;comment;code
false;public;1;15;;@Override @SuppressWarnings("unchecked") public void open(Configuration parameters) throws Exception {     StreamingRuntimeContext context = (StreamingRuntimeContext) getRuntimeContext().     if (format instanceof RichInputFormat) {         ((RichInputFormat) format).setRuntimeContext(context).     }     format.configure(parameters).     provider = context.getInputSplitProvider().     serializer = typeInfo.createSerializer(getRuntimeContext().getExecutionConfig()).     splitIterator = getInputSplits().     isRunning = splitIterator.hasNext(). }
false;public;1;39;;@Override public void run(SourceContext<OUT> ctx) throws Exception {     try {         Counter completedSplitsCounter = getRuntimeContext().getMetricGroup().counter("numSplitsProcessed").         if (isRunning && format instanceof RichInputFormat) {             ((RichInputFormat) format).openInputFormat().         }         OUT nextElement = serializer.createInstance().         while (isRunning) {             format.open(splitIterator.next()).             while (isRunning && !format.reachedEnd()) {                 nextElement = format.nextRecord(nextElement).                 if (nextElement != null) {                     ctx.collect(nextElement).                 } else {                     break.                 }             }             format.close().             completedSplitsCounter.inc().             if (isRunning) {                 isRunning = splitIterator.hasNext().             }         }     } finally {         format.close().         if (format instanceof RichInputFormat) {             ((RichInputFormat) format).closeInputFormat().         }         isRunning = false.     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;0;7;;@Override public void close() throws Exception {     format.close().     if (format instanceof RichInputFormat) {         ((RichInputFormat) format).closeInputFormat().     } }
true;public;0;3;/**  * Returns the {@code InputFormat}. This is only needed because we need to set the input  * split assigner on the {@code StreamGraph}.  */ ;/**  * Returns the {@code InputFormat}. This is only needed because we need to set the input  * split assigner on the {@code StreamGraph}.  */ public InputFormat<OUT, InputSplit> getFormat() {     return format. }
false;public;0;25;;@Override public boolean hasNext() {     if (exhausted) {         return false.     }     if (nextSplit != null) {         return true.     }     final InputSplit split.     try {         split = provider.getNextInputSplit(getRuntimeContext().getUserCodeClassLoader()).     } catch (InputSplitProviderException e) {         throw new RuntimeException("Could not retrieve next input split.", e).     }     if (split != null) {         this.nextSplit = split.         return true.     } else {         exhausted = true.         return false.     } }
false;public;0;10;;@Override public InputSplit next() {     if (this.nextSplit == null && !hasNext()) {         throw new NoSuchElementException().     }     final InputSplit tmp = this.nextSplit.     this.nextSplit = null.     return tmp. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;private;0;51;;private Iterator<InputSplit> getInputSplits() {     return new Iterator<InputSplit>() {          private InputSplit nextSplit.          private boolean exhausted.          @Override         public boolean hasNext() {             if (exhausted) {                 return false.             }             if (nextSplit != null) {                 return true.             }             final InputSplit split.             try {                 split = provider.getNextInputSplit(getRuntimeContext().getUserCodeClassLoader()).             } catch (InputSplitProviderException e) {                 throw new RuntimeException("Could not retrieve next input split.", e).             }             if (split != null) {                 this.nextSplit = split.                 return true.             } else {                 exhausted = true.                 return false.             }         }          @Override         public InputSplit next() {             if (this.nextSplit == null && !hasNext()) {                 throw new NoSuchElementException().             }             final InputSplit tmp = this.nextSplit.             this.nextSplit = null.             return tmp.         }          @Override         public void remove() {             throw new UnsupportedOperationException().         }     }. }
