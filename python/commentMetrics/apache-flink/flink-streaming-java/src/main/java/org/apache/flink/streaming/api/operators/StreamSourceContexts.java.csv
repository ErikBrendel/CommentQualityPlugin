commented;modifiers;parameterAmount;loc;comment;code
true;public,static;7;38;/**  * Depending on the {@link TimeCharacteristic}, this method will return the adequate  * {@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:  * <ul>  *     <li>{@link TimeCharacteristic#IngestionTime} = {@code AutomaticWatermarkContext}</li>  *     <li>{@link TimeCharacteristic#ProcessingTime} = {@code NonTimestampContext}</li>  *     <li>{@link TimeCharacteristic#EventTime} = {@code ManualWatermarkContext}</li>  * </ul>  */ ;/**  * Depending on the {@link TimeCharacteristic}, this method will return the adequate  * {@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:  * <ul>  *     <li>{@link TimeCharacteristic#IngestionTime} = {@code AutomaticWatermarkContext}</li>  *     <li>{@link TimeCharacteristic#ProcessingTime} = {@code NonTimestampContext}</li>  *     <li>{@link TimeCharacteristic#EventTime} = {@code ManualWatermarkContext}</li>  * </ul>  */ public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(TimeCharacteristic timeCharacteristic, ProcessingTimeService processingTimeService, Object checkpointLock, StreamStatusMaintainer streamStatusMaintainer, Output<StreamRecord<OUT>> output, long watermarkInterval, long idleTimeout) {     final SourceFunction.SourceContext<OUT> ctx.     switch(timeCharacteristic) {         case EventTime:             ctx = new ManualWatermarkContext<>(output, processingTimeService, checkpointLock, streamStatusMaintainer, idleTimeout).             break.         case IngestionTime:             ctx = new AutomaticWatermarkContext<>(output, watermarkInterval, processingTimeService, checkpointLock, streamStatusMaintainer, idleTimeout).             break.         case ProcessingTime:             ctx = new NonTimestampContext<>(checkpointLock, output).             break.         default:             throw new IllegalArgumentException(String.valueOf(timeCharacteristic)).     }     return ctx. }
false;public;1;6;;@Override public void collect(T element) {     synchronized (lock) {         output.collect(reuse.replace(element)).     } }
false;public;2;5;;@Override public void collectWithTimestamp(T element, long timestamp) {     // ignore the timestamp     collect(element). }
false;public;1;4;;@Override public void emitWatermark(Watermark mark) { // do nothing }
false;public;0;4;;@Override public void markAsTemporarilyIdle() { // do nothing }
false;public;0;4;;@Override public Object getCheckpointLock() {     return lock. }
false;public;0;2;;@Override public void close() { }
false;protected;1;18;;@Override protected void processAndCollect(T element) {     lastRecordTime = this.timeService.getCurrentProcessingTime().     output.collect(reuse.replace(element, lastRecordTime)).     // emission task.     if (lastRecordTime > nextWatermarkTime) {         // in case we jumped some watermarks, recompute the next watermark time         final long watermarkTime = lastRecordTime - (lastRecordTime % watermarkInterval).         nextWatermarkTime = watermarkTime + watermarkInterval.         output.emitWatermark(new Watermark(watermarkTime)).     // we do not need to register another timer here     // because the emitting task will do so.     } }
false;protected;2;4;;@Override protected void processAndCollectWithTimestamp(T element, long timestamp) {     processAndCollect(element). }
false;protected;1;5;;@Override protected boolean allowWatermark(Watermark mark) {     // allow Long.MAX_VALUE since this is the special end-watermark that for example the Kafka source emits     return mark.getTimestamp() == Long.MAX_VALUE && nextWatermarkTime != Long.MAX_VALUE. }
true;protected;1;13;/**  * This will only be called if allowWatermark returned {@code true}.  */ ;/**  * This will only be called if allowWatermark returned {@code true}.  */ @Override protected void processAndEmitWatermark(Watermark mark) {     nextWatermarkTime = Long.MAX_VALUE.     output.emitWatermark(mark).     // we can shutdown the watermark timer now, no watermarks will be needed any more.     // Note that this procedure actually doesn't need to be synchronized with the lock,     // but since it's only a one-time thing, doesn't hurt either     final ScheduledFuture<?> nextWatermarkTimer = this.nextWatermarkTimer.     if (nextWatermarkTimer != null) {         nextWatermarkTimer.cancel(true).     } }
false;public;0;9;;@Override public void close() {     super.close().     final ScheduledFuture<?> nextWatermarkTimer = this.nextWatermarkTimer.     if (nextWatermarkTimer != null) {         nextWatermarkTimer.cancel(true).     } }
false;public;1;31;;@Override public void onProcessingTime(long timestamp) {     final long currentTime = timeService.getCurrentProcessingTime().     synchronized (lock) {         // we should continue to automatically emit watermarks if we are active         if (streamStatusMaintainer.getStreamStatus().isActive()) {             if (idleTimeout != -1 && currentTime - lastRecordTime > idleTimeout) {                 // if we are configured to detect idleness, piggy-back the idle detection check on the                 // watermark interval, so that we may possibly discover idle sources faster before waiting                 // for the next idle check to fire                 markAsTemporarilyIdle().                 // no need to finish the next check, as we are now idle.                 cancelNextIdleDetectionTask().             } else if (currentTime > nextWatermarkTime) {                 // align the watermarks across all machines. this will ensure that we                 // don't have watermarks that creep along at different intervals because                 // the machine clocks are out of sync                 final long watermarkTime = currentTime - (currentTime % watermarkInterval).                 output.emitWatermark(new Watermark(watermarkTime)).                 nextWatermarkTime = watermarkTime + watermarkInterval.             }         }     }     long nextWatermark = currentTime + watermarkInterval.     nextWatermarkTimer = this.timeService.registerTimer(nextWatermark, new WatermarkEmittingTask(this.timeService, lock, output)). }
false;protected;1;4;;@Override protected void processAndCollect(T element) {     output.collect(reuse.replace(element)). }
false;protected;2;4;;@Override protected void processAndCollectWithTimestamp(T element, long timestamp) {     output.collect(reuse.replace(element, timestamp)). }
false;protected;1;4;;@Override protected void processAndEmitWatermark(Watermark mark) {     output.emitWatermark(mark). }
false;protected;1;4;;@Override protected boolean allowWatermark(Watermark mark) {     return true. }
false;public;1;14;;@Override public void collect(T element) {     synchronized (checkpointLock) {         streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE).         if (nextCheck != null) {             this.failOnNextCheck = false.         } else {             scheduleNextIdleDetectionTask().         }         processAndCollect(element).     } }
false;public;2;14;;@Override public void collectWithTimestamp(T element, long timestamp) {     synchronized (checkpointLock) {         streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE).         if (nextCheck != null) {             this.failOnNextCheck = false.         } else {             scheduleNextIdleDetectionTask().         }         processAndCollectWithTimestamp(element, timestamp).     } }
false;public;1;16;;@Override public void emitWatermark(Watermark mark) {     if (allowWatermark(mark)) {         synchronized (checkpointLock) {             streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE).             if (nextCheck != null) {                 this.failOnNextCheck = false.             } else {                 scheduleNextIdleDetectionTask().             }             processAndEmitWatermark(mark).         }     } }
false;public;0;6;;@Override public void markAsTemporarilyIdle() {     synchronized (checkpointLock) {         streamStatusMaintainer.toggleStreamStatus(StreamStatus.IDLE).     } }
false;public;0;4;;@Override public Object getCheckpointLock() {     return checkpointLock. }
false;public;0;4;;@Override public void close() {     cancelNextIdleDetectionTask(). }
false;public;1;15;;@Override public void onProcessingTime(long timestamp) throws Exception {     synchronized (checkpointLock) {         // set this to null now.         // the next idleness detection will be scheduled again         // depending on the below failOnNextCheck condition         nextCheck = null.         if (failOnNextCheck) {             markAsTemporarilyIdle().         } else {             scheduleNextIdleDetectionTask().         }     } }
false;private;0;9;;private void scheduleNextIdleDetectionTask() {     if (idleTimeout != -1) {         // reset flag. if it remains true when task fires, we have detected idleness         failOnNextCheck = true.         nextCheck = this.timeService.registerTimer(this.timeService.getCurrentProcessingTime() + idleTimeout, new IdlenessDetectionTask()).     } }
false;protected;0;6;;protected void cancelNextIdleDetectionTask() {     final ScheduledFuture<?> nextCheck = this.nextCheck.     if (nextCheck != null) {         nextCheck.cancel(true).     } }
true;protected,abstract;1;1;/**  * Process and collect record.  */ ;// ------------------------------------------------------------------------ // Abstract methods for concrete subclasses to implement. // These methods are guaranteed to be synchronized on the checkpoint lock, // so implementations don't need to do so. // ------------------------------------------------------------------------ /**  * Process and collect record.  */ protected abstract void processAndCollect(T element).
true;protected,abstract;2;1;/**  * Process and collect record with timestamp.  */ ;/**  * Process and collect record with timestamp.  */ protected abstract void processAndCollectWithTimestamp(T element, long timestamp).
true;protected,abstract;1;1;/**  * Whether or not a watermark should be allowed.  */ ;/**  * Whether or not a watermark should be allowed.  */ protected abstract boolean allowWatermark(Watermark mark).
true;protected,abstract;1;1;/**  * Process and emit watermark. Only called if  * {@link WatermarkContext#allowWatermark(Watermark)} returns {@code true}.  */ ;/**  * Process and emit watermark. Only called if  * {@link WatermarkContext#allowWatermark(Watermark)} returns {@code true}.  */ protected abstract void processAndEmitWatermark(Watermark mark).
