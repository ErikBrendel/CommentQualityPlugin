commented;modifiers;parameterAmount;loc;comment;code
false;public;0;21;;@Override public void run() {     try {         while (running) {             LOG.debug("Wait for next completed async stream element result.").             AsyncResult streamElementEntry = streamElementQueue.peekBlockingly().             output(streamElementEntry).         }     } catch (InterruptedException e) {         if (running) {             operatorActions.failOperator(e).         } else {             // Thread got interrupted which means that it should shut down             LOG.debug("Emitter thread got interrupted, shutting down.").         }     } catch (Throwable t) {         operatorActions.failOperator(new Exception("AsyncWaitOperator's emitter caught an " + "unexpected throwable.", t)).     } }
false;private;1;52;;private void output(AsyncResult asyncResult) throws InterruptedException {     if (asyncResult.isWatermark()) {         synchronized (checkpointLock) {             AsyncWatermarkResult asyncWatermarkResult = asyncResult.asWatermark().             LOG.debug("Output async watermark.").             output.emitWatermark(asyncWatermarkResult.getWatermark()).             // remove the peeked element from the async collector buffer so that it is no longer             // checkpointed             streamElementQueue.poll().             // notify the main thread that there is again space left in the async collector             // buffer             checkpointLock.notifyAll().         }     } else {         AsyncCollectionResult<OUT> streamRecordResult = asyncResult.asResultCollection().         if (streamRecordResult.hasTimestamp()) {             timestampedCollector.setAbsoluteTimestamp(streamRecordResult.getTimestamp()).         } else {             timestampedCollector.eraseTimestamp().         }         synchronized (checkpointLock) {             LOG.debug("Output async stream element collection result.").             try {                 Collection<OUT> resultCollection = streamRecordResult.get().                 if (resultCollection != null) {                     for (OUT result : resultCollection) {                         timestampedCollector.collect(result).                     }                 }             } catch (Exception e) {                 operatorActions.failOperator(new Exception("An async function call terminated with an exception. " + "Failing the AsyncWaitOperator.", e)).             }             // remove the peeked element from the async collector buffer so that it is no longer             // checkpointed             streamElementQueue.poll().             // notify the main thread that there is again space left in the async collector             // buffer             checkpointLock.notifyAll().         }     } }
false;public;0;3;;public void stop() {     running = false. }
