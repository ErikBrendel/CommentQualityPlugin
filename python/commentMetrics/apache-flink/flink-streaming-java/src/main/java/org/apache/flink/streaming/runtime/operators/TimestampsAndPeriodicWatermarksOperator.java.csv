commented;modifiers;parameterAmount;loc;comment;code
false;public;0;12;;@Override public void open() throws Exception {     super.open().     currentWatermark = Long.MIN_VALUE.     watermarkInterval = getExecutionConfig().getAutoWatermarkInterval().     if (watermarkInterval > 0) {         long now = getProcessingTimeService().getCurrentProcessingTime().         getProcessingTimeService().registerTimer(now + watermarkInterval, this).     } }
false;public;1;7;;@Override public void processElement(StreamRecord<T> element) throws Exception {     final long newTimestamp = userFunction.extractTimestamp(element.getValue(), element.hasTimestamp() ? element.getTimestamp() : Long.MIN_VALUE).     output.collect(element.replace(element.getValue(), newTimestamp)). }
false;public;1;13;;@Override public void onProcessingTime(long timestamp) throws Exception {     // register next timer     Watermark newWatermark = userFunction.getCurrentWatermark().     if (newWatermark != null && newWatermark.getTimestamp() > currentWatermark) {         currentWatermark = newWatermark.getTimestamp().         // emit watermark         output.emitWatermark(newWatermark).     }     long now = getProcessingTimeService().getCurrentProcessingTime().     getProcessingTimeService().registerTimer(now + watermarkInterval, this). }
true;public;1;9;/**  * Override the base implementation to completely ignore watermarks propagated from  * upstream (we rely only on the {@link AssignerWithPeriodicWatermarks} to emit  * watermarks from here).  */ ;/**  * Override the base implementation to completely ignore watermarks propagated from  * upstream (we rely only on the {@link AssignerWithPeriodicWatermarks} to emit  * watermarks from here).  */ @Override public void processWatermark(Watermark mark) throws Exception {     // to signal the end of input and to not block watermark progress downstream     if (mark.getTimestamp() == Long.MAX_VALUE && currentWatermark != Long.MAX_VALUE) {         currentWatermark = Long.MAX_VALUE.         output.emitWatermark(mark).     } }
false;public;0;12;;@Override public void close() throws Exception {     super.close().     // emit a final watermark     Watermark newWatermark = userFunction.getCurrentWatermark().     if (newWatermark != null && newWatermark.getTimestamp() > currentWatermark) {         currentWatermark = newWatermark.getTimestamp().         // emit watermark         output.emitWatermark(newWatermark).     } }
