commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@VisibleForTesting public long getGlobalModificationTime() {     return this.globalModificationTime. }
false;public;1;46;;@Override public void initializeState(FunctionInitializationContext context) throws Exception {     Preconditions.checkState(this.checkpointedState == null, "The " + getClass().getSimpleName() + " has already been initialized.").     this.checkpointedState = context.getOperatorStateStore().getListState(new ListStateDescriptor<>("file-monitoring-state", LongSerializer.INSTANCE)).     if (context.isRestored()) {         LOG.info("Restoring state for the {}.", getClass().getSimpleName()).         List<Long> retrievedStates = new ArrayList<>().         for (Long entry : this.checkpointedState.get()) {             retrievedStates.add(entry).         }         // given that the parallelism of the function is 1, we can only have 1 or 0 retrieved items.         // the 0 is for the case that we are migrating from a previous Flink version.         Preconditions.checkArgument(retrievedStates.size() <= 1, getClass().getSimpleName() + " retrieved invalid state.").         if (retrievedStates.size() == 1 && globalModificationTime != Long.MIN_VALUE) {             throw new IllegalArgumentException("The " + getClass().getSimpleName() + " has already restored from a previous Flink version.").         } else if (retrievedStates.size() == 1) {             this.globalModificationTime = retrievedStates.get(0).             if (LOG.isDebugEnabled()) {                 LOG.debug("{} retrieved a global mod time of {}.", getClass().getSimpleName(), globalModificationTime).             }         }     } else {         LOG.info("No state to restore for the {}.", getClass().getSimpleName()).     } }
false;public;1;10;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     format.configure(parameters).     if (LOG.isDebugEnabled()) {         LOG.debug("Opened {} (taskIdx= {}) for path: {}", getClass().getSimpleName(), getRuntimeContext().getIndexOfThisSubtask(), path).     } }
false;public;1;43;;@Override public void run(SourceFunction.SourceContext<TimestampedFileInputSplit> context) throws Exception {     Path p = new Path(path).     FileSystem fileSystem = FileSystem.get(p.toUri()).     if (!fileSystem.exists(p)) {         throw new FileNotFoundException("The provided file path " + path + " does not exist.").     }     checkpointLock = context.getCheckpointLock().     switch(watchType) {         case PROCESS_CONTINUOUSLY:             while (isRunning) {                 synchronized (checkpointLock) {                     monitorDirAndForwardSplits(fileSystem, context).                 }                 Thread.sleep(interval).             }             break.         case PROCESS_ONCE:             synchronized (checkpointLock) {                 if (globalModificationTime == Long.MIN_VALUE) {                     monitorDirAndForwardSplits(fileSystem, context).                     globalModificationTime = Long.MAX_VALUE.                 }                 isRunning = false.             }             break.         default:             isRunning = false.             throw new RuntimeException("Unknown WatchType" + watchType).     } }
false;private;2;17;;private void monitorDirAndForwardSplits(FileSystem fs, SourceContext<TimestampedFileInputSplit> context) throws IOException {     assert (Thread.holdsLock(checkpointLock)).     Map<Path, FileStatus> eligibleFiles = listEligibleFiles(fs, new Path(path)).     Map<Long, List<TimestampedFileInputSplit>> splitsSortedByModTime = getInputSplitsSortedByModTime(eligibleFiles).     for (Map.Entry<Long, List<TimestampedFileInputSplit>> splits : splitsSortedByModTime.entrySet()) {         long modificationTime = splits.getKey().         for (TimestampedFileInputSplit split : splits.getValue()) {             LOG.info("Forwarding split: " + split).             context.collect(split).         }         // update the global modification time         globalModificationTime = Math.max(globalModificationTime, modificationTime).     } }
true;private;1;24;/**  * Creates the input splits to be forwarded to the downstream tasks of the  * {@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before  * being forwarded and only splits belonging to files in the {@code eligibleFiles}  * list will be processed.  * @param eligibleFiles The files to process.  */ ;/**  * Creates the input splits to be forwarded to the downstream tasks of the  * {@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before  * being forwarded and only splits belonging to files in the {@code eligibleFiles}  * list will be processed.  * @param eligibleFiles The files to process.  */ private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(Map<Path, FileStatus> eligibleFiles) throws IOException {     Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>().     if (eligibleFiles.isEmpty()) {         return splitsByModTime.     }     for (FileInputSplit split : format.createInputSplits(readerParallelism)) {         FileStatus fileStatus = eligibleFiles.get(split.getPath()).         if (fileStatus != null) {             Long modTime = fileStatus.getModificationTime().             List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime).             if (splitsToForward == null) {                 splitsToForward = new ArrayList<>().                 splitsByModTime.put(modTime, splitsToForward).             }             splitsToForward.add(new TimestampedFileInputSplit(modTime, split.getSplitNumber(), split.getPath(), split.getStart(), split.getLength(), split.getHostnames())).         }     }     return splitsByModTime. }
true;private;2;31;/**  * Returns the paths of the files not yet processed.  * @param fileSystem The filesystem where the monitored directory resides.  */ ;/**  * Returns the paths of the files not yet processed.  * @param fileSystem The filesystem where the monitored directory resides.  */ private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException {     final FileStatus[] statuses.     try {         statuses = fileSystem.listStatus(path).     } catch (IOException e) {         // delay the check for eligible files in this case         return Collections.emptyMap().     }     if (statuses == null) {         LOG.warn("Path does not exist: {}", path).         return Collections.emptyMap().     } else {         Map<Path, FileStatus> files = new HashMap<>().         // handle the new files         for (FileStatus status : statuses) {             if (!status.isDir()) {                 Path filePath = status.getPath().                 long modificationTime = status.getModificationTime().                 if (!shouldIgnore(filePath, modificationTime)) {                     files.put(filePath, status).                 }             } else if (format.getNestedFileEnumeration() && format.acceptFile(status)) {                 files.putAll(listEligibleFiles(fileSystem, status.getPath())).             }         }         return files.     } }
true;private;2;9;/**  * Returns {@code true} if the file is NOT to be processed further.  * This happens if the modification time of the file is smaller than  * the {@link #globalModificationTime}.  * @param filePath the path of the file to check.  * @param modificationTime the modification time of the file.  */ ;/**  * Returns {@code true} if the file is NOT to be processed further.  * This happens if the modification time of the file is smaller than  * the {@link #globalModificationTime}.  * @param filePath the path of the file to check.  * @param modificationTime the modification time of the file.  */ private boolean shouldIgnore(Path filePath, long modificationTime) {     assert (Thread.holdsLock(checkpointLock)).     boolean shouldIgnore = modificationTime <= globalModificationTime.     if (shouldIgnore && LOG.isDebugEnabled()) {         LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime + " and global mod time= " + globalModificationTime).     }     return shouldIgnore. }
false;public;0;15;;@Override public void close() throws Exception {     super.close().     if (checkpointLock != null) {         synchronized (checkpointLock) {             globalModificationTime = Long.MAX_VALUE.             isRunning = false.         }     }     if (LOG.isDebugEnabled()) {         LOG.debug("Closed File Monitoring Source for path: " + path + ".").     } }
false;public;0;13;;@Override public void cancel() {     if (checkpointLock != null) {         // this is to cover the case where cancel() is called before the run()         synchronized (checkpointLock) {             globalModificationTime = Long.MAX_VALUE.             isRunning = false.         }     } else {         globalModificationTime = Long.MAX_VALUE.         isRunning = false.     } }
false;public;1;12;;// ---------------------			Checkpointing			-------------------------- @Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     Preconditions.checkState(this.checkpointedState != null, "The " + getClass().getSimpleName() + " state has not been properly initialized.").     this.checkpointedState.clear().     this.checkpointedState.add(this.globalModificationTime).     if (LOG.isDebugEnabled()) {         LOG.debug("{} checkpointed {}.", getClass().getSimpleName(), globalModificationTime).     } }
