commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Override public void open() throws Exception {     super.open().     watermarkInterval = getExecutionConfig().getAutoWatermarkInterval().     if (watermarkInterval > 0) {         long now = getProcessingTimeService().getCurrentProcessingTime().         getProcessingTimeService().registerTimer(now + watermarkInterval, this).     }     currentWatermark = Long.MIN_VALUE. }
false;public;1;10;;@Override public void processElement(StreamRecord<T> element) throws Exception {     long newTimestamp = userFunction.extractTimestamp(element.getValue(), element.getTimestamp()).     output.collect(element.replace(element.getValue(), newTimestamp)).     long watermark = userFunction.extractWatermark(element.getValue(), newTimestamp).     if (watermark > currentWatermark) {         currentWatermark = watermark.         output.emitWatermark(new Watermark(currentWatermark)).     } }
false;public;1;13;;@Override public void onProcessingTime(long timestamp) throws Exception {     // register next timer     long newWatermark = userFunction.getCurrentWatermark().     if (newWatermark > currentWatermark) {         currentWatermark = newWatermark.         // emit watermark         output.emitWatermark(new Watermark(currentWatermark)).     }     long now = getProcessingTimeService().getCurrentProcessingTime().     getProcessingTimeService().registerTimer(now + watermarkInterval, this). }
false;public;1;9;;@Override public void processWatermark(Watermark mark) throws Exception {     // to signal the end of input and to not block watermark progress downstream     if (mark.getTimestamp() == Long.MAX_VALUE && mark.getTimestamp() > currentWatermark) {         currentWatermark = Long.MAX_VALUE.         output.emitWatermark(mark).     } }
