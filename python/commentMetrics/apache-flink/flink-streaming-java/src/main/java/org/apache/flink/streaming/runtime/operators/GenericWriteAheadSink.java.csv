commented;modifiers;parameterAmount;loc;comment;code
false;public;1;25;;@Override public void initializeState(StateInitializationContext context) throws Exception {     super.initializeState(context).     Preconditions.checkState(this.checkpointedState == null, "The reader state has already been initialized.").     checkpointedState = context.getOperatorStateStore().getSerializableListState("pending-checkpoints").     int subtaskIdx = getRuntimeContext().getIndexOfThisSubtask().     if (context.isRestored()) {         LOG.info("Restoring state for the GenericWriteAheadSink (taskIdx={}).", subtaskIdx).         for (PendingCheckpoint pendingCheckpoint : checkpointedState.get()) {             this.pendingCheckpoints.add(pendingCheckpoint).         }         if (LOG.isDebugEnabled()) {             LOG.debug("GenericWriteAheadSink idx {} restored {}.", subtaskIdx, this.pendingCheckpoints).         }     } else {         LOG.info("No state to restore for the GenericWriteAheadSink (taskIdx={}).", subtaskIdx).     } }
false;public;0;10;;@Override public void open() throws Exception {     super.open().     committer.setOperatorId(id).     committer.open().     checkpointStorage = getContainingTask().getCheckpointStorage().     cleanRestoredHandles(). }
false;public;0;3;;public void close() throws Exception {     committer.close(). }
true;private;2;20;/**  * Called when a checkpoint barrier arrives. It closes any open streams to the backend  * and marks them as pending for committing to the external, third-party storage system.  *  * @param checkpointId the id of the latest received checkpoint.  * @throws IOException in case something went wrong when handling the stream to the backend.  */ ;/**  * Called when a checkpoint barrier arrives. It closes any open streams to the backend  * and marks them as pending for committing to the external, third-party storage system.  *  * @param checkpointId the id of the latest received checkpoint.  * @throws IOException in case something went wrong when handling the stream to the backend.  */ private void saveHandleInState(final long checkpointId, final long timestamp) throws Exception {     // only add handle if a new OperatorState was created since the last snapshot     if (out != null) {         int subtaskIdx = getRuntimeContext().getIndexOfThisSubtask().         StreamStateHandle handle = out.closeAndGetHandle().         PendingCheckpoint pendingCheckpoint = new PendingCheckpoint(checkpointId, subtaskIdx, timestamp, handle).         if (pendingCheckpoints.contains(pendingCheckpoint)) {             // we already have a checkpoint stored for that ID that may have been partially written,             // so we discard this "alternate version" and use the stored checkpoint             handle.discardState().         } else {             pendingCheckpoints.add(pendingCheckpoint).         }         out = null.     } }
false;public;1;28;;@Override public void snapshotState(StateSnapshotContext context) throws Exception {     super.snapshotState(context).     Preconditions.checkState(this.checkpointedState != null, "The operator state has not been properly initialized.").     saveHandleInState(context.getCheckpointId(), context.getCheckpointTimestamp()).     this.checkpointedState.clear().     try {         for (PendingCheckpoint pendingCheckpoint : pendingCheckpoints) {             // create a new partition for each entry.             this.checkpointedState.add(pendingCheckpoint).         }     } catch (Exception e) {         checkpointedState.clear().         throw new Exception("Could not add panding checkpoints to operator state " + "backend of operator " + getOperatorName() + '.', e).     }     int subtaskIdx = getRuntimeContext().getIndexOfThisSubtask().     if (LOG.isDebugEnabled()) {         LOG.debug("{} (taskIdx= {}) checkpointed {}.", getClass().getSimpleName(), subtaskIdx, this.pendingCheckpoints).     } }
true;private;0;14;/**  * Called at {@link #open()} to clean-up the pending handle list.  * It iterates over all restored pending handles, checks which ones are already  * committed to the outside storage system and removes them from the list.  */ ;/**  * Called at {@link #open()} to clean-up the pending handle list.  * It iterates over all restored pending handles, checks which ones are already  * committed to the outside storage system and removes them from the list.  */ private void cleanRestoredHandles() throws Exception {     synchronized (pendingCheckpoints) {         Iterator<PendingCheckpoint> pendingCheckpointIt = pendingCheckpoints.iterator().         while (pendingCheckpointIt.hasNext()) {             PendingCheckpoint pendingCheckpoint = pendingCheckpointIt.next().             if (committer.isCheckpointCommitted(pendingCheckpoint.subtaskId, pendingCheckpoint.checkpointId)) {                 pendingCheckpoint.stateHandle.discardState().                 pendingCheckpointIt.remove().             }         }     } }
false;public;1;52;;@Override public void notifyCheckpointComplete(long checkpointId) throws Exception {     super.notifyCheckpointComplete(checkpointId).     synchronized (pendingCheckpoints) {         Iterator<PendingCheckpoint> pendingCheckpointIt = pendingCheckpoints.iterator().         while (pendingCheckpointIt.hasNext()) {             PendingCheckpoint pendingCheckpoint = pendingCheckpointIt.next().             long pastCheckpointId = pendingCheckpoint.checkpointId.             int subtaskId = pendingCheckpoint.subtaskId.             long timestamp = pendingCheckpoint.timestamp.             StreamStateHandle streamHandle = pendingCheckpoint.stateHandle.             if (pastCheckpointId <= checkpointId) {                 try {                     if (!committer.isCheckpointCommitted(subtaskId, pastCheckpointId)) {                         try (FSDataInputStream in = streamHandle.openInputStream()) {                             boolean success = sendValues(new ReusingMutableToRegularIteratorWrapper<>(new InputViewIterator<>(new DataInputViewStreamWrapper(in), serializer), serializer), pastCheckpointId, timestamp).                             if (success) {                                 // in case the checkpoint was successfully committed,                                 // discard its state from the backend and mark it for removal                                 // in case it failed, we retry on the next checkpoint                                 committer.commitCheckpoint(subtaskId, pastCheckpointId).                                 streamHandle.discardState().                                 pendingCheckpointIt.remove().                             }                         }                     } else {                         streamHandle.discardState().                         pendingCheckpointIt.remove().                     }                 } catch (Exception e) {                     // we have to break here to prevent a new (later) checkpoint                     // from being committed before this one                     LOG.error("Could not commit checkpoint.", e).                     break.                 }             }         }     } }
true;protected,abstract;3;1;/**  * Write the given element into the backend.  *  * @param values The values to be written  * @param checkpointId The checkpoint ID of the checkpoint to be written  * @param timestamp The wall-clock timestamp of the checkpoint  *  * @return true, if the sending was successful, false otherwise  *  * @throws Exception  */ ;/**  * Write the given element into the backend.  *  * @param values The values to be written  * @param checkpointId The checkpoint ID of the checkpoint to be written  * @param timestamp The wall-clock timestamp of the checkpoint  *  * @return true, if the sending was successful, false otherwise  *  * @throws Exception  */ protected abstract boolean sendValues(Iterable<IN> values, long checkpointId, long timestamp) throws Exception.
false;public;1;9;;@Override public void processElement(StreamRecord<IN> element) throws Exception {     IN value = element.getValue().     // generate initial operator state     if (out == null) {         out = checkpointStorage.createTaskOwnedStateStream().     }     serializer.serialize(value, new DataOutputViewStreamWrapper(out)). }
false;public;1;5;;@Override public int compareTo(PendingCheckpoint o) {     int res = Long.compare(this.checkpointId, o.checkpointId).     return res != 0 ? res : this.subtaskId - o.subtaskId. }
false;public;1;10;;@Override public boolean equals(Object o) {     if (!(o instanceof GenericWriteAheadSink.PendingCheckpoint)) {         return false.     }     PendingCheckpoint other = (PendingCheckpoint) o.     return this.checkpointId == other.checkpointId && this.subtaskId == other.subtaskId && this.timestamp == other.timestamp. }
false;public;0;8;;@Override public int hashCode() {     int hash = 17.     hash = 31 * hash + (int) (checkpointId ^ (checkpointId >>> 32)).     hash = 31 * hash + subtaskId.     hash = 31 * hash + (int) (timestamp ^ (timestamp >>> 32)).     return hash. }
false;public;0;4;;@Override public String toString() {     return "Pending Checkpoint: id=" + checkpointId + "/" + subtaskId + "@" + timestamp. }
