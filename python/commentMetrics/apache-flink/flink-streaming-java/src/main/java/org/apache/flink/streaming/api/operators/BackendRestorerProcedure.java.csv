commented;modifiers;parameterAmount;loc;comment;code
true;public;1;49;/**  * Creates a new state backend and restores it from the provided set of state snapshot alternatives.  *  * @param restoreOptions list of prioritized state snapshot alternatives for recovery.  * @return the created (and restored) state backend.  * @throws Exception if the backend could not be created or restored.  */ ;/**  * Creates a new state backend and restores it from the provided set of state snapshot alternatives.  *  * @param restoreOptions list of prioritized state snapshot alternatives for recovery.  * @return the created (and restored) state backend.  * @throws Exception if the backend could not be created or restored.  */ @Nonnull public T createAndRestore(@Nonnull List<? extends Collection<S>> restoreOptions) throws Exception {     if (restoreOptions.isEmpty()) {         restoreOptions = Collections.singletonList(Collections.emptyList()).     }     int alternativeIdx = 0.     Exception collectedException = null.     while (alternativeIdx < restoreOptions.size()) {         Collection<S> restoreState = restoreOptions.get(alternativeIdx).         ++alternativeIdx.         // the automatic end-to-end tests. Those tests might fail if they are not aligned with the log message!         if (restoreState.isEmpty()) {             LOG.debug("Creating {} with empty state.", logDescription).         } else {             if (LOG.isTraceEnabled()) {                 LOG.trace("Creating {} and restoring with state {} from alternative ({}/{}).", logDescription, restoreState, alternativeIdx, restoreOptions.size()).             } else {                 LOG.debug("Creating {} and restoring with state from alternative ({}/{}).", logDescription, alternativeIdx, restoreOptions.size()).             }         }         try {             return attemptCreateAndRestore(restoreState).         } catch (Exception ex) {             collectedException = ExceptionUtils.firstOrSuppressed(ex, collectedException).             LOG.warn("Exception while restoring {} from alternative ({}/{}), will retry while more " + "alternatives are available.", logDescription, alternativeIdx, restoreOptions.size(), ex).             if (backendCloseableRegistry.isClosed()) {                 throw new FlinkException("Stopping restore attempts for already cancelled task.", collectedException).             }         }     }     throw new FlinkException("Could not restore " + logDescription + " from any of the " + restoreOptions.size() + " provided restore options.", collectedException). }
false;private;1;35;;private T attemptCreateAndRestore(Collection<S> restoreState) throws Exception {     // create a new, empty backend.     final T backendInstance = instanceSupplier.apply(restoreState).     try {         // register the backend with the registry to participate in task lifecycle w.r.t. cancellation.         backendCloseableRegistry.registerCloseable(backendInstance).         // attempt to restore from snapshot (or null if no state was checkpointed).         // TODO we could remove this invocation when moving all backend's restore into builder         backendInstance.restore(restoreState).         return backendInstance.     } catch (Exception ex) {         // under failure, we need do close...         if (backendCloseableRegistry.unregisterCloseable(backendInstance)) {             try {                 backendInstance.close().             } catch (IOException closeEx) {                 ex = ExceptionUtils.firstOrSuppressed(closeEx, ex).             }         }         // ... and dispose, e.g. to release native resources.         try {             backendInstance.dispose().         } catch (Exception disposeEx) {             ex = ExceptionUtils.firstOrSuppressed(disposeEx, ex).         }         throw ex.     } }
