commented;modifiers;parameterAmount;loc;comment;code
false;public;2;3;;public void run(final Object lockingObject, final StreamStatusMaintainer streamStatusMaintainer) throws Exception {     run(lockingObject, streamStatusMaintainer, output). }
false;public;3;49;;public void run(final Object lockingObject, final StreamStatusMaintainer streamStatusMaintainer, final Output<StreamRecord<OUT>> collector) throws Exception {     final TimeCharacteristic timeCharacteristic = getOperatorConfig().getTimeCharacteristic().     final Configuration configuration = this.getContainingTask().getEnvironment().getTaskManagerInfo().getConfiguration().     final long latencyTrackingInterval = getExecutionConfig().isLatencyTrackingConfigured() ? getExecutionConfig().getLatencyTrackingInterval() : configuration.getLong(MetricOptions.LATENCY_INTERVAL).     LatencyMarksEmitter<OUT> latencyEmitter = null.     if (latencyTrackingInterval > 0) {         latencyEmitter = new LatencyMarksEmitter<>(getProcessingTimeService(), collector, latencyTrackingInterval, this.getOperatorID(), getRuntimeContext().getIndexOfThisSubtask()).     }     final long watermarkInterval = getRuntimeContext().getExecutionConfig().getAutoWatermarkInterval().     this.ctx = StreamSourceContexts.getSourceContext(timeCharacteristic, getProcessingTimeService(), lockingObject, streamStatusMaintainer, collector, watermarkInterval, -1).     try {         userFunction.run(ctx).         // a final watermark that indicates that we reached the end of event-time         if (!isCanceledOrStopped()) {             ctx.emitWatermark(Watermark.MAX_WATERMARK).         }     } finally {         // make sure that the context is closed in any case         ctx.close().         if (latencyEmitter != null) {             latencyEmitter.close().         }     } }
false;public;0;12;;public void cancel() {     // important: marking the source as stopped has to happen before the function is stopped.     // the flag that tracks this status is volatile, so the memory model also guarantees     // the happens-before relationship     markCanceledOrStopped().     userFunction.cancel().     // the context may not be initialized if the source was never running.     if (ctx != null) {         ctx.close().     } }
true;protected;0;3;/**  * Marks this source as canceled or stopped.  *  * <p>This indicates that any exit of the {@link #run(Object, StreamStatusMaintainer, Output)} method  * cannot be interpreted as the result of a finite source.  */ ;/**  * Marks this source as canceled or stopped.  *  * <p>This indicates that any exit of the {@link #run(Object, StreamStatusMaintainer, Output)} method  * cannot be interpreted as the result of a finite source.  */ protected void markCanceledOrStopped() {     this.canceledOrStopped = true. }
true;protected;0;3;/**  * Checks whether the source has been canceled or stopped.  * @return True, if the source is canceled or stopped, false is not.  */ ;/**  * Checks whether the source has been canceled or stopped.  * @return True, if the source is canceled or stopped, false is not.  */ protected boolean isCanceledOrStopped() {     return canceledOrStopped. }
false;public;1;11;;@Override public void onProcessingTime(long timestamp) throws Exception {     try {         // ProcessingTimeService callbacks are executed under the checkpointing lock         output.emitLatencyMarker(new LatencyMarker(timestamp, operatorId, subtaskIndex)).     } catch (Throwable t) {         // we catch the Throwables here so that we don't trigger the processing         // timer services async exception handler         LOG.warn("Error while emitting latency marker.", t).     } }
false;public;0;3;;public void close() {     latencyMarkTimer.cancel(true). }
