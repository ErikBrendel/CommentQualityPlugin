commented;modifiers;parameterAmount;loc;comment;code
false;public;0;76;;public boolean processInput() throws Exception {     if (isFinished) {         return false.     }     if (numRecordsIn == null) {         try {             numRecordsIn = ((OperatorMetricGroup) streamOperator.getMetricGroup()).getIOMetricGroup().getNumRecordsInCounter().         } catch (Exception e) {             LOG.warn("An exception occurred during the metrics setup.", e).             numRecordsIn = new SimpleCounter().         }     }     while (true) {         if (currentRecordDeserializer != null) {             DeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate).             if (result.isBufferConsumed()) {                 currentRecordDeserializer.getCurrentBuffer().recycleBuffer().                 currentRecordDeserializer = null.             }             if (result.isFullRecord()) {                 StreamElement recordOrMark = deserializationDelegate.getInstance().                 if (recordOrMark.isWatermark()) {                     // handle watermark                     statusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), currentChannel).                     continue.                 } else if (recordOrMark.isStreamStatus()) {                     // handle stream status                     statusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), currentChannel).                     continue.                 } else if (recordOrMark.isLatencyMarker()) {                     // handle latency marker                     synchronized (lock) {                         streamOperator.processLatencyMarker(recordOrMark.asLatencyMarker()).                     }                     continue.                 } else {                     // now we can do the actual processing                     StreamRecord<IN> record = recordOrMark.asRecord().                     synchronized (lock) {                         numRecordsIn.inc().                         streamOperator.setKeyContextElement1(record).                         streamOperator.processElement(record).                     }                     return true.                 }             }         }         final BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked().         if (bufferOrEvent != null) {             if (bufferOrEvent.isBuffer()) {                 currentChannel = bufferOrEvent.getChannelIndex().                 currentRecordDeserializer = recordDeserializers[currentChannel].                 currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer()).             } else {                 // Event received                 final AbstractEvent event = bufferOrEvent.getEvent().                 if (event.getClass() != EndOfPartitionEvent.class) {                     throw new IOException("Unexpected event: " + event).                 }             }         } else {             isFinished = true.             if (!barrierHandler.isEmpty()) {                 throw new IllegalStateException("Trailing data in checkpoint barrier handler.").             }             return false.         }     } }
false;public;0;13;;public void cleanup() throws IOException {     // clear the buffers first. this part should not ever fail     for (RecordDeserializer<?> deserializer : recordDeserializers) {         Buffer buffer = deserializer.getCurrentBuffer().         if (buffer != null && !buffer.isRecycled()) {             buffer.recycleBuffer().         }         deserializer.clear().     }     // cleanup the barrier handler resources     barrierHandler.cleanup(). }
false;public;1;11;;@Override public void handleWatermark(Watermark watermark) {     try {         synchronized (lock) {             watermarkGauge.setCurrentWatermark(watermark.getTimestamp()).             operator.processWatermark(watermark).         }     } catch (Exception e) {         throw new RuntimeException("Exception occurred while processing valve output watermark: ", e).     } }
false;public;1;11;;@SuppressWarnings("unchecked") @Override public void handleStreamStatus(StreamStatus streamStatus) {     try {         synchronized (lock) {             streamStatusMaintainer.toggleStreamStatus(streamStatus).         }     } catch (Exception e) {         throw new RuntimeException("Exception occurred while processing valve output stream status: ", e).     } }
