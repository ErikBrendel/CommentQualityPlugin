commented;modifiers;parameterAmount;loc;comment;code
false;public;1;35;;@Override public void initializeState(FunctionInitializationContext context) throws Exception {     Preconditions.checkState(this.checkpointedState == null, "The " + getClass().getSimpleName() + " has already been initialized.").     this.checkpointedState = context.getOperatorStateStore().getSerializableListState("message-acknowledging-source-state").     this.idsForCurrentCheckpoint = new HashSet<>(64).     this.pendingCheckpoints = new ArrayDeque<>().     this.idsProcessedButNotAcknowledged = new HashSet<>().     if (context.isRestored()) {         LOG.info("Restoring state for the {}.", getClass().getSimpleName()).         List<SerializedCheckpointData[]> retrievedStates = new ArrayList<>().         for (SerializedCheckpointData[] entry : this.checkpointedState.get()) {             retrievedStates.add(entry).         }         // given that the parallelism of the function is 1, we can only have at most 1 state         Preconditions.checkArgument(retrievedStates.size() == 1, getClass().getSimpleName() + " retrieved invalid state.").         pendingCheckpoints = SerializedCheckpointData.toDeque(retrievedStates.get(0), idSerializer).         // already processed an incoming message.         for (Tuple2<Long, Set<UId>> checkpoint : pendingCheckpoints) {             idsProcessedButNotAcknowledged.addAll(checkpoint.f1).         }     } else {         LOG.info("No state to restore for the {}.", getClass().getSimpleName()).     } }
false;public;0;5;;@Override public void close() throws Exception {     idsForCurrentCheckpoint.clear().     pendingCheckpoints.clear(). }
true;protected,abstract;2;1;/**  * This method must be implemented to acknowledge the given set of IDs back to the message queue.  *  * @param uIds The list od IDs to acknowledge.  */ ;// ------------------------------------------------------------------------ // ID Checkpointing // ------------------------------------------------------------------------ /**  * This method must be implemented to acknowledge the given set of IDs back to the message queue.  *  * @param uIds The list od IDs to acknowledge.  */ protected abstract void acknowledgeIDs(long checkpointId, Set<UId> uIds).
true;protected;1;4;/**  * Adds an ID to be stored with the current checkpoint.  * @param uid The ID to add.  * @return True if the id has not been processed previously.  */ ;/**  * Adds an ID to be stored with the current checkpoint.  * @param uid The ID to add.  * @return True if the id has not been processed previously.  */ protected boolean addId(UId uid) {     idsForCurrentCheckpoint.add(uid).     return idsProcessedButNotAcknowledged.add(uid). }
false;public;1;16;;// ------------------------------------------------------------------------ // Checkpointing the data // ------------------------------------------------------------------------ @Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     Preconditions.checkState(this.checkpointedState != null, "The " + getClass().getSimpleName() + " has not been properly initialized.").     if (LOG.isDebugEnabled()) {         LOG.debug("{} checkpointing: Messages: {}, checkpoint id: {}, timestamp: {}", idsForCurrentCheckpoint, context.getCheckpointId(), context.getCheckpointTimestamp()).     }     pendingCheckpoints.addLast(new Tuple2<>(context.getCheckpointId(), idsForCurrentCheckpoint)).     idsForCurrentCheckpoint = new HashSet<>(64).     this.checkpointedState.clear().     this.checkpointedState.add(SerializedCheckpointData.fromDeque(pendingCheckpoints, idSerializer)). }
false;public;1;21;;@Override public void notifyCheckpointComplete(long checkpointId) throws Exception {     LOG.debug("Committing Messages externally for checkpoint {}", checkpointId).     for (Iterator<Tuple2<Long, Set<UId>>> iter = pendingCheckpoints.iterator(). iter.hasNext(). ) {         Tuple2<Long, Set<UId>> checkpoint = iter.next().         long id = checkpoint.f0.         if (id <= checkpointId) {             LOG.trace("Committing Messages with following IDs {}", checkpoint.f1).             acknowledgeIDs(checkpointId, checkpoint.f1).             // remove deduplication data             idsProcessedButNotAcknowledged.removeAll(checkpoint.f1).             // remove checkpoint data             iter.remove().         } else {             break.         }     } }
