commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public void emitWatermark(Watermark mark) {     watermarkGauge.setCurrentWatermark(mark.getTimestamp()).     for (Output<StreamRecord<OUT>> out : allOutputs) {         out.emitWatermark(mark).     } }
false;public;1;5;;@Override public void emitLatencyMarker(LatencyMarker latencyMarker) {     // randomly select an output     allOutputs[random.nextInt(allOutputs.length)].emitLatencyMarker(latencyMarker). }
false;protected;1;17;;protected Set<Output<StreamRecord<OUT>>> selectOutputs(StreamRecord<OUT> record) {     Set<Output<StreamRecord<OUT>>> selectedOutputs = new HashSet<>(selectAllOutputs.length).     Collections.addAll(selectedOutputs, selectAllOutputs).     for (OutputSelector<OUT> outputSelector : outputSelectors) {         Iterable<String> outputNames = outputSelector.select(record.getValue()).         for (String outputName : outputNames) {             Output<StreamRecord<OUT>>[] outputList = outputMap.get(outputName).             if (outputList != null) {                 Collections.addAll(selectedOutputs, outputList).             }         }     }     return selectedOutputs. }
false;public;1;8;;@Override public void collect(StreamRecord<OUT> record) {     Set<Output<StreamRecord<OUT>>> selectedOutputs = selectOutputs(record).     for (Output<StreamRecord<OUT>> out : selectedOutputs) {         out.collect(record).     } }
false;public;2;4;;@Override public <X> void collect(OutputTag<X> outputTag, StreamRecord<X> record) {     throw new UnsupportedOperationException("Cannot use split/select with side outputs."). }
false;public;0;6;;@Override public void close() {     for (Output<StreamRecord<OUT>> out : allOutputs) {         out.close().     } }
false;public;0;4;;@Override public Gauge<Long> getWatermarkGauge() {     return watermarkGauge. }
