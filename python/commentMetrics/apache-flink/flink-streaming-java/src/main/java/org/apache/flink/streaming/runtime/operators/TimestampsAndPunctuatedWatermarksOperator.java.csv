commented;modifiers;parameterAmount;loc;comment;code
false;public;1;14;;@Override public void processElement(StreamRecord<T> element) throws Exception {     final T value = element.getValue().     final long newTimestamp = userFunction.extractTimestamp(value, element.hasTimestamp() ? element.getTimestamp() : Long.MIN_VALUE).     output.collect(element.replace(element.getValue(), newTimestamp)).     final Watermark nextWatermark = userFunction.checkAndGetNextWatermark(value, newTimestamp).     if (nextWatermark != null && nextWatermark.getTimestamp() > currentWatermark) {         currentWatermark = nextWatermark.getTimestamp().         output.emitWatermark(nextWatermark).     } }
true;public;1;9;/**  * Override the base implementation to completely ignore watermarks propagated from  * upstream (we rely only on the {@link AssignerWithPunctuatedWatermarks} to emit  * watermarks from here).  */ ;/**  * Override the base implementation to completely ignore watermarks propagated from  * upstream (we rely only on the {@link AssignerWithPunctuatedWatermarks} to emit  * watermarks from here).  */ @Override public void processWatermark(Watermark mark) throws Exception {     // to signal the end of input and to not block watermark progress downstream     if (mark.getTimestamp() == Long.MAX_VALUE && currentWatermark != Long.MAX_VALUE) {         currentWatermark = Long.MAX_VALUE.         output.emitWatermark(mark).     } }
