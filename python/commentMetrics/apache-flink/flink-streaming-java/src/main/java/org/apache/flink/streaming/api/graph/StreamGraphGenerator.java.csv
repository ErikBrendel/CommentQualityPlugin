# id;timestamp;commentText;codeText;commentWords;codeWords
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1445418103;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1446112342;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1448554589;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1448626823;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1452526242;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1454527671;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1455486690;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1456247173;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1465920682;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1466027011;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1472663071;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1472663401;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1472663401;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1485181339;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1485269495;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1488304750;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1488304750;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1488304933;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1489165080;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1489671807;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1489782894;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1489782894;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1489819457;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1492530130;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1492530130;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1493195810;Transforms a {@code UnionTransformation}.__<p>_This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1493195810;Transforms a {@code UnionTransformation}.__<p>This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1493195810;Transforms a {@code UnionTransformation}.__<p>This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1493195810;Transforms a {@code UnionTransformation}.__<p>This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1495484544;Transforms a {@code UnionTransformation}.__<p>This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1515177485;Transforms a {@code UnionTransformation}.__<p>This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1518008865;Transforms a {@code UnionTransformation}.__<p>This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1526630738;Transforms a {@code UnionTransformation}.__<p>This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1531381123;Transforms a {@code UnionTransformation}.__<p>This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1547196539;Transforms a {@code UnionTransformation}.__<p>This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformUnion(UnionTransformation<T> union);1549467949;Transforms a {@code UnionTransformation}.__<p>This is easy, we only have to transform the inputs and return all the IDs in a list so_that downstream operations can connect to all upstream nodes.;private <T> Collection<Integer> transformUnion(UnionTransformation<T> union) {_		List<StreamTransformation<T>> inputs = union.getInputs()__		List<Integer> resultIds = new ArrayList<>()___		for (StreamTransformation<T> input: inputs) {_			resultIds.addAll(transform(input))__		}__		return resultIds__	};transforms,a,code,union,transformation,p,this,is,easy,we,only,have,to,transform,the,inputs,and,return,all,the,ids,in,a,list,so,that,downstream,operations,can,connect,to,all,upstream,nodes;private,t,collection,integer,transform,union,union,transformation,t,union,list,stream,transformation,t,inputs,union,get,inputs,list,integer,result,ids,new,array,list,for,stream,transformation,t,input,inputs,result,ids,add,all,transform,input,return,result,ids
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1456247173;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1465920682;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1466027011;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1472663071;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1472663401;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1472663401;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1485181339;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1485269495;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1488304750;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1488304750;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1488304933;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1489165080;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1489671807;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1489782894;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1489782894;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1489819457;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1492530130;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1492530130;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1493195810;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1493195810;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1493195810;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1493195810;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1495484544;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is choosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,choosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1515177485;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is chosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,chosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1518008865;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is chosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,chosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1526630738;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is chosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,chosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1531381123;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is chosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,chosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1547196539;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is chosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,chosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds);1549467949;Determines the slot sharing group for an operation based on the slot sharing group set by_the user and the slot sharing groups of the inputs.__<p>If the user specifies a group name, this is taken as is. If nothing is specified and_the input operations all have the same group name then this name is taken. Otherwise the_default group is chosen.__@param specifiedGroup The group specified by the user._@param inputIds The IDs of the input operations.;private String determineSlotSharingGroup(String specifiedGroup, Collection<Integer> inputIds) {_		if (specifiedGroup != null) {_			return specifiedGroup__		} else {_			String inputGroup = null__			for (int id: inputIds) {_				String inputGroupCandidate = streamGraph.getSlotSharingGroup(id)__				if (inputGroup == null) {_					inputGroup = inputGroupCandidate__				} else if (!inputGroup.equals(inputGroupCandidate)) {_					return "default"__				}_			}_			return inputGroup == null ? "default" : inputGroup__		}_	};determines,the,slot,sharing,group,for,an,operation,based,on,the,slot,sharing,group,set,by,the,user,and,the,slot,sharing,groups,of,the,inputs,p,if,the,user,specifies,a,group,name,this,is,taken,as,is,if,nothing,is,specified,and,the,input,operations,all,have,the,same,group,name,then,this,name,is,taken,otherwise,the,default,group,is,chosen,param,specified,group,the,group,specified,by,the,user,param,input,ids,the,ids,of,the,input,operations;private,string,determine,slot,sharing,group,string,specified,group,collection,integer,input,ids,if,specified,group,null,return,specified,group,else,string,input,group,null,for,int,id,input,ids,string,input,group,candidate,stream,graph,get,slot,sharing,group,id,if,input,group,null,input,group,input,group,candidate,else,if,input,group,equals,input,group,candidate,return,default,return,input,group,null,default,input,group
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1489165080;Transforms a {@code OneInputTransformation}.__<p>_This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1489671807;Transforms a {@code OneInputTransformation}.__<p>_This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1489782894;Transforms a {@code OneInputTransformation}.__<p>_This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1489782894;Transforms a {@code OneInputTransformation}.__<p>_This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1489819457;Transforms a {@code OneInputTransformation}.__<p>_This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1492530130;Transforms a {@code OneInputTransformation}.__<p>_This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1492530130;Transforms a {@code OneInputTransformation}.__<p>_This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1493195810;Transforms a {@code OneInputTransformation}.__<p>_This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1493195810;Transforms a {@code OneInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1493195810;Transforms a {@code OneInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1493195810;Transforms a {@code OneInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1495484544;Transforms a {@code OneInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1515177485;Transforms a {@code OneInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1518008865;Transforms a {@code OneInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1526630738;Transforms a {@code OneInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1531381123;Transforms a {@code OneInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getCoLocationGroupKey(),_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,co,location,group,key,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1547196539;Transforms a {@code OneInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getCoLocationGroupKey(),_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,co,location,group,key,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform);1549467949;Transforms a {@code OneInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOneInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getCoLocationGroupKey(),_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,one,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,co,location,group,key,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1445418103;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1446112342;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1448554589;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1448626823;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1452526242;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1454527671;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1455486690;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1456247173;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1465920682;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1466027011;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1472663071;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1472663401;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1472663401;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1485181339;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1485269495;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1488304750;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1488304750;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1488304933;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1489165080;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1489671807;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1489782894;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1489782894;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1489819457;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1492530130;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1492530130;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1493195810;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1493195810;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1493195810;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1493195810;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1495484544;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1515177485;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1518008865;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1526630738;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1531381123;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1547196539;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private StreamGraph generateInternal(List<StreamTransformation<?>> transformations);1549467949;This starts the actual transformation, beginning from the sinks.;private StreamGraph generateInternal(List<StreamTransformation<?>> transformations) {_		for (StreamTransformation<?> transformation: transformations) {_			transform(transformation)__		}_		return streamGraph__	};this,starts,the,actual,transformation,beginning,from,the,sinks;private,stream,graph,generate,internal,list,stream,transformation,transformations,for,stream,transformation,transformation,transformations,transform,transformation,return,stream,graph
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1445418103;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		resultIds.addAll(transform(input))___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}___		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				iterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				iterate.getWaitTime(),_				iterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,result,ids,add,all,transform,input,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1446112342;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		resultIds.addAll(transform(input))___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}___		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				iterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				iterate.getWaitTime(),_				iterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,result,ids,add,all,transform,input,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1448554589;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		resultIds.addAll(transform(input))___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}___		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				iterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				iterate.getWaitTime(),_				iterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,result,ids,add,all,transform,input,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1448626823;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		resultIds.addAll(transform(input))___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}___		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				iterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				iterate.getWaitTime(),_				iterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,result,ids,add,all,transform,input,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1452526242;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		resultIds.addAll(transform(input))___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}___		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				iterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				iterate.getWaitTime(),_				iterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,result,ids,add,all,transform,input,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1454527671;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		resultIds.addAll(transform(input))___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}___		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				iterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				iterate.getWaitTime(),_				iterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,result,ids,add,all,transform,input,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1455486690;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		resultIds.addAll(transform(input))___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}___		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				iterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				iterate.getWaitTime(),_				iterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,result,ids,add,all,transform,input,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1456247173;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				iterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				iterate.getWaitTime(),_				iterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1465920682;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				iterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				iterate.getWaitTime(),_				iterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1466027011;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				iterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				iterate.getWaitTime(),_				iterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1472663071;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1472663401;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1472663401;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1485181339;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1485269495;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1488304750;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1488304750;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1488304933;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1489165080;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1489671807;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources()	)___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1489782894;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources()	)___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1489782894;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources()	)___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1489819457;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources()	)___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1492530130;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources()	)___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1492530130;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources()	)___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1493195810;Transforms a {@code FeedbackTransformation}.__<p>_This will recursively transform the input and the feedback edges. We return the concatenation_of the input IDs and the feedback IDs so that downstream operations can be wired to both.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1493195810;Transforms a {@code FeedbackTransformation}.__<p>This will recursively transform the input and the feedback edges. We return the_concatenation of the input IDs and the feedback IDs so that downstream operations can be_wired to both.__<p>This is responsible for creating the IterationSource and IterationSink which are used to_feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1493195810;Transforms a {@code FeedbackTransformation}.__<p>This will recursively transform the input and the feedback edges. We return the_concatenation of the input IDs and the feedback IDs so that downstream operations can be_wired to both.__<p>This is responsible for creating the IterationSource and IterationSink which are used to_feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1493195810;Transforms a {@code FeedbackTransformation}.__<p>This will recursively transform the input and the feedback edges. We return the_concatenation of the input IDs and the feedback IDs so that downstream operations can be_wired to both.__<p>This is responsible for creating the IterationSource and IterationSink which are used to_feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1495484544;Transforms a {@code FeedbackTransformation}.__<p>This will recursively transform the input and the feedback edges. We return the_concatenation of the input IDs and the feedback IDs so that downstream operations can be_wired to both.__<p>This is responsible for creating the IterationSource and IterationSink which are used to_feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1515177485;Transforms a {@code FeedbackTransformation}.__<p>This will recursively transform the input and the feedback edges. We return the_concatenation of the input IDs and the feedback IDs so that downstream operations can be_wired to both.__<p>This is responsible for creating the IterationSource and IterationSink which are used to_feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1518008865;Transforms a {@code FeedbackTransformation}.__<p>This will recursively transform the input and the feedback edges. We return the_concatenation of the input IDs and the feedback IDs so that downstream operations can be_wired to both.__<p>This is responsible for creating the IterationSource and IterationSink which are used to_feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1526630738;Transforms a {@code FeedbackTransformation}.__<p>This will recursively transform the input and the feedback edges. We return the_concatenation of the input IDs and the feedback IDs so that downstream operations can be_wired to both.__<p>This is responsible for creating the IterationSource and IterationSink which are used to_feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1531381123;Transforms a {@code FeedbackTransformation}.__<p>This will recursively transform the input and the feedback edges. We return the_concatenation of the input IDs and the feedback IDs so that downstream operations can be_wired to both.__<p>This is responsible for creating the IterationSource and IterationSink which are used to_feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1547196539;Transforms a {@code FeedbackTransformation}.__<p>This will recursively transform the input and the feedback edges. We return the_concatenation of the input IDs and the feedback IDs so that downstream operations can be_wired to both.__<p>This is responsible for creating the IterationSource and IterationSink which are used to_feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate);1549467949;Transforms a {@code FeedbackTransformation}.__<p>This will recursively transform the input and the feedback edges. We return the_concatenation of the input IDs and the feedback IDs so that downstream operations can be_wired to both.__<p>This is responsible for creating the IterationSource and IterationSink which are used to_feed back the elements.;private <T> Collection<Integer> transformFeedback(FeedbackTransformation<T> iterate) {__		if (iterate.getFeedbackEdges().size() <= 0) {_			throw new IllegalStateException("Iteration " + iterate + " does not have any feedback edges.")__		}__		StreamTransformation<T> input = iterate.getInput()__		List<Integer> resultIds = new ArrayList<>()___		_		Collection<Integer> inputIds = transform(input)__		resultIds.addAll(inputIds)___		_		if (alreadyTransformed.containsKey(iterate)) {_			return alreadyTransformed.get(iterate)__		}__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_			iterate.getId(),_			getNewIterationNodeId(),_			getNewIterationNodeId(),_			iterate.getWaitTime(),_			iterate.getParallelism(),_			iterate.getMaxParallelism(),_			iterate.getMinResources(),_			iterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, iterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), iterate.getOutputType().createSerializer(env.getConfig()), null, null)___		_		_		resultIds.add(itSource.getId())___		_		_		alreadyTransformed.put(iterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<T> feedbackEdge : iterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return resultIds__	};transforms,a,code,feedback,transformation,p,this,will,recursively,transform,the,input,and,the,feedback,edges,we,return,the,concatenation,of,the,input,ids,and,the,feedback,ids,so,that,downstream,operations,can,be,wired,to,both,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,t,collection,integer,transform,feedback,feedback,transformation,t,iterate,if,iterate,get,feedback,edges,size,0,throw,new,illegal,state,exception,iteration,iterate,does,not,have,any,feedback,edges,stream,transformation,t,input,iterate,get,input,list,integer,result,ids,new,array,list,collection,integer,input,ids,transform,input,result,ids,add,all,input,ids,if,already,transformed,contains,key,iterate,return,already,transformed,get,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,iterate,get,wait,time,iterate,get,parallelism,iterate,get,max,parallelism,iterate,get,min,resources,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,iterate,get,output,type,create,serializer,env,get,config,null,null,result,ids,add,it,source,get,id,already,transformed,put,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,t,feedback,edge,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1445418103;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		streamGraph.addSource(source.getId(),_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof FileSourceFunction) {_			FileSourceFunction<T> fs = (FileSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,stream,graph,add,source,source,get,id,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,file,source,function,file,source,function,t,fs,file,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1446112342;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		streamGraph.addSource(source.getId(),_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof FileSourceFunction) {_			FileSourceFunction<T> fs = (FileSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,stream,graph,add,source,source,get,id,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,file,source,function,file,source,function,t,fs,file,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1448554589;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		streamGraph.addSource(source.getId(),_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof FileSourceFunction) {_			FileSourceFunction<T> fs = (FileSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,stream,graph,add,source,source,get,id,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,file,source,function,file,source,function,t,fs,file,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1448626823;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		streamGraph.addSource(source.getId(),_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof FileSourceFunction) {_			FileSourceFunction<T> fs = (FileSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,stream,graph,add,source,source,get,id,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,file,source,function,file,source,function,t,fs,file,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1452526242;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		streamGraph.addSource(source.getId(),_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof FileSourceFunction) {_			FileSourceFunction<T> fs = (FileSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,stream,graph,add,source,source,get,id,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,file,source,function,file,source,function,t,fs,file,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1454527671;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		streamGraph.addSource(source.getId(),_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof FileSourceFunction) {_			FileSourceFunction<T> fs = (FileSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,stream,graph,add,source,source,get,id,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,file,source,function,file,source,function,t,fs,file,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1455486690;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		streamGraph.addSource(source.getId(),_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof FileSourceFunction) {_			FileSourceFunction<T> fs = (FileSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,stream,graph,add,source,source,get,id,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,file,source,function,file,source,function,t,fs,file,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1456247173;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof FileSourceFunction) {_			FileSourceFunction<T> fs = (FileSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,file,source,function,file,source,function,t,fs,file,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1465920682;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSource) {_			InputFormatSource<T> fs = (InputFormatSource<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,input,format,source,t,fs,input,format,source,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1466027011;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1472663071;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1472663401;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1472663401;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1485181339;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1485269495;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1488304750;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1488304750;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1488304933;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1489165080;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1489671807;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1489782894;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1489782894;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1489819457;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1492530130;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1492530130;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1493195810;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1493195810;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1493195810;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1493195810;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1495484544;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1515177485;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1518008865;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1526630738;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), new ArrayList<Integer>())__		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,new,array,list,integer,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1531381123;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), Collections.emptyList())___		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getCoLocationGroupKey(),_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,collections,empty,list,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,co,location,group,key,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1547196539;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), Collections.emptyList())___		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getCoLocationGroupKey(),_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,collections,empty,list,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,co,location,group,key,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private <T> Collection<Integer> transformSource(SourceTransformation<T> source);1549467949;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSource(SourceTransformation<T> source) {_		String slotSharingGroup = determineSlotSharingGroup(source.getSlotSharingGroup(), Collections.emptyList())___		streamGraph.addSource(source.getId(),_				slotSharingGroup,_				source.getCoLocationGroupKey(),_				source.getOperator(),_				null,_				source.getOutputType(),_				"Source: " + source.getName())__		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {_			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction()__			streamGraph.setInputFormat(source.getId(), fs.getFormat())__		}_		streamGraph.setParallelism(source.getId(), source.getParallelism())__		streamGraph.setMaxParallelism(source.getId(), source.getMaxParallelism())__		return Collections.singleton(source.getId())__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,source,source,transformation,t,source,string,slot,sharing,group,determine,slot,sharing,group,source,get,slot,sharing,group,collections,empty,list,stream,graph,add,source,source,get,id,slot,sharing,group,source,get,co,location,group,key,source,get,operator,null,source,get,output,type,source,source,get,name,if,source,get,operator,get,user,function,instanceof,input,format,source,function,input,format,source,function,t,fs,input,format,source,function,t,source,get,operator,get,user,function,stream,graph,set,input,format,source,get,id,fs,get,format,stream,graph,set,parallelism,source,get,id,source,get,parallelism,stream,graph,set,max,parallelism,source,get,id,source,get,max,parallelism,return,collections,singleton,source,get,id
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1445418103;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getResourceStrategy() != StreamGraph.ResourceStrategy.DEFAULT) {_			streamGraph.setResourceStrategy(transform.getId(), transform.getResourceStrategy())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,resource,strategy,stream,graph,resource,strategy,default,stream,graph,set,resource,strategy,transform,get,id,transform,get,resource,strategy,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1446112342;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getResourceStrategy() != StreamGraph.ResourceStrategy.DEFAULT) {_			streamGraph.setResourceStrategy(transform.getId(), transform.getResourceStrategy())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,resource,strategy,stream,graph,resource,strategy,default,stream,graph,set,resource,strategy,transform,get,id,transform,get,resource,strategy,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1448554589;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getResourceStrategy() != StreamGraph.ResourceStrategy.DEFAULT) {_			streamGraph.setResourceStrategy(transform.getId(), transform.getResourceStrategy())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,resource,strategy,stream,graph,resource,strategy,default,stream,graph,set,resource,strategy,transform,get,id,transform,get,resource,strategy,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1448626823;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getResourceStrategy() != StreamGraph.ResourceStrategy.DEFAULT) {_			streamGraph.setResourceStrategy(transform.getId(), transform.getResourceStrategy())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,resource,strategy,stream,graph,resource,strategy,default,stream,graph,set,resource,strategy,transform,get,id,transform,get,resource,strategy,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1452526242;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getResourceStrategy() != StreamGraph.ResourceStrategy.DEFAULT) {_			streamGraph.setResourceStrategy(transform.getId(), transform.getResourceStrategy())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationId(transform.getId(), transform.getUid())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,resource,strategy,stream,graph,resource,strategy,default,stream,graph,set,resource,strategy,transform,get,id,transform,get,resource,strategy,if,transform,get,uid,null,stream,graph,set,transformation,id,transform,get,id,transform,get,uid,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1454527671;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getResourceStrategy() != StreamGraph.ResourceStrategy.DEFAULT) {_			streamGraph.setResourceStrategy(transform.getId(), transform.getResourceStrategy())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationId(transform.getId(), transform.getUid())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,resource,strategy,stream,graph,resource,strategy,default,stream,graph,set,resource,strategy,transform,get,id,transform,get,resource,strategy,if,transform,get,uid,null,stream,graph,set,transformation,id,transform,get,id,transform,get,uid,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1455486690;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getResourceStrategy() != StreamGraph.ResourceStrategy.DEFAULT) {_			streamGraph.setResourceStrategy(transform.getId(), transform.getResourceStrategy())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationId(transform.getId(), transform.getUid())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,resource,strategy,stream,graph,resource,strategy,default,stream,graph,set,resource,strategy,transform,get,id,transform,get,resource,strategy,if,transform,get,uid,null,stream,graph,set,transformation,id,transform,get,id,transform,get,uid,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1456247173;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationId(transform.getId(), transform.getUid())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,id,transform,get,id,transform,get,uid,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1465920682;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationId(transform.getId(), transform.getUid())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,id,transform,get,id,transform,get,uid,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1466027011;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationId(transform.getId(), transform.getUid())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,id,transform,get,id,transform,get,uid,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1472663071;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {_			_			_			_			int maxParallelism = env.getConfig().getMaxParallelism()___			if (maxParallelism <= 0) {_				maxParallelism = transform.getParallelism()___				_				if (maxParallelism <= 0) {_					transform.setParallelism(1)__					maxParallelism = 1__				}_			}__			transform.setMaxParallelism(maxParallelism)__		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationId(transform.getId(), transform.getUid())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,max,parallelism,env,get,config,get,max,parallelism,if,max,parallelism,0,max,parallelism,transform,get,parallelism,if,max,parallelism,0,transform,set,parallelism,1,max,parallelism,1,transform,set,max,parallelism,max,parallelism,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,id,transform,get,id,transform,get,uid,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1472663401;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {_			_			_			_			int maxParallelism = env.getConfig().getMaxParallelism()___			if (maxParallelism <= 0) {_				maxParallelism = transform.getParallelism()__				_				if (maxParallelism <= 0) {_					transform.setParallelism(1)__					maxParallelism = 1__				}_			}__			transform.setMaxParallelism(maxParallelism)__		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationId(transform.getId(), transform.getUid())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,max,parallelism,env,get,config,get,max,parallelism,if,max,parallelism,0,max,parallelism,transform,get,parallelism,if,max,parallelism,0,transform,set,parallelism,1,max,parallelism,1,transform,set,max,parallelism,max,parallelism,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,id,transform,get,id,transform,get,uid,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1472663401;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			_			int maxParallelism = env.getConfig().getMaxParallelism()___			if (maxParallelism <= 0) {__				int parallelism = transform.getParallelism()___				if(parallelism <= 0) {_					parallelism = 1__					transform.setParallelism(parallelism)__				}__				maxParallelism = Math.max(_						MathUtils.roundUpToPowerOfTwo(parallelism + (parallelism / 2)),_						KeyGroupRangeAssignment.DEFAULT_MAX_PARALLELISM)__			}__			transform.setMaxParallelism(maxParallelism)__		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationId(transform.getId(), transform.getUid())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,max,parallelism,env,get,config,get,max,parallelism,if,max,parallelism,0,int,parallelism,transform,get,parallelism,if,parallelism,0,parallelism,1,transform,set,parallelism,parallelism,max,parallelism,math,max,math,utils,round,up,to,power,of,two,parallelism,parallelism,2,key,group,range,assignment,transform,set,max,parallelism,max,parallelism,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,id,transform,get,id,transform,get,uid,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1485181339;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			_			int maxParallelism = env.getConfig().getMaxParallelism()___			if (maxParallelism <= 0) {__				int parallelism = transform.getParallelism()___				if(parallelism <= 0) {_					parallelism = 1__					transform.setParallelism(parallelism)__				}__				maxParallelism = Math.max(_						MathUtils.roundUpToPowerOfTwo(parallelism + (parallelism / 2)),_						KeyGroupRangeAssignment.DEFAULT_MAX_PARALLELISM)__			}__			transform.setMaxParallelism(maxParallelism)__		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,max,parallelism,env,get,config,get,max,parallelism,if,max,parallelism,0,int,parallelism,transform,get,parallelism,if,parallelism,0,parallelism,1,transform,set,parallelism,parallelism,max,parallelism,math,max,math,utils,round,up,to,power,of,two,parallelism,parallelism,2,key,group,range,assignment,transform,set,max,parallelism,max,parallelism,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1485269495;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1488304750;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResource() != null && transform.getPreferredResource() != null) {_			streamGraph.setResource(transform.getId(), transform.getMinResource(), transform.getPreferredResource())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resource,null,transform,get,preferred,resource,null,stream,graph,set,resource,transform,get,id,transform,get,min,resource,transform,get,preferred,resource,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1488304750;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResource(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resource,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1488304933;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOnInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResource(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,on,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resource,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1489165080;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResource(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resource,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1489671807;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1489782894;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1489782894;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1489819457;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1492530130;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1492530130;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1493195810;Transforms one {@code StreamTransformation}.__<p>_This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1493195810;Transforms one {@code StreamTransformation}.__<p>This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1493195810;Transforms one {@code StreamTransformation}.__<p>This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1493195810;Transforms one {@code StreamTransformation}.__<p>This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1495484544;Transforms one {@code StreamTransformation}.__<p>This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1515177485;Transforms one {@code StreamTransformation}.__<p>This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1518008865;Transforms one {@code StreamTransformation}.__<p>This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() > 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1526630738;Transforms one {@code StreamTransformation}.__<p>This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() >= 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1531381123;Transforms one {@code StreamTransformation}.__<p>This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() >= 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1547196539;Transforms one {@code StreamTransformation}.__<p>This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() >= 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private Collection<Integer> transform(StreamTransformation<?> transform);1549467949;Transforms one {@code StreamTransformation}.__<p>This checks whether we already transformed it and exits early in that case. If not it_delegates to one of the transformation specific methods.;private Collection<Integer> transform(StreamTransformation<?> transform) {__		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		LOG.debug("Transforming " + transform)___		if (transform.getMaxParallelism() <= 0) {__			_			_			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism()__			if (globalMaxParallelismFromConfig > 0) {_				transform.setMaxParallelism(globalMaxParallelismFromConfig)__			}_		}__		_		transform.getOutputType()___		Collection<Integer> transformedIds__		if (transform instanceof OneInputTransformation<?, ?>) {_			transformedIds = transformOneInputTransform((OneInputTransformation<?, ?>) transform)__		} else if (transform instanceof TwoInputTransformation<?, ?, ?>) {_			transformedIds = transformTwoInputTransform((TwoInputTransformation<?, ?, ?>) transform)__		} else if (transform instanceof SourceTransformation<?>) {_			transformedIds = transformSource((SourceTransformation<?>) transform)__		} else if (transform instanceof SinkTransformation<?>) {_			transformedIds = transformSink((SinkTransformation<?>) transform)__		} else if (transform instanceof UnionTransformation<?>) {_			transformedIds = transformUnion((UnionTransformation<?>) transform)__		} else if (transform instanceof SplitTransformation<?>) {_			transformedIds = transformSplit((SplitTransformation<?>) transform)__		} else if (transform instanceof SelectTransformation<?>) {_			transformedIds = transformSelect((SelectTransformation<?>) transform)__		} else if (transform instanceof FeedbackTransformation<?>) {_			transformedIds = transformFeedback((FeedbackTransformation<?>) transform)__		} else if (transform instanceof CoFeedbackTransformation<?>) {_			transformedIds = transformCoFeedback((CoFeedbackTransformation<?>) transform)__		} else if (transform instanceof PartitionTransformation<?>) {_			transformedIds = transformPartition((PartitionTransformation<?>) transform)__		} else if (transform instanceof SideOutputTransformation<?>) {_			transformedIds = transformSideOutput((SideOutputTransformation<?>) transform)__		} else {_			throw new IllegalStateException("Unknown transformation: " + transform)__		}__		_		_		if (!alreadyTransformed.containsKey(transform)) {_			alreadyTransformed.put(transform, transformedIds)__		}__		if (transform.getBufferTimeout() >= 0) {_			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout())__		}_		if (transform.getUid() != null) {_			streamGraph.setTransformationUID(transform.getId(), transform.getUid())__		}_		if (transform.getUserProvidedNodeHash() != null) {_			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash())__		}__		if (transform.getMinResources() != null && transform.getPreferredResources() != null) {_			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources())__		}__		return transformedIds__	};transforms,one,code,stream,transformation,p,this,checks,whether,we,already,transformed,it,and,exits,early,in,that,case,if,not,it,delegates,to,one,of,the,transformation,specific,methods;private,collection,integer,transform,stream,transformation,transform,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,log,debug,transforming,transform,if,transform,get,max,parallelism,0,int,global,max,parallelism,from,config,env,get,config,get,max,parallelism,if,global,max,parallelism,from,config,0,transform,set,max,parallelism,global,max,parallelism,from,config,transform,get,output,type,collection,integer,transformed,ids,if,transform,instanceof,one,input,transformation,transformed,ids,transform,one,input,transform,one,input,transformation,transform,else,if,transform,instanceof,two,input,transformation,transformed,ids,transform,two,input,transform,two,input,transformation,transform,else,if,transform,instanceof,source,transformation,transformed,ids,transform,source,source,transformation,transform,else,if,transform,instanceof,sink,transformation,transformed,ids,transform,sink,sink,transformation,transform,else,if,transform,instanceof,union,transformation,transformed,ids,transform,union,union,transformation,transform,else,if,transform,instanceof,split,transformation,transformed,ids,transform,split,split,transformation,transform,else,if,transform,instanceof,select,transformation,transformed,ids,transform,select,select,transformation,transform,else,if,transform,instanceof,feedback,transformation,transformed,ids,transform,feedback,feedback,transformation,transform,else,if,transform,instanceof,co,feedback,transformation,transformed,ids,transform,co,feedback,co,feedback,transformation,transform,else,if,transform,instanceof,partition,transformation,transformed,ids,transform,partition,partition,transformation,transform,else,if,transform,instanceof,side,output,transformation,transformed,ids,transform,side,output,side,output,transformation,transform,else,throw,new,illegal,state,exception,unknown,transformation,transform,if,already,transformed,contains,key,transform,already,transformed,put,transform,transformed,ids,if,transform,get,buffer,timeout,0,stream,graph,set,buffer,timeout,transform,get,id,transform,get,buffer,timeout,if,transform,get,uid,null,stream,graph,set,transformation,uid,transform,get,id,transform,get,uid,if,transform,get,user,provided,node,hash,null,stream,graph,set,transformation,user,hash,transform,get,id,transform,get,user,provided,node,hash,if,transform,get,min,resources,null,transform,get,preferred,resources,null,stream,graph,set,resources,transform,get,id,transform,get,min,resources,transform,get,preferred,resources,return,transformed,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1445418103;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1446112342;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1448554589;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1448626823;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1452526242;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1454527671;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1455486690;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1456247173;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1465920682;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1466027011;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1472663071;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1472663401;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1472663401;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1485181339;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1485269495;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1488304750;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1488304750;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1488304933;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1489165080;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1489671807;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1489782894;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1489782894;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1489819457;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1492530130;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1492530130;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1493195810;Transforms a {@code SplitTransformation}.__<p>_We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1493195810;Transforms a {@code SplitTransformation}.__<p>We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1493195810;Transforms a {@code SplitTransformation}.__<p>We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1493195810;Transforms a {@code SplitTransformation}.__<p>We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}___		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1495484544;Transforms a {@code SplitTransformation}.__<p>We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}__		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1515177485;Transforms a {@code SplitTransformation}.__<p>We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}__		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1518008865;Transforms a {@code SplitTransformation}.__<p>We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}__		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1526630738;Transforms a {@code SplitTransformation}.__<p>We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}__		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1531381123;Transforms a {@code SplitTransformation}.__<p>We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}__		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1547196539;Transforms a {@code SplitTransformation}.__<p>We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		validateSplitTransformation(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}__		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,validate,split,transformation,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSplit(SplitTransformation<T> split);1549467949;Transforms a {@code SplitTransformation}.__<p>We add the output selector to previously transformed nodes.;private <T> Collection<Integer> transformSplit(SplitTransformation<T> split) {__		StreamTransformation<T> input = split.getInput()__		Collection<Integer> resultIds = transform(input)___		validateSplitTransformation(input)___		_		if (alreadyTransformed.containsKey(split)) {_			return alreadyTransformed.get(split)__		}__		for (int inputId : resultIds) {_			streamGraph.addOutputSelector(inputId, split.getOutputSelector())__		}__		return resultIds__	};transforms,a,code,split,transformation,p,we,add,the,output,selector,to,previously,transformed,nodes;private,t,collection,integer,transform,split,split,transformation,t,split,stream,transformation,t,input,split,get,input,collection,integer,result,ids,transform,input,validate,split,transformation,input,if,already,transformed,contains,key,split,return,already,transformed,get,split,for,int,input,id,result,ids,stream,graph,add,output,selector,input,id,split,get,output,selector,return,result,ids
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1445418103;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1446112342;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1448554589;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1448626823;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1452526242;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1454527671;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1455486690;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1456247173;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1465920682;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1466027011;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1472663071;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1472663401;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1472663401;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1485181339;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1485269495;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1488304750;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1488304750;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1488304933;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1489165080;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1489671807;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1489782894;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1489782894;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1489819457;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1492530130;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1492530130;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1493195810;Transforms a {@code CoFeedbackTransformation}.__<p>_This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>_This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1493195810;Transforms a {@code CoFeedbackTransformation}.__<p>This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1493195810;Transforms a {@code CoFeedbackTransformation}.__<p>This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1493195810;Transforms a {@code CoFeedbackTransformation}.__<p>This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1495484544;Transforms a {@code CoFeedbackTransformation}.__<p>This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1515177485;Transforms a {@code CoFeedbackTransformation}.__<p>This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1518008865;Transforms a {@code CoFeedbackTransformation}.__<p>This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1526630738;Transforms a {@code CoFeedbackTransformation}.__<p>This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1531381123;Transforms a {@code CoFeedbackTransformation}.__<p>This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1547196539;Transforms a {@code CoFeedbackTransformation}.__<p>This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate);1549467949;Transforms a {@code CoFeedbackTransformation}.__<p>This will only transform feedback edges, the result of this transform will be wired_to the second input of a Co-Transform. The original input is wired directly to the first_input of the downstream Co-Transform.__<p>This is responsible for creating the IterationSource and IterationSink which_are used to feed back the elements.;private <F> Collection<Integer> transformCoFeedback(CoFeedbackTransformation<F> coIterate) {__		_		_		_		__		_		Tuple2<StreamNode, StreamNode> itSourceAndSink = streamGraph.createIterationSourceAndSink(_				coIterate.getId(),_				getNewIterationNodeId(),_				getNewIterationNodeId(),_				coIterate.getWaitTime(),_				coIterate.getParallelism(),_				coIterate.getMaxParallelism(),_				coIterate.getMinResources(),_				coIterate.getPreferredResources())___		StreamNode itSource = itSourceAndSink.f0__		StreamNode itSink = itSourceAndSink.f1___		_		streamGraph.setSerializers(itSource.getId(), null, null, coIterate.getOutputType().createSerializer(env.getConfig()))__		streamGraph.setSerializers(itSink.getId(), coIterate.getOutputType().createSerializer(env.getConfig()), null, null)___		Collection<Integer> resultIds = Collections.singleton(itSource.getId())___		_		_		alreadyTransformed.put(coIterate, resultIds)___		_		List<Integer> allFeedbackIds = new ArrayList<>()___		for (StreamTransformation<F> feedbackEdge : coIterate.getFeedbackEdges()) {_			Collection<Integer> feedbackIds = transform(feedbackEdge)__			allFeedbackIds.addAll(feedbackIds)__			for (Integer feedbackId: feedbackIds) {_				streamGraph.addEdge(feedbackId,_						itSink.getId(),_						0_				)__			}_		}__		String slotSharingGroup = determineSlotSharingGroup(null, allFeedbackIds)___		itSink.setSlotSharingGroup(slotSharingGroup)__		itSource.setSlotSharingGroup(slotSharingGroup)___		return Collections.singleton(itSource.getId())__	};transforms,a,code,co,feedback,transformation,p,this,will,only,transform,feedback,edges,the,result,of,this,transform,will,be,wired,to,the,second,input,of,a,co,transform,the,original,input,is,wired,directly,to,the,first,input,of,the,downstream,co,transform,p,this,is,responsible,for,creating,the,iteration,source,and,iteration,sink,which,are,used,to,feed,back,the,elements;private,f,collection,integer,transform,co,feedback,co,feedback,transformation,f,co,iterate,tuple2,stream,node,stream,node,it,source,and,sink,stream,graph,create,iteration,source,and,sink,co,iterate,get,id,get,new,iteration,node,id,get,new,iteration,node,id,co,iterate,get,wait,time,co,iterate,get,parallelism,co,iterate,get,max,parallelism,co,iterate,get,min,resources,co,iterate,get,preferred,resources,stream,node,it,source,it,source,and,sink,f0,stream,node,it,sink,it,source,and,sink,f1,stream,graph,set,serializers,it,source,get,id,null,null,co,iterate,get,output,type,create,serializer,env,get,config,stream,graph,set,serializers,it,sink,get,id,co,iterate,get,output,type,create,serializer,env,get,config,null,null,collection,integer,result,ids,collections,singleton,it,source,get,id,already,transformed,put,co,iterate,result,ids,list,integer,all,feedback,ids,new,array,list,for,stream,transformation,f,feedback,edge,co,iterate,get,feedback,edges,collection,integer,feedback,ids,transform,feedback,edge,all,feedback,ids,add,all,feedback,ids,for,integer,feedback,id,feedback,ids,stream,graph,add,edge,feedback,id,it,sink,get,id,0,string,slot,sharing,group,determine,slot,sharing,group,null,all,feedback,ids,it,sink,set,slot,sharing,group,slot,sharing,group,it,source,set,slot,sharing,group,slot,sharing,group,return,collections,singleton,it,source,get,id
StreamGraphGenerator -> public static StreamGraph generate( 			StreamExecutionEnvironment env, 			List<StreamTransformation<?>> transformations, 			int defaultParallelism);1489782894;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(_			StreamExecutionEnvironment env,_			List<StreamTransformation<?>> transformations,_			int defaultParallelism) {_		return new StreamGraphGenerator(env, defaultParallelism).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,int,default,parallelism,return,new,stream,graph,generator,env,default,parallelism,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate( 			StreamExecutionEnvironment env, 			List<StreamTransformation<?>> transformations, 			int defaultParallelism);1489782894;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(_			StreamExecutionEnvironment env,_			List<StreamTransformation<?>> transformations,_			int defaultParallelism) {_		return new StreamGraphGenerator(env, defaultParallelism).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,int,default,parallelism,return,new,stream,graph,generator,env,default,parallelism,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate( 			StreamExecutionEnvironment env, 			List<StreamTransformation<?>> transformations, 			int defaultParallelism);1489819457;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(_			StreamExecutionEnvironment env,_			List<StreamTransformation<?>> transformations,_			int defaultParallelism) {_		return new StreamGraphGenerator(env, defaultParallelism).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,int,default,parallelism,return,new,stream,graph,generator,env,default,parallelism,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate( 			StreamExecutionEnvironment env, 			List<StreamTransformation<?>> transformations, 			int defaultParallelism);1492530130;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(_			StreamExecutionEnvironment env,_			List<StreamTransformation<?>> transformations,_			int defaultParallelism) {_		return new StreamGraphGenerator(env, defaultParallelism).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,int,default,parallelism,return,new,stream,graph,generator,env,default,parallelism,generate,internal,transformations
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env, int defaultParallelism);1489782894;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env, int defaultParallelism) {_		this.streamGraph = new StreamGraph(env, defaultParallelism)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,int,default,parallelism,this,stream,graph,new,stream,graph,env,default,parallelism,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env, int defaultParallelism);1489782894;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env, int defaultParallelism) {_		this.streamGraph = new StreamGraph(env, defaultParallelism)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,int,default,parallelism,this,stream,graph,new,stream,graph,env,default,parallelism,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env, int defaultParallelism);1489819457;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env, int defaultParallelism) {_		this.streamGraph = new StreamGraph(env, defaultParallelism)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,int,default,parallelism,this,stream,graph,new,stream,graph,env,default,parallelism,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env, int defaultParallelism);1492530130;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env, int defaultParallelism) {_		this.streamGraph = new StreamGraph(env, defaultParallelism)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,int,default,parallelism,this,stream,graph,new,stream,graph,env,default,parallelism,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1445418103;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1446112342;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1448554589;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1448626823;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1452526242;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1454527671;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1455486690;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1456247173;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1465920682;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1466027011;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1472663071;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1472663401;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1472663401;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1485181339;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1485269495;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1488304750;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1488304750;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1488304933;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1489165080;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1489671807;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1489782894;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1489782894;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1489819457;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1492530130;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1492530130;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1493195810;Transforms a {@code PartitionTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1493195810;Transforms a {@code PartitionTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1493195810;Transforms a {@code PartitionTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1493195810;Transforms a {@code PartitionTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1495484544;Transforms a {@code PartitionTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1515177485;Transforms a {@code PartitionTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1518008865;Transforms a {@code PartitionTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1526630738;Transforms a {@code PartitionTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1531381123;Transforms a {@code PartitionTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1547196539;Transforms a {@code PartitionTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition);1549467949;Transforms a {@code PartitionTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the partition_property. @see StreamGraphGenerator;private <T> Collection<Integer> transformPartition(PartitionTransformation<T> partition) {_		StreamTransformation<T> input = partition.getInput()__		List<Integer> resultIds = new ArrayList<>()___		Collection<Integer> transformedIds = transform(input)__		for (Integer transformedId: transformedIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner())__			resultIds.add(virtualId)__		}__		return resultIds__	};transforms,a,code,partition,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,partition,property,see,stream,graph,generator;private,t,collection,integer,transform,partition,partition,transformation,t,partition,stream,transformation,t,input,partition,get,input,list,integer,result,ids,new,array,list,collection,integer,transformed,ids,transform,input,for,integer,transformed,id,transformed,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,partition,node,transformed,id,virtual,id,partition,get,partitioner,result,ids,add,virtual,id,return,result,ids
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1445418103;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1446112342;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1448554589;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1448626823;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1452526242;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1454527671;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1455486690;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1456247173;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1465920682;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1466027011;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1472663071;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1472663401;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1472663401;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1485181339;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1485269495;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1488304750;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1488304750;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1488304933;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1489165080;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1489671807;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1492530130;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1493195810;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1493195810;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1493195810;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1493195810;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1495484544;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1515177485;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1518008865;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1526630738;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1531381123;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1547196539;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations);1549467949;Generates a {@code StreamGraph} by traversing the graph of {@code StreamTransformations}_starting from the given transformations.__@param env The {@code StreamExecutionEnvironment} that is used to set some parameters of the_job_@param transformations The transformations starting from which to transform the graph__@return The generated {@code StreamGraph};public static StreamGraph generate(StreamExecutionEnvironment env, List<StreamTransformation<?>> transformations) {_		return new StreamGraphGenerator(env).generateInternal(transformations)__	};generates,a,code,stream,graph,by,traversing,the,graph,of,code,stream,transformations,starting,from,the,given,transformations,param,env,the,code,stream,execution,environment,that,is,used,to,set,some,parameters,of,the,job,param,transformations,the,transformations,starting,from,which,to,transform,the,graph,return,the,generated,code,stream,graph;public,static,stream,graph,generate,stream,execution,environment,env,list,stream,transformation,transformations,return,new,stream,graph,generator,env,generate,internal,transformations
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1445418103;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1446112342;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1448554589;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1448626823;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1452526242;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1454527671;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1455486690;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1456247173;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1465920682;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1466027011;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1472663071;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1472663401;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1472663401;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1485181339;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1485269495;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1488304750;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1488304750;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1488304933;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1489165080;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1489671807;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1489782894;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1489782894;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1489819457;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1492530130;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1492530130;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1493195810;Transforms a {@code SelectTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} holds the selected names._@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1493195810;Transforms a {@code SelectTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} holds the selected names.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1493195810;Transforms a {@code SelectTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} holds the selected names.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1493195810;Transforms a {@code SelectTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} holds the selected names.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1495484544;Transforms a {@code SelectTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} holds the selected names.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1515177485;Transforms a {@code SelectTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} holds the selected names.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1518008865;Transforms a {@code SelectTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} holds the selected names.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1526630738;Transforms a {@code SelectTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} holds the selected names.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1531381123;Transforms a {@code SelectTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} holds the selected names.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1547196539;Transforms a {@code SelectTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} holds the selected names.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSelect(SelectTransformation<T> select);1549467949;Transforms a {@code SelectTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} holds the selected names.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSelect(SelectTransformation<T> select) {_		StreamTransformation<T> input = select.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(select)) {_			return alreadyTransformed.get(select)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSelectNode(inputId, virtualId, select.getSelectedNames())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,select,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,holds,the,selected,names,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,select,select,transformation,t,select,stream,transformation,t,input,select,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,select,return,already,transformed,get,select,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,select,node,input,id,virtual,id,select,get,selected,names,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1489819457;Transforms a {@code SideOutputTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1492530130;Transforms a {@code SideOutputTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1492530130;Transforms a {@code SideOutputTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1493195810;Transforms a {@code SideOutputTransformation}.__<p>_For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1493195810;Transforms a {@code SideOutputTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1493195810;Transforms a {@code SideOutputTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1493195810;Transforms a {@code SideOutputTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)____		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1495484544;Transforms a {@code SideOutputTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1515177485;Transforms a {@code SideOutputTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1518008865;Transforms a {@code SideOutputTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1526630738;Transforms a {@code SideOutputTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1531381123;Transforms a {@code SideOutputTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1547196539;Transforms a {@code SideOutputTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput);1549467949;Transforms a {@code SideOutputTransformation}.__<p>For this we create a virtual node in the {@code StreamGraph} that holds the side-output_{@link org.apache.flink.util.OutputTag}.__@see org.apache.flink.streaming.api.graph.StreamGraphGenerator;private <T> Collection<Integer> transformSideOutput(SideOutputTransformation<T> sideOutput) {_		StreamTransformation<?> input = sideOutput.getInput()__		Collection<Integer> resultIds = transform(input)___		_		if (alreadyTransformed.containsKey(sideOutput)) {_			return alreadyTransformed.get(sideOutput)__		}__		List<Integer> virtualResultIds = new ArrayList<>()___		for (int inputId : resultIds) {_			int virtualId = StreamTransformation.getNewNodeId()__			streamGraph.addVirtualSideOutputNode(inputId, virtualId, sideOutput.getOutputTag())__			virtualResultIds.add(virtualId)__		}_		return virtualResultIds__	};transforms,a,code,side,output,transformation,p,for,this,we,create,a,virtual,node,in,the,code,stream,graph,that,holds,the,side,output,link,org,apache,flink,util,output,tag,see,org,apache,flink,streaming,api,graph,stream,graph,generator;private,t,collection,integer,transform,side,output,side,output,transformation,t,side,output,stream,transformation,input,side,output,get,input,collection,integer,result,ids,transform,input,if,already,transformed,contains,key,side,output,return,already,transformed,get,side,output,list,integer,virtual,result,ids,new,array,list,for,int,input,id,result,ids,int,virtual,id,stream,transformation,get,new,node,id,stream,graph,add,virtual,side,output,node,input,id,virtual,id,side,output,get,output,tag,virtual,result,ids,add,virtual,id,return,virtual,result,ids
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1445418103;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addCoOperator(_				transform.getId(),_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,co,operator,transform,get,id,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1446112342;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addCoOperator(_				transform.getId(),_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,co,operator,transform,get,id,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1448554589;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addCoOperator(_				transform.getId(),_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,co,operator,transform,get,id,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1448626823;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addCoOperator(_				transform.getId(),_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,co,operator,transform,get,id,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1452526242;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addCoOperator(_				transform.getId(),_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,co,operator,transform,get,id,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1454527671;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addCoOperator(_				transform.getId(),_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,co,operator,transform,get,id,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1455486690;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addCoOperator(_				transform.getId(),_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,co,operator,transform,get,id,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1456247173;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1465920682;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1466027011;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1472663071;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1472663401;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1472663401;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1485181339;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1485269495;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1488304750;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1488304750;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1488304933;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1489165080;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1489671807;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1489782894;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1489782894;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1489819457;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1492530130;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1492530130;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1493195810;Transforms a {@code TwoInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1493195810;Transforms a {@code TwoInputTransformation}.__<p>This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1493195810;Transforms a {@code TwoInputTransformation}.__<p>This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1493195810;Transforms a {@code TwoInputTransformation}.__<p>This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}___		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1495484544;Transforms a {@code TwoInputTransformation}.__<p>This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1515177485;Transforms a {@code TwoInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1518008865;Transforms a {@code TwoInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null || transform.getStateKeySelector2() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,transform,get,state,key,selector2,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1526630738;Transforms a {@code TwoInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null || transform.getStateKeySelector2() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,transform,get,state,key,selector2,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1531381123;Transforms a {@code TwoInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getCoLocationGroupKey(),_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null || transform.getStateKeySelector2() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,co,location,group,key,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,transform,get,state,key,selector2,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1547196539;Transforms a {@code TwoInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getCoLocationGroupKey(),_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null || transform.getStateKeySelector2() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,co,location,group,key,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,transform,get,state,key,selector2,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform);1549467949;Transforms a {@code TwoInputTransformation}.__<p>This recursively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN1, IN2, OUT> Collection<Integer> transformTwoInputTransform(TwoInputTransformation<IN1, IN2, OUT> transform) {__		Collection<Integer> inputIds1 = transform(transform.getInput1())__		Collection<Integer> inputIds2 = transform(transform.getInput2())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		List<Integer> allInputIds = new ArrayList<>()__		allInputIds.addAll(inputIds1)__		allInputIds.addAll(inputIds2)___		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), allInputIds)___		streamGraph.addCoOperator(_				transform.getId(),_				slotSharingGroup,_				transform.getCoLocationGroupKey(),_				transform.getOperator(),_				transform.getInputType1(),_				transform.getInputType2(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector1() != null || transform.getStateKeySelector2() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setTwoInputStateKey(transform.getId(), transform.getStateKeySelector1(), transform.getStateKeySelector2(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds1) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					1_			)__		}__		for (Integer inputId: inputIds2) {_			streamGraph.addEdge(inputId,_					transform.getId(),_					2_			)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,two,input,transformation,p,this,recursively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in1,in2,out,collection,integer,transform,two,input,transform,two,input,transformation,in1,in2,out,transform,collection,integer,input,ids1,transform,transform,get,input1,collection,integer,input,ids2,transform,transform,get,input2,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,list,integer,all,input,ids,new,array,list,all,input,ids,add,all,input,ids1,all,input,ids,add,all,input,ids2,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,all,input,ids,stream,graph,add,co,operator,transform,get,id,slot,sharing,group,transform,get,co,location,group,key,transform,get,operator,transform,get,input,type1,transform,get,input,type2,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector1,null,transform,get,state,key,selector2,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,two,input,state,key,transform,get,id,transform,get,state,key,selector1,transform,get,state,key,selector2,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids1,stream,graph,add,edge,input,id,transform,get,id,1,for,integer,input,id,input,ids2,stream,graph,add,edge,input,id,transform,get,id,2,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1445418103;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		_		if (env.getCheckpointInterval() > 0) {_			this.streamGraph.setCheckpointingEnabled(true)__			this.streamGraph.setCheckpointingInterval(env.getCheckpointInterval())__			this.streamGraph.setCheckpointingMode(env.getCheckpointingMode())__		}_		this.streamGraph.setStateBackend(env.getStateBackend())__		if (env.isForceCheckpointing()) {_			this.streamGraph.forceCheckpoint()__		}_		_		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,if,env,get,checkpoint,interval,0,this,stream,graph,set,checkpointing,enabled,true,this,stream,graph,set,checkpointing,interval,env,get,checkpoint,interval,this,stream,graph,set,checkpointing,mode,env,get,checkpointing,mode,this,stream,graph,set,state,backend,env,get,state,backend,if,env,is,force,checkpointing,this,stream,graph,force,checkpoint,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1446112342;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		_		if (env.getCheckpointInterval() > 0) {_			this.streamGraph.setCheckpointingEnabled(true)__			this.streamGraph.setCheckpointingInterval(env.getCheckpointInterval())__			this.streamGraph.setCheckpointingMode(env.getCheckpointingMode())__		}_		this.streamGraph.setStateBackend(env.getStateBackend())__		if (env.isForceCheckpointing()) {_			this.streamGraph.forceCheckpoint()__		}_		_		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,if,env,get,checkpoint,interval,0,this,stream,graph,set,checkpointing,enabled,true,this,stream,graph,set,checkpointing,interval,env,get,checkpoint,interval,this,stream,graph,set,checkpointing,mode,env,get,checkpointing,mode,this,stream,graph,set,state,backend,env,get,state,backend,if,env,is,force,checkpointing,this,stream,graph,force,checkpoint,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1448554589;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1448626823;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1452526242;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1454527671;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1455486690;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1456247173;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1465920682;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1466027011;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1472663071;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1472663401;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1472663401;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1485181339;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1485269495;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1488304750;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1488304750;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1488304933;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1489165080;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1489671807;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1492530130;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1493195810;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1493195810;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1493195810;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1493195810;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1495484544;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1515177485;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1518008865;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1526630738;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1531381123;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1547196539;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private StreamGraphGenerator(StreamExecutionEnvironment env);1549467949;Private constructor. The generator should only be invoked using {@link #generate}.;private StreamGraphGenerator(StreamExecutionEnvironment env) {_		this.streamGraph = new StreamGraph(env)__		this.streamGraph.setChaining(env.isChainingEnabled())__		this.streamGraph.setStateBackend(env.getStateBackend())__		this.env = env__		this.alreadyTransformed = new HashMap<>()__	};private,constructor,the,generator,should,only,be,invoked,using,link,generate;private,stream,graph,generator,stream,execution,environment,env,this,stream,graph,new,stream,graph,env,this,stream,graph,set,chaining,env,is,chaining,enabled,this,stream,graph,set,state,backend,env,get,state,backend,this,env,env,this,already,transformed,new,hash,map
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1445418103;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		streamGraph.addSink(sink.getId(),_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,stream,graph,add,sink,sink,get,id,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1446112342;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		streamGraph.addSink(sink.getId(),_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,stream,graph,add,sink,sink,get,id,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1448554589;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		streamGraph.addSink(sink.getId(),_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,stream,graph,add,sink,sink,get,id,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1448626823;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		streamGraph.addSink(sink.getId(),_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,stream,graph,add,sink,sink,get,id,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1452526242;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		streamGraph.addSink(sink.getId(),_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,stream,graph,add,sink,sink,get,id,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1454527671;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		streamGraph.addSink(sink.getId(),_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,stream,graph,add,sink,sink,get,id,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1455486690;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		streamGraph.addSink(sink.getId(),_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,stream,graph,add,sink,sink,get,id,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1456247173;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1465920682;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1466027011;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1472663071;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1472663401;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1472663401;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1485181339;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1485269495;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1488304750;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1488304750;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1488304933;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1489165080;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1489671807;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1489782894;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1489782894;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1489819457;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1492530130;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1492530130;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1493195810;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1493195810;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1493195810;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1493195810;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}___		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1495484544;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}__		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1515177485;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}__		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1518008865;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}__		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1526630738;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}__		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1531381123;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getCoLocationGroupKey(),_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}__		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,co,location,group,key,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1547196539;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getCoLocationGroupKey(),_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}__		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,co,location,group,key,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <T> Collection<Integer> transformSink(SinkTransformation<T> sink);1549467949;Transforms a {@code SourceTransformation}.;private <T> Collection<Integer> transformSink(SinkTransformation<T> sink) {__		Collection<Integer> inputIds = transform(sink.getInput())___		String slotSharingGroup = determineSlotSharingGroup(sink.getSlotSharingGroup(), inputIds)___		streamGraph.addSink(sink.getId(),_				slotSharingGroup,_				sink.getCoLocationGroupKey(),_				sink.getOperator(),_				sink.getInput().getOutputType(),_				null,_				"Sink: " + sink.getName())___		streamGraph.setParallelism(sink.getId(), sink.getParallelism())__		streamGraph.setMaxParallelism(sink.getId(), sink.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId,_					sink.getId(),_					0_			)__		}__		if (sink.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = sink.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(sink.getId(), sink.getStateKeySelector(), keySerializer)__		}__		return Collections.emptyList()__	};transforms,a,code,source,transformation;private,t,collection,integer,transform,sink,sink,transformation,t,sink,collection,integer,input,ids,transform,sink,get,input,string,slot,sharing,group,determine,slot,sharing,group,sink,get,slot,sharing,group,input,ids,stream,graph,add,sink,sink,get,id,slot,sharing,group,sink,get,co,location,group,key,sink,get,operator,sink,get,input,get,output,type,null,sink,sink,get,name,stream,graph,set,parallelism,sink,get,id,sink,get,parallelism,stream,graph,set,max,parallelism,sink,get,id,sink,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,sink,get,id,0,if,sink,get,state,key,selector,null,type,serializer,key,serializer,sink,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,sink,get,id,sink,get,state,key,selector,key,serializer,return,collections,empty,list
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1445418103;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addOperator(transform.getId(),_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}_		if (transform.getStateKeyType() != null) {_			_		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,operator,transform,get,id,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,key,transform,get,id,transform,get,state,key,selector,key,serializer,if,transform,get,state,key,type,null,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1446112342;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addOperator(transform.getId(),_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}_		if (transform.getStateKeyType() != null) {_			_		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,operator,transform,get,id,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,key,transform,get,id,transform,get,state,key,selector,key,serializer,if,transform,get,state,key,type,null,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1448554589;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addOperator(transform.getId(),_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}_		if (transform.getStateKeyType() != null) {_			_		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,operator,transform,get,id,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,key,transform,get,id,transform,get,state,key,selector,key,serializer,if,transform,get,state,key,type,null,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1448626823;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addOperator(transform.getId(),_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}_		if (transform.getStateKeyType() != null) {_			_		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,operator,transform,get,id,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,key,transform,get,id,transform,get,state,key,selector,key,serializer,if,transform,get,state,key,type,null,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1452526242;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addOperator(transform.getId(),_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}_		if (transform.getStateKeyType() != null) {_			_		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,operator,transform,get,id,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,key,transform,get,id,transform,get,state,key,selector,key,serializer,if,transform,get,state,key,type,null,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1454527671;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addOperator(transform.getId(),_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,operator,transform,get,id,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1455486690;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		streamGraph.addOperator(transform.getId(),_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,stream,graph,add,operator,transform,get,id,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1456247173;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1465920682;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1466027011;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1472663071;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1472663401;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1472663401;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1485181339;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1485269495;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1488304750;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1488304750;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
StreamGraphGenerator -> private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform);1488304933;Transforms a {@code OneInputTransformation}.__<p>_This recusively transforms the inputs, creates a new {@code StreamNode} in the graph and_wired the inputs to this new node.;private <IN, OUT> Collection<Integer> transformOnInputTransform(OneInputTransformation<IN, OUT> transform) {__		Collection<Integer> inputIds = transform(transform.getInput())___		_		if (alreadyTransformed.containsKey(transform)) {_			return alreadyTransformed.get(transform)__		}__		String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds)___		streamGraph.addOperator(transform.getId(),_				slotSharingGroup,_				transform.getOperator(),_				transform.getInputType(),_				transform.getOutputType(),_				transform.getName())___		if (transform.getStateKeySelector() != null) {_			TypeSerializer<?> keySerializer = transform.getStateKeyType().createSerializer(env.getConfig())__			streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer)__		}__		streamGraph.setParallelism(transform.getId(), transform.getParallelism())__		streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism())___		for (Integer inputId: inputIds) {_			streamGraph.addEdge(inputId, transform.getId(), 0)__		}__		return Collections.singleton(transform.getId())__	};transforms,a,code,one,input,transformation,p,this,recusively,transforms,the,inputs,creates,a,new,code,stream,node,in,the,graph,and,wired,the,inputs,to,this,new,node;private,in,out,collection,integer,transform,on,input,transform,one,input,transformation,in,out,transform,collection,integer,input,ids,transform,transform,get,input,if,already,transformed,contains,key,transform,return,already,transformed,get,transform,string,slot,sharing,group,determine,slot,sharing,group,transform,get,slot,sharing,group,input,ids,stream,graph,add,operator,transform,get,id,slot,sharing,group,transform,get,operator,transform,get,input,type,transform,get,output,type,transform,get,name,if,transform,get,state,key,selector,null,type,serializer,key,serializer,transform,get,state,key,type,create,serializer,env,get,config,stream,graph,set,one,input,state,key,transform,get,id,transform,get,state,key,selector,key,serializer,stream,graph,set,parallelism,transform,get,id,transform,get,parallelism,stream,graph,set,max,parallelism,transform,get,id,transform,get,max,parallelism,for,integer,input,id,input,ids,stream,graph,add,edge,input,id,transform,get,id,0,return,collections,singleton,transform,get,id
