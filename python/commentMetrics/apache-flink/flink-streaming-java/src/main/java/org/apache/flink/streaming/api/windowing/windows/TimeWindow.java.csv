commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the starting timestamp of the window. This is the first timestamp that belongs  * to this window.  *  * @return The starting timestamp of this window.  */ ;/**  * Gets the starting timestamp of the window. This is the first timestamp that belongs  * to this window.  *  * @return The starting timestamp of this window.  */ public long getStart() {     return start. }
true;public;0;3;/**  * Gets the end timestamp of this window. The end timestamp is exclusive, meaning it  * is the first timestamp that does not belong to this window any more.  *  * @return The exclusive end timestamp of this window.  */ ;/**  * Gets the end timestamp of this window. The end timestamp is exclusive, meaning it  * is the first timestamp that does not belong to this window any more.  *  * @return The exclusive end timestamp of this window.  */ public long getEnd() {     return end. }
true;public;0;4;/**  * Gets the largest timestamp that still belongs to this window.  *  * <p>This timestamp is identical to {@code getEnd() - 1}.  *  * @return The largest timestamp that still belongs to this window.  *  * @see #getEnd()  */ ;/**  * Gets the largest timestamp that still belongs to this window.  *  * <p>This timestamp is identical to {@code getEnd() - 1}.  *  * @return The largest timestamp that still belongs to this window.  *  * @see #getEnd()  */ @Override public long maxTimestamp() {     return end - 1. }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     TimeWindow window = (TimeWindow) o.     return end == window.end && start == window.start. }
false;public;0;4;;@Override public int hashCode() {     return MathUtils.longToIntWithBitMixing(start + end). }
false;public;0;7;;@Override public String toString() {     return "TimeWindow{" + "start=" + start + ", end=" + end + '}'. }
true;public;1;3;/**  * Returns {@code true} if this window intersects the given window.  */ ;/**  * Returns {@code true} if this window intersects the given window.  */ public boolean intersects(TimeWindow other) {     return this.start <= other.end && this.end >= other.start. }
true;public;1;3;/**  * Returns the minimal window covers both this window and the given window.  */ ;/**  * Returns the minimal window covers both this window and the given window.  */ public TimeWindow cover(TimeWindow other) {     return new TimeWindow(Math.min(start, other.start), Math.max(end, other.end)). }
false;public;0;4;;@Override public boolean isImmutableType() {     return true. }
false;public;0;4;;@Override public TimeWindow createInstance() {     return null. }
false;public;1;4;;@Override public TimeWindow copy(TimeWindow from) {     return from. }
false;public;2;4;;@Override public TimeWindow copy(TimeWindow from, TimeWindow reuse) {     return from. }
false;public;0;4;;@Override public int getLength() {     return 0. }
false;public;2;5;;@Override public void serialize(TimeWindow record, DataOutputView target) throws IOException {     target.writeLong(record.start).     target.writeLong(record.end). }
false;public;1;6;;@Override public TimeWindow deserialize(DataInputView source) throws IOException {     long start = source.readLong().     long end = source.readLong().     return new TimeWindow(start, end). }
false;public;2;4;;@Override public TimeWindow deserialize(TimeWindow reuse, DataInputView source) throws IOException {     return deserialize(source). }
false;public;2;5;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     target.writeLong(source.readLong()).     target.writeLong(source.readLong()). }
false;public;0;4;;// ------------------------------------------------------------------------ @Override public TypeSerializerSnapshot<TimeWindow> snapshotConfiguration() {     return new TimeWindowSerializerSnapshot(). }
false;public;2;4;;@Override public int compare(TimeWindow o1, TimeWindow o2) {     return Long.compare(o1.getStart(), o2.getStart()). }
true;public,static;2;44;/**  * Merge overlapping {@link TimeWindow}s. For use by merging  * {@link org.apache.flink.streaming.api.windowing.assigners.WindowAssigner WindowAssigners}.  */ ;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ /**  * Merge overlapping {@link TimeWindow}s. For use by merging  * {@link org.apache.flink.streaming.api.windowing.assigners.WindowAssigner WindowAssigners}.  */ public static void mergeWindows(Collection<TimeWindow> windows, MergingWindowAssigner.MergeCallback<TimeWindow> c) {     // sort the windows by the start time and then merge overlapping windows     List<TimeWindow> sortedWindows = new ArrayList<>(windows).     Collections.sort(sortedWindows, new Comparator<TimeWindow>() {          @Override         public int compare(TimeWindow o1, TimeWindow o2) {             return Long.compare(o1.getStart(), o2.getStart()).         }     }).     List<Tuple2<TimeWindow, Set<TimeWindow>>> merged = new ArrayList<>().     Tuple2<TimeWindow, Set<TimeWindow>> currentMerge = null.     for (TimeWindow candidate : sortedWindows) {         if (currentMerge == null) {             currentMerge = new Tuple2<>().             currentMerge.f0 = candidate.             currentMerge.f1 = new HashSet<>().             currentMerge.f1.add(candidate).         } else if (currentMerge.f0.intersects(candidate)) {             currentMerge.f0 = currentMerge.f0.cover(candidate).             currentMerge.f1.add(candidate).         } else {             merged.add(currentMerge).             currentMerge = new Tuple2<>().             currentMerge.f0 = candidate.             currentMerge.f1 = new HashSet<>().             currentMerge.f1.add(candidate).         }     }     if (currentMerge != null) {         merged.add(currentMerge).     }     for (Tuple2<TimeWindow, Set<TimeWindow>> m : merged) {         if (m.f1.size() > 1) {             c.merge(m.f1, m.f0).         }     } }
true;public,static;3;3;/**  * Method to get the window start for a timestamp.  *  * @param timestamp epoch millisecond to get the window start.  * @param offset The offset which window start would be shifted by.  * @param windowSize The size of the generated windows.  * @return window start  */ ;/**  * Method to get the window start for a timestamp.  *  * @param timestamp epoch millisecond to get the window start.  * @param offset The offset which window start would be shifted by.  * @param windowSize The size of the generated windows.  * @return window start  */ public static long getWindowStartWithOffset(long timestamp, long offset, long windowSize) {     return timestamp - (timestamp - offset + windowSize) % windowSize. }
