commented;modifiers;parameterAmount;loc;comment;code
false;public;0;17;;@Override public AsyncResult peekBlockingly() throws InterruptedException {     lock.lockInterruptibly().     try {         while (queue.isEmpty() || !queue.peek().isDone()) {             headIsCompleted.await().         }         LOG.debug("Peeked head element from ordered stream element queue with filling degree " + "({}/{}).", queue.size(), capacity).         return queue.peek().     } finally {         lock.unlock().     } }
false;public;0;19;;@Override public AsyncResult poll() throws InterruptedException {     lock.lockInterruptibly().     try {         while (queue.isEmpty() || !queue.peek().isDone()) {             headIsCompleted.await().         }         notFull.signalAll().         LOG.debug("Polled head element from ordered stream element queue. New filling degree " + "({}/{}).", queue.size() - 1, capacity).         return queue.poll().     } finally {         lock.unlock().     } }
false;public;0;14;;@Override public Collection<StreamElementQueueEntry<?>> values() throws InterruptedException {     lock.lockInterruptibly().     try {         StreamElementQueueEntry<?>[] array = new StreamElementQueueEntry[queue.size()].         array = queue.toArray(array).         return Arrays.asList(array).     } finally {         lock.unlock().     } }
false;public;0;4;;@Override public boolean isEmpty() {     return queue.isEmpty(). }
false;public;0;4;;@Override public int size() {     return queue.size(). }
false;public;1;14;;@Override public <T> void put(StreamElementQueueEntry<T> streamElementQueueEntry) throws InterruptedException {     lock.lockInterruptibly().     try {         while (queue.size() >= capacity) {             notFull.await().         }         addEntry(streamElementQueueEntry).     } finally {         lock.unlock().     } }
false;public;1;22;;@Override public <T> boolean tryPut(StreamElementQueueEntry<T> streamElementQueueEntry) throws InterruptedException {     lock.lockInterruptibly().     try {         if (queue.size() < capacity) {             addEntry(streamElementQueueEntry).             LOG.debug("Put element into ordered stream element queue. New filling degree " + "({}/{}).", queue.size(), capacity).             return true.         } else {             LOG.debug("Failed to put element into ordered stream element queue because it " + "was full ({}/{}).", queue.size(), capacity).             return false.         }     } finally {         lock.unlock().     } }
true;private;1;20;/**  * Add the given {@link StreamElementQueueEntry} to the queue. Additionally, this method  * registers a onComplete callback which is triggered once the given queue entry is completed.  *  * @param streamElementQueueEntry to be inserted  * @param <T> Type of the stream element queue entry's result  */ ;/**  * Add the given {@link StreamElementQueueEntry} to the queue. Additionally, this method  * registers a onComplete callback which is triggered once the given queue entry is completed.  *  * @param streamElementQueueEntry to be inserted  * @param <T> Type of the stream element queue entry's result  */ private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry) {     assert (lock.isHeldByCurrentThread()).     queue.addLast(streamElementQueueEntry).     streamElementQueueEntry.onComplete((StreamElementQueueEntry<T> value) -> {         try {             onCompleteHandler(value).         } catch (InterruptedException e) {             // we got interrupted. This indicates a shutdown of the executor             LOG.debug("AsyncBufferEntry could not be properly completed because the " + "executor thread has been interrupted.", e).         } catch (Throwable t) {             operatorActions.failOperator(new Exception("Could not complete the " + "stream element queue entry: " + value + '.', t)).         }     }, executor). }
true;private;1;12;/**  * Check if the completed {@link StreamElementQueueEntry} is the current head. If this is the  * case, then notify the consumer thread about a new consumable entry.  *  * @param streamElementQueueEntry which has been completed  * @throws InterruptedException if the current thread is interrupted  */ ;/**  * Check if the completed {@link StreamElementQueueEntry} is the current head. If this is the  * case, then notify the consumer thread about a new consumable entry.  *  * @param streamElementQueueEntry which has been completed  * @throws InterruptedException if the current thread is interrupted  */ private void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException {     lock.lockInterruptibly().     try {         if (!queue.isEmpty() && queue.peek().isDone()) {             LOG.debug("Signal ordered stream element queue has completed head element.").             headIsCompleted.signalAll().         }     } finally {         lock.unlock().     } }
