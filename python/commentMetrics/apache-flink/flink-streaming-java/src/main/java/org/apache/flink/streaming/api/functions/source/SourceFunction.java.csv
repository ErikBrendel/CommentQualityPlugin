commented;modifiers;parameterAmount;loc;comment;code
true;;1;1;/**  * Starts the source. Implementations can use the {@link SourceContext} emit  * elements.  *  * <p>Sources that implement {@link org.apache.flink.streaming.api.checkpoint.CheckpointedFunction}  * must lock on the checkpoint lock (using a synchronized block) before updating internal  * state and emitting elements, to make both an atomic operation:  *  * <pre>{@code  *  public class ExampleCountSource implements SourceFunction<Long>, CheckpointedFunction {  *      private long count = 0L.  *      private volatile boolean isRunning = true.  *  *      private transient ListState<Long> checkpointedCount.  *  *      public void run(SourceContext<T> ctx) {  *          while (isRunning && count < 1000) {  *              // this synchronized block ensures that state checkpointing,  *              // internal state updates and emission of elements are an atomic operation  *              synchronized (ctx.getCheckpointLock()) {  *                  ctx.collect(count).  *                  count++.  *              }  *          }  *      }  *  *      public void cancel() {  *          isRunning = false.  *      }  *  *      public void initializeState(FunctionInitializationContext context) {  *          this.checkpointedCount = context  *              .getOperatorStateStore()  *              .getListState(new ListStateDescriptor<>("count", Long.class)).  *  *          if (context.isRestored()) {  *              for (Long count : this.checkpointedCount.get()) {  *                  this.count = count.  *              }  *          }  *      }  *  *      public void snapshotState(FunctionSnapshotContext context) {  *          this.checkpointedCount.clear().  *          this.checkpointedCount.add(count).  *      }  * }  * }</pre>  *  * @param ctx The context to emit elements to and for accessing locks.  */ ;/**  * Starts the source. Implementations can use the {@link SourceContext} emit  * elements.  *  * <p>Sources that implement {@link org.apache.flink.streaming.api.checkpoint.CheckpointedFunction}  * must lock on the checkpoint lock (using a synchronized block) before updating internal  * state and emitting elements, to make both an atomic operation:  *  * <pre>{@code  *  public class ExampleCountSource implements SourceFunction<Long>, CheckpointedFunction {  *      private long count = 0L.  *      private volatile boolean isRunning = true.  *  *      private transient ListState<Long> checkpointedCount.  *  *      public void run(SourceContext<T> ctx) {  *          while (isRunning && count < 1000) {  *              // this synchronized block ensures that state checkpointing,  *              // internal state updates and emission of elements are an atomic operation  *              synchronized (ctx.getCheckpointLock()) {  *                  ctx.collect(count).  *                  count++.  *              }  *          }  *      }  *  *      public void cancel() {  *          isRunning = false.  *      }  *  *      public void initializeState(FunctionInitializationContext context) {  *          this.checkpointedCount = context  *              .getOperatorStateStore()  *              .getListState(new ListStateDescriptor<>("count", Long.class)).  *  *          if (context.isRestored()) {  *              for (Long count : this.checkpointedCount.get()) {  *                  this.count = count.  *              }  *          }  *      }  *  *      public void snapshotState(FunctionSnapshotContext context) {  *          this.checkpointedCount.clear().  *          this.checkpointedCount.add(count).  *      }  * }  * }</pre>  *  * @param ctx The context to emit elements to and for accessing locks.  */ void run(SourceContext<T> ctx) throws Exception.
true;;0;1;/**  * Cancels the source. Most sources will have a while loop inside the  * {@link #run(SourceContext)} method. The implementation needs to ensure that the  * source will break out of that loop after this method is called.  *  * <p>A typical pattern is to have an {@code "volatile boolean isRunning"} flag that is set to  * {@code false} in this method. That flag is checked in the loop condition.  *  * <p>When a source is canceled, the executing thread will also be interrupted  * (via {@link Thread#interrupt()}). The interruption happens strictly after this  * method has been called, so any interruption handler can rely on the fact that  * this method has completed. It is good practice to make any flags altered by  * this method "volatile", in order to guarantee the visibility of the effects of  * this method to any interruption handler.  */ ;/**  * Cancels the source. Most sources will have a while loop inside the  * {@link #run(SourceContext)} method. The implementation needs to ensure that the  * source will break out of that loop after this method is called.  *  * <p>A typical pattern is to have an {@code "volatile boolean isRunning"} flag that is set to  * {@code false} in this method. That flag is checked in the loop condition.  *  * <p>When a source is canceled, the executing thread will also be interrupted  * (via {@link Thread#interrupt()}). The interruption happens strictly after this  * method has been called, so any interruption handler can rely on the fact that  * this method has completed. It is good practice to make any flags altered by  * this method "volatile", in order to guarantee the visibility of the effects of  * this method to any interruption handler.  */ void cancel().
true;;1;1;/**  * Emits one element from the source, without attaching a timestamp. In most cases,  * this is the default way of emitting elements.  *  * <p>The timestamp that the element will get assigned depends on the time characteristic of  * the streaming program:  * <ul>  *     <li>On {@link TimeCharacteristic#ProcessingTime}, the element has no timestamp.</li>  *     <li>On {@link TimeCharacteristic#IngestionTime}, the element gets the system's  *         current time as the timestamp.</li>  *     <li>On {@link TimeCharacteristic#EventTime}, the element will have no timestamp initially.  *         It needs to get a timestamp (via a {@link TimestampAssigner}) before any time-dependent  *         operation (like time windows).</li>  * </ul>  *  * @param element The element to emit  */ ;/**  * Emits one element from the source, without attaching a timestamp. In most cases,  * this is the default way of emitting elements.  *  * <p>The timestamp that the element will get assigned depends on the time characteristic of  * the streaming program:  * <ul>  *     <li>On {@link TimeCharacteristic#ProcessingTime}, the element has no timestamp.</li>  *     <li>On {@link TimeCharacteristic#IngestionTime}, the element gets the system's  *         current time as the timestamp.</li>  *     <li>On {@link TimeCharacteristic#EventTime}, the element will have no timestamp initially.  *         It needs to get a timestamp (via a {@link TimestampAssigner}) before any time-dependent  *         operation (like time windows).</li>  * </ul>  *  * @param element The element to emit  */ void collect(T element).
true;;2;2;/**  * Emits one element from the source, and attaches the given timestamp. This method  * is relevant for programs using {@link TimeCharacteristic#EventTime}, where the  * sources assign timestamps themselves, rather than relying on a {@link TimestampAssigner}  * on the stream.  *  * <p>On certain time characteristics, this timestamp may be ignored or overwritten.  * This allows programs to switch between the different time characteristics and behaviors  * without changing the code of the source functions.  * <ul>  *     <li>On {@link TimeCharacteristic#ProcessingTime}, the timestamp will be ignored,  *         because processing time never works with element timestamps.</li>  *     <li>On {@link TimeCharacteristic#IngestionTime}, the timestamp is overwritten with the  *         system's current time, to realize proper ingestion time semantics.</li>  *     <li>On {@link TimeCharacteristic#EventTime}, the timestamp will be used.</li>  * </ul>  *  * @param element The element to emit  * @param timestamp The timestamp in milliseconds since the Epoch  */ ;/**  * Emits one element from the source, and attaches the given timestamp. This method  * is relevant for programs using {@link TimeCharacteristic#EventTime}, where the  * sources assign timestamps themselves, rather than relying on a {@link TimestampAssigner}  * on the stream.  *  * <p>On certain time characteristics, this timestamp may be ignored or overwritten.  * This allows programs to switch between the different time characteristics and behaviors  * without changing the code of the source functions.  * <ul>  *     <li>On {@link TimeCharacteristic#ProcessingTime}, the timestamp will be ignored,  *         because processing time never works with element timestamps.</li>  *     <li>On {@link TimeCharacteristic#IngestionTime}, the timestamp is overwritten with the  *         system's current time, to realize proper ingestion time semantics.</li>  *     <li>On {@link TimeCharacteristic#EventTime}, the timestamp will be used.</li>  * </ul>  *  * @param element The element to emit  * @param timestamp The timestamp in milliseconds since the Epoch  */ @PublicEvolving void collectWithTimestamp(T element, long timestamp).
true;;1;2;/**  * Emits the given {@link Watermark}. A Watermark of value {@code t} declares that no  * elements with a timestamp {@code t' <= t} will occur any more. If further such  * elements will be emitted, those elements are considered <i>late</i>.  *  * <p>This method is only relevant when running on {@link TimeCharacteristic#EventTime}.  * On {@link TimeCharacteristic#ProcessingTime},Watermarks will be ignored. On  * {@link TimeCharacteristic#IngestionTime}, the Watermarks will be replaced by the  * automatic ingestion time watermarks.  *  * @param mark The Watermark to emit  */ ;/**  * Emits the given {@link Watermark}. A Watermark of value {@code t} declares that no  * elements with a timestamp {@code t' <= t} will occur any more. If further such  * elements will be emitted, those elements are considered <i>late</i>.  *  * <p>This method is only relevant when running on {@link TimeCharacteristic#EventTime}.  * On {@link TimeCharacteristic#ProcessingTime},Watermarks will be ignored. On  * {@link TimeCharacteristic#IngestionTime}, the Watermarks will be replaced by the  * automatic ingestion time watermarks.  *  * @param mark The Watermark to emit  */ @PublicEvolving void emitWatermark(Watermark mark).
true;;0;2;/**  * Marks the source to be temporarily idle. This tells the system that this source will  * temporarily stop emitting records and watermarks for an indefinite amount of time. This  * is only relevant when running on {@link TimeCharacteristic#IngestionTime} and  * {@link TimeCharacteristic#EventTime}, allowing downstream tasks to advance their  * watermarks without the need to wait for watermarks from this source while it is idle.  *  * <p>Source functions should make a best effort to call this method as soon as they  * acknowledge themselves to be idle. The system will consider the source to resume activity  * again once {@link SourceContext#collect(T)}, {@link SourceContext#collectWithTimestamp(T, long)},  * or {@link SourceContext#emitWatermark(Watermark)} is called to emit elements or watermarks from the source.  */ ;/**  * Marks the source to be temporarily idle. This tells the system that this source will  * temporarily stop emitting records and watermarks for an indefinite amount of time. This  * is only relevant when running on {@link TimeCharacteristic#IngestionTime} and  * {@link TimeCharacteristic#EventTime}, allowing downstream tasks to advance their  * watermarks without the need to wait for watermarks from this source while it is idle.  *  * <p>Source functions should make a best effort to call this method as soon as they  * acknowledge themselves to be idle. The system will consider the source to resume activity  * again once {@link SourceContext#collect(T)}, {@link SourceContext#collectWithTimestamp(T, long)},  * or {@link SourceContext#emitWatermark(Watermark)} is called to emit elements or watermarks from the source.  */ @PublicEvolving void markAsTemporarilyIdle().
true;;0;1;/**  * Returns the checkpoint lock. Please refer to the class-level comment in  * {@link SourceFunction} for details about how to write a consistent checkpointed  * source.  *  * @return The object to use as the lock  */ ;/**  * Returns the checkpoint lock. Please refer to the class-level comment in  * {@link SourceFunction} for details about how to write a consistent checkpointed  * source.  *  * @return The object to use as the lock  */ Object getCheckpointLock().
true;;0;1;/**  * This method is called by the system to shut down the context.  */ ;/**  * This method is called by the system to shut down the context.  */ void close().
