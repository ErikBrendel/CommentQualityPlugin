# id;timestamp;commentText;codeText;commentWords;codeWords
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1445418103;Starts the source. You can use the {@link org.apache.flink.util.Collector} parameter to emit_elements. Sources that implement_{@link org.apache.flink.streaming.api.checkpoint.Checkpointed} must lock on the_checkpoint lock (using a synchronized block) before updating internal state and/or emitting_elements. Also, the update of state and emission of elements must happen in the same_synchronized block.__@param ctx The context for interaction with the outside world.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,you,can,use,the,link,org,apache,flink,util,collector,parameter,to,emit,elements,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,or,emitting,elements,also,the,update,of,state,and,emission,of,elements,must,happen,in,the,same,synchronized,block,param,ctx,the,context,for,interaction,with,the,outside,world;void,run,source,context,t,ctx,throws,exception
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1446112342;Starts the source. You can use the {@link org.apache.flink.util.Collector} parameter to emit_elements. Sources that implement_{@link org.apache.flink.streaming.api.checkpoint.Checkpointed} must lock on the_checkpoint lock (using a synchronized block) before updating internal state and/or emitting_elements. Also, the update of state and emission of elements must happen in the same_synchronized block.__@param ctx The context for interaction with the outside world.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,you,can,use,the,link,org,apache,flink,util,collector,parameter,to,emit,elements,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,or,emitting,elements,also,the,update,of,state,and,emission,of,elements,must,happen,in,the,same,synchronized,block,param,ctx,the,context,for,interaction,with,the,outside,world;void,run,source,context,t,ctx,throws,exception
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1454679829;Starts the source. You can use the {@link org.apache.flink.util.Collector} parameter to emit_elements. Sources that implement_{@link org.apache.flink.streaming.api.checkpoint.Checkpointed} must lock on the_checkpoint lock (using a synchronized block) before updating internal state and/or emitting_elements. Also, the update of state and emission of elements must happen in the same_synchronized block.__@param ctx The context for interaction with the outside world.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,you,can,use,the,link,org,apache,flink,util,collector,parameter,to,emit,elements,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,or,emitting,elements,also,the,update,of,state,and,emission,of,elements,must,happen,in,the,same,synchronized,block,param,ctx,the,context,for,interaction,with,the,outside,world;void,run,source,context,t,ctx,throws,exception
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1455101486;Starts the source. You can use the {@link org.apache.flink.util.Collector} parameter to emit_elements. Sources that implement_{@link org.apache.flink.streaming.api.checkpoint.Checkpointed} must lock on the_checkpoint lock (using a synchronized block) before updating internal state and/or emitting_elements. Also, the update of state and emission of elements must happen in the same_synchronized block.__@param ctx The context for interaction with the outside world.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,you,can,use,the,link,org,apache,flink,util,collector,parameter,to,emit,elements,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,or,emitting,elements,also,the,update,of,state,and,emission,of,elements,must,happen,in,the,same,synchronized,block,param,ctx,the,context,for,interaction,with,the,outside,world;void,run,source,context,t,ctx,throws,exception
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1456347641;Starts the source. You can use the {@link org.apache.flink.util.Collector} parameter to emit_elements. Sources that implement_{@link org.apache.flink.streaming.api.checkpoint.Checkpointed} must lock on the_checkpoint lock (using a synchronized block) before updating internal state and/or emitting_elements. Also, the update of state and emission of elements must happen in the same_synchronized block.__@param ctx The context for interaction with the outside world.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,you,can,use,the,link,org,apache,flink,util,collector,parameter,to,emit,elements,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,or,emitting,elements,also,the,update,of,state,and,emission,of,elements,must,happen,in,the,same,synchronized,block,param,ctx,the,context,for,interaction,with,the,outside,world;void,run,source,context,t,ctx,throws,exception
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1456999993;Starts the source. Implementations can use the {@link SourceContext} emit_elements.__<p>Sources that implement {@link org.apache.flink.streaming.api.checkpoint.Checkpointed}_must lock on the checkpoint lock (using a synchronized block) before updating internal_state and emitting elements, to make both an atomic operation:__<pre>{@code_public class ExampleSource<T> implements SourceFunction<T>, Checkpointed<Long> {_private long count = 0L__private volatile boolean isRunning = true___public void run(SourceContext<T> ctx) {_while (isRunning && count < 1000) {_synchronized (ctx.getCheckpointLock()) {_ctx.collect(count)__count++______public void cancel() {_isRunning = false____public Long snapshotState(long checkpointId, long checkpointTimestamp) { return count_ }__public void restoreState(Long state) { this.count = state_ }__}</pre>__@param ctx The context to emit elements to and for accessing locks.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,implementations,can,use,the,link,source,context,emit,elements,p,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,emitting,elements,to,make,both,an,atomic,operation,pre,code,public,class,example,source,t,implements,source,function,t,checkpointed,long,private,long,count,0l,private,volatile,boolean,is,running,true,public,void,run,source,context,t,ctx,while,is,running,count,1000,synchronized,ctx,get,checkpoint,lock,ctx,collect,count,count,public,void,cancel,is,running,false,public,long,snapshot,state,long,checkpoint,id,long,checkpoint,timestamp,return,count,public,void,restore,state,long,state,this,count,state,pre,param,ctx,the,context,to,emit,elements,to,and,for,accessing,locks;void,run,source,context,t,ctx,throws,exception
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1487783998;Starts the source. Implementations can use the {@link SourceContext} emit_elements.__<p>Sources that implement {@link org.apache.flink.streaming.api.checkpoint.Checkpointed}_must lock on the checkpoint lock (using a synchronized block) before updating internal_state and emitting elements, to make both an atomic operation:__<pre>{@code_public class ExampleSource<T> implements SourceFunction<T>, Checkpointed<Long> {_private long count = 0L__private volatile boolean isRunning = true___public void run(SourceContext<T> ctx) {_while (isRunning && count < 1000) {_synchronized (ctx.getCheckpointLock()) {_ctx.collect(count)__count++______public void cancel() {_isRunning = false____public Long snapshotState(long checkpointId, long checkpointTimestamp) { return count_ }__public void restoreState(Long state) { this.count = state_ }__}</pre>__@param ctx The context to emit elements to and for accessing locks.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,implementations,can,use,the,link,source,context,emit,elements,p,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,emitting,elements,to,make,both,an,atomic,operation,pre,code,public,class,example,source,t,implements,source,function,t,checkpointed,long,private,long,count,0l,private,volatile,boolean,is,running,true,public,void,run,source,context,t,ctx,while,is,running,count,1000,synchronized,ctx,get,checkpoint,lock,ctx,collect,count,count,public,void,cancel,is,running,false,public,long,snapshot,state,long,checkpoint,id,long,checkpoint,timestamp,return,count,public,void,restore,state,long,state,this,count,state,pre,param,ctx,the,context,to,emit,elements,to,and,for,accessing,locks;void,run,source,context,t,ctx,throws,exception
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1493195810;Starts the source. Implementations can use the {@link SourceContext} emit_elements.__<p>Sources that implement {@link org.apache.flink.streaming.api.checkpoint.Checkpointed}_must lock on the checkpoint lock (using a synchronized block) before updating internal_state and emitting elements, to make both an atomic operation:__<pre>{@code_public class ExampleSource<T> implements SourceFunction<T>, Checkpointed<Long> {_private long count = 0L__private volatile boolean isRunning = true___public void run(SourceContext<T> ctx) {_while (isRunning && count < 1000) {_synchronized (ctx.getCheckpointLock()) {_ctx.collect(count)__count++______public void cancel() {_isRunning = false____public Long snapshotState(long checkpointId, long checkpointTimestamp) { return count_ }__public void restoreState(Long state) { this.count = state_ }__}</pre>__@param ctx The context to emit elements to and for accessing locks.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,implementations,can,use,the,link,source,context,emit,elements,p,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,emitting,elements,to,make,both,an,atomic,operation,pre,code,public,class,example,source,t,implements,source,function,t,checkpointed,long,private,long,count,0l,private,volatile,boolean,is,running,true,public,void,run,source,context,t,ctx,while,is,running,count,1000,synchronized,ctx,get,checkpoint,lock,ctx,collect,count,count,public,void,cancel,is,running,false,public,long,snapshot,state,long,checkpoint,id,long,checkpoint,timestamp,return,count,public,void,restore,state,long,state,this,count,state,pre,param,ctx,the,context,to,emit,elements,to,and,for,accessing,locks;void,run,source,context,t,ctx,throws,exception
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1493195810;Starts the source. Implementations can use the {@link SourceContext} emit_elements.__<p>Sources that implement {@link org.apache.flink.streaming.api.checkpoint.Checkpointed}_must lock on the checkpoint lock (using a synchronized block) before updating internal_state and emitting elements, to make both an atomic operation:__<pre>{@code_public class ExampleSource<T> implements SourceFunction<T>, Checkpointed<Long> {_private long count = 0L__private volatile boolean isRunning = true___public void run(SourceContext<T> ctx) {_while (isRunning && count < 1000) {_synchronized (ctx.getCheckpointLock()) {_ctx.collect(count)__count++______public void cancel() {_isRunning = false____public Long snapshotState(long checkpointId, long checkpointTimestamp) { return count_ }__public void restoreState(Long state) { this.count = state_ }__}</pre>__@param ctx The context to emit elements to and for accessing locks.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,implementations,can,use,the,link,source,context,emit,elements,p,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,emitting,elements,to,make,both,an,atomic,operation,pre,code,public,class,example,source,t,implements,source,function,t,checkpointed,long,private,long,count,0l,private,volatile,boolean,is,running,true,public,void,run,source,context,t,ctx,while,is,running,count,1000,synchronized,ctx,get,checkpoint,lock,ctx,collect,count,count,public,void,cancel,is,running,false,public,long,snapshot,state,long,checkpoint,id,long,checkpoint,timestamp,return,count,public,void,restore,state,long,state,this,count,state,pre,param,ctx,the,context,to,emit,elements,to,and,for,accessing,locks;void,run,source,context,t,ctx,throws,exception
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1493195810;Starts the source. Implementations can use the {@link SourceContext} emit_elements.__<p>Sources that implement {@link org.apache.flink.streaming.api.checkpoint.Checkpointed}_must lock on the checkpoint lock (using a synchronized block) before updating internal_state and emitting elements, to make both an atomic operation:__<pre>{@code_public class ExampleSource<T> implements SourceFunction<T>, Checkpointed<Long> {_private long count = 0L__private volatile boolean isRunning = true___public void run(SourceContext<T> ctx) {_while (isRunning && count < 1000) {_synchronized (ctx.getCheckpointLock()) {_ctx.collect(count)__count++______public void cancel() {_isRunning = false____public Long snapshotState(long checkpointId, long checkpointTimestamp) { return count_ }__public void restoreState(Long state) { this.count = state_ }__}</pre>__@param ctx The context to emit elements to and for accessing locks.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,implementations,can,use,the,link,source,context,emit,elements,p,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,emitting,elements,to,make,both,an,atomic,operation,pre,code,public,class,example,source,t,implements,source,function,t,checkpointed,long,private,long,count,0l,private,volatile,boolean,is,running,true,public,void,run,source,context,t,ctx,while,is,running,count,1000,synchronized,ctx,get,checkpoint,lock,ctx,collect,count,count,public,void,cancel,is,running,false,public,long,snapshot,state,long,checkpoint,id,long,checkpoint,timestamp,return,count,public,void,restore,state,long,state,this,count,state,pre,param,ctx,the,context,to,emit,elements,to,and,for,accessing,locks;void,run,source,context,t,ctx,throws,exception
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1495484544;Starts the source. Implementations can use the {@link SourceContext} emit_elements.__<p>Sources that implement {@link org.apache.flink.streaming.api.checkpoint.Checkpointed}_must lock on the checkpoint lock (using a synchronized block) before updating internal_state and emitting elements, to make both an atomic operation:__<pre>{@code_public class ExampleSource<T> implements SourceFunction<T>, Checkpointed<Long> {_private long count = 0L__private volatile boolean isRunning = true___public void run(SourceContext<T> ctx) {_while (isRunning && count < 1000) {_synchronized (ctx.getCheckpointLock()) {_ctx.collect(count)__count++______public void cancel() {_isRunning = false____public Long snapshotState(long checkpointId, long checkpointTimestamp) { return count_ }__public void restoreState(Long state) { this.count = state_ }__}</pre>__@param ctx The context to emit elements to and for accessing locks.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,implementations,can,use,the,link,source,context,emit,elements,p,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,emitting,elements,to,make,both,an,atomic,operation,pre,code,public,class,example,source,t,implements,source,function,t,checkpointed,long,private,long,count,0l,private,volatile,boolean,is,running,true,public,void,run,source,context,t,ctx,while,is,running,count,1000,synchronized,ctx,get,checkpoint,lock,ctx,collect,count,count,public,void,cancel,is,running,false,public,long,snapshot,state,long,checkpoint,id,long,checkpoint,timestamp,return,count,public,void,restore,state,long,state,this,count,state,pre,param,ctx,the,context,to,emit,elements,to,and,for,accessing,locks;void,run,source,context,t,ctx,throws,exception
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1515212028;Starts the source. Implementations can use the {@link SourceContext} emit_elements.__<p>Sources that implement {@link org.apache.flink.streaming.api.checkpoint.CheckpointedFunction}_must lock on the checkpoint lock (using a synchronized block) before updating internal_state and emitting elements, to make both an atomic operation:__<pre>{@code_public class ExampleSource<T> implements SourceFunction<T>, CheckpointedFunction<Long> {_private long count = 0L__private volatile boolean isRunning = true___public void run(SourceContext<T> ctx) {_while (isRunning && count < 1000) {_synchronized (ctx.getCheckpointLock()) {_ctx.collect(count)__count++______public void cancel() {_isRunning = false____public Long snapshotState(long checkpointId, long checkpointTimestamp) { return count_ }__public void restoreState(Long state) { this.count = state_ }__}</pre>__@param ctx The context to emit elements to and for accessing locks.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,implementations,can,use,the,link,source,context,emit,elements,p,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,function,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,emitting,elements,to,make,both,an,atomic,operation,pre,code,public,class,example,source,t,implements,source,function,t,checkpointed,function,long,private,long,count,0l,private,volatile,boolean,is,running,true,public,void,run,source,context,t,ctx,while,is,running,count,1000,synchronized,ctx,get,checkpoint,lock,ctx,collect,count,count,public,void,cancel,is,running,false,public,long,snapshot,state,long,checkpoint,id,long,checkpoint,timestamp,return,count,public,void,restore,state,long,state,this,count,state,pre,param,ctx,the,context,to,emit,elements,to,and,for,accessing,locks;void,run,source,context,t,ctx,throws,exception
SourceFunction -> void run(SourceContext<T> ctx) throws Exception_;1515212028;Starts the source. Implementations can use the {@link SourceContext} emit_elements.__<p>Sources that implement {@link org.apache.flink.streaming.api.checkpoint.CheckpointedFunction}_must lock on the checkpoint lock (using a synchronized block) before updating internal_state and emitting elements, to make both an atomic operation:__<pre>{@code_public class ExampleCountSource implements SourceFunction<Long>, CheckpointedFunction {_private long count = 0L__private volatile boolean isRunning = true___private transient ListState<Long> checkpointedCount___public void run(SourceContext<T> ctx) {_while (isRunning && count < 1000) {_// this synchronized block ensures that state checkpointing,_// internal state updates and emission of elements are an atomic operation_synchronized (ctx.getCheckpointLock()) {_ctx.collect(count)__count++______public void cancel() {_isRunning = false____public void initializeState(FunctionInitializationContext context) {_this.checkpointedCount = context_.getOperatorStateStore()_.getListState(new ListStateDescriptor<>("count", Long.class))___if (context.isRestored()) {_for (Long count : this.checkpointedCount.get()) {_this.count = count______public void snapshotState(FunctionSnapshotContext context) {_this.checkpointedCount.clear()__this.checkpointedCount.add(count)____}</pre>__@param ctx The context to emit elements to and for accessing locks.;void run(SourceContext<T> ctx) throws Exception_;starts,the,source,implementations,can,use,the,link,source,context,emit,elements,p,sources,that,implement,link,org,apache,flink,streaming,api,checkpoint,checkpointed,function,must,lock,on,the,checkpoint,lock,using,a,synchronized,block,before,updating,internal,state,and,emitting,elements,to,make,both,an,atomic,operation,pre,code,public,class,example,count,source,implements,source,function,long,checkpointed,function,private,long,count,0l,private,volatile,boolean,is,running,true,private,transient,list,state,long,checkpointed,count,public,void,run,source,context,t,ctx,while,is,running,count,1000,this,synchronized,block,ensures,that,state,checkpointing,internal,state,updates,and,emission,of,elements,are,an,atomic,operation,synchronized,ctx,get,checkpoint,lock,ctx,collect,count,count,public,void,cancel,is,running,false,public,void,initialize,state,function,initialization,context,context,this,checkpointed,count,context,get,operator,state,store,get,list,state,new,list,state,descriptor,count,long,class,if,context,is,restored,for,long,count,this,checkpointed,count,get,this,count,count,public,void,snapshot,state,function,snapshot,context,context,this,checkpointed,count,clear,this,checkpointed,count,add,count,pre,param,ctx,the,context,to,emit,elements,to,and,for,accessing,locks;void,run,source,context,t,ctx,throws,exception
SourceFunction -> SourceContext -> void close()_;1445418103;This must be called when closing the source operator to allow the {@link SourceContext}_to clean up internal state.;void close()_;this,must,be,called,when,closing,the,source,operator,to,allow,the,link,source,context,to,clean,up,internal,state;void,close
SourceFunction -> SourceContext -> void close()_;1446112342;This must be called when closing the source operator to allow the {@link SourceContext}_to clean up internal state.;void close()_;this,must,be,called,when,closing,the,source,operator,to,allow,the,link,source,context,to,clean,up,internal,state;void,close
SourceFunction -> SourceContext -> void close()_;1454679829;This must be called when closing the source operator to allow the {@link SourceContext}_to clean up internal state.;void close()_;this,must,be,called,when,closing,the,source,operator,to,allow,the,link,source,context,to,clean,up,internal,state;void,close
SourceFunction -> SourceContext -> void close()_;1455101486;This must be called when closing the source operator to allow the {@link SourceContext}_to clean up internal state.;void close()_;this,must,be,called,when,closing,the,source,operator,to,allow,the,link,source,context,to,clean,up,internal,state;void,close
SourceFunction -> SourceContext -> void close()_;1456347641;This must be called when closing the source operator to allow the {@link SourceContext}_to clean up internal state.;void close()_;this,must,be,called,when,closing,the,source,operator,to,allow,the,link,source,context,to,clean,up,internal,state;void,close
SourceFunction -> SourceContext -> void close()_;1456999993;This method is called by the system to shut down the context.;void close()_;this,method,is,called,by,the,system,to,shut,down,the,context;void,close
SourceFunction -> SourceContext -> void close()_;1487783998;This method is called by the system to shut down the context.;void close()_;this,method,is,called,by,the,system,to,shut,down,the,context;void,close
SourceFunction -> SourceContext -> void close()_;1493195810;This method is called by the system to shut down the context.;void close()_;this,method,is,called,by,the,system,to,shut,down,the,context;void,close
SourceFunction -> SourceContext -> void close()_;1493195810;This method is called by the system to shut down the context.;void close()_;this,method,is,called,by,the,system,to,shut,down,the,context;void,close
SourceFunction -> SourceContext -> void close()_;1493195810;This method is called by the system to shut down the context.;void close()_;this,method,is,called,by,the,system,to,shut,down,the,context;void,close
SourceFunction -> SourceContext -> void close()_;1495484544;This method is called by the system to shut down the context.;void close()_;this,method,is,called,by,the,system,to,shut,down,the,context;void,close
SourceFunction -> SourceContext -> void close()_;1515212028;This method is called by the system to shut down the context.;void close()_;this,method,is,called,by,the,system,to,shut,down,the,context;void,close
SourceFunction -> SourceContext -> void close()_;1515212028;This method is called by the system to shut down the context.;void close()_;this,method,is,called,by,the,system,to,shut,down,the,context;void,close
SourceFunction -> SourceContext -> @PublicEvolving 		void collectWithTimestamp(T element, long timestamp)_;1456347641;Emits one element from the source with the given timestamp.__@param element The element to emit_@param timestamp The timestamp in milliseconds;@PublicEvolving_		void collectWithTimestamp(T element, long timestamp)_;emits,one,element,from,the,source,with,the,given,timestamp,param,element,the,element,to,emit,param,timestamp,the,timestamp,in,milliseconds;public,evolving,void,collect,with,timestamp,t,element,long,timestamp
SourceFunction -> SourceContext -> @PublicEvolving 		void collectWithTimestamp(T element, long timestamp)_;1456999993;Emits one element from the source, and attaches the given timestamp. This method_is relevant for programs using {@link TimeCharacteristic#EventTime}, where the_sources assign timestamps themselves, rather than relying on a {@link TimestampAssigner}_on the stream.__<p>On certain time characteristics, this timestamp may be ignored or overwritten._This allows programs to switch between the different time characteristics and behaviors_without changing the code of the source functions._<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the timestamp will be ignored,_because processing time never works with element timestamps.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the timestamp is overwritten with the_system's current time, to realize proper ingestion time semantics.</li>_<li>On {@link TimeCharacteristic#EventTime}, the timestamp will be used.</li>_</ul>__@param element The element to emit_@param timestamp The timestamp in milliseconds since the Epoch;@PublicEvolving_		void collectWithTimestamp(T element, long timestamp)_;emits,one,element,from,the,source,and,attaches,the,given,timestamp,this,method,is,relevant,for,programs,using,link,time,characteristic,event,time,where,the,sources,assign,timestamps,themselves,rather,than,relying,on,a,link,timestamp,assigner,on,the,stream,p,on,certain,time,characteristics,this,timestamp,may,be,ignored,or,overwritten,this,allows,programs,to,switch,between,the,different,time,characteristics,and,behaviors,without,changing,the,code,of,the,source,functions,ul,li,on,link,time,characteristic,processing,time,the,timestamp,will,be,ignored,because,processing,time,never,works,with,element,timestamps,li,li,on,link,time,characteristic,ingestion,time,the,timestamp,is,overwritten,with,the,system,s,current,time,to,realize,proper,ingestion,time,semantics,li,li,on,link,time,characteristic,event,time,the,timestamp,will,be,used,li,ul,param,element,the,element,to,emit,param,timestamp,the,timestamp,in,milliseconds,since,the,epoch;public,evolving,void,collect,with,timestamp,t,element,long,timestamp
SourceFunction -> SourceContext -> @PublicEvolving 		void collectWithTimestamp(T element, long timestamp)_;1487783998;Emits one element from the source, and attaches the given timestamp. This method_is relevant for programs using {@link TimeCharacteristic#EventTime}, where the_sources assign timestamps themselves, rather than relying on a {@link TimestampAssigner}_on the stream.__<p>On certain time characteristics, this timestamp may be ignored or overwritten._This allows programs to switch between the different time characteristics and behaviors_without changing the code of the source functions._<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the timestamp will be ignored,_because processing time never works with element timestamps.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the timestamp is overwritten with the_system's current time, to realize proper ingestion time semantics.</li>_<li>On {@link TimeCharacteristic#EventTime}, the timestamp will be used.</li>_</ul>__@param element The element to emit_@param timestamp The timestamp in milliseconds since the Epoch;@PublicEvolving_		void collectWithTimestamp(T element, long timestamp)_;emits,one,element,from,the,source,and,attaches,the,given,timestamp,this,method,is,relevant,for,programs,using,link,time,characteristic,event,time,where,the,sources,assign,timestamps,themselves,rather,than,relying,on,a,link,timestamp,assigner,on,the,stream,p,on,certain,time,characteristics,this,timestamp,may,be,ignored,or,overwritten,this,allows,programs,to,switch,between,the,different,time,characteristics,and,behaviors,without,changing,the,code,of,the,source,functions,ul,li,on,link,time,characteristic,processing,time,the,timestamp,will,be,ignored,because,processing,time,never,works,with,element,timestamps,li,li,on,link,time,characteristic,ingestion,time,the,timestamp,is,overwritten,with,the,system,s,current,time,to,realize,proper,ingestion,time,semantics,li,li,on,link,time,characteristic,event,time,the,timestamp,will,be,used,li,ul,param,element,the,element,to,emit,param,timestamp,the,timestamp,in,milliseconds,since,the,epoch;public,evolving,void,collect,with,timestamp,t,element,long,timestamp
SourceFunction -> SourceContext -> @PublicEvolving 		void collectWithTimestamp(T element, long timestamp)_;1493195810;Emits one element from the source, and attaches the given timestamp. This method_is relevant for programs using {@link TimeCharacteristic#EventTime}, where the_sources assign timestamps themselves, rather than relying on a {@link TimestampAssigner}_on the stream.__<p>On certain time characteristics, this timestamp may be ignored or overwritten._This allows programs to switch between the different time characteristics and behaviors_without changing the code of the source functions._<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the timestamp will be ignored,_because processing time never works with element timestamps.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the timestamp is overwritten with the_system's current time, to realize proper ingestion time semantics.</li>_<li>On {@link TimeCharacteristic#EventTime}, the timestamp will be used.</li>_</ul>__@param element The element to emit_@param timestamp The timestamp in milliseconds since the Epoch;@PublicEvolving_		void collectWithTimestamp(T element, long timestamp)_;emits,one,element,from,the,source,and,attaches,the,given,timestamp,this,method,is,relevant,for,programs,using,link,time,characteristic,event,time,where,the,sources,assign,timestamps,themselves,rather,than,relying,on,a,link,timestamp,assigner,on,the,stream,p,on,certain,time,characteristics,this,timestamp,may,be,ignored,or,overwritten,this,allows,programs,to,switch,between,the,different,time,characteristics,and,behaviors,without,changing,the,code,of,the,source,functions,ul,li,on,link,time,characteristic,processing,time,the,timestamp,will,be,ignored,because,processing,time,never,works,with,element,timestamps,li,li,on,link,time,characteristic,ingestion,time,the,timestamp,is,overwritten,with,the,system,s,current,time,to,realize,proper,ingestion,time,semantics,li,li,on,link,time,characteristic,event,time,the,timestamp,will,be,used,li,ul,param,element,the,element,to,emit,param,timestamp,the,timestamp,in,milliseconds,since,the,epoch;public,evolving,void,collect,with,timestamp,t,element,long,timestamp
SourceFunction -> SourceContext -> @PublicEvolving 		void collectWithTimestamp(T element, long timestamp)_;1493195810;Emits one element from the source, and attaches the given timestamp. This method_is relevant for programs using {@link TimeCharacteristic#EventTime}, where the_sources assign timestamps themselves, rather than relying on a {@link TimestampAssigner}_on the stream.__<p>On certain time characteristics, this timestamp may be ignored or overwritten._This allows programs to switch between the different time characteristics and behaviors_without changing the code of the source functions._<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the timestamp will be ignored,_because processing time never works with element timestamps.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the timestamp is overwritten with the_system's current time, to realize proper ingestion time semantics.</li>_<li>On {@link TimeCharacteristic#EventTime}, the timestamp will be used.</li>_</ul>__@param element The element to emit_@param timestamp The timestamp in milliseconds since the Epoch;@PublicEvolving_		void collectWithTimestamp(T element, long timestamp)_;emits,one,element,from,the,source,and,attaches,the,given,timestamp,this,method,is,relevant,for,programs,using,link,time,characteristic,event,time,where,the,sources,assign,timestamps,themselves,rather,than,relying,on,a,link,timestamp,assigner,on,the,stream,p,on,certain,time,characteristics,this,timestamp,may,be,ignored,or,overwritten,this,allows,programs,to,switch,between,the,different,time,characteristics,and,behaviors,without,changing,the,code,of,the,source,functions,ul,li,on,link,time,characteristic,processing,time,the,timestamp,will,be,ignored,because,processing,time,never,works,with,element,timestamps,li,li,on,link,time,characteristic,ingestion,time,the,timestamp,is,overwritten,with,the,system,s,current,time,to,realize,proper,ingestion,time,semantics,li,li,on,link,time,characteristic,event,time,the,timestamp,will,be,used,li,ul,param,element,the,element,to,emit,param,timestamp,the,timestamp,in,milliseconds,since,the,epoch;public,evolving,void,collect,with,timestamp,t,element,long,timestamp
SourceFunction -> SourceContext -> @PublicEvolving 		void collectWithTimestamp(T element, long timestamp)_;1493195810;Emits one element from the source, and attaches the given timestamp. This method_is relevant for programs using {@link TimeCharacteristic#EventTime}, where the_sources assign timestamps themselves, rather than relying on a {@link TimestampAssigner}_on the stream.__<p>On certain time characteristics, this timestamp may be ignored or overwritten._This allows programs to switch between the different time characteristics and behaviors_without changing the code of the source functions._<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the timestamp will be ignored,_because processing time never works with element timestamps.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the timestamp is overwritten with the_system's current time, to realize proper ingestion time semantics.</li>_<li>On {@link TimeCharacteristic#EventTime}, the timestamp will be used.</li>_</ul>__@param element The element to emit_@param timestamp The timestamp in milliseconds since the Epoch;@PublicEvolving_		void collectWithTimestamp(T element, long timestamp)_;emits,one,element,from,the,source,and,attaches,the,given,timestamp,this,method,is,relevant,for,programs,using,link,time,characteristic,event,time,where,the,sources,assign,timestamps,themselves,rather,than,relying,on,a,link,timestamp,assigner,on,the,stream,p,on,certain,time,characteristics,this,timestamp,may,be,ignored,or,overwritten,this,allows,programs,to,switch,between,the,different,time,characteristics,and,behaviors,without,changing,the,code,of,the,source,functions,ul,li,on,link,time,characteristic,processing,time,the,timestamp,will,be,ignored,because,processing,time,never,works,with,element,timestamps,li,li,on,link,time,characteristic,ingestion,time,the,timestamp,is,overwritten,with,the,system,s,current,time,to,realize,proper,ingestion,time,semantics,li,li,on,link,time,characteristic,event,time,the,timestamp,will,be,used,li,ul,param,element,the,element,to,emit,param,timestamp,the,timestamp,in,milliseconds,since,the,epoch;public,evolving,void,collect,with,timestamp,t,element,long,timestamp
SourceFunction -> SourceContext -> @PublicEvolving 		void collectWithTimestamp(T element, long timestamp)_;1495484544;Emits one element from the source, and attaches the given timestamp. This method_is relevant for programs using {@link TimeCharacteristic#EventTime}, where the_sources assign timestamps themselves, rather than relying on a {@link TimestampAssigner}_on the stream.__<p>On certain time characteristics, this timestamp may be ignored or overwritten._This allows programs to switch between the different time characteristics and behaviors_without changing the code of the source functions._<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the timestamp will be ignored,_because processing time never works with element timestamps.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the timestamp is overwritten with the_system's current time, to realize proper ingestion time semantics.</li>_<li>On {@link TimeCharacteristic#EventTime}, the timestamp will be used.</li>_</ul>__@param element The element to emit_@param timestamp The timestamp in milliseconds since the Epoch;@PublicEvolving_		void collectWithTimestamp(T element, long timestamp)_;emits,one,element,from,the,source,and,attaches,the,given,timestamp,this,method,is,relevant,for,programs,using,link,time,characteristic,event,time,where,the,sources,assign,timestamps,themselves,rather,than,relying,on,a,link,timestamp,assigner,on,the,stream,p,on,certain,time,characteristics,this,timestamp,may,be,ignored,or,overwritten,this,allows,programs,to,switch,between,the,different,time,characteristics,and,behaviors,without,changing,the,code,of,the,source,functions,ul,li,on,link,time,characteristic,processing,time,the,timestamp,will,be,ignored,because,processing,time,never,works,with,element,timestamps,li,li,on,link,time,characteristic,ingestion,time,the,timestamp,is,overwritten,with,the,system,s,current,time,to,realize,proper,ingestion,time,semantics,li,li,on,link,time,characteristic,event,time,the,timestamp,will,be,used,li,ul,param,element,the,element,to,emit,param,timestamp,the,timestamp,in,milliseconds,since,the,epoch;public,evolving,void,collect,with,timestamp,t,element,long,timestamp
SourceFunction -> SourceContext -> @PublicEvolving 		void collectWithTimestamp(T element, long timestamp)_;1515212028;Emits one element from the source, and attaches the given timestamp. This method_is relevant for programs using {@link TimeCharacteristic#EventTime}, where the_sources assign timestamps themselves, rather than relying on a {@link TimestampAssigner}_on the stream.__<p>On certain time characteristics, this timestamp may be ignored or overwritten._This allows programs to switch between the different time characteristics and behaviors_without changing the code of the source functions._<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the timestamp will be ignored,_because processing time never works with element timestamps.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the timestamp is overwritten with the_system's current time, to realize proper ingestion time semantics.</li>_<li>On {@link TimeCharacteristic#EventTime}, the timestamp will be used.</li>_</ul>__@param element The element to emit_@param timestamp The timestamp in milliseconds since the Epoch;@PublicEvolving_		void collectWithTimestamp(T element, long timestamp)_;emits,one,element,from,the,source,and,attaches,the,given,timestamp,this,method,is,relevant,for,programs,using,link,time,characteristic,event,time,where,the,sources,assign,timestamps,themselves,rather,than,relying,on,a,link,timestamp,assigner,on,the,stream,p,on,certain,time,characteristics,this,timestamp,may,be,ignored,or,overwritten,this,allows,programs,to,switch,between,the,different,time,characteristics,and,behaviors,without,changing,the,code,of,the,source,functions,ul,li,on,link,time,characteristic,processing,time,the,timestamp,will,be,ignored,because,processing,time,never,works,with,element,timestamps,li,li,on,link,time,characteristic,ingestion,time,the,timestamp,is,overwritten,with,the,system,s,current,time,to,realize,proper,ingestion,time,semantics,li,li,on,link,time,characteristic,event,time,the,timestamp,will,be,used,li,ul,param,element,the,element,to,emit,param,timestamp,the,timestamp,in,milliseconds,since,the,epoch;public,evolving,void,collect,with,timestamp,t,element,long,timestamp
SourceFunction -> SourceContext -> @PublicEvolving 		void collectWithTimestamp(T element, long timestamp)_;1515212028;Emits one element from the source, and attaches the given timestamp. This method_is relevant for programs using {@link TimeCharacteristic#EventTime}, where the_sources assign timestamps themselves, rather than relying on a {@link TimestampAssigner}_on the stream.__<p>On certain time characteristics, this timestamp may be ignored or overwritten._This allows programs to switch between the different time characteristics and behaviors_without changing the code of the source functions._<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the timestamp will be ignored,_because processing time never works with element timestamps.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the timestamp is overwritten with the_system's current time, to realize proper ingestion time semantics.</li>_<li>On {@link TimeCharacteristic#EventTime}, the timestamp will be used.</li>_</ul>__@param element The element to emit_@param timestamp The timestamp in milliseconds since the Epoch;@PublicEvolving_		void collectWithTimestamp(T element, long timestamp)_;emits,one,element,from,the,source,and,attaches,the,given,timestamp,this,method,is,relevant,for,programs,using,link,time,characteristic,event,time,where,the,sources,assign,timestamps,themselves,rather,than,relying,on,a,link,timestamp,assigner,on,the,stream,p,on,certain,time,characteristics,this,timestamp,may,be,ignored,or,overwritten,this,allows,programs,to,switch,between,the,different,time,characteristics,and,behaviors,without,changing,the,code,of,the,source,functions,ul,li,on,link,time,characteristic,processing,time,the,timestamp,will,be,ignored,because,processing,time,never,works,with,element,timestamps,li,li,on,link,time,characteristic,ingestion,time,the,timestamp,is,overwritten,with,the,system,s,current,time,to,realize,proper,ingestion,time,semantics,li,li,on,link,time,characteristic,event,time,the,timestamp,will,be,used,li,ul,param,element,the,element,to,emit,param,timestamp,the,timestamp,in,milliseconds,since,the,epoch;public,evolving,void,collect,with,timestamp,t,element,long,timestamp
SourceFunction -> void cancel()_;1445418103;Cancels the source. Most sources will have a while loop inside the_{@link #run} method. You need to ensure that the source will break out of this loop. This_can be achieved by having a volatile field "isRunning" that is checked in the loop and that_is set to false in this method.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,method,you,need,to,ensure,that,the,source,will,break,out,of,this,loop,this,can,be,achieved,by,having,a,volatile,field,is,running,that,is,checked,in,the,loop,and,that,is,set,to,false,in,this,method;void,cancel
SourceFunction -> void cancel()_;1446112342;Cancels the source. Most sources will have a while loop inside the_{@link #run} method. You need to ensure that the source will break out of this loop. This_can be achieved by having a volatile field "isRunning" that is checked in the loop and that_is set to false in this method.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,method,you,need,to,ensure,that,the,source,will,break,out,of,this,loop,this,can,be,achieved,by,having,a,volatile,field,is,running,that,is,checked,in,the,loop,and,that,is,set,to,false,in,this,method;void,cancel
SourceFunction -> void cancel()_;1454679829;Cancels the source. Most sources will have a while loop inside the_{@link #run} method. You need to ensure that the source will break out of this loop. This_can be achieved by having a volatile field "isRunning" that is checked in the loop and that_is set to false in this method.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,method,you,need,to,ensure,that,the,source,will,break,out,of,this,loop,this,can,be,achieved,by,having,a,volatile,field,is,running,that,is,checked,in,the,loop,and,that,is,set,to,false,in,this,method;void,cancel
SourceFunction -> void cancel()_;1455101486;Cancels the source. Most sources will have a while loop inside the_{@link #run} method. You need to ensure that the source will break out of this loop. This_can be achieved by having a volatile field "isRunning" that is checked in the loop and that_is set to false in this method.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,method,you,need,to,ensure,that,the,source,will,break,out,of,this,loop,this,can,be,achieved,by,having,a,volatile,field,is,running,that,is,checked,in,the,loop,and,that,is,set,to,false,in,this,method;void,cancel
SourceFunction -> void cancel()_;1456347641;Cancels the source. Most sources will have a while loop inside the_{@link #run} method. You need to ensure that the source will break out of this loop. This_can be achieved by having a volatile field "isRunning" that is checked in the loop and that_is set to false in this method.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,method,you,need,to,ensure,that,the,source,will,break,out,of,this,loop,this,can,be,achieved,by,having,a,volatile,field,is,running,that,is,checked,in,the,loop,and,that,is,set,to,false,in,this,method;void,cancel
SourceFunction -> void cancel()_;1456999993;Cancels the source. Most sources will have a while loop inside the_{@link #run(SourceContext)} method. The implementation needs to ensure that the_source will break out of that loop after this method is called.__<p>A typical pattern is to have an {@code "volatile boolean isRunning"} flag that is set to_{@code false} in this method. That flag is checked in the loop condition.__<p>When a source is canceled, the executing thread will also be interrupted_(via {@link Thread#interrupt()}). The interruption happens strictly after this_method has been called, so any interruption handler can rely on the fact that_this method has completed. It is good practice to make any flags altered by_this method "volatile", in order to guarantee the visibility of the effects of_this method to any interruption handler.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,source,context,method,the,implementation,needs,to,ensure,that,the,source,will,break,out,of,that,loop,after,this,method,is,called,p,a,typical,pattern,is,to,have,an,code,volatile,boolean,is,running,flag,that,is,set,to,code,false,in,this,method,that,flag,is,checked,in,the,loop,condition,p,when,a,source,is,canceled,the,executing,thread,will,also,be,interrupted,via,link,thread,interrupt,the,interruption,happens,strictly,after,this,method,has,been,called,so,any,interruption,handler,can,rely,on,the,fact,that,this,method,has,completed,it,is,good,practice,to,make,any,flags,altered,by,this,method,volatile,in,order,to,guarantee,the,visibility,of,the,effects,of,this,method,to,any,interruption,handler;void,cancel
SourceFunction -> void cancel()_;1487783998;Cancels the source. Most sources will have a while loop inside the_{@link #run(SourceContext)} method. The implementation needs to ensure that the_source will break out of that loop after this method is called.__<p>A typical pattern is to have an {@code "volatile boolean isRunning"} flag that is set to_{@code false} in this method. That flag is checked in the loop condition.__<p>When a source is canceled, the executing thread will also be interrupted_(via {@link Thread#interrupt()}). The interruption happens strictly after this_method has been called, so any interruption handler can rely on the fact that_this method has completed. It is good practice to make any flags altered by_this method "volatile", in order to guarantee the visibility of the effects of_this method to any interruption handler.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,source,context,method,the,implementation,needs,to,ensure,that,the,source,will,break,out,of,that,loop,after,this,method,is,called,p,a,typical,pattern,is,to,have,an,code,volatile,boolean,is,running,flag,that,is,set,to,code,false,in,this,method,that,flag,is,checked,in,the,loop,condition,p,when,a,source,is,canceled,the,executing,thread,will,also,be,interrupted,via,link,thread,interrupt,the,interruption,happens,strictly,after,this,method,has,been,called,so,any,interruption,handler,can,rely,on,the,fact,that,this,method,has,completed,it,is,good,practice,to,make,any,flags,altered,by,this,method,volatile,in,order,to,guarantee,the,visibility,of,the,effects,of,this,method,to,any,interruption,handler;void,cancel
SourceFunction -> void cancel()_;1493195810;Cancels the source. Most sources will have a while loop inside the_{@link #run(SourceContext)} method. The implementation needs to ensure that the_source will break out of that loop after this method is called.__<p>A typical pattern is to have an {@code "volatile boolean isRunning"} flag that is set to_{@code false} in this method. That flag is checked in the loop condition.__<p>When a source is canceled, the executing thread will also be interrupted_(via {@link Thread#interrupt()}). The interruption happens strictly after this_method has been called, so any interruption handler can rely on the fact that_this method has completed. It is good practice to make any flags altered by_this method "volatile", in order to guarantee the visibility of the effects of_this method to any interruption handler.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,source,context,method,the,implementation,needs,to,ensure,that,the,source,will,break,out,of,that,loop,after,this,method,is,called,p,a,typical,pattern,is,to,have,an,code,volatile,boolean,is,running,flag,that,is,set,to,code,false,in,this,method,that,flag,is,checked,in,the,loop,condition,p,when,a,source,is,canceled,the,executing,thread,will,also,be,interrupted,via,link,thread,interrupt,the,interruption,happens,strictly,after,this,method,has,been,called,so,any,interruption,handler,can,rely,on,the,fact,that,this,method,has,completed,it,is,good,practice,to,make,any,flags,altered,by,this,method,volatile,in,order,to,guarantee,the,visibility,of,the,effects,of,this,method,to,any,interruption,handler;void,cancel
SourceFunction -> void cancel()_;1493195810;Cancels the source. Most sources will have a while loop inside the_{@link #run(SourceContext)} method. The implementation needs to ensure that the_source will break out of that loop after this method is called.__<p>A typical pattern is to have an {@code "volatile boolean isRunning"} flag that is set to_{@code false} in this method. That flag is checked in the loop condition.__<p>When a source is canceled, the executing thread will also be interrupted_(via {@link Thread#interrupt()}). The interruption happens strictly after this_method has been called, so any interruption handler can rely on the fact that_this method has completed. It is good practice to make any flags altered by_this method "volatile", in order to guarantee the visibility of the effects of_this method to any interruption handler.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,source,context,method,the,implementation,needs,to,ensure,that,the,source,will,break,out,of,that,loop,after,this,method,is,called,p,a,typical,pattern,is,to,have,an,code,volatile,boolean,is,running,flag,that,is,set,to,code,false,in,this,method,that,flag,is,checked,in,the,loop,condition,p,when,a,source,is,canceled,the,executing,thread,will,also,be,interrupted,via,link,thread,interrupt,the,interruption,happens,strictly,after,this,method,has,been,called,so,any,interruption,handler,can,rely,on,the,fact,that,this,method,has,completed,it,is,good,practice,to,make,any,flags,altered,by,this,method,volatile,in,order,to,guarantee,the,visibility,of,the,effects,of,this,method,to,any,interruption,handler;void,cancel
SourceFunction -> void cancel()_;1493195810;Cancels the source. Most sources will have a while loop inside the_{@link #run(SourceContext)} method. The implementation needs to ensure that the_source will break out of that loop after this method is called.__<p>A typical pattern is to have an {@code "volatile boolean isRunning"} flag that is set to_{@code false} in this method. That flag is checked in the loop condition.__<p>When a source is canceled, the executing thread will also be interrupted_(via {@link Thread#interrupt()}). The interruption happens strictly after this_method has been called, so any interruption handler can rely on the fact that_this method has completed. It is good practice to make any flags altered by_this method "volatile", in order to guarantee the visibility of the effects of_this method to any interruption handler.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,source,context,method,the,implementation,needs,to,ensure,that,the,source,will,break,out,of,that,loop,after,this,method,is,called,p,a,typical,pattern,is,to,have,an,code,volatile,boolean,is,running,flag,that,is,set,to,code,false,in,this,method,that,flag,is,checked,in,the,loop,condition,p,when,a,source,is,canceled,the,executing,thread,will,also,be,interrupted,via,link,thread,interrupt,the,interruption,happens,strictly,after,this,method,has,been,called,so,any,interruption,handler,can,rely,on,the,fact,that,this,method,has,completed,it,is,good,practice,to,make,any,flags,altered,by,this,method,volatile,in,order,to,guarantee,the,visibility,of,the,effects,of,this,method,to,any,interruption,handler;void,cancel
SourceFunction -> void cancel()_;1495484544;Cancels the source. Most sources will have a while loop inside the_{@link #run(SourceContext)} method. The implementation needs to ensure that the_source will break out of that loop after this method is called.__<p>A typical pattern is to have an {@code "volatile boolean isRunning"} flag that is set to_{@code false} in this method. That flag is checked in the loop condition.__<p>When a source is canceled, the executing thread will also be interrupted_(via {@link Thread#interrupt()}). The interruption happens strictly after this_method has been called, so any interruption handler can rely on the fact that_this method has completed. It is good practice to make any flags altered by_this method "volatile", in order to guarantee the visibility of the effects of_this method to any interruption handler.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,source,context,method,the,implementation,needs,to,ensure,that,the,source,will,break,out,of,that,loop,after,this,method,is,called,p,a,typical,pattern,is,to,have,an,code,volatile,boolean,is,running,flag,that,is,set,to,code,false,in,this,method,that,flag,is,checked,in,the,loop,condition,p,when,a,source,is,canceled,the,executing,thread,will,also,be,interrupted,via,link,thread,interrupt,the,interruption,happens,strictly,after,this,method,has,been,called,so,any,interruption,handler,can,rely,on,the,fact,that,this,method,has,completed,it,is,good,practice,to,make,any,flags,altered,by,this,method,volatile,in,order,to,guarantee,the,visibility,of,the,effects,of,this,method,to,any,interruption,handler;void,cancel
SourceFunction -> void cancel()_;1515212028;Cancels the source. Most sources will have a while loop inside the_{@link #run(SourceContext)} method. The implementation needs to ensure that the_source will break out of that loop after this method is called.__<p>A typical pattern is to have an {@code "volatile boolean isRunning"} flag that is set to_{@code false} in this method. That flag is checked in the loop condition.__<p>When a source is canceled, the executing thread will also be interrupted_(via {@link Thread#interrupt()}). The interruption happens strictly after this_method has been called, so any interruption handler can rely on the fact that_this method has completed. It is good practice to make any flags altered by_this method "volatile", in order to guarantee the visibility of the effects of_this method to any interruption handler.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,source,context,method,the,implementation,needs,to,ensure,that,the,source,will,break,out,of,that,loop,after,this,method,is,called,p,a,typical,pattern,is,to,have,an,code,volatile,boolean,is,running,flag,that,is,set,to,code,false,in,this,method,that,flag,is,checked,in,the,loop,condition,p,when,a,source,is,canceled,the,executing,thread,will,also,be,interrupted,via,link,thread,interrupt,the,interruption,happens,strictly,after,this,method,has,been,called,so,any,interruption,handler,can,rely,on,the,fact,that,this,method,has,completed,it,is,good,practice,to,make,any,flags,altered,by,this,method,volatile,in,order,to,guarantee,the,visibility,of,the,effects,of,this,method,to,any,interruption,handler;void,cancel
SourceFunction -> void cancel()_;1515212028;Cancels the source. Most sources will have a while loop inside the_{@link #run(SourceContext)} method. The implementation needs to ensure that the_source will break out of that loop after this method is called.__<p>A typical pattern is to have an {@code "volatile boolean isRunning"} flag that is set to_{@code false} in this method. That flag is checked in the loop condition.__<p>When a source is canceled, the executing thread will also be interrupted_(via {@link Thread#interrupt()}). The interruption happens strictly after this_method has been called, so any interruption handler can rely on the fact that_this method has completed. It is good practice to make any flags altered by_this method "volatile", in order to guarantee the visibility of the effects of_this method to any interruption handler.;void cancel()_;cancels,the,source,most,sources,will,have,a,while,loop,inside,the,link,run,source,context,method,the,implementation,needs,to,ensure,that,the,source,will,break,out,of,that,loop,after,this,method,is,called,p,a,typical,pattern,is,to,have,an,code,volatile,boolean,is,running,flag,that,is,set,to,code,false,in,this,method,that,flag,is,checked,in,the,loop,condition,p,when,a,source,is,canceled,the,executing,thread,will,also,be,interrupted,via,link,thread,interrupt,the,interruption,happens,strictly,after,this,method,has,been,called,so,any,interruption,handler,can,rely,on,the,fact,that,this,method,has,completed,it,is,good,practice,to,make,any,flags,altered,by,this,method,volatile,in,order,to,guarantee,the,visibility,of,the,effects,of,this,method,to,any,interruption,handler;void,cancel
SourceFunction -> SourceContext -> public void collectWithTimestamp(T element, long timestamp)_;1445418103;Emits one element from the source with the given timestamp.__@param element The element to emit_@param timestamp The timestamp in milliseconds;public void collectWithTimestamp(T element, long timestamp)_;emits,one,element,from,the,source,with,the,given,timestamp,param,element,the,element,to,emit,param,timestamp,the,timestamp,in,milliseconds;public,void,collect,with,timestamp,t,element,long,timestamp
SourceFunction -> SourceContext -> public void collectWithTimestamp(T element, long timestamp)_;1446112342;Emits one element from the source with the given timestamp.__@param element The element to emit_@param timestamp The timestamp in milliseconds;public void collectWithTimestamp(T element, long timestamp)_;emits,one,element,from,the,source,with,the,given,timestamp,param,element,the,element,to,emit,param,timestamp,the,timestamp,in,milliseconds;public,void,collect,with,timestamp,t,element,long,timestamp
SourceFunction -> SourceContext -> @PublicEvolving 		void markAsTemporarilyIdle()_;1487783998;Marks the source to be temporarily idle. This tells the system that this source will_temporarily stop emitting records and watermarks for an indefinite amount of time. This_is only relevant when running on {@link TimeCharacteristic#IngestionTime} and_{@link TimeCharacteristic#EventTime}, allowing downstream tasks to advance their_watermarks without the need to wait for watermarks from this source while it is idle.__<p>Source functions should make a best effort to call this method as soon as they_acknowledge themselves to be idle. The system will consider the source to resume activity_again once {@link SourceContext#collect(T)}, {@link SourceContext#collectWithTimestamp(T, long)},_or {@link SourceContext#emitWatermark(Watermark)} is called to emit elements or watermarks from the source.;@PublicEvolving_		void markAsTemporarilyIdle()_;marks,the,source,to,be,temporarily,idle,this,tells,the,system,that,this,source,will,temporarily,stop,emitting,records,and,watermarks,for,an,indefinite,amount,of,time,this,is,only,relevant,when,running,on,link,time,characteristic,ingestion,time,and,link,time,characteristic,event,time,allowing,downstream,tasks,to,advance,their,watermarks,without,the,need,to,wait,for,watermarks,from,this,source,while,it,is,idle,p,source,functions,should,make,a,best,effort,to,call,this,method,as,soon,as,they,acknowledge,themselves,to,be,idle,the,system,will,consider,the,source,to,resume,activity,again,once,link,source,context,collect,t,link,source,context,collect,with,timestamp,t,long,or,link,source,context,emit,watermark,watermark,is,called,to,emit,elements,or,watermarks,from,the,source;public,evolving,void,mark,as,temporarily,idle
SourceFunction -> SourceContext -> @PublicEvolving 		void markAsTemporarilyIdle()_;1493195810;Marks the source to be temporarily idle. This tells the system that this source will_temporarily stop emitting records and watermarks for an indefinite amount of time. This_is only relevant when running on {@link TimeCharacteristic#IngestionTime} and_{@link TimeCharacteristic#EventTime}, allowing downstream tasks to advance their_watermarks without the need to wait for watermarks from this source while it is idle.__<p>Source functions should make a best effort to call this method as soon as they_acknowledge themselves to be idle. The system will consider the source to resume activity_again once {@link SourceContext#collect(T)}, {@link SourceContext#collectWithTimestamp(T, long)},_or {@link SourceContext#emitWatermark(Watermark)} is called to emit elements or watermarks from the source.;@PublicEvolving_		void markAsTemporarilyIdle()_;marks,the,source,to,be,temporarily,idle,this,tells,the,system,that,this,source,will,temporarily,stop,emitting,records,and,watermarks,for,an,indefinite,amount,of,time,this,is,only,relevant,when,running,on,link,time,characteristic,ingestion,time,and,link,time,characteristic,event,time,allowing,downstream,tasks,to,advance,their,watermarks,without,the,need,to,wait,for,watermarks,from,this,source,while,it,is,idle,p,source,functions,should,make,a,best,effort,to,call,this,method,as,soon,as,they,acknowledge,themselves,to,be,idle,the,system,will,consider,the,source,to,resume,activity,again,once,link,source,context,collect,t,link,source,context,collect,with,timestamp,t,long,or,link,source,context,emit,watermark,watermark,is,called,to,emit,elements,or,watermarks,from,the,source;public,evolving,void,mark,as,temporarily,idle
SourceFunction -> SourceContext -> @PublicEvolving 		void markAsTemporarilyIdle()_;1493195810;Marks the source to be temporarily idle. This tells the system that this source will_temporarily stop emitting records and watermarks for an indefinite amount of time. This_is only relevant when running on {@link TimeCharacteristic#IngestionTime} and_{@link TimeCharacteristic#EventTime}, allowing downstream tasks to advance their_watermarks without the need to wait for watermarks from this source while it is idle.__<p>Source functions should make a best effort to call this method as soon as they_acknowledge themselves to be idle. The system will consider the source to resume activity_again once {@link SourceContext#collect(T)}, {@link SourceContext#collectWithTimestamp(T, long)},_or {@link SourceContext#emitWatermark(Watermark)} is called to emit elements or watermarks from the source.;@PublicEvolving_		void markAsTemporarilyIdle()_;marks,the,source,to,be,temporarily,idle,this,tells,the,system,that,this,source,will,temporarily,stop,emitting,records,and,watermarks,for,an,indefinite,amount,of,time,this,is,only,relevant,when,running,on,link,time,characteristic,ingestion,time,and,link,time,characteristic,event,time,allowing,downstream,tasks,to,advance,their,watermarks,without,the,need,to,wait,for,watermarks,from,this,source,while,it,is,idle,p,source,functions,should,make,a,best,effort,to,call,this,method,as,soon,as,they,acknowledge,themselves,to,be,idle,the,system,will,consider,the,source,to,resume,activity,again,once,link,source,context,collect,t,link,source,context,collect,with,timestamp,t,long,or,link,source,context,emit,watermark,watermark,is,called,to,emit,elements,or,watermarks,from,the,source;public,evolving,void,mark,as,temporarily,idle
SourceFunction -> SourceContext -> @PublicEvolving 		void markAsTemporarilyIdle()_;1493195810;Marks the source to be temporarily idle. This tells the system that this source will_temporarily stop emitting records and watermarks for an indefinite amount of time. This_is only relevant when running on {@link TimeCharacteristic#IngestionTime} and_{@link TimeCharacteristic#EventTime}, allowing downstream tasks to advance their_watermarks without the need to wait for watermarks from this source while it is idle.__<p>Source functions should make a best effort to call this method as soon as they_acknowledge themselves to be idle. The system will consider the source to resume activity_again once {@link SourceContext#collect(T)}, {@link SourceContext#collectWithTimestamp(T, long)},_or {@link SourceContext#emitWatermark(Watermark)} is called to emit elements or watermarks from the source.;@PublicEvolving_		void markAsTemporarilyIdle()_;marks,the,source,to,be,temporarily,idle,this,tells,the,system,that,this,source,will,temporarily,stop,emitting,records,and,watermarks,for,an,indefinite,amount,of,time,this,is,only,relevant,when,running,on,link,time,characteristic,ingestion,time,and,link,time,characteristic,event,time,allowing,downstream,tasks,to,advance,their,watermarks,without,the,need,to,wait,for,watermarks,from,this,source,while,it,is,idle,p,source,functions,should,make,a,best,effort,to,call,this,method,as,soon,as,they,acknowledge,themselves,to,be,idle,the,system,will,consider,the,source,to,resume,activity,again,once,link,source,context,collect,t,link,source,context,collect,with,timestamp,t,long,or,link,source,context,emit,watermark,watermark,is,called,to,emit,elements,or,watermarks,from,the,source;public,evolving,void,mark,as,temporarily,idle
SourceFunction -> SourceContext -> @PublicEvolving 		void markAsTemporarilyIdle()_;1495484544;Marks the source to be temporarily idle. This tells the system that this source will_temporarily stop emitting records and watermarks for an indefinite amount of time. This_is only relevant when running on {@link TimeCharacteristic#IngestionTime} and_{@link TimeCharacteristic#EventTime}, allowing downstream tasks to advance their_watermarks without the need to wait for watermarks from this source while it is idle.__<p>Source functions should make a best effort to call this method as soon as they_acknowledge themselves to be idle. The system will consider the source to resume activity_again once {@link SourceContext#collect(T)}, {@link SourceContext#collectWithTimestamp(T, long)},_or {@link SourceContext#emitWatermark(Watermark)} is called to emit elements or watermarks from the source.;@PublicEvolving_		void markAsTemporarilyIdle()_;marks,the,source,to,be,temporarily,idle,this,tells,the,system,that,this,source,will,temporarily,stop,emitting,records,and,watermarks,for,an,indefinite,amount,of,time,this,is,only,relevant,when,running,on,link,time,characteristic,ingestion,time,and,link,time,characteristic,event,time,allowing,downstream,tasks,to,advance,their,watermarks,without,the,need,to,wait,for,watermarks,from,this,source,while,it,is,idle,p,source,functions,should,make,a,best,effort,to,call,this,method,as,soon,as,they,acknowledge,themselves,to,be,idle,the,system,will,consider,the,source,to,resume,activity,again,once,link,source,context,collect,t,link,source,context,collect,with,timestamp,t,long,or,link,source,context,emit,watermark,watermark,is,called,to,emit,elements,or,watermarks,from,the,source;public,evolving,void,mark,as,temporarily,idle
SourceFunction -> SourceContext -> @PublicEvolving 		void markAsTemporarilyIdle()_;1515212028;Marks the source to be temporarily idle. This tells the system that this source will_temporarily stop emitting records and watermarks for an indefinite amount of time. This_is only relevant when running on {@link TimeCharacteristic#IngestionTime} and_{@link TimeCharacteristic#EventTime}, allowing downstream tasks to advance their_watermarks without the need to wait for watermarks from this source while it is idle.__<p>Source functions should make a best effort to call this method as soon as they_acknowledge themselves to be idle. The system will consider the source to resume activity_again once {@link SourceContext#collect(T)}, {@link SourceContext#collectWithTimestamp(T, long)},_or {@link SourceContext#emitWatermark(Watermark)} is called to emit elements or watermarks from the source.;@PublicEvolving_		void markAsTemporarilyIdle()_;marks,the,source,to,be,temporarily,idle,this,tells,the,system,that,this,source,will,temporarily,stop,emitting,records,and,watermarks,for,an,indefinite,amount,of,time,this,is,only,relevant,when,running,on,link,time,characteristic,ingestion,time,and,link,time,characteristic,event,time,allowing,downstream,tasks,to,advance,their,watermarks,without,the,need,to,wait,for,watermarks,from,this,source,while,it,is,idle,p,source,functions,should,make,a,best,effort,to,call,this,method,as,soon,as,they,acknowledge,themselves,to,be,idle,the,system,will,consider,the,source,to,resume,activity,again,once,link,source,context,collect,t,link,source,context,collect,with,timestamp,t,long,or,link,source,context,emit,watermark,watermark,is,called,to,emit,elements,or,watermarks,from,the,source;public,evolving,void,mark,as,temporarily,idle
SourceFunction -> SourceContext -> @PublicEvolving 		void markAsTemporarilyIdle()_;1515212028;Marks the source to be temporarily idle. This tells the system that this source will_temporarily stop emitting records and watermarks for an indefinite amount of time. This_is only relevant when running on {@link TimeCharacteristic#IngestionTime} and_{@link TimeCharacteristic#EventTime}, allowing downstream tasks to advance their_watermarks without the need to wait for watermarks from this source while it is idle.__<p>Source functions should make a best effort to call this method as soon as they_acknowledge themselves to be idle. The system will consider the source to resume activity_again once {@link SourceContext#collect(T)}, {@link SourceContext#collectWithTimestamp(T, long)},_or {@link SourceContext#emitWatermark(Watermark)} is called to emit elements or watermarks from the source.;@PublicEvolving_		void markAsTemporarilyIdle()_;marks,the,source,to,be,temporarily,idle,this,tells,the,system,that,this,source,will,temporarily,stop,emitting,records,and,watermarks,for,an,indefinite,amount,of,time,this,is,only,relevant,when,running,on,link,time,characteristic,ingestion,time,and,link,time,characteristic,event,time,allowing,downstream,tasks,to,advance,their,watermarks,without,the,need,to,wait,for,watermarks,from,this,source,while,it,is,idle,p,source,functions,should,make,a,best,effort,to,call,this,method,as,soon,as,they,acknowledge,themselves,to,be,idle,the,system,will,consider,the,source,to,resume,activity,again,once,link,source,context,collect,t,link,source,context,collect,with,timestamp,t,long,or,link,source,context,emit,watermark,watermark,is,called,to,emit,elements,or,watermarks,from,the,source;public,evolving,void,mark,as,temporarily,idle
SourceFunction -> SourceContext -> void collect(T element)_;1445418103;Emits one element from the source. The result of {@link System#currentTimeMillis()} is set as_the timestamp of the emitted element.__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,the,result,of,link,system,current,time,millis,is,set,as,the,timestamp,of,the,emitted,element,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> void collect(T element)_;1446112342;Emits one element from the source. The result of {@link System#currentTimeMillis()} is set as_the timestamp of the emitted element.__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,the,result,of,link,system,current,time,millis,is,set,as,the,timestamp,of,the,emitted,element,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> void collect(T element)_;1454679829;Emits one element from the source. The result of {@link System#currentTimeMillis()} is set as_the timestamp of the emitted element.__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,the,result,of,link,system,current,time,millis,is,set,as,the,timestamp,of,the,emitted,element,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> void collect(T element)_;1455101486;Emits one element from the source. The result of {@link System#currentTimeMillis()} is set as_the timestamp of the emitted element.__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,the,result,of,link,system,current,time,millis,is,set,as,the,timestamp,of,the,emitted,element,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> void collect(T element)_;1456347641;Emits one element from the source. The result of {@link System#currentTimeMillis()} is set as_the timestamp of the emitted element.__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,the,result,of,link,system,current,time,millis,is,set,as,the,timestamp,of,the,emitted,element,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> void collect(T element)_;1456999993;Emits one element from the source, without attaching a timestamp. In most cases,_this is the default way of emitting elements.__<p>The timestamp that the element will get assigned depends on the time characteristic of_the streaming program:_<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the element has no timestamp.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the element gets the system's_current time as the timestamp.</li>_<li>On {@link TimeCharacteristic#EventTime}, the element will have no timestamp initially._It needs to get a timestamp (via a {@link TimestampAssigner}) before any time-dependent_operation (like time windows).</li>_</ul>__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,without,attaching,a,timestamp,in,most,cases,this,is,the,default,way,of,emitting,elements,p,the,timestamp,that,the,element,will,get,assigned,depends,on,the,time,characteristic,of,the,streaming,program,ul,li,on,link,time,characteristic,processing,time,the,element,has,no,timestamp,li,li,on,link,time,characteristic,ingestion,time,the,element,gets,the,system,s,current,time,as,the,timestamp,li,li,on,link,time,characteristic,event,time,the,element,will,have,no,timestamp,initially,it,needs,to,get,a,timestamp,via,a,link,timestamp,assigner,before,any,time,dependent,operation,like,time,windows,li,ul,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> void collect(T element)_;1487783998;Emits one element from the source, without attaching a timestamp. In most cases,_this is the default way of emitting elements.__<p>The timestamp that the element will get assigned depends on the time characteristic of_the streaming program:_<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the element has no timestamp.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the element gets the system's_current time as the timestamp.</li>_<li>On {@link TimeCharacteristic#EventTime}, the element will have no timestamp initially._It needs to get a timestamp (via a {@link TimestampAssigner}) before any time-dependent_operation (like time windows).</li>_</ul>__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,without,attaching,a,timestamp,in,most,cases,this,is,the,default,way,of,emitting,elements,p,the,timestamp,that,the,element,will,get,assigned,depends,on,the,time,characteristic,of,the,streaming,program,ul,li,on,link,time,characteristic,processing,time,the,element,has,no,timestamp,li,li,on,link,time,characteristic,ingestion,time,the,element,gets,the,system,s,current,time,as,the,timestamp,li,li,on,link,time,characteristic,event,time,the,element,will,have,no,timestamp,initially,it,needs,to,get,a,timestamp,via,a,link,timestamp,assigner,before,any,time,dependent,operation,like,time,windows,li,ul,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> void collect(T element)_;1493195810;Emits one element from the source, without attaching a timestamp. In most cases,_this is the default way of emitting elements.__<p>The timestamp that the element will get assigned depends on the time characteristic of_the streaming program:_<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the element has no timestamp.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the element gets the system's_current time as the timestamp.</li>_<li>On {@link TimeCharacteristic#EventTime}, the element will have no timestamp initially._It needs to get a timestamp (via a {@link TimestampAssigner}) before any time-dependent_operation (like time windows).</li>_</ul>__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,without,attaching,a,timestamp,in,most,cases,this,is,the,default,way,of,emitting,elements,p,the,timestamp,that,the,element,will,get,assigned,depends,on,the,time,characteristic,of,the,streaming,program,ul,li,on,link,time,characteristic,processing,time,the,element,has,no,timestamp,li,li,on,link,time,characteristic,ingestion,time,the,element,gets,the,system,s,current,time,as,the,timestamp,li,li,on,link,time,characteristic,event,time,the,element,will,have,no,timestamp,initially,it,needs,to,get,a,timestamp,via,a,link,timestamp,assigner,before,any,time,dependent,operation,like,time,windows,li,ul,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> void collect(T element)_;1493195810;Emits one element from the source, without attaching a timestamp. In most cases,_this is the default way of emitting elements.__<p>The timestamp that the element will get assigned depends on the time characteristic of_the streaming program:_<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the element has no timestamp.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the element gets the system's_current time as the timestamp.</li>_<li>On {@link TimeCharacteristic#EventTime}, the element will have no timestamp initially._It needs to get a timestamp (via a {@link TimestampAssigner}) before any time-dependent_operation (like time windows).</li>_</ul>__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,without,attaching,a,timestamp,in,most,cases,this,is,the,default,way,of,emitting,elements,p,the,timestamp,that,the,element,will,get,assigned,depends,on,the,time,characteristic,of,the,streaming,program,ul,li,on,link,time,characteristic,processing,time,the,element,has,no,timestamp,li,li,on,link,time,characteristic,ingestion,time,the,element,gets,the,system,s,current,time,as,the,timestamp,li,li,on,link,time,characteristic,event,time,the,element,will,have,no,timestamp,initially,it,needs,to,get,a,timestamp,via,a,link,timestamp,assigner,before,any,time,dependent,operation,like,time,windows,li,ul,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> void collect(T element)_;1493195810;Emits one element from the source, without attaching a timestamp. In most cases,_this is the default way of emitting elements.__<p>The timestamp that the element will get assigned depends on the time characteristic of_the streaming program:_<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the element has no timestamp.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the element gets the system's_current time as the timestamp.</li>_<li>On {@link TimeCharacteristic#EventTime}, the element will have no timestamp initially._It needs to get a timestamp (via a {@link TimestampAssigner}) before any time-dependent_operation (like time windows).</li>_</ul>__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,without,attaching,a,timestamp,in,most,cases,this,is,the,default,way,of,emitting,elements,p,the,timestamp,that,the,element,will,get,assigned,depends,on,the,time,characteristic,of,the,streaming,program,ul,li,on,link,time,characteristic,processing,time,the,element,has,no,timestamp,li,li,on,link,time,characteristic,ingestion,time,the,element,gets,the,system,s,current,time,as,the,timestamp,li,li,on,link,time,characteristic,event,time,the,element,will,have,no,timestamp,initially,it,needs,to,get,a,timestamp,via,a,link,timestamp,assigner,before,any,time,dependent,operation,like,time,windows,li,ul,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> void collect(T element)_;1495484544;Emits one element from the source, without attaching a timestamp. In most cases,_this is the default way of emitting elements.__<p>The timestamp that the element will get assigned depends on the time characteristic of_the streaming program:_<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the element has no timestamp.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the element gets the system's_current time as the timestamp.</li>_<li>On {@link TimeCharacteristic#EventTime}, the element will have no timestamp initially._It needs to get a timestamp (via a {@link TimestampAssigner}) before any time-dependent_operation (like time windows).</li>_</ul>__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,without,attaching,a,timestamp,in,most,cases,this,is,the,default,way,of,emitting,elements,p,the,timestamp,that,the,element,will,get,assigned,depends,on,the,time,characteristic,of,the,streaming,program,ul,li,on,link,time,characteristic,processing,time,the,element,has,no,timestamp,li,li,on,link,time,characteristic,ingestion,time,the,element,gets,the,system,s,current,time,as,the,timestamp,li,li,on,link,time,characteristic,event,time,the,element,will,have,no,timestamp,initially,it,needs,to,get,a,timestamp,via,a,link,timestamp,assigner,before,any,time,dependent,operation,like,time,windows,li,ul,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> void collect(T element)_;1515212028;Emits one element from the source, without attaching a timestamp. In most cases,_this is the default way of emitting elements.__<p>The timestamp that the element will get assigned depends on the time characteristic of_the streaming program:_<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the element has no timestamp.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the element gets the system's_current time as the timestamp.</li>_<li>On {@link TimeCharacteristic#EventTime}, the element will have no timestamp initially._It needs to get a timestamp (via a {@link TimestampAssigner}) before any time-dependent_operation (like time windows).</li>_</ul>__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,without,attaching,a,timestamp,in,most,cases,this,is,the,default,way,of,emitting,elements,p,the,timestamp,that,the,element,will,get,assigned,depends,on,the,time,characteristic,of,the,streaming,program,ul,li,on,link,time,characteristic,processing,time,the,element,has,no,timestamp,li,li,on,link,time,characteristic,ingestion,time,the,element,gets,the,system,s,current,time,as,the,timestamp,li,li,on,link,time,characteristic,event,time,the,element,will,have,no,timestamp,initially,it,needs,to,get,a,timestamp,via,a,link,timestamp,assigner,before,any,time,dependent,operation,like,time,windows,li,ul,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> void collect(T element)_;1515212028;Emits one element from the source, without attaching a timestamp. In most cases,_this is the default way of emitting elements.__<p>The timestamp that the element will get assigned depends on the time characteristic of_the streaming program:_<ul>_<li>On {@link TimeCharacteristic#ProcessingTime}, the element has no timestamp.</li>_<li>On {@link TimeCharacteristic#IngestionTime}, the element gets the system's_current time as the timestamp.</li>_<li>On {@link TimeCharacteristic#EventTime}, the element will have no timestamp initially._It needs to get a timestamp (via a {@link TimestampAssigner}) before any time-dependent_operation (like time windows).</li>_</ul>__@param element The element to emit;void collect(T element)_;emits,one,element,from,the,source,without,attaching,a,timestamp,in,most,cases,this,is,the,default,way,of,emitting,elements,p,the,timestamp,that,the,element,will,get,assigned,depends,on,the,time,characteristic,of,the,streaming,program,ul,li,on,link,time,characteristic,processing,time,the,element,has,no,timestamp,li,li,on,link,time,characteristic,ingestion,time,the,element,gets,the,system,s,current,time,as,the,timestamp,li,li,on,link,time,characteristic,event,time,the,element,will,have,no,timestamp,initially,it,needs,to,get,a,timestamp,via,a,link,timestamp,assigner,before,any,time,dependent,operation,like,time,windows,li,ul,param,element,the,element,to,emit;void,collect,t,element
SourceFunction -> SourceContext -> @PublicEvolving 		void emitWatermark(Watermark mark)_;1455101486;Emits the given {@link org.apache.flink.streaming.api.watermark.Watermark}.__<p>_<b>Important:</b>_Sources must only manually emit watermarks when they implement_{@link EventTimeSourceFunction}._Otherwise, elements automatically get the current timestamp assigned at ingress_and the system automatically emits watermarks.__@param mark The {@link Watermark} to emit;@PublicEvolving_		void emitWatermark(Watermark mark)_;emits,the,given,link,org,apache,flink,streaming,api,watermark,watermark,p,b,important,b,sources,must,only,manually,emit,watermarks,when,they,implement,link,event,time,source,function,otherwise,elements,automatically,get,the,current,timestamp,assigned,at,ingress,and,the,system,automatically,emits,watermarks,param,mark,the,link,watermark,to,emit;public,evolving,void,emit,watermark,watermark,mark
SourceFunction -> SourceContext -> @PublicEvolving 		void emitWatermark(Watermark mark)_;1456347641;Emits the given {@link org.apache.flink.streaming.api.watermark.Watermark}.__<p>_<b>Important:</b>_Sources must only manually emit watermarks when they implement_{@link EventTimeSourceFunction}._Otherwise, elements automatically get the current timestamp assigned at ingress_and the system automatically emits watermarks.__@param mark The {@link Watermark} to emit;@PublicEvolving_		void emitWatermark(Watermark mark)_;emits,the,given,link,org,apache,flink,streaming,api,watermark,watermark,p,b,important,b,sources,must,only,manually,emit,watermarks,when,they,implement,link,event,time,source,function,otherwise,elements,automatically,get,the,current,timestamp,assigned,at,ingress,and,the,system,automatically,emits,watermarks,param,mark,the,link,watermark,to,emit;public,evolving,void,emit,watermark,watermark,mark
SourceFunction -> SourceContext -> @PublicEvolving 		void emitWatermark(Watermark mark)_;1456999993;Emits the given {@link Watermark}. A Watermark of value {@code t} declares that no_elements with a timestamp {@code t' <= t} will occur any more. If further such_elements will be emitted, those elements are considered <i>late</i>.__<p>This method is only relevant when running on {@link TimeCharacteristic#EventTime}._On {@link TimeCharacteristic#ProcessingTime},Watermarks will be ignored. On_{@link TimeCharacteristic#IngestionTime}, the Watermarks will be replaced by the_automatic ingestion time watermarks.__@param mark The Watermark to emit;@PublicEvolving_		void emitWatermark(Watermark mark)_;emits,the,given,link,watermark,a,watermark,of,value,code,t,declares,that,no,elements,with,a,timestamp,code,t,t,will,occur,any,more,if,further,such,elements,will,be,emitted,those,elements,are,considered,i,late,i,p,this,method,is,only,relevant,when,running,on,link,time,characteristic,event,time,on,link,time,characteristic,processing,time,watermarks,will,be,ignored,on,link,time,characteristic,ingestion,time,the,watermarks,will,be,replaced,by,the,automatic,ingestion,time,watermarks,param,mark,the,watermark,to,emit;public,evolving,void,emit,watermark,watermark,mark
SourceFunction -> SourceContext -> @PublicEvolving 		void emitWatermark(Watermark mark)_;1487783998;Emits the given {@link Watermark}. A Watermark of value {@code t} declares that no_elements with a timestamp {@code t' <= t} will occur any more. If further such_elements will be emitted, those elements are considered <i>late</i>.__<p>This method is only relevant when running on {@link TimeCharacteristic#EventTime}._On {@link TimeCharacteristic#ProcessingTime},Watermarks will be ignored. On_{@link TimeCharacteristic#IngestionTime}, the Watermarks will be replaced by the_automatic ingestion time watermarks.__@param mark The Watermark to emit;@PublicEvolving_		void emitWatermark(Watermark mark)_;emits,the,given,link,watermark,a,watermark,of,value,code,t,declares,that,no,elements,with,a,timestamp,code,t,t,will,occur,any,more,if,further,such,elements,will,be,emitted,those,elements,are,considered,i,late,i,p,this,method,is,only,relevant,when,running,on,link,time,characteristic,event,time,on,link,time,characteristic,processing,time,watermarks,will,be,ignored,on,link,time,characteristic,ingestion,time,the,watermarks,will,be,replaced,by,the,automatic,ingestion,time,watermarks,param,mark,the,watermark,to,emit;public,evolving,void,emit,watermark,watermark,mark
SourceFunction -> SourceContext -> @PublicEvolving 		void emitWatermark(Watermark mark)_;1493195810;Emits the given {@link Watermark}. A Watermark of value {@code t} declares that no_elements with a timestamp {@code t' <= t} will occur any more. If further such_elements will be emitted, those elements are considered <i>late</i>.__<p>This method is only relevant when running on {@link TimeCharacteristic#EventTime}._On {@link TimeCharacteristic#ProcessingTime},Watermarks will be ignored. On_{@link TimeCharacteristic#IngestionTime}, the Watermarks will be replaced by the_automatic ingestion time watermarks.__@param mark The Watermark to emit;@PublicEvolving_		void emitWatermark(Watermark mark)_;emits,the,given,link,watermark,a,watermark,of,value,code,t,declares,that,no,elements,with,a,timestamp,code,t,t,will,occur,any,more,if,further,such,elements,will,be,emitted,those,elements,are,considered,i,late,i,p,this,method,is,only,relevant,when,running,on,link,time,characteristic,event,time,on,link,time,characteristic,processing,time,watermarks,will,be,ignored,on,link,time,characteristic,ingestion,time,the,watermarks,will,be,replaced,by,the,automatic,ingestion,time,watermarks,param,mark,the,watermark,to,emit;public,evolving,void,emit,watermark,watermark,mark
SourceFunction -> SourceContext -> @PublicEvolving 		void emitWatermark(Watermark mark)_;1493195810;Emits the given {@link Watermark}. A Watermark of value {@code t} declares that no_elements with a timestamp {@code t' <= t} will occur any more. If further such_elements will be emitted, those elements are considered <i>late</i>.__<p>This method is only relevant when running on {@link TimeCharacteristic#EventTime}._On {@link TimeCharacteristic#ProcessingTime},Watermarks will be ignored. On_{@link TimeCharacteristic#IngestionTime}, the Watermarks will be replaced by the_automatic ingestion time watermarks.__@param mark The Watermark to emit;@PublicEvolving_		void emitWatermark(Watermark mark)_;emits,the,given,link,watermark,a,watermark,of,value,code,t,declares,that,no,elements,with,a,timestamp,code,t,t,will,occur,any,more,if,further,such,elements,will,be,emitted,those,elements,are,considered,i,late,i,p,this,method,is,only,relevant,when,running,on,link,time,characteristic,event,time,on,link,time,characteristic,processing,time,watermarks,will,be,ignored,on,link,time,characteristic,ingestion,time,the,watermarks,will,be,replaced,by,the,automatic,ingestion,time,watermarks,param,mark,the,watermark,to,emit;public,evolving,void,emit,watermark,watermark,mark
SourceFunction -> SourceContext -> @PublicEvolving 		void emitWatermark(Watermark mark)_;1493195810;Emits the given {@link Watermark}. A Watermark of value {@code t} declares that no_elements with a timestamp {@code t' <= t} will occur any more. If further such_elements will be emitted, those elements are considered <i>late</i>.__<p>This method is only relevant when running on {@link TimeCharacteristic#EventTime}._On {@link TimeCharacteristic#ProcessingTime},Watermarks will be ignored. On_{@link TimeCharacteristic#IngestionTime}, the Watermarks will be replaced by the_automatic ingestion time watermarks.__@param mark The Watermark to emit;@PublicEvolving_		void emitWatermark(Watermark mark)_;emits,the,given,link,watermark,a,watermark,of,value,code,t,declares,that,no,elements,with,a,timestamp,code,t,t,will,occur,any,more,if,further,such,elements,will,be,emitted,those,elements,are,considered,i,late,i,p,this,method,is,only,relevant,when,running,on,link,time,characteristic,event,time,on,link,time,characteristic,processing,time,watermarks,will,be,ignored,on,link,time,characteristic,ingestion,time,the,watermarks,will,be,replaced,by,the,automatic,ingestion,time,watermarks,param,mark,the,watermark,to,emit;public,evolving,void,emit,watermark,watermark,mark
SourceFunction -> SourceContext -> @PublicEvolving 		void emitWatermark(Watermark mark)_;1495484544;Emits the given {@link Watermark}. A Watermark of value {@code t} declares that no_elements with a timestamp {@code t' <= t} will occur any more. If further such_elements will be emitted, those elements are considered <i>late</i>.__<p>This method is only relevant when running on {@link TimeCharacteristic#EventTime}._On {@link TimeCharacteristic#ProcessingTime},Watermarks will be ignored. On_{@link TimeCharacteristic#IngestionTime}, the Watermarks will be replaced by the_automatic ingestion time watermarks.__@param mark The Watermark to emit;@PublicEvolving_		void emitWatermark(Watermark mark)_;emits,the,given,link,watermark,a,watermark,of,value,code,t,declares,that,no,elements,with,a,timestamp,code,t,t,will,occur,any,more,if,further,such,elements,will,be,emitted,those,elements,are,considered,i,late,i,p,this,method,is,only,relevant,when,running,on,link,time,characteristic,event,time,on,link,time,characteristic,processing,time,watermarks,will,be,ignored,on,link,time,characteristic,ingestion,time,the,watermarks,will,be,replaced,by,the,automatic,ingestion,time,watermarks,param,mark,the,watermark,to,emit;public,evolving,void,emit,watermark,watermark,mark
SourceFunction -> SourceContext -> @PublicEvolving 		void emitWatermark(Watermark mark)_;1515212028;Emits the given {@link Watermark}. A Watermark of value {@code t} declares that no_elements with a timestamp {@code t' <= t} will occur any more. If further such_elements will be emitted, those elements are considered <i>late</i>.__<p>This method is only relevant when running on {@link TimeCharacteristic#EventTime}._On {@link TimeCharacteristic#ProcessingTime},Watermarks will be ignored. On_{@link TimeCharacteristic#IngestionTime}, the Watermarks will be replaced by the_automatic ingestion time watermarks.__@param mark The Watermark to emit;@PublicEvolving_		void emitWatermark(Watermark mark)_;emits,the,given,link,watermark,a,watermark,of,value,code,t,declares,that,no,elements,with,a,timestamp,code,t,t,will,occur,any,more,if,further,such,elements,will,be,emitted,those,elements,are,considered,i,late,i,p,this,method,is,only,relevant,when,running,on,link,time,characteristic,event,time,on,link,time,characteristic,processing,time,watermarks,will,be,ignored,on,link,time,characteristic,ingestion,time,the,watermarks,will,be,replaced,by,the,automatic,ingestion,time,watermarks,param,mark,the,watermark,to,emit;public,evolving,void,emit,watermark,watermark,mark
SourceFunction -> SourceContext -> @PublicEvolving 		void emitWatermark(Watermark mark)_;1515212028;Emits the given {@link Watermark}. A Watermark of value {@code t} declares that no_elements with a timestamp {@code t' <= t} will occur any more. If further such_elements will be emitted, those elements are considered <i>late</i>.__<p>This method is only relevant when running on {@link TimeCharacteristic#EventTime}._On {@link TimeCharacteristic#ProcessingTime},Watermarks will be ignored. On_{@link TimeCharacteristic#IngestionTime}, the Watermarks will be replaced by the_automatic ingestion time watermarks.__@param mark The Watermark to emit;@PublicEvolving_		void emitWatermark(Watermark mark)_;emits,the,given,link,watermark,a,watermark,of,value,code,t,declares,that,no,elements,with,a,timestamp,code,t,t,will,occur,any,more,if,further,such,elements,will,be,emitted,those,elements,are,considered,i,late,i,p,this,method,is,only,relevant,when,running,on,link,time,characteristic,event,time,on,link,time,characteristic,processing,time,watermarks,will,be,ignored,on,link,time,characteristic,ingestion,time,the,watermarks,will,be,replaced,by,the,automatic,ingestion,time,watermarks,param,mark,the,watermark,to,emit;public,evolving,void,emit,watermark,watermark,mark
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1445418103;Returns the checkpoint lock. Please refer to the explanation about checkpointed sources_in {@link org.apache.flink.streaming.api.functions.source.SourceFunction}.__@return The object to use as the lock.;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,explanation,about,checkpointed,sources,in,link,org,apache,flink,streaming,api,functions,source,source,function,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1446112342;Returns the checkpoint lock. Please refer to the explanation about checkpointed sources_in {@link org.apache.flink.streaming.api.functions.source.SourceFunction}.__@return The object to use as the lock.;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,explanation,about,checkpointed,sources,in,link,org,apache,flink,streaming,api,functions,source,source,function,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1454679829;Returns the checkpoint lock. Please refer to the explanation about checkpointed sources_in {@link org.apache.flink.streaming.api.functions.source.SourceFunction}.__@return The object to use as the lock.;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,explanation,about,checkpointed,sources,in,link,org,apache,flink,streaming,api,functions,source,source,function,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1455101486;Returns the checkpoint lock. Please refer to the explanation about checkpointed sources_in {@link org.apache.flink.streaming.api.functions.source.SourceFunction}.__@return The object to use as the lock.;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,explanation,about,checkpointed,sources,in,link,org,apache,flink,streaming,api,functions,source,source,function,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1456347641;Returns the checkpoint lock. Please refer to the explanation about checkpointed sources_in {@link org.apache.flink.streaming.api.functions.source.SourceFunction}.__@return The object to use as the lock.;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,explanation,about,checkpointed,sources,in,link,org,apache,flink,streaming,api,functions,source,source,function,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1456999993;Returns the checkpoint lock. Please refer to the class-level comment in_{@link SourceFunction} for details about how to write a consistent checkpointed_source.__@return The object to use as the lock;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,class,level,comment,in,link,source,function,for,details,about,how,to,write,a,consistent,checkpointed,source,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1487783998;Returns the checkpoint lock. Please refer to the class-level comment in_{@link SourceFunction} for details about how to write a consistent checkpointed_source.__@return The object to use as the lock;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,class,level,comment,in,link,source,function,for,details,about,how,to,write,a,consistent,checkpointed,source,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1493195810;Returns the checkpoint lock. Please refer to the class-level comment in_{@link SourceFunction} for details about how to write a consistent checkpointed_source.__@return The object to use as the lock;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,class,level,comment,in,link,source,function,for,details,about,how,to,write,a,consistent,checkpointed,source,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1493195810;Returns the checkpoint lock. Please refer to the class-level comment in_{@link SourceFunction} for details about how to write a consistent checkpointed_source.__@return The object to use as the lock;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,class,level,comment,in,link,source,function,for,details,about,how,to,write,a,consistent,checkpointed,source,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1493195810;Returns the checkpoint lock. Please refer to the class-level comment in_{@link SourceFunction} for details about how to write a consistent checkpointed_source.__@return The object to use as the lock;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,class,level,comment,in,link,source,function,for,details,about,how,to,write,a,consistent,checkpointed,source,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1495484544;Returns the checkpoint lock. Please refer to the class-level comment in_{@link SourceFunction} for details about how to write a consistent checkpointed_source.__@return The object to use as the lock;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,class,level,comment,in,link,source,function,for,details,about,how,to,write,a,consistent,checkpointed,source,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1515212028;Returns the checkpoint lock. Please refer to the class-level comment in_{@link SourceFunction} for details about how to write a consistent checkpointed_source.__@return The object to use as the lock;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,class,level,comment,in,link,source,function,for,details,about,how,to,write,a,consistent,checkpointed,source,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> Object getCheckpointLock()_;1515212028;Returns the checkpoint lock. Please refer to the class-level comment in_{@link SourceFunction} for details about how to write a consistent checkpointed_source.__@return The object to use as the lock;Object getCheckpointLock()_;returns,the,checkpoint,lock,please,refer,to,the,class,level,comment,in,link,source,function,for,details,about,how,to,write,a,consistent,checkpointed,source,return,the,object,to,use,as,the,lock;object,get,checkpoint,lock
SourceFunction -> SourceContext -> void emitWatermark(Watermark mark)_;1445418103;Emits the given {@link org.apache.flink.streaming.api.watermark.Watermark}.__<p>_<b>Important:</b>_Sources must only manually emit watermarks when they implement_{@link EventTimeSourceFunction}._Otherwise, elements automatically get the current timestamp assigned at ingress_and the system automatically emits watermarks.__@param mark The {@link Watermark} to emit;void emitWatermark(Watermark mark)_;emits,the,given,link,org,apache,flink,streaming,api,watermark,watermark,p,b,important,b,sources,must,only,manually,emit,watermarks,when,they,implement,link,event,time,source,function,otherwise,elements,automatically,get,the,current,timestamp,assigned,at,ingress,and,the,system,automatically,emits,watermarks,param,mark,the,link,watermark,to,emit;void,emit,watermark,watermark,mark
SourceFunction -> SourceContext -> void emitWatermark(Watermark mark)_;1446112342;Emits the given {@link org.apache.flink.streaming.api.watermark.Watermark}.__<p>_<b>Important:</b>_Sources must only manually emit watermarks when they implement_{@link EventTimeSourceFunction}._Otherwise, elements automatically get the current timestamp assigned at ingress_and the system automatically emits watermarks.__@param mark The {@link Watermark} to emit;void emitWatermark(Watermark mark)_;emits,the,given,link,org,apache,flink,streaming,api,watermark,watermark,p,b,important,b,sources,must,only,manually,emit,watermarks,when,they,implement,link,event,time,source,function,otherwise,elements,automatically,get,the,current,timestamp,assigned,at,ingress,and,the,system,automatically,emits,watermarks,param,mark,the,link,watermark,to,emit;void,emit,watermark,watermark,mark
