commented;modifiers;parameterAmount;loc;comment;code
true;public;3;60;/**  * Starts the local {@link InternalTimerServiceImpl} by:  * <ol>  *     <li>Setting the {@code keySerialized} and {@code namespaceSerializer} for the timers it will contain.</li>  *     <li>Setting the {@code triggerTarget} which contains the action to be performed when a timer fires.</li>  *     <li>Re-registering timers that were retrieved after recovering from a node failure, if any.</li>  * </ol>  * This method can be called multiple times, as long as it is called with the same serializers.  */ ;/**  * Starts the local {@link InternalTimerServiceImpl} by:  * <ol>  *     <li>Setting the {@code keySerialized} and {@code namespaceSerializer} for the timers it will contain.</li>  *     <li>Setting the {@code triggerTarget} which contains the action to be performed when a timer fires.</li>  *     <li>Re-registering timers that were retrieved after recovering from a node failure, if any.</li>  * </ol>  * This method can be called multiple times, as long as it is called with the same serializers.  */ public void startTimerService(TypeSerializer<K> keySerializer, TypeSerializer<N> namespaceSerializer, Triggerable<K, N> triggerTarget) {     if (!isInitialized) {         if (keySerializer == null || namespaceSerializer == null) {             throw new IllegalArgumentException("The TimersService serializers cannot be null.").         }         if (this.keySerializer != null || this.namespaceSerializer != null || this.triggerTarget != null) {             throw new IllegalStateException("The TimerService has already been initialized.").         }         // the following is the case where we restore         if (restoredTimersSnapshot != null) {             TypeSerializerSchemaCompatibility<K> keySerializerCompatibility = restoredTimersSnapshot.getKeySerializerSnapshot().resolveSchemaCompatibility(keySerializer).             if (keySerializerCompatibility.isIncompatible() || keySerializerCompatibility.isCompatibleAfterMigration()) {                 throw new IllegalStateException("Tried to initialize restored TimerService with new key serializer that requires migration or is incompatible.").             }             TypeSerializerSchemaCompatibility<N> namespaceSerializerCompatibility = restoredTimersSnapshot.getNamespaceSerializerSnapshot().resolveSchemaCompatibility(namespaceSerializer).             if (namespaceSerializerCompatibility.isIncompatible() || namespaceSerializerCompatibility.isCompatibleAfterMigration()) {                 throw new IllegalStateException("Tried to initialize restored TimerService with new namespace serializer that requires migration or is incompatible.").             }             this.keySerializer = keySerializerCompatibility.isCompatibleAsIs() ? keySerializer : keySerializerCompatibility.getReconfiguredSerializer().             this.namespaceSerializer = namespaceSerializerCompatibility.isCompatibleAsIs() ? namespaceSerializer : namespaceSerializerCompatibility.getReconfiguredSerializer().         } else {             this.keySerializer = keySerializer.             this.namespaceSerializer = namespaceSerializer.         }         this.keyDeserializer = null.         this.namespaceDeserializer = null.         this.triggerTarget = Preconditions.checkNotNull(triggerTarget).         // re-register the restored timers (if any)         final InternalTimer<K, N> headTimer = processingTimeTimersQueue.peek().         if (headTimer != null) {             nextTimer = processingTimeService.registerTimer(headTimer.getTimestamp(), this).         }         this.isInitialized = true.     } else {         if (!(this.keySerializer.equals(keySerializer) && this.namespaceSerializer.equals(namespaceSerializer))) {             throw new IllegalArgumentException("Already initialized Timer Service " + "tried to be initialized with different key and namespace serializers.").         }     } }
false;public;0;4;;@Override public long currentProcessingTime() {     return processingTimeService.getCurrentProcessingTime(). }
false;public;0;4;;@Override public long currentWatermark() {     return currentWatermark. }
false;public;2;14;;@Override public void registerProcessingTimeTimer(N namespace, long time) {     InternalTimer<K, N> oldHead = processingTimeTimersQueue.peek().     if (processingTimeTimersQueue.add(new TimerHeapInternalTimer<>(time, (K) keyContext.getCurrentKey(), namespace))) {         long nextTriggerTime = oldHead != null ? oldHead.getTimestamp() : Long.MAX_VALUE.         // check if we need to re-schedule our timer to earlier         if (time < nextTriggerTime) {             if (nextTimer != null) {                 nextTimer.cancel(false).             }             nextTimer = processingTimeService.registerTimer(time, this).         }     } }
false;public;2;4;;@Override public void registerEventTimeTimer(N namespace, long time) {     eventTimeTimersQueue.add(new TimerHeapInternalTimer<>(time, (K) keyContext.getCurrentKey(), namespace)). }
false;public;2;4;;@Override public void deleteProcessingTimeTimer(N namespace, long time) {     processingTimeTimersQueue.remove(new TimerHeapInternalTimer<>(time, (K) keyContext.getCurrentKey(), namespace)). }
false;public;2;4;;@Override public void deleteEventTimeTimer(N namespace, long time) {     eventTimeTimersQueue.remove(new TimerHeapInternalTimer<>(time, (K) keyContext.getCurrentKey(), namespace)). }
false;public;1;18;;@Override public void onProcessingTime(long time) throws Exception {     // null out the timer in case the Triggerable calls registerProcessingTimeTimer()     // inside the callback.     nextTimer = null.     InternalTimer<K, N> timer.     while ((timer = processingTimeTimersQueue.peek()) != null && timer.getTimestamp() <= time) {         processingTimeTimersQueue.poll().         keyContext.setCurrentKey(timer.getKey()).         triggerTarget.onProcessingTime(timer).     }     if (timer != null && nextTimer == null) {         nextTimer = processingTimeService.registerTimer(timer.getTimestamp(), this).     } }
false;public;1;11;;public void advanceWatermark(long time) throws Exception {     currentWatermark = time.     InternalTimer<K, N> timer.     while ((timer = eventTimeTimersQueue.peek()) != null && timer.getTimestamp() <= time) {         eventTimeTimersQueue.poll().         keyContext.setCurrentKey(timer.getKey()).         triggerTarget.onEventTime(timer).     } }
true;public;1;7;/**  * Snapshots the timers (both processing and event time ones) for a given {@code keyGroupIdx}.  *  * @param keyGroupIdx the id of the key-group to be put in the snapshot.  * @return a snapshot containing the timers for the given key-group, and the serializers for them  */ ;/**  * Snapshots the timers (both processing and event time ones) for a given {@code keyGroupIdx}.  *  * @param keyGroupIdx the id of the key-group to be put in the snapshot.  * @return a snapshot containing the timers for the given key-group, and the serializers for them  */ public InternalTimersSnapshot<K, N> snapshotTimersForKeyGroup(int keyGroupIdx) {     return new InternalTimersSnapshot<>(keySerializer, namespaceSerializer, eventTimeTimersQueue.getSubsetForKeyGroup(keyGroupIdx), processingTimeTimersQueue.getSubsetForKeyGroup(keyGroupIdx)). }
false;public;0;3;;public TypeSerializer<K> getKeySerializer() {     return keySerializer. }
false;public;0;3;;public TypeSerializer<N> getNamespaceSerializer() {     return namespaceSerializer. }
true;public;2;25;/**  * Restore the timers (both processing and event time ones) for a given {@code keyGroupIdx}.  *  * @param restoredSnapshot the restored snapshot containing the key-group's timers,  *                       and the serializers that were used to write them  * @param keyGroupIdx the id of the key-group to be put in the snapshot.  */ ;/**  * Restore the timers (both processing and event time ones) for a given {@code keyGroupIdx}.  *  * @param restoredSnapshot the restored snapshot containing the key-group's timers,  *                       and the serializers that were used to write them  * @param keyGroupIdx the id of the key-group to be put in the snapshot.  */ @SuppressWarnings("unchecked") public void restoreTimersForKeyGroup(InternalTimersSnapshot<?, ?> restoredSnapshot, int keyGroupIdx) {     this.restoredTimersSnapshot = (InternalTimersSnapshot<K, N>) restoredSnapshot.     TypeSerializer<K> restoredKeySerializer = restoredTimersSnapshot.getKeySerializerSnapshot().restoreSerializer().     if (this.keyDeserializer != null && !this.keyDeserializer.equals(restoredKeySerializer)) {         throw new IllegalArgumentException("Tried to restore timers for the same service with different key serializers.").     }     this.keyDeserializer = restoredKeySerializer.     TypeSerializer<N> restoredNamespaceSerializer = restoredTimersSnapshot.getNamespaceSerializerSnapshot().restoreSerializer().     if (this.namespaceDeserializer != null && !this.namespaceDeserializer.equals(restoredNamespaceSerializer)) {         throw new IllegalArgumentException("Tried to restore timers for the same service with different namespace serializers.").     }     this.namespaceDeserializer = restoredNamespaceSerializer.     checkArgument(localKeyGroupRange.contains(keyGroupIdx), "Key Group " + keyGroupIdx + " does not belong to the local range.").     // restore the event time timers     eventTimeTimersQueue.addAll(restoredTimersSnapshot.getEventTimeTimers()).     // restore the processing time timers     processingTimeTimersQueue.addAll(restoredTimersSnapshot.getProcessingTimeTimers()). }
false;public;0;4;;@VisibleForTesting public int numProcessingTimeTimers() {     return this.processingTimeTimersQueue.size(). }
false;public;0;4;;@VisibleForTesting public int numEventTimeTimers() {     return this.eventTimeTimersQueue.size(). }
false;public;1;4;;@VisibleForTesting public int numProcessingTimeTimers(N namespace) {     return countTimersInNamespaceInternal(namespace, processingTimeTimersQueue). }
false;public;1;4;;@VisibleForTesting public int numEventTimeTimers(N namespace) {     return countTimersInNamespaceInternal(namespace, eventTimeTimersQueue). }
false;private;2;14;;private int countTimersInNamespaceInternal(N namespace, InternalPriorityQueue<TimerHeapInternalTimer<K, N>> queue) {     int count = 0.     try (final CloseableIterator<TimerHeapInternalTimer<K, N>> iterator = queue.iterator()) {         while (iterator.hasNext()) {             final TimerHeapInternalTimer<K, N> timer = iterator.next().             if (timer.getNamespace().equals(namespace)) {                 count++.             }         }     } catch (Exception e) {         throw new FlinkRuntimeException("Exception when closing iterator.", e).     }     return count. }
false;;0;4;;@VisibleForTesting int getLocalKeyGroupRangeStartIdx() {     return this.localKeyGroupRangeStartIdx. }
false;;0;4;;@VisibleForTesting List<Set<TimerHeapInternalTimer<K, N>>> getEventTimeTimersPerKeyGroup() {     return partitionElementsByKeyGroup(eventTimeTimersQueue). }
false;;0;4;;@VisibleForTesting List<Set<TimerHeapInternalTimer<K, N>>> getProcessingTimeTimersPerKeyGroup() {     return partitionElementsByKeyGroup(processingTimeTimersQueue). }
false;private;1;7;;private <T> List<Set<T>> partitionElementsByKeyGroup(KeyGroupedInternalPriorityQueue<T> keyGroupedQueue) {     List<Set<T>> result = new ArrayList<>(localKeyGroupRange.getNumberOfKeyGroups()).     for (int keyGroup : localKeyGroupRange) {         result.add(Collections.unmodifiableSet(keyGroupedQueue.getSubsetForKeyGroup(keyGroup))).     }     return result. }
