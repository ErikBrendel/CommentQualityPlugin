commented;modifiers;parameterAmount;loc;comment;code
false;public;0;14;;@Override public void open() throws Exception {     super.open().     collector = new TimestampedCollector<>(output).     this.broadcastStates = new HashMap<>(broadcastStateDescriptors.size()).     for (MapStateDescriptor<?, ?> descriptor : broadcastStateDescriptors) {         broadcastStates.put(descriptor, getOperatorStateBackend().getBroadcastState(descriptor)).     }     rwContext = new ReadWriteContextImpl(getExecutionConfig(), userFunction, broadcastStates, getProcessingTimeService()).     rContext = new ReadOnlyContextImpl(getExecutionConfig(), userFunction, broadcastStates, getProcessingTimeService()). }
false;public;1;7;;@Override public void processElement1(StreamRecord<IN1> element) throws Exception {     collector.setTimestamp(element).     rContext.setElement(element).     userFunction.processElement(element.getValue(), rContext, collector).     rContext.setElement(null). }
false;public;1;7;;@Override public void processElement2(StreamRecord<IN2> element) throws Exception {     collector.setTimestamp(element).     rwContext.setElement(element).     userFunction.processBroadcastElement(element.getValue(), rwContext, collector).     rwContext.setElement(null). }
false;public;1;5;;@Override public void processWatermark(Watermark mark) throws Exception {     super.processWatermark(mark).     currentWatermark = mark.getTimestamp(). }
false;;1;3;;void setElement(StreamRecord<IN2> e) {     this.element = e. }
false;public;0;5;;@Override public Long timestamp() {     checkState(element != null).     return element.getTimestamp(). }
false;public;1;13;;@Override public <K, V> BroadcastState<K, V> getBroadcastState(MapStateDescriptor<K, V> stateDescriptor) {     Preconditions.checkNotNull(stateDescriptor).     stateDescriptor.initializeSerializerUnlessSet(config).     BroadcastState<K, V> state = (BroadcastState<K, V>) states.get(stateDescriptor).     if (state == null) {         throw new IllegalArgumentException("The requested state does not exist. " + "Check for typos in your state descriptor, or specify the state descriptor " + "in the datastream.broadcast(...) call if you forgot to register it.").     }     return state. }
false;public;2;5;;@Override public <X> void output(OutputTag<X> outputTag, X value) {     checkArgument(outputTag != null, "OutputTag must not be null.").     output.collect(outputTag, new StreamRecord<>(value, element.getTimestamp())). }
false;public;0;4;;@Override public long currentProcessingTime() {     return timerService.getCurrentProcessingTime(). }
false;public;0;4;;@Override public long currentWatermark() {     return currentWatermark. }
false;;1;3;;void setElement(StreamRecord<IN1> e) {     this.element = e. }
false;public;0;5;;@Override public Long timestamp() {     checkState(element != null).     return element.hasTimestamp() ? element.getTimestamp() : null. }
false;public;2;5;;@Override public <X> void output(OutputTag<X> outputTag, X value) {     checkArgument(outputTag != null, "OutputTag must not be null.").     output.collect(outputTag, new StreamRecord<>(value, element.getTimestamp())). }
false;public;0;4;;@Override public long currentProcessingTime() {     return timerService.getCurrentProcessingTime(). }
false;public;0;4;;@Override public long currentWatermark() {     return currentWatermark. }
false;public;1;13;;@Override public <K, V> ReadOnlyBroadcastState<K, V> getBroadcastState(MapStateDescriptor<K, V> stateDescriptor) {     Preconditions.checkNotNull(stateDescriptor).     stateDescriptor.initializeSerializerUnlessSet(config).     ReadOnlyBroadcastState<K, V> state = (ReadOnlyBroadcastState<K, V>) states.get(stateDescriptor).     if (state == null) {         throw new IllegalArgumentException("The requested state does not exist. " + "Check for typos in your state descriptor, or specify the state descriptor " + "in the datastream.broadcast(...) call if you forgot to register it.").     }     return state. }
