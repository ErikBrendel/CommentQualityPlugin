commented;modifiers;parameterAmount;loc;comment;code
true;public;1;11;/**  * Adds a feedback edge. The parallelism of the {@code StreamTransformation} must match  * the parallelism of the input {@code StreamTransformation} of the upstream  * {@code StreamTransformation}.  *  * @param transform The new feedback {@code StreamTransformation}.  */ ;/**  * Adds a feedback edge. The parallelism of the {@code StreamTransformation} must match  * the parallelism of the input {@code StreamTransformation} of the upstream  * {@code StreamTransformation}.  *  * @param transform The new feedback {@code StreamTransformation}.  */ public void addFeedbackEdge(StreamTransformation<F> transform) {     if (transform.getParallelism() != this.getParallelism()) {         throw new UnsupportedOperationException("Parallelism of the feedback stream must match the parallelism of the original" + " stream. Parallelism of original stream: " + this.getParallelism() + ". parallelism of feedback stream: " + transform.getParallelism()).     }     feedbackEdges.add(transform). }
true;public;0;3;/**  * Returns the list of feedback {@code StreamTransformations}.  */ ;/**  * Returns the list of feedback {@code StreamTransformations}.  */ public List<StreamTransformation<F>> getFeedbackEdges() {     return feedbackEdges. }
true;public;0;3;/**  * Returns the wait time. This is the amount of time that the feedback operator keeps listening  * for feedback elements. Once the time expires the operation will close and will not receive  * further elements.  */ ;/**  * Returns the wait time. This is the amount of time that the feedback operator keeps listening  * for feedback elements. Once the time expires the operation will close and will not receive  * further elements.  */ public Long getWaitTime() {     return waitTime. }
false;public,final;1;4;;@Override public final void setChainingStrategy(ChainingStrategy strategy) {     throw new UnsupportedOperationException("Cannot set chaining strategy on Split Transformation."). }
false;public;0;4;;@Override public Collection<StreamTransformation<?>> getTransitivePredecessors() {     return Collections.<StreamTransformation<?>>singleton(this). }
