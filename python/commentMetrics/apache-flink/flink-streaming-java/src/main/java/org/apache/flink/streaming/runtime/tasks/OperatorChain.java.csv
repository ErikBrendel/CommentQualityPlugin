commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public StreamStatus getStreamStatus() {     return streamStatus. }
false;public;1;11;;@Override public void toggleStreamStatus(StreamStatus status) {     if (!status.equals(this.streamStatus)) {         this.streamStatus = status.         // try and forward the stream status change to all outgoing connections         for (RecordWriterOutput<?> streamOutput : streamOutputs) {             streamOutput.emitStreamStatus(status).         }     } }
false;public;3;6;;public void broadcastCheckpointBarrier(long id, long timestamp, CheckpointOptions checkpointOptions) throws IOException {     CheckpointBarrier barrier = new CheckpointBarrier(id, timestamp, checkpointOptions).     for (RecordWriterOutput<?> streamOutput : streamOutputs) {         streamOutput.broadcastEvent(barrier).     } }
false;public;1;6;;public void broadcastCheckpointCancelMarker(long id) throws IOException {     CancelCheckpointMarker barrier = new CancelCheckpointMarker(id).     for (RecordWriterOutput<?> streamOutput : streamOutputs) {         streamOutput.broadcastEvent(barrier).     } }
false;public;1;11;;public void prepareSnapshotPreBarrier(long checkpointId) throws Exception {     // go forward through the operator chain and tell each operator     // to prepare the checkpoint     final StreamOperator<?>[] operators = this.allOperators.     for (int i = operators.length - 1. i >= 0. --i) {         final StreamOperator<?> op = operators[i].         if (op != null) {             op.prepareSnapshotPreBarrier(checkpointId).         }     } }
false;public;0;3;;public RecordWriterOutput<?>[] getStreamOutputs() {     return streamOutputs. }
false;public;0;3;;public StreamOperator<?>[] getAllOperators() {     return allOperators. }
false;public;0;3;;public WatermarkGaugeExposingOutput<StreamRecord<OUT>> getChainEntryPoint() {     return chainEntryPoint. }
true;public;0;5;/**  * This method should be called before finishing the record emission, to make sure any data  * that is still buffered will be sent. It also ensures that all data sending related  * exceptions are recognized.  *  * @throws IOException Thrown, if the buffered data cannot be pushed into the output streams.  */ ;/**  * This method should be called before finishing the record emission, to make sure any data  * that is still buffered will be sent. It also ensures that all data sending related  * exceptions are recognized.  *  * @throws IOException Thrown, if the buffered data cannot be pushed into the output streams.  */ public void flushOutputs() throws IOException {     for (RecordWriterOutput<?> streamOutput : getStreamOutputs()) {         streamOutput.flush().     } }
true;public;0;5;/**  * This method releases all resources of the record writer output. It stops the output  * flushing thread (if there is one) and releases all buffers currently held by the output  * serializers.  *  * <p>This method should never fail.  */ ;/**  * This method releases all resources of the record writer output. It stops the output  * flushing thread (if there is one) and releases all buffers currently held by the output  * serializers.  *  * <p>This method should never fail.  */ public void releaseOutputs() {     for (RecordWriterOutput<?> streamOutput : streamOutputs) {         streamOutput.close().     } }
false;public;0;3;;public OP getHeadOperator() {     return headOperator. }
false;public;0;3;;public int getChainLength() {     return allOperators == null ? 0 : allOperators.length. }
false;private;6;76;;// ------------------------------------------------------------------------ // initialization utilities // ------------------------------------------------------------------------ private <T> WatermarkGaugeExposingOutput<StreamRecord<T>> createOutputCollector(StreamTask<?, ?> containingTask, StreamConfig operatorConfig, Map<Integer, StreamConfig> chainedConfigs, ClassLoader userCodeClassloader, Map<StreamEdge, RecordWriterOutput<?>> streamOutputs, List<StreamOperator<?>> allOperators) {     List<Tuple2<WatermarkGaugeExposingOutput<StreamRecord<T>>, StreamEdge>> allOutputs = new ArrayList<>(4).     // create collectors for the network outputs     for (StreamEdge outputEdge : operatorConfig.getNonChainedOutputs(userCodeClassloader)) {         @SuppressWarnings("unchecked")         RecordWriterOutput<T> output = (RecordWriterOutput<T>) streamOutputs.get(outputEdge).         allOutputs.add(new Tuple2<>(output, outputEdge)).     }     // Create collectors for the chained outputs     for (StreamEdge outputEdge : operatorConfig.getChainedOutputs(userCodeClassloader)) {         int outputId = outputEdge.getTargetId().         StreamConfig chainedOpConfig = chainedConfigs.get(outputId).         WatermarkGaugeExposingOutput<StreamRecord<T>> output = createChainedOperator(containingTask, chainedOpConfig, chainedConfigs, userCodeClassloader, streamOutputs, allOperators, outputEdge.getOutputTag()).         allOutputs.add(new Tuple2<>(output, outputEdge)).     }     // if there are multiple outputs, or the outputs are directed, we need to     // wrap them as one output     List<OutputSelector<T>> selectors = operatorConfig.getOutputSelectors(userCodeClassloader).     if (selectors == null || selectors.isEmpty()) {         // simple path, no selector necessary         if (allOutputs.size() == 1) {             return allOutputs.get(0).f0.         } else {             // send to N outputs. Note that this includes the special case             // of sending to zero outputs             @SuppressWarnings({ "unchecked", "rawtypes" })             Output<StreamRecord<T>>[] asArray = new Output[allOutputs.size()].             for (int i = 0. i < allOutputs.size(). i++) {                 asArray[i] = allOutputs.get(i).f0.             }             // otherwise multi-chaining would not work correctly.             if (containingTask.getExecutionConfig().isObjectReuseEnabled()) {                 return new CopyingBroadcastingOutputCollector<>(asArray, this).             } else {                 return new BroadcastingOutputCollector<>(asArray, this).             }         }     } else {         // otherwise multi-chaining would not work correctly.         if (containingTask.getExecutionConfig().isObjectReuseEnabled()) {             return new CopyingDirectedOutput<>(selectors, allOutputs).         } else {             return new DirectedOutput<>(selectors, allOutputs).         }     } }
false;private;7;39;;private <IN, OUT> WatermarkGaugeExposingOutput<StreamRecord<IN>> createChainedOperator(StreamTask<?, ?> containingTask, StreamConfig operatorConfig, Map<Integer, StreamConfig> chainedConfigs, ClassLoader userCodeClassloader, Map<StreamEdge, RecordWriterOutput<?>> streamOutputs, List<StreamOperator<?>> allOperators, OutputTag<IN> outputTag) {     // create the output that the operator writes to first. this may recursively create more operators     WatermarkGaugeExposingOutput<StreamRecord<OUT>> chainedOperatorOutput = createOutputCollector(containingTask, operatorConfig, chainedConfigs, userCodeClassloader, streamOutputs, allOperators).     // now create the operator and give it the output collector to write its output to     OneInputStreamOperator<IN, OUT> chainedOperator = operatorConfig.getStreamOperator(userCodeClassloader).     chainedOperator.setup(containingTask, operatorConfig, chainedOperatorOutput).     allOperators.add(chainedOperator).     WatermarkGaugeExposingOutput<StreamRecord<IN>> currentOperatorOutput.     if (containingTask.getExecutionConfig().isObjectReuseEnabled()) {         currentOperatorOutput = new ChainingOutput<>(chainedOperator, this, outputTag).     } else {         TypeSerializer<IN> inSerializer = operatorConfig.getTypeSerializerIn1(userCodeClassloader).         currentOperatorOutput = new CopyingChainingOutput<>(chainedOperator, inSerializer, outputTag, this).     }     // wrap watermark gauges since registered metrics must be unique     chainedOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, currentOperatorOutput.getWatermarkGauge()::getValue).     chainedOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_OUTPUT_WATERMARK, chainedOperatorOutput.getWatermarkGauge()::getValue).     return currentOperatorOutput. }
false;private;4;20;;private RecordWriterOutput<OUT> createStreamOutput(RecordWriter<SerializationDelegate<StreamRecord<OUT>>> recordWriter, StreamEdge edge, StreamConfig upStreamConfig, Environment taskEnvironment) {     // OutputTag, return null if not sideOutput     OutputTag sideOutputTag = edge.getOutputTag().     TypeSerializer outSerializer = null.     if (edge.getOutputTag() != null) {         // side output         outSerializer = upStreamConfig.getTypeSerializerSideOut(edge.getOutputTag(), taskEnvironment.getUserClassLoader()).     } else {         // main output         outSerializer = upStreamConfig.getTypeSerializerOut(taskEnvironment.getUserClassLoader()).     }     return new RecordWriterOutput<>(recordWriter, outSerializer, sideOutputTag, this). }
false;;0;1;;Gauge<Long> getWatermarkGauge().
false;public;1;9;;@Override public void collect(StreamRecord<T> record) {     if (this.outputTag != null) {         // we are only responsible for emitting to the main input         return.     }     pushToOperator(record). }
false;public;2;10;;@Override public <X> void collect(OutputTag<X> outputTag, StreamRecord<X> record) {     if (this.outputTag == null || !this.outputTag.equals(outputTag)) {         // OutputTag.         return.     }     pushToOperator(record). }
false;protected;1;15;;protected <X> void pushToOperator(StreamRecord<X> record) {     try {         // we know that the given outputTag matches our OutputTag so the record         // must be of the type that our operator expects.         @SuppressWarnings("unchecked")         StreamRecord<T> castRecord = (StreamRecord<T>) record.         numRecordsIn.inc().         operator.setKeyContextElement1(castRecord).         operator.processElement(castRecord).     } catch (Exception e) {         throw new ExceptionInChainedOperatorException(e).     } }
false;public;1;12;;@Override public void emitWatermark(Watermark mark) {     try {         watermarkGauge.setCurrentWatermark(mark.getTimestamp()).         if (streamStatusProvider.getStreamStatus().isActive()) {             operator.processWatermark(mark).         }     } catch (Exception e) {         throw new ExceptionInChainedOperatorException(e).     } }
false;public;1;9;;@Override public void emitLatencyMarker(LatencyMarker latencyMarker) {     try {         operator.processLatencyMarker(latencyMarker).     } catch (Exception e) {         throw new ExceptionInChainedOperatorException(e).     } }
false;public;0;9;;@Override public void close() {     try {         operator.close().     } catch (Exception e) {         throw new ExceptionInChainedOperatorException(e).     } }
false;public;0;4;;@Override public Gauge<Long> getWatermarkGauge() {     return watermarkGauge. }
false;public;1;9;;@Override public void collect(StreamRecord<T> record) {     if (this.outputTag != null) {         // we are only responsible for emitting to the main input         return.     }     pushToOperator(record). }
false;public;2;10;;@Override public <X> void collect(OutputTag<X> outputTag, StreamRecord<X> record) {     if (this.outputTag == null || !this.outputTag.equals(outputTag)) {         // OutputTag.         return.     }     pushToOperator(record). }
false;protected;1;32;;@Override protected <X> void pushToOperator(StreamRecord<X> record) {     try {         // we know that the given outputTag matches our OutputTag so the record         // must be of the type that our operator (and Serializer) expects.         @SuppressWarnings("unchecked")         StreamRecord<T> castRecord = (StreamRecord<T>) record.         numRecordsIn.inc().         StreamRecord<T> copy = castRecord.copy(serializer.copy(castRecord.getValue())).         operator.setKeyContextElement1(copy).         operator.processElement(copy).     } catch (ClassCastException e) {         if (outputTag != null) {             // Enrich error message             ClassCastException replace = new ClassCastException(String.format("%s. Failed to push OutputTag with id '%s' to operator. " + "This can occur when multiple OutputTags with different types " + "but identical names are being used.", e.getMessage(), outputTag.getId())).             throw new ExceptionInChainedOperatorException(replace).         } else {             throw new ExceptionInChainedOperatorException(e).         }     } catch (Exception e) {         throw new ExceptionInChainedOperatorException(e).     } }
false;public;1;9;;@Override public void emitWatermark(Watermark mark) {     watermarkGauge.setCurrentWatermark(mark.getTimestamp()).     if (streamStatusProvider.getStreamStatus().isActive()) {         for (Output<StreamRecord<T>> output : outputs) {             output.emitWatermark(mark).         }     } }
false;public;1;11;;@Override public void emitLatencyMarker(LatencyMarker latencyMarker) {     if (outputs.length <= 0) {     // ignore     } else if (outputs.length == 1) {         outputs[0].emitLatencyMarker(latencyMarker).     } else {         // randomly select an output         outputs[random.nextInt(outputs.length)].emitLatencyMarker(latencyMarker).     } }
false;public;0;4;;@Override public Gauge<Long> getWatermarkGauge() {     return watermarkGauge. }
false;public;1;6;;@Override public void collect(StreamRecord<T> record) {     for (Output<StreamRecord<T>> output : outputs) {         output.collect(record).     } }
false;public;2;6;;@Override public <X> void collect(OutputTag<X> outputTag, StreamRecord<X> record) {     for (Output<StreamRecord<T>> output : outputs) {         output.collect(outputTag, record).     } }
false;public;0;6;;@Override public void close() {     for (Output<StreamRecord<T>> output : outputs) {         output.close().     } }
false;public;1;14;;@Override public void collect(StreamRecord<T> record) {     for (int i = 0. i < outputs.length - 1. i++) {         Output<StreamRecord<T>> output = outputs[i].         StreamRecord<T> shallowCopy = record.copy(record.getValue()).         output.collect(shallowCopy).     }     if (outputs.length > 0) {         // don't copy for the last output         outputs[outputs.length - 1].collect(record).     } }
false;public;2;14;;@Override public <X> void collect(OutputTag<X> outputTag, StreamRecord<X> record) {     for (int i = 0. i < outputs.length - 1. i++) {         Output<StreamRecord<T>> output = outputs[i].         StreamRecord<X> shallowCopy = record.copy(record.getValue()).         output.collect(outputTag, shallowCopy).     }     if (outputs.length > 0) {         // don't copy for the last output         outputs[outputs.length - 1].collect(outputTag, record).     } }
