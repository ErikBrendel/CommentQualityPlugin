commented;modifiers;parameterAmount;loc;comment;code
false;public;0;27;;@Override public void init() throws Exception {     StreamConfig configuration = getConfiguration().     TypeSerializer<IN> inSerializer = configuration.getTypeSerializerIn1(getUserCodeClassLoader()).     int numberOfInputs = configuration.getNumberOfInputs().     if (numberOfInputs > 0) {         InputGate[] inputGates = getEnvironment().getAllInputGates().         inputProcessor = new StreamInputProcessor<>(inputGates, inSerializer, this, configuration.getCheckpointMode(), getCheckpointLock(), getEnvironment().getIOManager(), getEnvironment().getTaskManagerInfo().getConfiguration(), getStreamStatusMaintainer(), this.headOperator, getEnvironment().getMetricGroup().getIOMetricGroup(), inputWatermarkGauge).     }     headOperator.getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, this.inputWatermarkGauge).     // wrap watermark gauge since registered metrics must be unique     getEnvironment().getMetricGroup().gauge(MetricNames.IO_CURRENT_INPUT_WATERMARK, this.inputWatermarkGauge::getValue). }
false;protected;0;9;;@Override protected void run() throws Exception {     // cache processor reference on the stack, to make the code more JIT friendly     final StreamInputProcessor<IN> inputProcessor = this.inputProcessor.     while (running && inputProcessor.processInput()) {     // all the work happens in the "processInput" method     } }
false;protected;0;6;;@Override protected void cleanup() throws Exception {     if (inputProcessor != null) {         inputProcessor.cleanup().     } }
false;protected;0;4;;@Override protected void cancelTask() {     running = false. }
