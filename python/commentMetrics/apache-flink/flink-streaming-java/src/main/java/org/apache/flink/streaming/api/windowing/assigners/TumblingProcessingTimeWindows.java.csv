commented;modifiers;parameterAmount;loc;comment;code
false;public;3;6;;@Override public Collection<TimeWindow> assignWindows(Object element, long timestamp, WindowAssignerContext context) {     final long now = context.getCurrentProcessingTime().     long start = TimeWindow.getWindowStartWithOffset(now, offset, size).     return Collections.singletonList(new TimeWindow(start, start + size)). }
false;public;0;3;;public long getSize() {     return size. }
false;public;1;4;;@Override public Trigger<Object, TimeWindow> getDefaultTrigger(StreamExecutionEnvironment env) {     return ProcessingTimeTrigger.create(). }
false;public;0;4;;@Override public String toString() {     return "TumblingProcessingTimeWindows(" + size + ")". }
true;public,static;1;3;/**  * Creates a new {@code TumblingProcessingTimeWindows} {@link WindowAssigner} that assigns  * elements to time windows based on the element timestamp.  *  * @param size The size of the generated windows.  * @return The time policy.  */ ;/**  * Creates a new {@code TumblingProcessingTimeWindows} {@link WindowAssigner} that assigns  * elements to time windows based on the element timestamp.  *  * @param size The size of the generated windows.  * @return The time policy.  */ public static TumblingProcessingTimeWindows of(Time size) {     return new TumblingProcessingTimeWindows(size.toMilliseconds(), 0). }
true;public,static;2;3;/**  * Creates a new {@code TumblingProcessingTimeWindows} {@link WindowAssigner} that assigns  * elements to time windows based on the element timestamp and offset.  *  * <p>For example, if you want window a stream by hour,but window begins at the 15th minutes  * of each hour, you can use {@code of(Time.hours(1),Time.minutes(15))},then you will get  * time windows start at 0:15:00,1:15:00,2:15:00,etc.  *  * <p>Rather than that,if you are living in somewhere which is not using UTC±00:00 time,  * such as China which is using UTC+08:00,and you want a time window with size of one day,  * and window begins at every 00:00:00 of local time,you may use {@code of(Time.days(1),Time.hours(-8))}.  * The parameter of offset is {@code Time.hours(-8))} since UTC+08:00 is 8 hours earlier than UTC time.  *  * @param size The size of the generated windows.  * @param offset The offset which window start would be shifted by.  * @return The time policy.  */ ;/**  * Creates a new {@code TumblingProcessingTimeWindows} {@link WindowAssigner} that assigns  * elements to time windows based on the element timestamp and offset.  *  * <p>For example, if you want window a stream by hour,but window begins at the 15th minutes  * of each hour, you can use {@code of(Time.hours(1),Time.minutes(15))},then you will get  * time windows start at 0:15:00,1:15:00,2:15:00,etc.  *  * <p>Rather than that,if you are living in somewhere which is not using UTC±00:00 time,  * such as China which is using UTC+08:00,and you want a time window with size of one day,  * and window begins at every 00:00:00 of local time,you may use {@code of(Time.days(1),Time.hours(-8))}.  * The parameter of offset is {@code Time.hours(-8))} since UTC+08:00 is 8 hours earlier than UTC time.  *  * @param size The size of the generated windows.  * @param offset The offset which window start would be shifted by.  * @return The time policy.  */ public static TumblingProcessingTimeWindows of(Time size, Time offset) {     return new TumblingProcessingTimeWindows(size.toMilliseconds(), offset.toMilliseconds()). }
false;public;1;4;;@Override public TypeSerializer<TimeWindow> getWindowSerializer(ExecutionConfig executionConfig) {     return new TimeWindow.Serializer(). }
false;public;0;4;;@Override public boolean isEventTime() {     return false. }
