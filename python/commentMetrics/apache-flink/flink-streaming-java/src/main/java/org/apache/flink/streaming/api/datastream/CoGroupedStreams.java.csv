# id;timestamp;commentText;codeText;commentWords;codeWords
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1445418103;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1454527671;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1454679829;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1455101486;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1455718153;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1456528025;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1456774151;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1472563673;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1472563673;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1493195810;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1493195810;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1493195810;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1494180263;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1495484544;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1496852938;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getBinaryOperatorReturnType(_					function,_					CoGroupFunction.class,_					true,_					true,_					input1.getType(),_					input2.getType(),_					"CoGroup",_					false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,binary,operator,return,type,function,co,group,function,class,true,true,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1496911361;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getCoGroupReturnTypes(_				function,_				input1.getType(),_				input2.getType(),_				"CoGroup",_				false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,co,group,return,types,function,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1515177485;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getCoGroupReturnTypes(_				function,_				input1.getType(),_				input2.getType(),_				"CoGroup",_				false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,co,group,return,types,function,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1532066767;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getCoGroupReturnTypes(_				function,_				input1.getType(),_				input2.getType(),_				"CoGroup",_				false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,co,group,return,types,function,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1537450148;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getCoGroupReturnTypes(_				function,_				input1.getType(),_				input2.getType(),_				"CoGroup",_				false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,co,group,return,types,function,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1539149027;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getCoGroupReturnTypes(_				function,_				input1.getType(),_				input2.getType(),_				"CoGroup",_				false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,co,group,return,types,function,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1539149114;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getCoGroupReturnTypes(_				function,_				input1.getType(),_				input2.getType(),_				"CoGroup",_				false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,co,group,return,types,function,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1548860007;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getCoGroupReturnTypes(_				function,_				input1.getType(),_				input2.getType(),_				"CoGroup",_				false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,co,group,return,types,function,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function);1550652777;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}_method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {__			TypeInformation<T> resultType = TypeExtractor.getCoGroupReturnTypes(_				function,_				input1.getType(),_				input2.getType(),_				"CoGroup",_				false)___			return apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,type,extractor,get,co,group,return,types,function,input1,get,type,input2,get,type,co,group,false,return,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1472563673;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>_Note: This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)} method has the wrong return type._</p>_@deprecated This method will be replaced by {@link #apply(CoGroupFunction, TypeInformation)} in Flink 2.0._So use the {@link #apply(CoGroupFunction, TypeInformation)} in the future.;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,p,deprecated,this,method,will,be,replaced,by,link,apply,co,group,function,type,information,in,flink,2,0,so,use,the,link,apply,co,group,function,type,information,in,the,future;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1472563673;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1493195810;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1493195810;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1493195810;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1494180263;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1495484544;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1496852938;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1496911361;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1515177485;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1532066767;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1537450148;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1539149027;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1539149114;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1548860007;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1550652777;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}_method is fixed in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			return (SingleOutputStreamOperator<T>) apply(function, resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,type,information,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,type,information,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,type,information,t,result,type,return,single,output,stream,operator,t,apply,function,result,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType);1532066767;Specifies a {@link KeySelector} for elements from the first input with explicit type information.__@param keySelector The KeySelector to be used for extracting the first input's key for partitioning._@param keyType The type information describing the key type.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType)  {_		Preconditions.checkNotNull(keySelector)__		Preconditions.checkNotNull(keyType)__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input,with,explicit,type,information,param,key,selector,the,key,selector,to,be,used,for,extracting,the,first,input,s,key,for,partitioning,param,key,type,the,type,information,describing,the,key,type;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,preconditions,check,not,null,key,selector,preconditions,check,not,null,key,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType);1537450148;Specifies a {@link KeySelector} for elements from the first input with explicit type information.__@param keySelector The KeySelector to be used for extracting the first input's key for partitioning._@param keyType The type information describing the key type.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType)  {_		Preconditions.checkNotNull(keySelector)__		Preconditions.checkNotNull(keyType)__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input,with,explicit,type,information,param,key,selector,the,key,selector,to,be,used,for,extracting,the,first,input,s,key,for,partitioning,param,key,type,the,type,information,describing,the,key,type;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,preconditions,check,not,null,key,selector,preconditions,check,not,null,key,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType);1539149027;Specifies a {@link KeySelector} for elements from the first input with explicit type information.__@param keySelector The KeySelector to be used for extracting the first input's key for partitioning._@param keyType The type information describing the key type.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType)  {_		Preconditions.checkNotNull(keySelector)__		Preconditions.checkNotNull(keyType)__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input,with,explicit,type,information,param,key,selector,the,key,selector,to,be,used,for,extracting,the,first,input,s,key,for,partitioning,param,key,type,the,type,information,describing,the,key,type;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,preconditions,check,not,null,key,selector,preconditions,check,not,null,key,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType);1539149114;Specifies a {@link KeySelector} for elements from the first input with explicit type information.__@param keySelector The KeySelector to be used for extracting the first input's key for partitioning._@param keyType The type information describing the key type.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType)  {_		Preconditions.checkNotNull(keySelector)__		Preconditions.checkNotNull(keyType)__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input,with,explicit,type,information,param,key,selector,the,key,selector,to,be,used,for,extracting,the,first,input,s,key,for,partitioning,param,key,type,the,type,information,describing,the,key,type;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,preconditions,check,not,null,key,selector,preconditions,check,not,null,key,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType);1548860007;Specifies a {@link KeySelector} for elements from the first input with explicit type information.__@param keySelector The KeySelector to be used for extracting the first input's key for partitioning._@param keyType The type information describing the key type.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType)  {_		Preconditions.checkNotNull(keySelector)__		Preconditions.checkNotNull(keyType)__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input,with,explicit,type,information,param,key,selector,the,key,selector,to,be,used,for,extracting,the,first,input,s,key,for,partitioning,param,key,type,the,type,information,describing,the,key,type;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,preconditions,check,not,null,key,selector,preconditions,check,not,null,key,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType);1550652777;Specifies a {@link KeySelector} for elements from the first input with explicit type information.__@param keySelector The KeySelector to be used for extracting the first input's key for partitioning._@param keyType The type information describing the key type.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType)  {_		Preconditions.checkNotNull(keySelector)__		Preconditions.checkNotNull(keyType)__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input,with,explicit,type,information,param,key,selector,the,key,selector,to,be,used,for,extracting,the,first,input,s,key,for,partitioning,param,key,type,the,type,information,describing,the,key,type;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,preconditions,check,not,null,key,selector,preconditions,check,not,null,key,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> Where -> EqualTo -> public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1445418103;Specifies the window on which the co-group operation works.;public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1454527671;Specifies the window on which the co-group operation works.;public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> UnionSerializerConfigSnapshot -> public UnionSerializerConfigSnapshot();1496852938;This empty nullary constructor is required for deserializing the configuration.;public UnionSerializerConfigSnapshot() {};this,empty,nullary,constructor,is,required,for,deserializing,the,configuration;public,union,serializer,config,snapshot
CoGroupedStreams -> UnionSerializerConfigSnapshot -> public UnionSerializerConfigSnapshot();1496911361;This empty nullary constructor is required for deserializing the configuration.;public UnionSerializerConfigSnapshot() {};this,empty,nullary,constructor,is,required,for,deserializing,the,configuration;public,union,serializer,config,snapshot
CoGroupedStreams -> UnionSerializerConfigSnapshot -> public UnionSerializerConfigSnapshot();1515177485;This empty nullary constructor is required for deserializing the configuration.;public UnionSerializerConfigSnapshot() {};this,empty,nullary,constructor,is,required,for,deserializing,the,configuration;public,union,serializer,config,snapshot
CoGroupedStreams -> UnionSerializerConfigSnapshot -> public UnionSerializerConfigSnapshot();1532066767;This empty nullary constructor is required for deserializing the configuration.;public UnionSerializerConfigSnapshot() {};this,empty,nullary,constructor,is,required,for,deserializing,the,configuration;public,union,serializer,config,snapshot
CoGroupedStreams -> UnionSerializerConfigSnapshot -> public UnionSerializerConfigSnapshot();1537450148;This empty nullary constructor is required for deserializing the configuration.;public UnionSerializerConfigSnapshot() {};this,empty,nullary,constructor,is,required,for,deserializing,the,configuration;public,union,serializer,config,snapshot
CoGroupedStreams -> UnionSerializerConfigSnapshot -> public UnionSerializerConfigSnapshot();1539149027;This empty nullary constructor is required for deserializing the configuration.;public UnionSerializerConfigSnapshot() {};this,empty,nullary,constructor,is,required,for,deserializing,the,configuration;public,union,serializer,config,snapshot
CoGroupedStreams -> UnionSerializerConfigSnapshot -> public UnionSerializerConfigSnapshot();1539149114;This empty nullary constructor is required for deserializing the configuration.;public UnionSerializerConfigSnapshot() {};this,empty,nullary,constructor,is,required,for,deserializing,the,configuration;public,union,serializer,config,snapshot
CoGroupedStreams -> UnionSerializerConfigSnapshot -> public UnionSerializerConfigSnapshot();1548860007;This empty nullary constructor is required for deserializing the configuration.;public UnionSerializerConfigSnapshot() {_		};this,empty,nullary,constructor,is,required,for,deserializing,the,configuration;public,union,serializer,config,snapshot
CoGroupedStreams -> UnionSerializerConfigSnapshot -> public UnionSerializerConfigSnapshot();1550652777;This empty nullary constructor is required for deserializing the configuration.;public UnionSerializerConfigSnapshot() {_		};this,empty,nullary,constructor,is,required,for,deserializing,the,configuration;public,union,serializer,config,snapshot
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1445418103;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " + _						"first key = " + this.keyType + " , second key = " + otherKey)__			}_			_			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1454527671;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " + _						"first key = " + this.keyType + " , second key = " + otherKey)__			}_			_			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1454679829;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " + _						"first key = " + this.keyType + " , second key = " + otherKey)__			}_			_			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1455101486;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " + _						"first key = " + this.keyType + " , second key = " + otherKey)__			}_			_			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1455718153;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " + _						"first key = " + this.keyType + " , second key = " + otherKey)__			}_			_			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1456528025;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " + _						"first key = " + this.keyType + " , second key = " + otherKey)__			}_			_			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1456774151;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " + _						"first key = " + this.keyType + " , second key = " + otherKey)__			}_			_			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1472563673;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " + _						"first key = " + this.keyType + " , second key = " + otherKey)__			}_			_			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1472563673;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " + _						"first key = " + this.keyType + " , second key = " + otherKey)__			}_			_			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1493195810;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " + _						"first key = " + this.keyType + " , second key = " + otherKey)__			}_			_			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1493195810;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + otherKey)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1493195810;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + otherKey)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1494180263;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + otherKey)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1495484544;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + otherKey)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1496852938;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + otherKey)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1496911361;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + otherKey)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1515177485;Specifies a {@link KeySelector} for elements from the second input.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			if (!otherKey.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + otherKey)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,if,other,key,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,other,key,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1532066767;Specifies a {@link KeySelector} for elements from the second input.__@param keySelector The KeySelector to be used for extracting the second input's key for partitioning.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			Preconditions.checkNotNull(keySelector)__			final TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			return equalTo(keySelector, otherKey)__		};specifies,a,link,key,selector,for,elements,from,the,second,input,param,key,selector,the,key,selector,to,be,used,for,extracting,the,second,input,s,key,for,partitioning;public,equal,to,equal,to,key,selector,t2,key,key,selector,preconditions,check,not,null,key,selector,final,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,return,equal,to,key,selector,other,key
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1537450148;Specifies a {@link KeySelector} for elements from the second input.__@param keySelector The KeySelector to be used for extracting the second input's key for partitioning.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			Preconditions.checkNotNull(keySelector)__			final TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			return equalTo(keySelector, otherKey)__		};specifies,a,link,key,selector,for,elements,from,the,second,input,param,key,selector,the,key,selector,to,be,used,for,extracting,the,second,input,s,key,for,partitioning;public,equal,to,equal,to,key,selector,t2,key,key,selector,preconditions,check,not,null,key,selector,final,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,return,equal,to,key,selector,other,key
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1539149027;Specifies a {@link KeySelector} for elements from the second input.__@param keySelector The KeySelector to be used for extracting the second input's key for partitioning.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			Preconditions.checkNotNull(keySelector)__			final TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			return equalTo(keySelector, otherKey)__		};specifies,a,link,key,selector,for,elements,from,the,second,input,param,key,selector,the,key,selector,to,be,used,for,extracting,the,second,input,s,key,for,partitioning;public,equal,to,equal,to,key,selector,t2,key,key,selector,preconditions,check,not,null,key,selector,final,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,return,equal,to,key,selector,other,key
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1539149114;Specifies a {@link KeySelector} for elements from the second input.__@param keySelector The KeySelector to be used for extracting the second input's key for partitioning.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			Preconditions.checkNotNull(keySelector)__			final TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			return equalTo(keySelector, otherKey)__		};specifies,a,link,key,selector,for,elements,from,the,second,input,param,key,selector,the,key,selector,to,be,used,for,extracting,the,second,input,s,key,for,partitioning;public,equal,to,equal,to,key,selector,t2,key,key,selector,preconditions,check,not,null,key,selector,final,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,return,equal,to,key,selector,other,key
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1548860007;Specifies a {@link KeySelector} for elements from the second input.__@param keySelector The KeySelector to be used for extracting the second input's key for partitioning.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			Preconditions.checkNotNull(keySelector)__			final TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			return equalTo(keySelector, otherKey)__		};specifies,a,link,key,selector,for,elements,from,the,second,input,param,key,selector,the,key,selector,to,be,used,for,extracting,the,second,input,s,key,for,partitioning;public,equal,to,equal,to,key,selector,t2,key,key,selector,preconditions,check,not,null,key,selector,final,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,return,equal,to,key,selector,other,key
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector);1550652777;Specifies a {@link KeySelector} for elements from the second input.__@param keySelector The KeySelector to be used for extracting the second input's key for partitioning.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector)  {_			Preconditions.checkNotNull(keySelector)__			final TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType())__			return equalTo(keySelector, otherKey)__		};specifies,a,link,key,selector,for,elements,from,the,second,input,param,key,selector,the,key,selector,to,be,used,for,extracting,the,second,input,s,key,for,partitioning;public,equal,to,equal,to,key,selector,t2,key,key,selector,preconditions,check,not,null,key,selector,final,type,information,key,other,key,type,extractor,get,key,selector,types,key,selector,input2,get,type,return,equal,to,key,selector,other,key
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1472563673;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>_Note: This is a temporary workaround while the {@link #apply(CoGroupFunction)} method has the wrong return type._</p>_@deprecated This method will be replaced by {@link #apply(CoGroupFunction)} in Flink 2.0._So use the {@link #apply(CoGroupFunction)} in the future.;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,p,deprecated,this,method,will,be,replaced,by,link,apply,co,group,function,in,flink,2,0,so,use,the,link,apply,co,group,function,in,the,future;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1472563673;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1493195810;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1493195810;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1493195810;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1494180263;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1495484544;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1496852938;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1496911361;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1515177485;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1532066767;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1537450148;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1539149027;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1539149114;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1548860007;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		@Deprecated 		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function);1550652777;Completes the co-group operation with the user function that is executed_for windowed groups.__<p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}_method has the wrong return type and hence does not allow one to set an operator-specific_parallelism__@deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed_in the next major version of Flink (2.0).;@PublicEvolving_		@Deprecated_		public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {_			return (SingleOutputStreamOperator<T>) apply(function)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,b,note,b,this,is,a,temporary,workaround,while,the,link,apply,co,group,function,method,has,the,wrong,return,type,and,hence,does,not,allow,one,to,set,an,operator,specific,parallelism,deprecated,this,method,will,be,removed,once,the,link,apply,co,group,function,method,is,fixed,in,the,next,major,version,of,flink,2,0;public,evolving,deprecated,public,t,single,output,stream,operator,t,with,co,group,function,t1,t2,t,function,return,single,output,stream,operator,t,apply,function
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1455101486;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1455718153;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1456528025;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1456774151;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1472563673;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1472563673;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1493195810;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1493195810;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1493195810;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1494180263;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1495484544;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1496852938;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1496911361;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1515177485;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1532066767;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1537450148;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor, allowedLateness)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor,allowed,lateness
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1539149027;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor, allowedLateness)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor,allowed,lateness
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1539149114;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor, allowedLateness)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor,allowed,lateness
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1548860007;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor, allowedLateness)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor,allowed,lateness
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1550652777;Sets the {@code Trigger} that should be used to trigger window emission.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor, allowedLateness)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,evolving,public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor,allowed,lateness
CoGroupedStreams -> WithWindow -> public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1445418103;Sets the {@code Evictor} that should be used to evict elements from a window before emission.__<p>_Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1454527671;Sets the {@code Evictor} that should be used to evict elements from a window before emission.__<p>_Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> allowedLateness(Time newLateness);1537450148;Sets the time by which elements are allowed to be late._@see WindowedStream#allowedLateness(Time);@PublicEvolving_		public WithWindow<T1, T2, KEY, W> allowedLateness(Time newLateness) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, evictor, newLateness)__		};sets,the,time,by,which,elements,are,allowed,to,be,late,see,windowed,stream,allowed,lateness,time;public,evolving,public,with,window,t1,t2,key,w,allowed,lateness,time,new,lateness,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,evictor,new,lateness
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> allowedLateness(Time newLateness);1539149027;Sets the time by which elements are allowed to be late._@see WindowedStream#allowedLateness(Time);@PublicEvolving_		public WithWindow<T1, T2, KEY, W> allowedLateness(Time newLateness) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, evictor, newLateness)__		};sets,the,time,by,which,elements,are,allowed,to,be,late,see,windowed,stream,allowed,lateness,time;public,evolving,public,with,window,t1,t2,key,w,allowed,lateness,time,new,lateness,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,evictor,new,lateness
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> allowedLateness(Time newLateness);1539149114;Sets the time by which elements are allowed to be late._@see WindowedStream#allowedLateness(Time);@PublicEvolving_		public WithWindow<T1, T2, KEY, W> allowedLateness(Time newLateness) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, evictor, newLateness)__		};sets,the,time,by,which,elements,are,allowed,to,be,late,see,windowed,stream,allowed,lateness,time;public,evolving,public,with,window,t1,t2,key,w,allowed,lateness,time,new,lateness,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,evictor,new,lateness
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> allowedLateness(Time newLateness);1548860007;Sets the time by which elements are allowed to be late._@see WindowedStream#allowedLateness(Time);@PublicEvolving_		public WithWindow<T1, T2, KEY, W> allowedLateness(Time newLateness) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, evictor, newLateness)__		};sets,the,time,by,which,elements,are,allowed,to,be,late,see,windowed,stream,allowed,lateness,time;public,evolving,public,with,window,t1,t2,key,w,allowed,lateness,time,new,lateness,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,evictor,new,lateness
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> allowedLateness(Time newLateness);1550652777;Sets the time by which elements are allowed to be late._@see WindowedStream#allowedLateness(Time);@PublicEvolving_		public WithWindow<T1, T2, KEY, W> allowedLateness(Time newLateness) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, evictor, newLateness)__		};sets,the,time,by,which,elements,are,allowed,to,be,late,see,windowed,stream,allowed,lateness,time;public,evolving,public,with,window,t1,t2,key,w,allowed,lateness,time,new,lateness,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,evictor,new,lateness
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1445418103;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1454527671;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1454679829;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1455101486;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1455718153;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1456528025;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1456774151;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1472563673;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1472563673;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1493195810;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1493195810;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1493195810;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1494180263;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1495484544;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1496852938;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1496911361;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1515177485;Specifies a {@link KeySelector} for elements from the first input.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return new Where<>(input1.clean(keySelector), keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input;public,key,where,key,where,key,selector,t1,key,key,selector,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,new,where,input1,clean,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1532066767;Specifies a {@link KeySelector} for elements from the first input.__@param keySelector The KeySelector to be used for extracting the first input's key for partitioning.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		Preconditions.checkNotNull(keySelector)__		final TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return where(keySelector, keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input,param,key,selector,the,key,selector,to,be,used,for,extracting,the,first,input,s,key,for,partitioning;public,key,where,key,where,key,selector,t1,key,key,selector,preconditions,check,not,null,key,selector,final,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,where,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1537450148;Specifies a {@link KeySelector} for elements from the first input.__@param keySelector The KeySelector to be used for extracting the first input's key for partitioning.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		Preconditions.checkNotNull(keySelector)__		final TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return where(keySelector, keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input,param,key,selector,the,key,selector,to,be,used,for,extracting,the,first,input,s,key,for,partitioning;public,key,where,key,where,key,selector,t1,key,key,selector,preconditions,check,not,null,key,selector,final,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,where,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1539149027;Specifies a {@link KeySelector} for elements from the first input.__@param keySelector The KeySelector to be used for extracting the first input's key for partitioning.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		Preconditions.checkNotNull(keySelector)__		final TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return where(keySelector, keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input,param,key,selector,the,key,selector,to,be,used,for,extracting,the,first,input,s,key,for,partitioning;public,key,where,key,where,key,selector,t1,key,key,selector,preconditions,check,not,null,key,selector,final,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,where,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1539149114;Specifies a {@link KeySelector} for elements from the first input.__@param keySelector The KeySelector to be used for extracting the first input's key for partitioning.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		Preconditions.checkNotNull(keySelector)__		final TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return where(keySelector, keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input,param,key,selector,the,key,selector,to,be,used,for,extracting,the,first,input,s,key,for,partitioning;public,key,where,key,where,key,selector,t1,key,key,selector,preconditions,check,not,null,key,selector,final,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,where,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1548860007;Specifies a {@link KeySelector} for elements from the first input.__@param keySelector The KeySelector to be used for extracting the first input's key for partitioning.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		Preconditions.checkNotNull(keySelector)__		final TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return where(keySelector, keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input,param,key,selector,the,key,selector,to,be,used,for,extracting,the,first,input,s,key,for,partitioning;public,key,where,key,where,key,selector,t1,key,key,selector,preconditions,check,not,null,key,selector,final,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,where,key,selector,key,type
CoGroupedStreams -> public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector);1550652777;Specifies a {@link KeySelector} for elements from the first input.__@param keySelector The KeySelector to be used for extracting the first input's key for partitioning.;public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector)  {_		Preconditions.checkNotNull(keySelector)__		final TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType())__		return where(keySelector, keyType)__	};specifies,a,link,key,selector,for,elements,from,the,first,input,param,key,selector,the,key,selector,to,be,used,for,extracting,the,first,input,s,key,for,partitioning;public,key,where,key,where,key,selector,t1,key,key,selector,preconditions,check,not,null,key,selector,final,type,information,key,key,type,type,extractor,get,key,selector,types,key,selector,input1,get,type,return,where,key,selector,key,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1445418103;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)__			_			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)__			_			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp = _					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1454527671;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)__			_			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)__			_			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp = _					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1454679829;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)__			_			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)__			_			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp = _					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1455101486;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)__			_			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)__			_			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp = _					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1455718153;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)__			_			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)__			_			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp = _					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1456528025;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)__			_			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)__			_			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp = _					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1456774151;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)__			_			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)__			_			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp = _					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1472563673;Completes the co-group operation with the user function that is executed_for windowed groups.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)__			_			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)__			_			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp = _					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1472563673;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)__			_			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)__			_			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp = _					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1493195810;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)__			_			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)__			_			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp = _					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1493195810;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1493195810;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1494180263;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1495484544;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1496852938;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1496911361;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1515177485;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1532066767;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			WindowedStream<TaggedUnion<T1, T2>, KEY, W> windowOp =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowOp.trigger(trigger)__			}_			if (evictor != null) {_				windowOp.evictor(evictor)__			}__			return windowOp.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,tagged,union,t1,t2,key,w,window,op,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,window,op,trigger,trigger,if,evictor,null,window,op,evictor,evictor,return,window,op,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1537450148;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			windowedStream =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowedStream.trigger(trigger)__			}_			if (evictor != null) {_				windowedStream.evictor(evictor)__			}_			if (allowedLateness != null) {_				windowedStream.allowedLateness(allowedLateness)__			}__			return windowedStream.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,windowed,stream,trigger,trigger,if,evictor,null,windowed,stream,evictor,evictor,if,allowed,lateness,null,windowed,stream,allowed,lateness,allowed,lateness,return,windowed,stream,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1539149027;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			windowedStream =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowedStream.trigger(trigger)__			}_			if (evictor != null) {_				windowedStream.evictor(evictor)__			}_			if (allowedLateness != null) {_				windowedStream.allowedLateness(allowedLateness)__			}__			return windowedStream.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,windowed,stream,trigger,trigger,if,evictor,null,windowed,stream,evictor,evictor,if,allowed,lateness,null,windowed,stream,allowed,lateness,allowed,lateness,return,windowed,stream,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1539149114;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			windowedStream =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowedStream.trigger(trigger)__			}_			if (evictor != null) {_				windowedStream.evictor(evictor)__			}_			if (allowedLateness != null) {_				windowedStream.allowedLateness(allowedLateness)__			}__			return windowedStream.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,windowed,stream,trigger,trigger,if,evictor,null,windowed,stream,evictor,evictor,if,allowed,lateness,null,windowed,stream,allowed,lateness,allowed,lateness,return,windowed,stream,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1548860007;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			windowedStream =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowedStream.trigger(trigger)__			}_			if (evictor != null) {_				windowedStream.evictor(evictor)__			}_			if (allowedLateness != null) {_				windowedStream.allowedLateness(allowedLateness)__			}__			return windowedStream.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,windowed,stream,trigger,trigger,if,evictor,null,windowed,stream,evictor,evictor,if,allowed,lateness,null,windowed,stream,allowed,lateness,allowed,lateness,return,windowed,stream,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType);1550652777;Completes the co-group operation with the user function that is executed_for windowed groups.__<p>Note: This method's return type does not support setting an operator-specific parallelism._Due to binary backwards compatibility, this cannot be altered. Use the_{@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.;public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {_			_			function = input1.getExecutionEnvironment().clean(function)___			UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType())__			UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2)___			DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1_					.map(new Input1Tagger<T1, T2>())_					.setParallelism(input1.getParallelism())_					.returns(unionType)__			DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2_					.map(new Input2Tagger<T1, T2>())_					.setParallelism(input2.getParallelism())_					.returns(unionType)___			DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2)___			_			windowedStream =_					new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType)_					.window(windowAssigner)___			if (trigger != null) {_				windowedStream.trigger(trigger)__			}_			if (evictor != null) {_				windowedStream.evictor(evictor)__			}_			if (allowedLateness != null) {_				windowedStream.allowedLateness(allowedLateness)__			}__			return windowedStream.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType)__		};completes,the,co,group,operation,with,the,user,function,that,is,executed,for,windowed,groups,p,note,this,method,s,return,type,does,not,support,setting,an,operator,specific,parallelism,due,to,binary,backwards,compatibility,this,cannot,be,altered,use,the,link,with,co,group,function,type,information,method,to,set,an,operator,specific,parallelism;public,t,data,stream,t,apply,co,group,function,t1,t2,t,function,type,information,t,result,type,function,input1,get,execution,environment,clean,function,union,type,info,t1,t2,union,type,new,union,type,info,input1,get,type,input2,get,type,union,key,selector,t1,t2,key,union,key,selector,new,union,key,selector,key,selector1,key,selector2,data,stream,tagged,union,t1,t2,tagged,input1,input1,map,new,input1tagger,t1,t2,set,parallelism,input1,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,tagged,input2,input2,map,new,input2tagger,t1,t2,set,parallelism,input2,get,parallelism,returns,union,type,data,stream,tagged,union,t1,t2,union,stream,tagged,input1,union,tagged,input2,windowed,stream,new,keyed,stream,tagged,union,t1,t2,key,union,stream,union,key,selector,key,type,window,window,assigner,if,trigger,null,windowed,stream,trigger,trigger,if,evictor,null,windowed,stream,evictor,evictor,if,allowed,lateness,null,windowed,stream,allowed,lateness,allowed,lateness,return,windowed,stream,apply,new,co,group,window,function,t1,t2,t,key,w,function,result,type
CoGroupedStreams -> WithWindow -> public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1445418103;Sets the {@code Trigger} that should be used to trigger window emission.;public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> WithWindow -> public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger);1454527671;Sets the {@code Trigger} that should be used to trigger window emission.;public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, newTrigger, evictor)__		};sets,the,code,trigger,that,should,be,used,to,trigger,window,emission;public,with,window,t1,t2,key,w,trigger,trigger,super,tagged,union,t1,t2,super,w,new,trigger,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,new,trigger,evictor
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType);1532066767;Specifies a {@link KeySelector} for elements from the second input with explicit type information for the key type.__@param keySelector The KeySelector to be used for extracting the key for partitioning._@param keyType The type information describing the key type.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType)  {_			Preconditions.checkNotNull(keySelector)__			Preconditions.checkNotNull(keyType)___			if (!keyType.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + keyType)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input,with,explicit,type,information,for,the,key,type,param,key,selector,the,key,selector,to,be,used,for,extracting,the,key,for,partitioning,param,key,type,the,type,information,describing,the,key,type;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,key,type,preconditions,check,not,null,key,selector,preconditions,check,not,null,key,type,if,key,type,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,key,type,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType);1537450148;Specifies a {@link KeySelector} for elements from the second input with explicit type information for the key type.__@param keySelector The KeySelector to be used for extracting the key for partitioning._@param keyType The type information describing the key type.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType)  {_			Preconditions.checkNotNull(keySelector)__			Preconditions.checkNotNull(keyType)___			if (!keyType.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + keyType)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input,with,explicit,type,information,for,the,key,type,param,key,selector,the,key,selector,to,be,used,for,extracting,the,key,for,partitioning,param,key,type,the,type,information,describing,the,key,type;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,key,type,preconditions,check,not,null,key,selector,preconditions,check,not,null,key,type,if,key,type,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,key,type,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType);1539149027;Specifies a {@link KeySelector} for elements from the second input with explicit type information for the key type.__@param keySelector The KeySelector to be used for extracting the key for partitioning._@param keyType The type information describing the key type.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType)  {_			Preconditions.checkNotNull(keySelector)__			Preconditions.checkNotNull(keyType)___			if (!keyType.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + keyType)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input,with,explicit,type,information,for,the,key,type,param,key,selector,the,key,selector,to,be,used,for,extracting,the,key,for,partitioning,param,key,type,the,type,information,describing,the,key,type;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,key,type,preconditions,check,not,null,key,selector,preconditions,check,not,null,key,type,if,key,type,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,key,type,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType);1539149114;Specifies a {@link KeySelector} for elements from the second input with explicit type information for the key type.__@param keySelector The KeySelector to be used for extracting the key for partitioning._@param keyType The type information describing the key type.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType)  {_			Preconditions.checkNotNull(keySelector)__			Preconditions.checkNotNull(keyType)___			if (!keyType.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + keyType)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input,with,explicit,type,information,for,the,key,type,param,key,selector,the,key,selector,to,be,used,for,extracting,the,key,for,partitioning,param,key,type,the,type,information,describing,the,key,type;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,key,type,preconditions,check,not,null,key,selector,preconditions,check,not,null,key,type,if,key,type,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,key,type,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType);1548860007;Specifies a {@link KeySelector} for elements from the second input with explicit type information for the key type.__@param keySelector The KeySelector to be used for extracting the key for partitioning._@param keyType The type information describing the key type.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType)  {_			Preconditions.checkNotNull(keySelector)__			Preconditions.checkNotNull(keyType)___			if (!keyType.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + keyType)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input,with,explicit,type,information,for,the,key,type,param,key,selector,the,key,selector,to,be,used,for,extracting,the,key,for,partitioning,param,key,type,the,type,information,describing,the,key,type;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,key,type,preconditions,check,not,null,key,selector,preconditions,check,not,null,key,type,if,key,type,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,key,type,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> Where -> public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType);1550652777;Specifies a {@link KeySelector} for elements from the second input with explicit type information for the key type.__@param keySelector The KeySelector to be used for extracting the key for partitioning._@param keyType The type information describing the key type.;public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType)  {_			Preconditions.checkNotNull(keySelector)__			Preconditions.checkNotNull(keyType)___			if (!keyType.equals(this.keyType)) {_				throw new IllegalArgumentException("The keys for the two inputs are not equal: " +_						"first key = " + this.keyType + " , second key = " + keyType)__			}__			return new EqualTo(input2.clean(keySelector))__		};specifies,a,link,key,selector,for,elements,from,the,second,input,with,explicit,type,information,for,the,key,type,param,key,selector,the,key,selector,to,be,used,for,extracting,the,key,for,partitioning,param,key,type,the,type,information,describing,the,key,type;public,equal,to,equal,to,key,selector,t2,key,key,selector,type,information,key,key,type,preconditions,check,not,null,key,selector,preconditions,check,not,null,key,type,if,key,type,equals,this,key,type,throw,new,illegal,argument,exception,the,keys,for,the,two,inputs,are,not,equal,first,key,this,key,type,second,key,key,type,return,new,equal,to,input2,clean,key,selector
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1455101486;Sets the {@code Evictor} that should be used to evict elements from a window before emission.__<p>_Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1455718153;Sets the {@code Evictor} that should be used to evict elements from a window before emission.__<p>_Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1456528025;Sets the {@code Evictor} that should be used to evict elements from a window before emission.__<p>_Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1456774151;Sets the {@code Evictor} that should be used to evict elements from a window before emission.__<p>_Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1472563673;Sets the {@code Evictor} that should be used to evict elements from a window before emission.__<p>_Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1472563673;Sets the {@code Evictor} that should be used to evict elements from a window before emission.__<p>_Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1493195810;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1493195810;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1493195810;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1494180263;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1495484544;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1496852938;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1496911361;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1515177485;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1532066767;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1537450148;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor, allowedLateness)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor,allowed,lateness
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1539149027;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor, allowedLateness)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor,allowed,lateness
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1539149114;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor, allowedLateness)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor,allowed,lateness
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1548860007;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor, allowedLateness)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor,allowed,lateness
CoGroupedStreams -> WithWindow -> @PublicEvolving 		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor);1550652777;Sets the {@code Evictor} that should be used to evict elements from a window before_emission.__<p>Note: When using an evictor window performance will degrade significantly, since_pre-aggregation of window results cannot be used.;@PublicEvolving_		public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {_			return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType,_					windowAssigner, trigger, newEvictor, allowedLateness)__		};sets,the,code,evictor,that,should,be,used,to,evict,elements,from,a,window,before,emission,p,note,when,using,an,evictor,window,performance,will,degrade,significantly,since,pre,aggregation,of,window,results,cannot,be,used;public,evolving,public,with,window,t1,t2,key,w,evictor,evictor,super,tagged,union,t1,t2,super,w,new,evictor,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,window,assigner,trigger,new,evictor,allowed,lateness
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1445418103;Creates new CoGroped data streams, which are the first step towards building a streaming co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1454527671;Creates new CoGroped data streams, which are the first step towards building a streaming co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1454679829;Creates new CoGroped data streams, which are the first step towards building a streaming co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1455101486;Creates new CoGroped data streams, which are the first step towards building a streaming co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1455718153;Creates new CoGroped data streams, which are the first step towards building a streaming co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1456528025;Creates new CoGroped data streams, which are the first step towards building a streaming co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1456774151;Creates new CoGroped data streams, which are the first step towards building a streaming co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1472563673;Creates new CoGroped data streams, which are the first step towards building a streaming co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1472563673;Creates new CoGroped data streams, which are the first step towards building a streaming co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1493195810;Creates new CoGroped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1493195810;Creates new CoGroped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1493195810;Creates new CoGroped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1494180263;Creates new CoGroped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1495484544;Creates new CoGroped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,groped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1496852938;Creates new CoGrouped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,grouped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1496911361;Creates new CoGrouped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,grouped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1515177485;Creates new CoGrouped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,grouped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1532066767;Creates new CoGrouped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,grouped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1537450148;Creates new CoGrouped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,grouped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1539149027;Creates new CoGrouped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,grouped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1539149114;Creates new CoGrouped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,grouped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1548860007;Creates new CoGrouped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,grouped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2);1550652777;Creates new CoGrouped data streams, which are the first step towards building a streaming_co-group.__@param input1 The first data stream._@param input2 The second data stream.;public CoGroupedStreams(DataStream<T1> input1, DataStream<T2> input2) {_		this.input1 = requireNonNull(input1)__		this.input2 = requireNonNull(input2)__	};creates,new,co,grouped,data,streams,which,are,the,first,step,towards,building,a,streaming,co,group,param,input1,the,first,data,stream,param,input2,the,second,data,stream;public,co,grouped,streams,data,stream,t1,input1,data,stream,t2,input2,this,input1,require,non,null,input1,this,input2,require,non,null,input2
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1455101486;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1455718153;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1456528025;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1456774151;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1472563673;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1472563673;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1493195810;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1493195810;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1493195810;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1494180263;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1495484544;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1496852938;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1496911361;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1515177485;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1532066767;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1537450148;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1539149027;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1539149114;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1548860007;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null,null
CoGroupedStreams -> Where -> EqualTo -> @PublicEvolving 			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner);1550652777;Specifies the window on which the co-group operation works.;@PublicEvolving_			public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {_				return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null, null)__			};specifies,the,window,on,which,the,co,group,operation,works;public,evolving,public,w,extends,window,with,window,t1,t2,key,w,window,window,assigner,super,tagged,union,t1,t2,w,assigner,return,new,with,window,input1,input2,key,selector1,key,selector2,key,type,assigner,null,null,null
