commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * Specifies a {@link KeySelector} for elements from the first input.  *  * @param keySelector The KeySelector to be used for extracting the first input's key for partitioning.  */ ;/**  * Specifies a {@link KeySelector} for elements from the first input.  *  * @param keySelector The KeySelector to be used for extracting the first input's key for partitioning.  */ public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector) {     Preconditions.checkNotNull(keySelector).     final TypeInformation<KEY> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType()).     return where(keySelector, keyType). }
true;public;2;5;/**  * Specifies a {@link KeySelector} for elements from the first input with explicit type information.  *  * @param keySelector The KeySelector to be used for extracting the first input's key for partitioning.  * @param keyType The type information describing the key type.  */ ;/**  * Specifies a {@link KeySelector} for elements from the first input with explicit type information.  *  * @param keySelector The KeySelector to be used for extracting the first input's key for partitioning.  * @param keyType The type information describing the key type.  */ public <KEY> Where<KEY> where(KeySelector<T1, KEY> keySelector, TypeInformation<KEY> keyType) {     Preconditions.checkNotNull(keySelector).     Preconditions.checkNotNull(keyType).     return new Where<>(input1.clean(keySelector), keyType). }
true;public;1;5;/**  * Specifies a {@link KeySelector} for elements from the second input.  *  * @param keySelector The KeySelector to be used for extracting the second input's key for partitioning.  */ ;/**  * Specifies a {@link KeySelector} for elements from the second input.  *  * @param keySelector The KeySelector to be used for extracting the second input's key for partitioning.  */ public EqualTo equalTo(KeySelector<T2, KEY> keySelector) {     Preconditions.checkNotNull(keySelector).     final TypeInformation<KEY> otherKey = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType()).     return equalTo(keySelector, otherKey). }
true;public;2;11;/**  * Specifies a {@link KeySelector} for elements from the second input with explicit type information for the key type.  *  * @param keySelector The KeySelector to be used for extracting the key for partitioning.  * @param keyType The type information describing the key type.  */ ;/**  * Specifies a {@link KeySelector} for elements from the second input with explicit type information for the key type.  *  * @param keySelector The KeySelector to be used for extracting the key for partitioning.  * @param keyType The type information describing the key type.  */ public EqualTo equalTo(KeySelector<T2, KEY> keySelector, TypeInformation<KEY> keyType) {     Preconditions.checkNotNull(keySelector).     Preconditions.checkNotNull(keyType).     if (!keyType.equals(this.keyType)) {         throw new IllegalArgumentException("The keys for the two inputs are not equal: " + "first key = " + this.keyType + " , second key = " + keyType).     }     return new EqualTo(input2.clean(keySelector)). }
true;public;1;4;/**  * Specifies the window on which the co-group operation works.  */ ;/**  * Specifies the window on which the co-group operation works.  */ @PublicEvolving public <W extends Window> WithWindow<T1, T2, KEY, W> window(WindowAssigner<? super TaggedUnion<T1, T2>, W> assigner) {     return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, assigner, null, null, null). }
true;public;1;5;/**  * Sets the {@code Trigger} that should be used to trigger window emission.  */ ;/**  * Sets the {@code Trigger} that should be used to trigger window emission.  */ @PublicEvolving public WithWindow<T1, T2, KEY, W> trigger(Trigger<? super TaggedUnion<T1, T2>, ? super W> newTrigger) {     return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, windowAssigner, newTrigger, evictor, allowedLateness). }
true;public;1;5;/**  * Sets the {@code Evictor} that should be used to evict elements from a window before  * emission.  *  * <p>Note: When using an evictor window performance will degrade significantly, since  * pre-aggregation of window results cannot be used.  */ ;/**  * Sets the {@code Evictor} that should be used to evict elements from a window before  * emission.  *  * <p>Note: When using an evictor window performance will degrade significantly, since  * pre-aggregation of window results cannot be used.  */ @PublicEvolving public WithWindow<T1, T2, KEY, W> evictor(Evictor<? super TaggedUnion<T1, T2>, ? super W> newEvictor) {     return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, windowAssigner, trigger, newEvictor, allowedLateness). }
true;public;1;5;/**  * Sets the time by which elements are allowed to be late.  * @see WindowedStream#allowedLateness(Time)  */ ;/**  * Sets the time by which elements are allowed to be late.  * @see WindowedStream#allowedLateness(Time)  */ @PublicEvolving public WithWindow<T1, T2, KEY, W> allowedLateness(Time newLateness) {     return new WithWindow<>(input1, input2, keySelector1, keySelector2, keyType, windowAssigner, trigger, evictor, newLateness). }
true;public;1;11;/**  * Completes the co-group operation with the user function that is executed  * for windowed groups.  *  * <p>Note: This method's return type does not support setting an operator-specific parallelism.  * Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}  * method to set an operator-specific parallelism.  */ ;/**  * Completes the co-group operation with the user function that is executed  * for windowed groups.  *  * <p>Note: This method's return type does not support setting an operator-specific parallelism.  * Due to binary backwards compatibility, this cannot be altered. Use the {@link #with(CoGroupFunction)}  * method to set an operator-specific parallelism.  */ public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function) {     TypeInformation<T> resultType = TypeExtractor.getCoGroupReturnTypes(function, input1.getType(), input2.getType(), "CoGroup", false).     return apply(function, resultType). }
true;public;1;5;/**  * Completes the co-group operation with the user function that is executed  * for windowed groups.  *  * <p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}  * method has the wrong return type and hence does not allow one to set an operator-specific  * parallelism  *  * @deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed  *             in the next major version of Flink (2.0).  */ ;/**  * Completes the co-group operation with the user function that is executed  * for windowed groups.  *  * <p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction)}  * method has the wrong return type and hence does not allow one to set an operator-specific  * parallelism  *  * @deprecated This method will be removed once the {@link #apply(CoGroupFunction)} method is fixed  *             in the next major version of Flink (2.0).  */ @PublicEvolving @Deprecated public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function) {     return (SingleOutputStreamOperator<T>) apply(function). }
true;public;2;35;/**  * Completes the co-group operation with the user function that is executed  * for windowed groups.  *  * <p>Note: This method's return type does not support setting an operator-specific parallelism.  * Due to binary backwards compatibility, this cannot be altered. Use the  * {@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.  */ ;/**  * Completes the co-group operation with the user function that is executed  * for windowed groups.  *  * <p>Note: This method's return type does not support setting an operator-specific parallelism.  * Due to binary backwards compatibility, this cannot be altered. Use the  * {@link #with(CoGroupFunction, TypeInformation)} method to set an operator-specific parallelism.  */ public <T> DataStream<T> apply(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {     // clean the closure     function = input1.getExecutionEnvironment().clean(function).     UnionTypeInfo<T1, T2> unionType = new UnionTypeInfo<>(input1.getType(), input2.getType()).     UnionKeySelector<T1, T2, KEY> unionKeySelector = new UnionKeySelector<>(keySelector1, keySelector2).     DataStream<TaggedUnion<T1, T2>> taggedInput1 = input1.map(new Input1Tagger<T1, T2>()).setParallelism(input1.getParallelism()).returns(unionType).     DataStream<TaggedUnion<T1, T2>> taggedInput2 = input2.map(new Input2Tagger<T1, T2>()).setParallelism(input2.getParallelism()).returns(unionType).     DataStream<TaggedUnion<T1, T2>> unionStream = taggedInput1.union(taggedInput2).     // we explicitly create the keyed stream to manually pass the key type information in     windowedStream = new KeyedStream<TaggedUnion<T1, T2>, KEY>(unionStream, unionKeySelector, keyType).window(windowAssigner).     if (trigger != null) {         windowedStream.trigger(trigger).     }     if (evictor != null) {         windowedStream.evictor(evictor).     }     if (allowedLateness != null) {         windowedStream.allowedLateness(allowedLateness).     }     return windowedStream.apply(new CoGroupWindowFunction<T1, T2, T, KEY, W>(function), resultType). }
true;public;2;5;/**  * Completes the co-group operation with the user function that is executed  * for windowed groups.  *  * <p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}  * method has the wrong return type and hence does not allow one to set an operator-specific  * parallelism  *  * @deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}  *             method is fixed in the next major version of Flink (2.0).  */ ;/**  * Completes the co-group operation with the user function that is executed  * for windowed groups.  *  * <p><b>Note:</b> This is a temporary workaround while the {@link #apply(CoGroupFunction, TypeInformation)}  * method has the wrong return type and hence does not allow one to set an operator-specific  * parallelism  *  * @deprecated This method will be removed once the {@link #apply(CoGroupFunction, TypeInformation)}  *             method is fixed in the next major version of Flink (2.0).  */ @PublicEvolving @Deprecated public <T> SingleOutputStreamOperator<T> with(CoGroupFunction<T1, T2, T> function, TypeInformation<T> resultType) {     return (SingleOutputStreamOperator<T>) apply(function, resultType). }
false;;0;4;;@VisibleForTesting Time getAllowedLateness() {     return allowedLateness. }
false;;0;4;;@VisibleForTesting WindowedStream<TaggedUnion<T1, T2>, KEY, W> getWindowedStream() {     return windowedStream. }
false;public;0;3;;public boolean isOne() {     return one != null. }
false;public;0;3;;public boolean isTwo() {     return two != null. }
false;public;0;3;;public T1 getOne() {     return one. }
false;public;0;3;;public T2 getTwo() {     return two. }
false;public,static;1;3;;public static <T1, T2> TaggedUnion<T1, T2> one(T1 one) {     return new TaggedUnion<>(one, null). }
false;public,static;1;3;;public static <T1, T2> TaggedUnion<T1, T2> two(T2 two) {     return new TaggedUnion<>(null, two). }
false;public;0;4;;@Override public boolean isBasicType() {     return false. }
false;public;0;4;;@Override public boolean isTupleType() {     return false. }
false;public;0;4;;@Override public int getArity() {     return 2. }
false;public;0;4;;@Override public int getTotalFields() {     return 2. }
false;public;0;5;;@Override @SuppressWarnings("unchecked, rawtypes") public Class<TaggedUnion<T1, T2>> getTypeClass() {     return (Class) TaggedUnion.class. }
false;public;0;4;;@Override public boolean isKeyType() {     return true. }
false;public;1;4;;@Override public TypeSerializer<TaggedUnion<T1, T2>> createSerializer(ExecutionConfig config) {     return new UnionSerializer<>(oneType.createSerializer(config), twoType.createSerializer(config)). }
false;public;0;4;;@Override public String toString() {     return "TaggedUnion<" + oneType + ", " + twoType + ">". }
false;public;1;11;;@Override public boolean equals(Object obj) {     if (obj instanceof UnionTypeInfo) {         @SuppressWarnings("unchecked")         UnionTypeInfo<T1, T2> unionTypeInfo = (UnionTypeInfo<T1, T2>) obj.         return unionTypeInfo.canEqual(this) && oneType.equals(unionTypeInfo.oneType) && twoType.equals(unionTypeInfo.twoType).     } else {         return false.     } }
false;public;0;4;;@Override public int hashCode() {     return 31 * oneType.hashCode() + twoType.hashCode(). }
false;public;1;4;;@Override public boolean canEqual(Object obj) {     return obj instanceof UnionTypeInfo. }
false;public;0;4;;@Override public boolean isImmutableType() {     return false. }
false;public;0;4;;@Override public TypeSerializer<TaggedUnion<T1, T2>> duplicate() {     return this. }
false;public;0;4;;@Override public TaggedUnion<T1, T2> createInstance() {     return null. }
false;public;1;8;;@Override public TaggedUnion<T1, T2> copy(TaggedUnion<T1, T2> from) {     if (from.isOne()) {         return TaggedUnion.one(oneSerializer.copy(from.getOne())).     } else {         return TaggedUnion.two(twoSerializer.copy(from.getTwo())).     } }
false;public;2;7;;@Override public TaggedUnion<T1, T2> copy(TaggedUnion<T1, T2> from, TaggedUnion<T1, T2> reuse) {     if (from.isOne()) {         return TaggedUnion.one(oneSerializer.copy(from.getOne())).     } else {         return TaggedUnion.two(twoSerializer.copy(from.getTwo())).     } }
false;public;0;4;;@Override public int getLength() {     return -1. }
false;public;2;10;;@Override public void serialize(TaggedUnion<T1, T2> record, DataOutputView target) throws IOException {     if (record.isOne()) {         target.writeByte(1).         oneSerializer.serialize(record.getOne(), target).     } else {         target.writeByte(2).         twoSerializer.serialize(record.getTwo(), target).     } }
false;public;1;9;;@Override public TaggedUnion<T1, T2> deserialize(DataInputView source) throws IOException {     byte tag = source.readByte().     if (tag == 1) {         return TaggedUnion.one(oneSerializer.deserialize(source)).     } else {         return TaggedUnion.two(twoSerializer.deserialize(source)).     } }
false;public;2;10;;@Override public TaggedUnion<T1, T2> deserialize(TaggedUnion<T1, T2> reuse, DataInputView source) throws IOException {     byte tag = source.readByte().     if (tag == 1) {         return TaggedUnion.one(oneSerializer.deserialize(source)).     } else {         return TaggedUnion.two(twoSerializer.deserialize(source)).     } }
false;public;2;10;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     byte tag = source.readByte().     target.writeByte(tag).     if (tag == 1) {         oneSerializer.copy(source, target).     } else {         twoSerializer.copy(source, target).     } }
false;public;0;4;;@Override public int hashCode() {     return 31 * oneSerializer.hashCode() + twoSerializer.hashCode(). }
false;public;1;11;;@Override @SuppressWarnings("unchecked") public boolean equals(Object obj) {     if (obj instanceof UnionSerializer) {         UnionSerializer<T1, T2> other = (UnionSerializer<T1, T2>) obj.         return oneSerializer.equals(other.oneSerializer) && twoSerializer.equals(other.twoSerializer).     } else {         return false.     } }
false;public;0;4;;@Override public TypeSerializerSnapshot<TaggedUnion<T1, T2>> snapshotConfiguration() {     return new UnionSerializerSnapshot<>(this). }
false;public;1;11;;@Override public TypeSerializerSchemaCompatibility<TaggedUnion<T1, T2>> resolveSchemaCompatibility(TypeSerializer<TaggedUnion<T1, T2>> newSerializer) {     List<Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> nestedSerializersAndConfigs = getNestedSerializersAndConfigs().     return CompositeTypeSerializerUtil.delegateCompatibilityCheckToNewSnapshot(newSerializer, new UnionSerializerSnapshot<>(), nestedSerializersAndConfigs.get(0).f1, nestedSerializersAndConfigs.get(1).f1). }
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
false;protected;0;4;;@Override protected int getCurrentOuterSnapshotVersion() {     return VERSION. }
false;protected;1;4;;@Override protected TypeSerializer<?>[] getNestedSerializers(UnionSerializer<T1, T2> outerSerializer) {     return new TypeSerializer[] { outerSerializer.oneSerializer, outerSerializer.twoSerializer }. }
false;protected;1;5;;@SuppressWarnings("unchecked") @Override protected UnionSerializer<T1, T2> createOuterSerializerWithNestedSerializers(TypeSerializer<?>[] nestedSerializers) {     return new UnionSerializer<>((TypeSerializer<T1>) nestedSerializers[0], (TypeSerializer<T2>) nestedSerializers[1]). }
false;public;1;4;;@Override public TaggedUnion<T1, T2> map(T1 value) throws Exception {     return TaggedUnion.one(value). }
false;public;1;4;;@Override public TaggedUnion<T1, T2> map(T2 value) throws Exception {     return TaggedUnion.two(value). }
false;public;1;8;;@Override public KEY getKey(TaggedUnion<T1, T2> value) throws Exception {     if (value.isOne()) {         return keySelector1.getKey(value.getOne()).     } else {         return keySelector2.getKey(value.getTwo()).     } }
false;public;4;18;;@Override public void apply(KEY key, W window, Iterable<TaggedUnion<T1, T2>> values, Collector<T> out) throws Exception {     List<T1> oneValues = new ArrayList<>().     List<T2> twoValues = new ArrayList<>().     for (TaggedUnion<T1, T2> val : values) {         if (val.isOne()) {             oneValues.add(val.getOne()).         } else {             twoValues.add(val.getTwo()).         }     }     wrappedFunction.coGroup(oneValues, twoValues, out). }
