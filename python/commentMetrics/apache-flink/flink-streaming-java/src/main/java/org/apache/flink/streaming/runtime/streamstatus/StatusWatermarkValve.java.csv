commented;modifiers;parameterAmount;loc;comment;code
false;;1;1;;void handleWatermark(Watermark watermark).
false;;1;1;;void handleStreamStatus(StreamStatus streamStatus).
true;public;2;19;/**  * Feed a {@link Watermark} into the valve. If the input triggers the valve to output a new Watermark,  * {@link ValveOutputHandler#handleWatermark(Watermark)} will be called to process the new Watermark.  *  * @param watermark the watermark to feed to the valve  * @param channelIndex the index of the channel that the fed watermark belongs to (index starting from 0)  */ ;/**  * Feed a {@link Watermark} into the valve. If the input triggers the valve to output a new Watermark,  * {@link ValveOutputHandler#handleWatermark(Watermark)} will be called to process the new Watermark.  *  * @param watermark the watermark to feed to the valve  * @param channelIndex the index of the channel that the fed watermark belongs to (index starting from 0)  */ public void inputWatermark(Watermark watermark, int channelIndex) {     // ignore the input watermark if its input channel, or all input channels are idle (i.e. overall the valve is idle).     if (lastOutputStreamStatus.isActive() && channelStatuses[channelIndex].streamStatus.isActive()) {         long watermarkMillis = watermark.getTimestamp().         // if the input watermark's value is less than the last received watermark for its input channel, ignore it also.         if (watermarkMillis > channelStatuses[channelIndex].watermark) {             channelStatuses[channelIndex].watermark = watermarkMillis.             // previously unaligned input channels are now aligned if its watermark has caught up             if (!channelStatuses[channelIndex].isWatermarkAligned && watermarkMillis >= lastOutputWatermark) {                 channelStatuses[channelIndex].isWatermarkAligned = true.             }             // now, attempt to find a new min watermark across all aligned channels             findAndOutputNewMinWatermarkAcrossAlignedChannels().         }     } }
true;public;2;48;/**  * Feed a {@link StreamStatus} into the valve. This may trigger the valve to output either a new Stream Status,  * for which {@link ValveOutputHandler#handleStreamStatus(StreamStatus)} will be called, or a new Watermark,  * for which {@link ValveOutputHandler#handleWatermark(Watermark)} will be called.  *  * @param streamStatus the stream status to feed to the valve  * @param channelIndex the index of the channel that the fed stream status belongs to (index starting from 0)  */ ;/**  * Feed a {@link StreamStatus} into the valve. This may trigger the valve to output either a new Stream Status,  * for which {@link ValveOutputHandler#handleStreamStatus(StreamStatus)} will be called, or a new Watermark,  * for which {@link ValveOutputHandler#handleWatermark(Watermark)} will be called.  *  * @param streamStatus the stream status to feed to the valve  * @param channelIndex the index of the channel that the fed stream status belongs to (index starting from 0)  */ public void inputStreamStatus(StreamStatus streamStatus, int channelIndex) {     // only account for stream status inputs that will result in a status change for the input channel     if (streamStatus.isIdle() && channelStatuses[channelIndex].streamStatus.isActive()) {         // handle active -> idle toggle for the input channel         channelStatuses[channelIndex].streamStatus = StreamStatus.IDLE.         // the channel is now idle, therefore not aligned         channelStatuses[channelIndex].isWatermarkAligned = false.         // status from the valve (this also marks the valve as idle)         if (!InputChannelStatus.hasActiveChannels(channelStatuses)) {             // if the watermark of the last active channel that just became idle is the current min watermark.             if (channelStatuses[channelIndex].watermark == lastOutputWatermark) {                 findAndOutputMaxWatermarkAcrossAllChannels().             }             lastOutputStreamStatus = StreamStatus.IDLE.             outputHandler.handleStreamStatus(lastOutputStreamStatus).         } else if (channelStatuses[channelIndex].watermark == lastOutputWatermark) {             // if the watermark of the channel that just became idle equals the last output             // watermark (the previous overall min watermark), we may be able to find a new             // min watermark from the remaining aligned channels             findAndOutputNewMinWatermarkAcrossAlignedChannels().         }     } else if (streamStatus.isActive() && channelStatuses[channelIndex].streamStatus.isIdle()) {         // handle idle -> active toggle for the input channel         channelStatuses[channelIndex].streamStatus = StreamStatus.ACTIVE.         // the overall last output watermark of the valve, then we can set the channel to be aligned already.         if (channelStatuses[channelIndex].watermark >= lastOutputWatermark) {             channelStatuses[channelIndex].isWatermarkAligned = true.         }         // status because at least one of the input channels is now active         if (lastOutputStreamStatus.isIdle()) {             lastOutputStreamStatus = StreamStatus.ACTIVE.             outputHandler.handleStreamStatus(lastOutputStreamStatus).         }     } }
false;private;0;19;;private void findAndOutputNewMinWatermarkAcrossAlignedChannels() {     long newMinWatermark = Long.MAX_VALUE.     boolean hasAlignedChannels = false.     // determine new overall watermark by considering only watermark-aligned channels across all channels     for (InputChannelStatus channelStatus : channelStatuses) {         if (channelStatus.isWatermarkAligned) {             hasAlignedChannels = true.             newMinWatermark = Math.min(channelStatus.watermark, newMinWatermark).         }     }     // from some remaining aligned channel, and is also larger than the last output watermark     if (hasAlignedChannels && newMinWatermark > lastOutputWatermark) {         lastOutputWatermark = newMinWatermark.         outputHandler.handleWatermark(new Watermark(lastOutputWatermark)).     } }
false;private;0;12;;private void findAndOutputMaxWatermarkAcrossAllChannels() {     long maxWatermark = Long.MIN_VALUE.     for (InputChannelStatus channelStatus : channelStatuses) {         maxWatermark = Math.max(channelStatus.watermark, maxWatermark).     }     if (maxWatermark > lastOutputWatermark) {         lastOutputWatermark = maxWatermark.         outputHandler.handleWatermark(new Watermark(lastOutputWatermark)).     } }
true;private,static;1;8;/**  * Utility to check if at least one channel in a given array of input channels is active.  */ ;/**  * Utility to check if at least one channel in a given array of input channels is active.  */ private static boolean hasActiveChannels(InputChannelStatus[] channelStatuses) {     for (InputChannelStatus status : channelStatuses) {         if (status.streamStatus.isActive()) {             return true.         }     }     return false. }
false;protected;1;8;;@VisibleForTesting protected InputChannelStatus getInputChannelStatus(int channelIndex) {     Preconditions.checkArgument(channelIndex >= 0 && channelIndex < channelStatuses.length, "Invalid channel index. Number of input channels: " + channelStatuses.length).     return channelStatuses[channelIndex]. }
