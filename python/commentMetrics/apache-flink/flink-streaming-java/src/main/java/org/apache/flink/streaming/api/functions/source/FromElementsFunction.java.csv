commented;modifiers;parameterAmount;loc;comment;code
false;public;1;25;;@Override public void initializeState(FunctionInitializationContext context) throws Exception {     Preconditions.checkState(this.checkpointedState == null, "The " + getClass().getSimpleName() + " has already been initialized.").     this.checkpointedState = context.getOperatorStateStore().getListState(new ListStateDescriptor<>("from-elements-state", IntSerializer.INSTANCE)).     if (context.isRestored()) {         List<Integer> retrievedStates = new ArrayList<>().         for (Integer entry : this.checkpointedState.get()) {             retrievedStates.add(entry).         }         // given that the parallelism of the function is 1, we can only have 1 state         Preconditions.checkArgument(retrievedStates.size() == 1, getClass().getSimpleName() + " retrieved invalid state.").         this.numElementsToSkip = retrievedStates.get(0).     } }
false;public;1;42;;@Override public void run(SourceContext<T> ctx) throws Exception {     ByteArrayInputStream bais = new ByteArrayInputStream(elementsSerialized).     final DataInputView input = new DataInputViewStreamWrapper(bais).     // if we are restored from a checkpoint and need to skip elements, skip them now.     int toSkip = numElementsToSkip.     if (toSkip > 0) {         try {             while (toSkip > 0) {                 serializer.deserialize(input).                 toSkip--.             }         } catch (Exception e) {             throw new IOException("Failed to deserialize an element from the source. " + "If you are using user-defined serialization (Value and Writable types), check the " + "serialization functions.\nSerializer is " + serializer).         }         this.numElementsEmitted = this.numElementsToSkip.     }     final Object lock = ctx.getCheckpointLock().     while (isRunning && numElementsEmitted < numElements) {         T next.         try {             next = serializer.deserialize(input).         } catch (Exception e) {             throw new IOException("Failed to deserialize an element from the source. " + "If you are using user-defined serialization (Value and Writable types), check the " + "serialization functions.\nSerializer is " + serializer).         }         synchronized (lock) {             ctx.collect(next).             numElementsEmitted++.         }     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
true;public;0;3;/**  * Gets the number of elements produced in total by this function.  *  * @return The number of elements produced in total.  */ ;/**  * Gets the number of elements produced in total by this function.  *  * @return The number of elements produced in total.  */ public int getNumElements() {     return numElements. }
true;public;0;3;/**  * Gets the number of elements emitted so far.  *  * @return The number of elements emitted so far.  */ ;/**  * Gets the number of elements emitted so far.  *  * @return The number of elements emitted so far.  */ public int getNumElementsEmitted() {     return numElementsEmitted. }
false;public;1;8;;// ------------------------------------------------------------------------ // Checkpointing // ------------------------------------------------------------------------ @Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     Preconditions.checkState(this.checkpointedState != null, "The " + getClass().getSimpleName() + " has not been properly initialized.").     this.checkpointedState.clear().     this.checkpointedState.add(this.numElementsEmitted). }
true;public,static;2;12;/**  * Verifies that all elements in the collection are non-null, and are of the given class, or  * a subclass thereof.  *  * @param elements The collection to check.  * @param viewedAs The class to which the elements must be assignable to.  *  * @param <OUT> The generic type of the collection to be checked.  */ ;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ /**  * Verifies that all elements in the collection are non-null, and are of the given class, or  * a subclass thereof.  *  * @param elements The collection to check.  * @param viewedAs The class to which the elements must be assignable to.  *  * @param <OUT> The generic type of the collection to be checked.  */ public static <OUT> void checkCollection(Collection<OUT> elements, Class<OUT> viewedAs) {     for (OUT elem : elements) {         if (elem == null) {             throw new IllegalArgumentException("The collection contains a null element").         }         if (!viewedAs.isAssignableFrom(elem.getClass())) {             throw new IllegalArgumentException("The elements in the collection are not all subclasses of " + viewedAs.getCanonicalName()).         }     } }
