commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;0;1;/**  * Returns the current processing time.  */ ;/**  * Returns the current processing time.  */ public abstract long getCurrentProcessingTime().
true;public,abstract;2;1;/**  * Registers a task to be executed when (processing) time is {@code timestamp}.  *  * @param timestamp   Time when the task is to be executed (in processing time)  * @param target      The task to be executed  *  * @return The future that represents the scheduled task. This always returns some future,  *         even if the timer was shut down  */ ;/**  * Registers a task to be executed when (processing) time is {@code timestamp}.  *  * @param timestamp   Time when the task is to be executed (in processing time)  * @param target      The task to be executed  *  * @return The future that represents the scheduled task. This always returns some future,  *         even if the timer was shut down  */ public abstract ScheduledFuture<?> registerTimer(long timestamp, ProcessingTimeCallback target).
true;public,abstract;3;1;/**  * Registers a task to be executed repeatedly at a fixed rate.  *  * @param callback to be executed after the initial delay and then after each period  * @param initialDelay initial delay to start executing callback  * @param period after the initial delay after which the callback is executed  * @return Scheduled future representing the task to be executed repeatedly  */ ;/**  * Registers a task to be executed repeatedly at a fixed rate.  *  * @param callback to be executed after the initial delay and then after each period  * @param initialDelay initial delay to start executing callback  * @param period after the initial delay after which the callback is executed  * @return Scheduled future representing the task to be executed repeatedly  */ public abstract ScheduledFuture<?> scheduleAtFixedRate(ProcessingTimeCallback callback, long initialDelay, long period).
true;public,abstract;0;1;/**  * Returns <tt>true</tt> if the service has been shut down, <tt>false</tt> otherwise.  */ ;/**  * Returns <tt>true</tt> if the service has been shut down, <tt>false</tt> otherwise.  */ public abstract boolean isTerminated().
true;public,abstract;0;1;/**  * This method puts the service into a state where it does not register new timers, but  * returns for each call to {@link #registerTimer(long, ProcessingTimeCallback)} only a "mock" future.  * Furthermore, the method clears all not yet started timers.  *  * <p>This method can be used to cleanly shut down the timer service. The using components  * will not notice that the service is shut down (as for example via exceptions when registering  * a new timer), but the service will simply not fire any timer any more.  */ ;/**  * This method puts the service into a state where it does not register new timers, but  * returns for each call to {@link #registerTimer(long, ProcessingTimeCallback)} only a "mock" future.  * Furthermore, the method clears all not yet started timers.  *  * <p>This method can be used to cleanly shut down the timer service. The using components  * will not notice that the service is shut down (as for example via exceptions when registering  * a new timer), but the service will simply not fire any timer any more.  */ public abstract void quiesce() throws InterruptedException.
true;public,abstract;0;1;/**  * This method can be used after calling {@link #quiesce()}, and awaits the completion  * of currently executing timers.  */ ;/**  * This method can be used after calling {@link #quiesce()}, and awaits the completion  * of currently executing timers.  */ public abstract void awaitPendingAfterQuiesce() throws InterruptedException.
true;public,abstract;0;1;/**  * Shuts down and clean up the timer service provider hard and immediately. This does not wait  * for any timer to complete. Any further call to {@link #registerTimer(long, ProcessingTimeCallback)}  * will result in a hard exception.  */ ;/**  * Shuts down and clean up the timer service provider hard and immediately. This does not wait  * for any timer to complete. Any further call to {@link #registerTimer(long, ProcessingTimeCallback)}  * will result in a hard exception.  */ public abstract void shutdownService().
true;public,abstract;1;1;/**  * Shuts down and clean up the timer service provider hard and immediately. This does not wait  * for any timer to complete. Any further call to {@link #registerTimer(long, ProcessingTimeCallback)}  * will result in a hard exception. This call cannot be interrupted and will block until the shutdown is completed  * or the timeout is exceeded.  *  * @param timeoutMs timeout for blocking on the service shutdown in milliseconds.  * @return returns true iff the shutdown was completed.  */ ;/**  * Shuts down and clean up the timer service provider hard and immediately. This does not wait  * for any timer to complete. Any further call to {@link #registerTimer(long, ProcessingTimeCallback)}  * will result in a hard exception. This call cannot be interrupted and will block until the shutdown is completed  * or the timeout is exceeded.  *  * @param timeoutMs timeout for blocking on the service shutdown in milliseconds.  * @return returns true iff the shutdown was completed.  */ public abstract boolean shutdownServiceUninterruptible(long timeoutMs).
true;public,abstract;2;1;/**  * Shuts down and clean up the timer service provider hard and immediately. This does wait  * for all timers to complete or until the time limit is exceeded. Any call to  * {@link #registerTimer(long, ProcessingTimeCallback)} will result in a hard exception after calling this method.  * @param time time to wait for termination.  * @param timeUnit time unit of parameter time.  * @return {@code true} if this timer service and all pending timers are terminated and  *         {@code false} if the timeout elapsed before this happened.  */ ;/**  * Shuts down and clean up the timer service provider hard and immediately. This does wait  * for all timers to complete or until the time limit is exceeded. Any call to  * {@link #registerTimer(long, ProcessingTimeCallback)} will result in a hard exception after calling this method.  * @param time time to wait for termination.  * @param timeUnit time unit of parameter time.  * @return {@code true} if this timer service and all pending timers are terminated and  *         {@code false} if the timeout elapsed before this happened.  */ public abstract boolean shutdownAndAwaitPending(long time, TimeUnit timeUnit) throws InterruptedException.
