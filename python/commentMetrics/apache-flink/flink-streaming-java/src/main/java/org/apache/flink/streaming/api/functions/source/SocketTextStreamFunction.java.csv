commented;modifiers;parameterAmount;loc;comment;code
false;public;1;52;;@Override public void run(SourceContext<String> ctx) throws Exception {     final StringBuilder buffer = new StringBuilder().     long attempt = 0.     while (isRunning) {         try (Socket socket = new Socket()) {             currentSocket = socket.             LOG.info("Connecting to server socket " + hostname + ':' + port).             socket.connect(new InetSocketAddress(hostname, port), CONNECTION_TIMEOUT_TIME).             try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {                 char[] cbuf = new char[8192].                 int bytesRead.                 while (isRunning && (bytesRead = reader.read(cbuf)) != -1) {                     buffer.append(cbuf, 0, bytesRead).                     int delimPos.                     while (buffer.length() >= delimiter.length() && (delimPos = buffer.indexOf(delimiter)) != -1) {                         String record = buffer.substring(0, delimPos).                         // truncate trailing carriage return                         if (delimiter.equals("\n") && record.endsWith("\r")) {                             record = record.substring(0, record.length() - 1).                         }                         ctx.collect(record).                         buffer.delete(0, delimPos + delimiter.length()).                     }                 }             }         }         // if we dropped out of this loop due to an EOF, sleep and retry         if (isRunning) {             attempt++.             if (maxNumRetries == -1 || attempt < maxNumRetries) {                 LOG.warn("Lost connection to server socket. Retrying in " + delayBetweenRetries + " msecs...").                 Thread.sleep(delayBetweenRetries).             } else {                 // throw new EOFException("Reached end of stream and reconnects are not enabled.").                 break.             }         }     }     // collect trailing data     if (buffer.length() > 0) {         ctx.collect(buffer.toString()).     } }
false;public;0;11;;@Override public void cancel() {     isRunning = false.     // we need to close the socket as well, because the Thread.interrupt() function will     // not wake the thread in the socketStream.read() method when blocked.     Socket theSocket = this.currentSocket.     if (theSocket != null) {         IOUtils.closeSocket(theSocket).     } }
