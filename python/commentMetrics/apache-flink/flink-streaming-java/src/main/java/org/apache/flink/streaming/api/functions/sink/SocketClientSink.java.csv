commented;modifiers;parameterAmount;loc;comment;code
true;public;1;11;/**  * Initialize the connection with the Socket in the server.  * @param parameters Configuration.  */ ;// ------------------------------------------------------------------------ // Life cycle // ------------------------------------------------------------------------ /**  * Initialize the connection with the Socket in the server.  * @param parameters Configuration.  */ @Override public void open(Configuration parameters) throws Exception {     try {         synchronized (lock) {             createConnection().         }     } catch (IOException e) {         throw new IOException("Cannot connect to socket server at " + hostName + ":" + port, e).     } }
true;public;1;77;/**  * Called when new data arrives to the sink, and forwards it to Socket.  *  * @param value The value to write to the socket.  */ ;/**  * Called when new data arrives to the sink, and forwards it to Socket.  *  * @param value The value to write to the socket.  */ @Override public void invoke(IN value) throws Exception {     byte[] msg = schema.serialize(value).     try {         outputStream.write(msg).         if (autoFlush) {             outputStream.flush().         }     } catch (IOException e) {         // if no re-tries are enable, fail immediately         if (maxNumRetries == 0) {             throw new IOException("Failed to send message '" + value + "' to socket server at " + hostName + ":" + port + ". Connection re-tries are not enabled.", e).         }         LOG.error("Failed to send message '" + value + "' to socket server at " + hostName + ":" + port + ". Trying to reconnect...", e).         synchronized (lock) {             IOException lastException = null.             retries = 0.             while (isRunning && (maxNumRetries < 0 || retries < maxNumRetries)) {                 // first, clean up the old resources                 try {                     if (outputStream != null) {                         outputStream.close().                     }                 } catch (IOException ee) {                     LOG.error("Could not close output stream from failed write attempt", ee).                 }                 try {                     if (client != null) {                         client.close().                     }                 } catch (IOException ee) {                     LOG.error("Could not close socket from failed write attempt", ee).                 }                 // try again                 retries++.                 try {                     // initialize a new connection                     createConnection().                     // re-try the write                     outputStream.write(msg).                     // success!                     return.                 } catch (IOException ee) {                     lastException = ee.                     LOG.error("Re-connect to socket server and send message failed. Retry time(s): " + retries, ee).                 }                 // wait before re-attempting to connect                 lock.wait(CONNECTION_RETRY_DELAY).             }             // throw an exception if the task is still running, otherwise simply leave the method             if (isRunning) {                 throw new IOException("Failed to send message '" + value + "' to socket server at " + hostName + ":" + port + ". Failed after " + retries + " retries.", lastException).             }         }     } }
true;public;0;23;/**  * Closes the connection with the Socket server.  */ ;/**  * Closes the connection with the Socket server.  */ @Override public void close() throws Exception {     // flag this as not running any more     isRunning = false.     // clean up in locked scope, so there is no concurrent change to the stream and client     synchronized (lock) {         // we notify first (this statement cannot fail). The notified thread will not continue         // anyways before it can re-acquire the lock         lock.notifyAll().         try {             if (outputStream != null) {                 outputStream.close().             }         } finally {             if (client != null) {                 client.close().             }         }     } }
false;private;0;7;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ private void createConnection() throws IOException {     client = new Socket(hostName, port).     client.setKeepAlive(true).     client.setTcpNoDelay(true).     outputStream = client.getOutputStream(). }
false;;0;5;;// ------------------------------------------------------------------------ // For testing // ------------------------------------------------------------------------ int getCurrentNumberOfRetries() {     synchronized (lock) {         return retries.     } }
