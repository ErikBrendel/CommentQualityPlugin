commented;modifiers;parameterAmount;loc;comment;code
false;public;2;13;;@Override public int compare(Integer idOne, Integer idTwo) {     boolean isIdOneSinkId = streamGraph.getSinkIDs().contains(idOne).     boolean isIdTwoSinkId = streamGraph.getSinkIDs().contains(idTwo).     // put sinks at the back     if (isIdOneSinkId == isIdTwoSinkId) {         return idOne.compareTo(idTwo).     } else if (isIdOneSinkId) {         return 1.     } else {         return -1.     } }
false;public;0;23;;public String getJSON() {     ObjectNode json = mapper.createObjectNode().     ArrayNode nodes = mapper.createArrayNode().     json.put("nodes", nodes).     List<Integer> operatorIDs = new ArrayList<Integer>(streamGraph.getVertexIDs()).     Collections.sort(operatorIDs, new Comparator<Integer>() {          @Override         public int compare(Integer idOne, Integer idTwo) {             boolean isIdOneSinkId = streamGraph.getSinkIDs().contains(idOne).             boolean isIdTwoSinkId = streamGraph.getSinkIDs().contains(idTwo).             // put sinks at the back             if (isIdOneSinkId == isIdTwoSinkId) {                 return idOne.compareTo(idTwo).             } else if (isIdOneSinkId) {                 return 1.             } else {                 return -1.             }         }     }).     visit(nodes, operatorIDs, new HashMap<Integer, Integer>()).     return json.toString(). }
false;private;3;54;;private void visit(ArrayNode jsonArray, List<Integer> toVisit, Map<Integer, Integer> edgeRemapings) {     Integer vertexID = toVisit.get(0).     StreamNode vertex = streamGraph.getStreamNode(vertexID).     if (streamGraph.getSourceIDs().contains(vertexID) || Collections.disjoint(vertex.getInEdges(), toVisit)) {         ObjectNode node = mapper.createObjectNode().         decorateNode(vertexID, node).         if (!streamGraph.getSourceIDs().contains(vertexID)) {             ArrayNode inputs = mapper.createArrayNode().             node.put(PREDECESSORS, inputs).             for (StreamEdge inEdge : vertex.getInEdges()) {                 int inputID = inEdge.getSourceId().                 Integer mappedID = (edgeRemapings.keySet().contains(inputID)) ? edgeRemapings.get(inputID) : inputID.                 decorateEdge(inputs, inEdge, mappedID).             }         }         jsonArray.add(node).         toVisit.remove(vertexID).     } else {         Integer iterationHead = -1.         for (StreamEdge inEdge : vertex.getInEdges()) {             int operator = inEdge.getSourceId().             if (streamGraph.vertexIDtoLoopTimeout.containsKey(operator)) {                 iterationHead = operator.             }         }         ObjectNode obj = mapper.createObjectNode().         ArrayNode iterationSteps = mapper.createArrayNode().         obj.put(STEPS, iterationSteps).         obj.put(ID, iterationHead).         obj.put(PACT, "IterativeDataStream").         obj.put(PARALLELISM, streamGraph.getStreamNode(iterationHead).getParallelism()).         obj.put(CONTENTS, "Stream Iteration").         ArrayNode iterationInputs = mapper.createArrayNode().         obj.put(PREDECESSORS, iterationInputs).         toVisit.remove(iterationHead).         visitIteration(iterationSteps, toVisit, iterationHead, edgeRemapings, iterationInputs).         jsonArray.add(obj).     }     if (!toVisit.isEmpty()) {         visit(jsonArray, toVisit, edgeRemapings).     } }
false;private;5;30;;private void visitIteration(ArrayNode jsonArray, List<Integer> toVisit, int headId, Map<Integer, Integer> edgeRemapings, ArrayNode iterationInEdges) {     Integer vertexID = toVisit.get(0).     StreamNode vertex = streamGraph.getStreamNode(vertexID).     toVisit.remove(vertexID).     // Ignoring head and tail to avoid redundancy     if (!streamGraph.vertexIDtoLoopTimeout.containsKey(vertexID)) {         ObjectNode obj = mapper.createObjectNode().         jsonArray.add(obj).         decorateNode(vertexID, obj).         ArrayNode inEdges = mapper.createArrayNode().         obj.put(PREDECESSORS, inEdges).         for (StreamEdge inEdge : vertex.getInEdges()) {             int inputID = inEdge.getSourceId().             if (edgeRemapings.keySet().contains(inputID)) {                 decorateEdge(inEdges, inEdge, inputID).             } else if (!streamGraph.vertexIDtoLoopTimeout.containsKey(inputID)) {                 decorateEdge(iterationInEdges, inEdge, inputID).             }         }         edgeRemapings.put(vertexID, headId).         visitIteration(jsonArray, toVisit, headId, edgeRemapings, iterationInEdges).     } }
false;private;3;7;;private void decorateEdge(ArrayNode inputArray, StreamEdge inEdge, int mappedInputID) {     ObjectNode input = mapper.createObjectNode().     inputArray.add(input).     input.put(ID, mappedInputID).     input.put(SHIP_STRATEGY, inEdge.getPartitioner().toString()).     input.put(SIDE, (inputArray.size() == 0) ? "first" : "second"). }
false;private;2;21;;private void decorateNode(Integer vertexID, ObjectNode node) {     StreamNode vertex = streamGraph.getStreamNode(vertexID).     node.put(ID, vertexID).     node.put(TYPE, vertex.getOperatorName()).     if (streamGraph.getSourceIDs().contains(vertexID)) {         node.put(PACT, "Data Source").     } else if (streamGraph.getSinkIDs().contains(vertexID)) {         node.put(PACT, "Data Sink").     } else {         node.put(PACT, "Operator").     }     StreamOperator<?> operator = streamGraph.getStreamNode(vertexID).getOperator().     node.put(CONTENTS, vertex.getOperatorName()).     node.put(PARALLELISM, streamGraph.getStreamNode(vertexID).getParallelism()). }
