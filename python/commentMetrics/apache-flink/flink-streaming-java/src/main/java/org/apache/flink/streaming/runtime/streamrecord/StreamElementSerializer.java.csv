commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public TypeSerializer<T> getContainedTypeSerializer() {     return this.typeSerializer. }
false;public;0;4;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ @Override public boolean isImmutableType() {     return false. }
false;public;0;5;;@Override public StreamElementSerializer<T> duplicate() {     TypeSerializer<T> copy = typeSerializer.duplicate().     return (copy == typeSerializer) ? this : new StreamElementSerializer<T>(copy). }
false;public;0;4;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ @Override public StreamRecord<T> createInstance() {     return new StreamRecord<T>(typeSerializer.createInstance()). }
false;public;0;4;;@Override public int getLength() {     return -1. }
false;public;1;15;;@Override public StreamElement copy(StreamElement from) {     // we can reuse the timestamp since Instant is immutable     if (from.isRecord()) {         StreamRecord<T> fromRecord = from.asRecord().         return fromRecord.copy(typeSerializer.copy(fromRecord.getValue())).     } else if (from.isWatermark() || from.isStreamStatus() || from.isLatencyMarker()) {         // is immutable         return from.     } else {         throw new RuntimeException().     } }
false;public;2;18;;@Override public StreamElement copy(StreamElement from, StreamElement reuse) {     if (from.isRecord() && reuse.isRecord()) {         StreamRecord<T> fromRecord = from.asRecord().         StreamRecord<T> reuseRecord = reuse.asRecord().         T valueCopy = typeSerializer.copy(fromRecord.getValue(), reuseRecord.getValue()).         fromRecord.copyTo(valueCopy, reuseRecord).         return reuse.     } else if (from.isWatermark() || from.isStreamStatus() || from.isLatencyMarker()) {         // is immutable         return from.     } else {         throw new RuntimeException("Cannot copy " + from + " -> " + reuse).     } }
false;public;2;28;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     int tag = source.readByte().     target.write(tag).     if (tag == TAG_REC_WITH_TIMESTAMP) {         // move timestamp         target.writeLong(source.readLong()).         typeSerializer.copy(source, target).     } else if (tag == TAG_REC_WITHOUT_TIMESTAMP) {         typeSerializer.copy(source, target).     } else if (tag == TAG_WATERMARK) {         target.writeLong(source.readLong()).     } else if (tag == TAG_STREAM_STATUS) {         target.writeInt(source.readInt()).     } else if (tag == TAG_LATENCY_MARKER) {         target.writeLong(source.readLong()).         target.writeLong(source.readLong()).         target.writeLong(source.readLong()).         target.writeInt(source.readInt()).     } else {         throw new IOException("Corrupt stream, found tag: " + tag).     } }
false;public;2;32;;@Override public void serialize(StreamElement value, DataOutputView target) throws IOException {     if (value.isRecord()) {         StreamRecord<T> record = value.asRecord().         if (record.hasTimestamp()) {             target.write(TAG_REC_WITH_TIMESTAMP).             target.writeLong(record.getTimestamp()).         } else {             target.write(TAG_REC_WITHOUT_TIMESTAMP).         }         typeSerializer.serialize(record.getValue(), target).     } else if (value.isWatermark()) {         target.write(TAG_WATERMARK).         target.writeLong(value.asWatermark().getTimestamp()).     } else if (value.isStreamStatus()) {         target.write(TAG_STREAM_STATUS).         target.writeInt(value.asStreamStatus().getStatus()).     } else if (value.isLatencyMarker()) {         target.write(TAG_LATENCY_MARKER).         target.writeLong(value.asLatencyMarker().getMarkedTime()).         target.writeLong(value.asLatencyMarker().getOperatorId().getLowerPart()).         target.writeLong(value.asLatencyMarker().getOperatorId().getUpperPart()).         target.writeInt(value.asLatencyMarker().getSubtaskIndex()).     } else {         throw new RuntimeException().     } }
false;public;1;23;;@Override public StreamElement deserialize(DataInputView source) throws IOException {     int tag = source.readByte().     if (tag == TAG_REC_WITH_TIMESTAMP) {         long timestamp = source.readLong().         return new StreamRecord<T>(typeSerializer.deserialize(source), timestamp).     } else if (tag == TAG_REC_WITHOUT_TIMESTAMP) {         return new StreamRecord<T>(typeSerializer.deserialize(source)).     } else if (tag == TAG_WATERMARK) {         return new Watermark(source.readLong()).     } else if (tag == TAG_STREAM_STATUS) {         return new StreamStatus(source.readInt()).     } else if (tag == TAG_LATENCY_MARKER) {         return new LatencyMarker(source.readLong(), new OperatorID(source.readLong(), source.readLong()), source.readInt()).     } else {         throw new IOException("Corrupt stream, found tag: " + tag).     } }
false;public;2;26;;@Override public StreamElement deserialize(StreamElement reuse, DataInputView source) throws IOException {     int tag = source.readByte().     if (tag == TAG_REC_WITH_TIMESTAMP) {         long timestamp = source.readLong().         T value = typeSerializer.deserialize(source).         StreamRecord<T> reuseRecord = reuse.asRecord().         reuseRecord.replace(value, timestamp).         return reuseRecord.     } else if (tag == TAG_REC_WITHOUT_TIMESTAMP) {         T value = typeSerializer.deserialize(source).         StreamRecord<T> reuseRecord = reuse.asRecord().         reuseRecord.replace(value).         return reuseRecord.     } else if (tag == TAG_WATERMARK) {         return new Watermark(source.readLong()).     } else if (tag == TAG_LATENCY_MARKER) {         return new LatencyMarker(source.readLong(), new OperatorID(source.readLong(), source.readLong()), source.readInt()).     } else {         throw new IOException("Corrupt stream, found tag: " + tag).     } }
false;public;1;10;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ @Override public boolean equals(Object obj) {     if (obj instanceof StreamElementSerializer) {         StreamElementSerializer<?> other = (StreamElementSerializer<?>) obj.         return typeSerializer.equals(other.typeSerializer).     } else {         return false.     } }
false;public;0;4;;@Override public int hashCode() {     return typeSerializer.hashCode(). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // Serializer configuration snapshotting & compatibility //  // This serializer may be used by Flink internal operators that need to checkpoint // buffered records. Therefore, it may be part of managed state and need to implement // the configuration snapshot and compatibility methods. // -------------------------------------------------------------------------------------------- @Override public StreamElementSerializerSnapshot<T> snapshotConfiguration() {     return new StreamElementSerializerSnapshot<>(this). }
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
false;public;1;7;;@Override public TypeSerializerSchemaCompatibility<StreamElement> resolveSchemaCompatibility(TypeSerializer<StreamElement> newSerializer) {     return CompositeTypeSerializerUtil.delegateCompatibilityCheckToNewSnapshot(newSerializer, new StreamElementSerializerSnapshot<>(), getSingleNestedSerializerAndConfig().f1). }
false;protected;0;4;;@Override protected int getCurrentOuterSnapshotVersion() {     return VERSION. }
false;protected;1;4;;@Override protected TypeSerializer<?>[] getNestedSerializers(StreamElementSerializer<T> outerSerializer) {     return new TypeSerializer[] { outerSerializer.getContainedTypeSerializer() }. }
false;protected;1;7;;@Override protected StreamElementSerializer<T> createOuterSerializerWithNestedSerializers(TypeSerializer<?>[] nestedSerializers) {     @SuppressWarnings("unchecked")     TypeSerializer<T> casted = (TypeSerializer<T>) nestedSerializers[0].     return new StreamElementSerializer<>(casted). }
