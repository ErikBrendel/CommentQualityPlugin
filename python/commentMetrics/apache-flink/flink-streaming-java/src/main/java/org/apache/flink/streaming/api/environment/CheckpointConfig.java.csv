commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Checks whether checkpointing is enabled.  *  * @return True if checkpointing is enables, false otherwise.  */ ;// ------------------------------------------------------------------------ /**  * Checks whether checkpointing is enabled.  *  * @return True if checkpointing is enables, false otherwise.  */ public boolean isCheckpointingEnabled() {     return checkpointInterval > 0. }
true;public;0;3;/**  * Gets the checkpointing mode (exactly-once vs. at-least-once).  *  * @return The checkpointing mode.  */ ;/**  * Gets the checkpointing mode (exactly-once vs. at-least-once).  *  * @return The checkpointing mode.  */ public CheckpointingMode getCheckpointingMode() {     return checkpointingMode. }
true;public;1;3;/**  * Sets the checkpointing mode (exactly-once vs. at-least-once).  *  * @param checkpointingMode The checkpointing mode.  */ ;/**  * Sets the checkpointing mode (exactly-once vs. at-least-once).  *  * @param checkpointingMode The checkpointing mode.  */ public void setCheckpointingMode(CheckpointingMode checkpointingMode) {     this.checkpointingMode = requireNonNull(checkpointingMode). }
true;public;0;3;/**  * Gets the interval in which checkpoints are periodically scheduled.  *  * <p>This setting defines the base interval. Checkpoint triggering may be delayed by the settings  * {@link #getMaxConcurrentCheckpoints()} and {@link #getMinPauseBetweenCheckpoints()}.  *  * @return The checkpoint interval, in milliseconds.  */ ;/**  * Gets the interval in which checkpoints are periodically scheduled.  *  * <p>This setting defines the base interval. Checkpoint triggering may be delayed by the settings  * {@link #getMaxConcurrentCheckpoints()} and {@link #getMinPauseBetweenCheckpoints()}.  *  * @return The checkpoint interval, in milliseconds.  */ public long getCheckpointInterval() {     return checkpointInterval. }
true;public;1;6;/**  * Sets the interval in which checkpoints are periodically scheduled.  *  * <p>This setting defines the base interval. Checkpoint triggering may be delayed by the settings  * {@link #setMaxConcurrentCheckpoints(int)} and {@link #setMinPauseBetweenCheckpoints(long)}.  *  * @param checkpointInterval The checkpoint interval, in milliseconds.  */ ;/**  * Sets the interval in which checkpoints are periodically scheduled.  *  * <p>This setting defines the base interval. Checkpoint triggering may be delayed by the settings  * {@link #setMaxConcurrentCheckpoints(int)} and {@link #setMinPauseBetweenCheckpoints(long)}.  *  * @param checkpointInterval The checkpoint interval, in milliseconds.  */ public void setCheckpointInterval(long checkpointInterval) {     if (checkpointInterval <= 0) {         throw new IllegalArgumentException("Checkpoint interval must be larger than zero").     }     this.checkpointInterval = checkpointInterval. }
true;public;0;3;/**  * Gets the maximum time that a checkpoint may take before being discarded.  *  * @return The checkpoint timeout, in milliseconds.  */ ;/**  * Gets the maximum time that a checkpoint may take before being discarded.  *  * @return The checkpoint timeout, in milliseconds.  */ public long getCheckpointTimeout() {     return checkpointTimeout. }
true;public;1;6;/**  * Sets the maximum time that a checkpoint may take before being discarded.  *  * @param checkpointTimeout The checkpoint timeout, in milliseconds.  */ ;/**  * Sets the maximum time that a checkpoint may take before being discarded.  *  * @param checkpointTimeout The checkpoint timeout, in milliseconds.  */ public void setCheckpointTimeout(long checkpointTimeout) {     if (checkpointTimeout <= 0) {         throw new IllegalArgumentException("Checkpoint timeout must be larger than zero").     }     this.checkpointTimeout = checkpointTimeout. }
true;public;0;3;/**  * Gets the minimal pause between checkpointing attempts. This setting defines how soon the  * checkpoint coordinator may trigger another checkpoint after it becomes possible to trigger  * another checkpoint with respect to the maximum number of concurrent checkpoints  * (see {@link #getMaxConcurrentCheckpoints()}).  *  * @return The minimal pause before the next checkpoint is triggered.  */ ;/**  * Gets the minimal pause between checkpointing attempts. This setting defines how soon the  * checkpoint coordinator may trigger another checkpoint after it becomes possible to trigger  * another checkpoint with respect to the maximum number of concurrent checkpoints  * (see {@link #getMaxConcurrentCheckpoints()}).  *  * @return The minimal pause before the next checkpoint is triggered.  */ public long getMinPauseBetweenCheckpoints() {     return minPauseBetweenCheckpoints. }
true;public;1;6;/**  * Sets the minimal pause between checkpointing attempts. This setting defines how soon the  * checkpoint coordinator may trigger another checkpoint after it becomes possible to trigger  * another checkpoint with respect to the maximum number of concurrent checkpoints  * (see {@link #setMaxConcurrentCheckpoints(int)}).  *  * <p>If the maximum number of concurrent checkpoints is set to one, this setting makes effectively sure  * that a minimum amount of time passes where no checkpoint is in progress at all.  *  * @param minPauseBetweenCheckpoints The minimal pause before the next checkpoint is triggered.  */ ;/**  * Sets the minimal pause between checkpointing attempts. This setting defines how soon the  * checkpoint coordinator may trigger another checkpoint after it becomes possible to trigger  * another checkpoint with respect to the maximum number of concurrent checkpoints  * (see {@link #setMaxConcurrentCheckpoints(int)}).  *  * <p>If the maximum number of concurrent checkpoints is set to one, this setting makes effectively sure  * that a minimum amount of time passes where no checkpoint is in progress at all.  *  * @param minPauseBetweenCheckpoints The minimal pause before the next checkpoint is triggered.  */ public void setMinPauseBetweenCheckpoints(long minPauseBetweenCheckpoints) {     if (minPauseBetweenCheckpoints < 0) {         throw new IllegalArgumentException("Pause value must be zero or positive").     }     this.minPauseBetweenCheckpoints = minPauseBetweenCheckpoints. }
true;public;0;3;/**  * Gets the maximum number of checkpoint attempts that may be in progress at the same time. If this  * value is <i>n</i>, then no checkpoints will be triggered while <i>n</i> checkpoint attempts are  * currently in flight. For the next checkpoint to be triggered, one checkpoint attempt would need  * to finish or expire.  *  * @return The maximum number of concurrent checkpoint attempts.  */ ;/**  * Gets the maximum number of checkpoint attempts that may be in progress at the same time. If this  * value is <i>n</i>, then no checkpoints will be triggered while <i>n</i> checkpoint attempts are  * currently in flight. For the next checkpoint to be triggered, one checkpoint attempt would need  * to finish or expire.  *  * @return The maximum number of concurrent checkpoint attempts.  */ public int getMaxConcurrentCheckpoints() {     return maxConcurrentCheckpoints. }
true;public;1;6;/**  * Sets the maximum number of checkpoint attempts that may be in progress at the same time. If this  * value is <i>n</i>, then no checkpoints will be triggered while <i>n</i> checkpoint attempts are  * currently in flight. For the next checkpoint to be triggered, one checkpoint attempt would need  * to finish or expire.  *  * @param maxConcurrentCheckpoints The maximum number of concurrent checkpoint attempts.  */ ;/**  * Sets the maximum number of checkpoint attempts that may be in progress at the same time. If this  * value is <i>n</i>, then no checkpoints will be triggered while <i>n</i> checkpoint attempts are  * currently in flight. For the next checkpoint to be triggered, one checkpoint attempt would need  * to finish or expire.  *  * @param maxConcurrentCheckpoints The maximum number of concurrent checkpoint attempts.  */ public void setMaxConcurrentCheckpoints(int maxConcurrentCheckpoints) {     if (maxConcurrentCheckpoints < 1) {         throw new IllegalArgumentException("The maximum number of concurrent attempts must be at least one.").     }     this.maxConcurrentCheckpoints = maxConcurrentCheckpoints. }
true;public;0;5;/**  * Checks whether checkpointing is forced, despite currently non-checkpointable iteration feedback.  *  * @return True, if checkpointing is forced, false otherwise.  *  * @deprecated This will be removed once iterations properly participate in checkpointing.  */ ;/**  * Checks whether checkpointing is forced, despite currently non-checkpointable iteration feedback.  *  * @return True, if checkpointing is forced, false otherwise.  *  * @deprecated This will be removed once iterations properly participate in checkpointing.  */ @Deprecated @PublicEvolving public boolean isForceCheckpointing() {     return forceCheckpointing. }
true;public;1;5;/**  * Checks whether checkpointing is forced, despite currently non-checkpointable iteration feedback.  *  * @param forceCheckpointing The flag to force checkpointing.  *  * @deprecated This will be removed once iterations properly participate in checkpointing.  */ ;/**  * Checks whether checkpointing is forced, despite currently non-checkpointable iteration feedback.  *  * @param forceCheckpointing The flag to force checkpointing.  *  * @deprecated This will be removed once iterations properly participate in checkpointing.  */ @Deprecated @PublicEvolving public void setForceCheckpointing(boolean forceCheckpointing) {     this.forceCheckpointing = forceCheckpointing. }
true;public;0;3;/**  * This determines the behaviour of tasks if there is an error in their local checkpointing. If this returns true,  * tasks will fail as a reaction. If this returns false, task will only decline the failed checkpoint.  */ ;/**  * This determines the behaviour of tasks if there is an error in their local checkpointing. If this returns true,  * tasks will fail as a reaction. If this returns false, task will only decline the failed checkpoint.  */ public boolean isFailOnCheckpointingErrors() {     return failOnCheckpointingErrors. }
true;public;1;3;/**  * Sets the expected behaviour for tasks in case that they encounter an error in their checkpointing procedure.  * If this is set to true, the task will fail on checkpointing error. If this is set to false, the task will only  * decline a the checkpoint and continue running. The default is true.  */ ;/**  * Sets the expected behaviour for tasks in case that they encounter an error in their checkpointing procedure.  * If this is set to true, the task will fail on checkpointing error. If this is set to false, the task will only  * decline a the checkpoint and continue running. The default is true.  */ public void setFailOnCheckpointingErrors(boolean failOnCheckpointingErrors) {     this.failOnCheckpointingErrors = failOnCheckpointingErrors. }
true;public;1;4;/**  * Enables checkpoints to be persisted externally.  *  * <p>Externalized checkpoints write their meta data out to persistent  * storage and are <strong>not</strong> automatically cleaned up when  * the owning job fails or is suspended (terminating with job status  * {@link JobStatus#FAILED} or {@link JobStatus#SUSPENDED}). In this  * case, you have to manually clean up the checkpoint state, both  * the meta data and actual program state.  *  * <p>The {@link ExternalizedCheckpointCleanup} mode defines how an  * externalized checkpoint should be cleaned up on job cancellation. If you  * choose to retain externalized checkpoints on cancellation you have you  * handle checkpoint clean up manually when you cancel the job as well  * (terminating with job status {@link JobStatus#CANCELED}).  *  * <p>The target directory for externalized checkpoints is configured  * via {@link org.apache.flink.configuration.CheckpointingOptions#CHECKPOINTS_DIRECTORY}.  *  * @param cleanupMode Externalized checkpoint cleanup behaviour.  */ ;/**  * Enables checkpoints to be persisted externally.  *  * <p>Externalized checkpoints write their meta data out to persistent  * storage and are <strong>not</strong> automatically cleaned up when  * the owning job fails or is suspended (terminating with job status  * {@link JobStatus#FAILED} or {@link JobStatus#SUSPENDED}). In this  * case, you have to manually clean up the checkpoint state, both  * the meta data and actual program state.  *  * <p>The {@link ExternalizedCheckpointCleanup} mode defines how an  * externalized checkpoint should be cleaned up on job cancellation. If you  * choose to retain externalized checkpoints on cancellation you have you  * handle checkpoint clean up manually when you cancel the job as well  * (terminating with job status {@link JobStatus#CANCELED}).  *  * <p>The target directory for externalized checkpoints is configured  * via {@link org.apache.flink.configuration.CheckpointingOptions#CHECKPOINTS_DIRECTORY}.  *  * @param cleanupMode Externalized checkpoint cleanup behaviour.  */ @PublicEvolving public void enableExternalizedCheckpoints(ExternalizedCheckpointCleanup cleanupMode) {     this.externalizedCheckpointCleanup = checkNotNull(cleanupMode). }
true;public;0;4;/**  * Returns whether checkpoints should be persisted externally.  *  * @return <code>true</code> if checkpoints should be externalized.  */ ;/**  * Returns whether checkpoints should be persisted externally.  *  * @return <code>true</code> if checkpoints should be externalized.  */ @PublicEvolving public boolean isExternalizedCheckpointsEnabled() {     return externalizedCheckpointCleanup != null. }
true;public;0;4;/**  * Returns the cleanup behaviour for externalized checkpoints.  *  * @return The cleanup behaviour for externalized checkpoints or  * <code>null</code> if none is configured.  */ ;/**  * Returns the cleanup behaviour for externalized checkpoints.  *  * @return The cleanup behaviour for externalized checkpoints or  * <code>null</code> if none is configured.  */ @PublicEvolving public ExternalizedCheckpointCleanup getExternalizedCheckpointCleanup() {     return externalizedCheckpointCleanup. }
true;public;0;3;/**  * Returns whether persistent checkpoints shall be discarded on  * cancellation of the job.  *  * @return <code>true</code> if persistent checkpoints shall be discarded  * on cancellation of the job.  */ ;/**  * Returns whether persistent checkpoints shall be discarded on  * cancellation of the job.  *  * @return <code>true</code> if persistent checkpoints shall be discarded  * on cancellation of the job.  */ public boolean deleteOnCancellation() {     return deleteOnCancellation. }
