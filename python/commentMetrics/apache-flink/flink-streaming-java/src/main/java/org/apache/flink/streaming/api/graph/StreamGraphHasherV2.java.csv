# id;timestamp;commentText;codeText;commentWords;codeWords
StreamGraphHasherV2 -> private byte[] generateDeterministicHash( 			StreamNode node, 			Hasher hasher, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1481709237;Generates a deterministic hash from node-local properties and input and_output edges.;private byte[] generateDeterministicHash(_			StreamNode node,_			Hasher hasher,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		_		_		_		generateNodeLocalHash(node, hasher, hashes.size())___		_		for (StreamEdge outEdge : node.getOutEdges()) {_			if (isChainable(outEdge, isChainingEnabled)) {_				StreamNode chainedNode = outEdge.getTargetVertex()___				_				_				generateNodeLocalHash(chainedNode, hasher, hashes.size())__			}_		}__		byte[] hash = hasher.hash().asBytes()___		_		_		for (StreamEdge inEdge : node.getInEdges()) {_			byte[] otherHash = hashes.get(inEdge.getSourceId())___			_			if (otherHash == null) {_				throw new IllegalStateException("Missing hash for input node "_						+ inEdge.getSourceVertex() + ". Cannot generate hash for "_						+ node + ".")__			}__			for (int j = 0_ j < hash.length_ j++) {_				hash[j] = (byte) (hash[j] * 37 ^ otherHash[j])__			}_		}__		if (LOG.isDebugEnabled()) {_			String udfClassName = ""__			if (node.getOperator() instanceof AbstractUdfStreamOperator) {_				udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator())_						.getUserFunction().getClass().getName()__			}__			LOG.debug("Generated hash '" + byteToHexString(hash) + "' for node " +_					"'" + node.toString() + "' {id: " + node.getId() + ", " +_					"parallelism: " + node.getParallelism() + ", " +_					"user function: " + udfClassName + "}")__		}__		return hash__	};generates,a,deterministic,hash,from,node,local,properties,and,input,and,output,edges;private,byte,generate,deterministic,hash,stream,node,node,hasher,hasher,map,integer,byte,hashes,boolean,is,chaining,enabled,generate,node,local,hash,node,hasher,hashes,size,for,stream,edge,out,edge,node,get,out,edges,if,is,chainable,out,edge,is,chaining,enabled,stream,node,chained,node,out,edge,get,target,vertex,generate,node,local,hash,chained,node,hasher,hashes,size,byte,hash,hasher,hash,as,bytes,for,stream,edge,in,edge,node,get,in,edges,byte,other,hash,hashes,get,in,edge,get,source,id,if,other,hash,null,throw,new,illegal,state,exception,missing,hash,for,input,node,in,edge,get,source,vertex,cannot,generate,hash,for,node,for,int,j,0,j,hash,length,j,hash,j,byte,hash,j,37,other,hash,j,if,log,is,debug,enabled,string,udf,class,name,if,node,get,operator,instanceof,abstract,udf,stream,operator,udf,class,name,abstract,udf,stream,operator,node,get,operator,get,user,function,get,class,get,name,log,debug,generated,hash,byte,to,hex,string,hash,for,node,node,to,string,id,node,get,id,parallelism,node,get,parallelism,user,function,udf,class,name,return,hash
StreamGraphHasherV2 -> private byte[] generateDeterministicHash( 			StreamNode node, 			Hasher hasher, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1485181339;Generates a deterministic hash from node-local properties and input and_output edges.;private byte[] generateDeterministicHash(_			StreamNode node,_			Hasher hasher,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		_		_		_		generateNodeLocalHash(node, hasher, hashes.size())___		_		for (StreamEdge outEdge : node.getOutEdges()) {_			if (isChainable(outEdge, isChainingEnabled)) {_				StreamNode chainedNode = outEdge.getTargetVertex()___				_				_				generateNodeLocalHash(chainedNode, hasher, hashes.size())__			}_		}__		byte[] hash = hasher.hash().asBytes()___		_		_		for (StreamEdge inEdge : node.getInEdges()) {_			byte[] otherHash = hashes.get(inEdge.getSourceId())___			_			if (otherHash == null) {_				throw new IllegalStateException("Missing hash for input node "_						+ inEdge.getSourceVertex() + ". Cannot generate hash for "_						+ node + ".")__			}__			for (int j = 0_ j < hash.length_ j++) {_				hash[j] = (byte) (hash[j] * 37 ^ otherHash[j])__			}_		}__		if (LOG.isDebugEnabled()) {_			String udfClassName = ""__			if (node.getOperator() instanceof AbstractUdfStreamOperator) {_				udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator())_						.getUserFunction().getClass().getName()__			}__			LOG.debug("Generated hash '" + byteToHexString(hash) + "' for node " +_					"'" + node.toString() + "' {id: " + node.getId() + ", " +_					"parallelism: " + node.getParallelism() + ", " +_					"user function: " + udfClassName + "}")__		}__		return hash__	};generates,a,deterministic,hash,from,node,local,properties,and,input,and,output,edges;private,byte,generate,deterministic,hash,stream,node,node,hasher,hasher,map,integer,byte,hashes,boolean,is,chaining,enabled,generate,node,local,hash,node,hasher,hashes,size,for,stream,edge,out,edge,node,get,out,edges,if,is,chainable,out,edge,is,chaining,enabled,stream,node,chained,node,out,edge,get,target,vertex,generate,node,local,hash,chained,node,hasher,hashes,size,byte,hash,hasher,hash,as,bytes,for,stream,edge,in,edge,node,get,in,edges,byte,other,hash,hashes,get,in,edge,get,source,id,if,other,hash,null,throw,new,illegal,state,exception,missing,hash,for,input,node,in,edge,get,source,vertex,cannot,generate,hash,for,node,for,int,j,0,j,hash,length,j,hash,j,byte,hash,j,37,other,hash,j,if,log,is,debug,enabled,string,udf,class,name,if,node,get,operator,instanceof,abstract,udf,stream,operator,udf,class,name,abstract,udf,stream,operator,node,get,operator,get,user,function,get,class,get,name,log,debug,generated,hash,byte,to,hex,string,hash,for,node,node,to,string,id,node,get,id,parallelism,node,get,parallelism,user,function,udf,class,name,return,hash
StreamGraphHasherV2 -> private byte[] generateDeterministicHash( 			StreamNode node, 			Hasher hasher, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1493195810;Generates a deterministic hash from node-local properties and input and_output edges.;private byte[] generateDeterministicHash(_			StreamNode node,_			Hasher hasher,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		_		_		_		generateNodeLocalHash(node, hasher, hashes.size())___		_		for (StreamEdge outEdge : node.getOutEdges()) {_			if (isChainable(outEdge, isChainingEnabled)) {_				StreamNode chainedNode = outEdge.getTargetVertex()___				_				_				generateNodeLocalHash(chainedNode, hasher, hashes.size())__			}_		}__		byte[] hash = hasher.hash().asBytes()___		_		_		for (StreamEdge inEdge : node.getInEdges()) {_			byte[] otherHash = hashes.get(inEdge.getSourceId())___			_			if (otherHash == null) {_				throw new IllegalStateException("Missing hash for input node "_						+ inEdge.getSourceVertex() + ". Cannot generate hash for "_						+ node + ".")__			}__			for (int j = 0_ j < hash.length_ j++) {_				hash[j] = (byte) (hash[j] * 37 ^ otherHash[j])__			}_		}__		if (LOG.isDebugEnabled()) {_			String udfClassName = ""__			if (node.getOperator() instanceof AbstractUdfStreamOperator) {_				udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator())_						.getUserFunction().getClass().getName()__			}__			LOG.debug("Generated hash '" + byteToHexString(hash) + "' for node " +_					"'" + node.toString() + "' {id: " + node.getId() + ", " +_					"parallelism: " + node.getParallelism() + ", " +_					"user function: " + udfClassName + "}")__		}__		return hash__	};generates,a,deterministic,hash,from,node,local,properties,and,input,and,output,edges;private,byte,generate,deterministic,hash,stream,node,node,hasher,hasher,map,integer,byte,hashes,boolean,is,chaining,enabled,generate,node,local,hash,node,hasher,hashes,size,for,stream,edge,out,edge,node,get,out,edges,if,is,chainable,out,edge,is,chaining,enabled,stream,node,chained,node,out,edge,get,target,vertex,generate,node,local,hash,chained,node,hasher,hashes,size,byte,hash,hasher,hash,as,bytes,for,stream,edge,in,edge,node,get,in,edges,byte,other,hash,hashes,get,in,edge,get,source,id,if,other,hash,null,throw,new,illegal,state,exception,missing,hash,for,input,node,in,edge,get,source,vertex,cannot,generate,hash,for,node,for,int,j,0,j,hash,length,j,hash,j,byte,hash,j,37,other,hash,j,if,log,is,debug,enabled,string,udf,class,name,if,node,get,operator,instanceof,abstract,udf,stream,operator,udf,class,name,abstract,udf,stream,operator,node,get,operator,get,user,function,get,class,get,name,log,debug,generated,hash,byte,to,hex,string,hash,for,node,node,to,string,id,node,get,id,parallelism,node,get,parallelism,user,function,udf,class,name,return,hash
StreamGraphHasherV2 -> private byte[] generateDeterministicHash( 			StreamNode node, 			Hasher hasher, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1493195810;Generates a deterministic hash from node-local properties and input and_output edges.;private byte[] generateDeterministicHash(_			StreamNode node,_			Hasher hasher,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		_		_		_		generateNodeLocalHash(node, hasher, hashes.size())___		_		for (StreamEdge outEdge : node.getOutEdges()) {_			if (isChainable(outEdge, isChainingEnabled)) {_				StreamNode chainedNode = outEdge.getTargetVertex()___				_				_				generateNodeLocalHash(chainedNode, hasher, hashes.size())__			}_		}__		byte[] hash = hasher.hash().asBytes()___		_		_		for (StreamEdge inEdge : node.getInEdges()) {_			byte[] otherHash = hashes.get(inEdge.getSourceId())___			_			if (otherHash == null) {_				throw new IllegalStateException("Missing hash for input node "_						+ inEdge.getSourceVertex() + ". Cannot generate hash for "_						+ node + ".")__			}__			for (int j = 0_ j < hash.length_ j++) {_				hash[j] = (byte) (hash[j] * 37 ^ otherHash[j])__			}_		}__		if (LOG.isDebugEnabled()) {_			String udfClassName = ""__			if (node.getOperator() instanceof AbstractUdfStreamOperator) {_				udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator())_						.getUserFunction().getClass().getName()__			}__			LOG.debug("Generated hash '" + byteToHexString(hash) + "' for node " +_					"'" + node.toString() + "' {id: " + node.getId() + ", " +_					"parallelism: " + node.getParallelism() + ", " +_					"user function: " + udfClassName + "}")__		}__		return hash__	};generates,a,deterministic,hash,from,node,local,properties,and,input,and,output,edges;private,byte,generate,deterministic,hash,stream,node,node,hasher,hasher,map,integer,byte,hashes,boolean,is,chaining,enabled,generate,node,local,hash,node,hasher,hashes,size,for,stream,edge,out,edge,node,get,out,edges,if,is,chainable,out,edge,is,chaining,enabled,stream,node,chained,node,out,edge,get,target,vertex,generate,node,local,hash,chained,node,hasher,hashes,size,byte,hash,hasher,hash,as,bytes,for,stream,edge,in,edge,node,get,in,edges,byte,other,hash,hashes,get,in,edge,get,source,id,if,other,hash,null,throw,new,illegal,state,exception,missing,hash,for,input,node,in,edge,get,source,vertex,cannot,generate,hash,for,node,for,int,j,0,j,hash,length,j,hash,j,byte,hash,j,37,other,hash,j,if,log,is,debug,enabled,string,udf,class,name,if,node,get,operator,instanceof,abstract,udf,stream,operator,udf,class,name,abstract,udf,stream,operator,node,get,operator,get,user,function,get,class,get,name,log,debug,generated,hash,byte,to,hex,string,hash,for,node,node,to,string,id,node,get,id,parallelism,node,get,parallelism,user,function,udf,class,name,return,hash
StreamGraphHasherV2 -> private byte[] generateDeterministicHash( 			StreamNode node, 			Hasher hasher, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1493403095;Generates a deterministic hash from node-local properties and input and_output edges.;private byte[] generateDeterministicHash(_			StreamNode node,_			Hasher hasher,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		_		_		_		generateNodeLocalHash(node, hasher, hashes.size())___		_		for (StreamEdge outEdge : node.getOutEdges()) {_			if (isChainable(outEdge, isChainingEnabled)) {_				StreamNode chainedNode = outEdge.getTargetVertex()___				_				_				generateNodeLocalHash(chainedNode, hasher, hashes.size())__			}_		}__		byte[] hash = hasher.hash().asBytes()___		_		_		for (StreamEdge inEdge : node.getInEdges()) {_			byte[] otherHash = hashes.get(inEdge.getSourceId())___			_			if (otherHash == null) {_				throw new IllegalStateException("Missing hash for input node "_						+ inEdge.getSourceVertex() + ". Cannot generate hash for "_						+ node + ".")__			}__			for (int j = 0_ j < hash.length_ j++) {_				hash[j] = (byte) (hash[j] * 37 ^ otherHash[j])__			}_		}__		if (LOG.isDebugEnabled()) {_			String udfClassName = ""__			if (node.getOperator() instanceof AbstractUdfStreamOperator) {_				udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator())_						.getUserFunction().getClass().getName()__			}__			LOG.debug("Generated hash '" + byteToHexString(hash) + "' for node " +_					"'" + node.toString() + "' {id: " + node.getId() + ", " +_					"parallelism: " + node.getParallelism() + ", " +_					"user function: " + udfClassName + "}")__		}__		return hash__	};generates,a,deterministic,hash,from,node,local,properties,and,input,and,output,edges;private,byte,generate,deterministic,hash,stream,node,node,hasher,hasher,map,integer,byte,hashes,boolean,is,chaining,enabled,generate,node,local,hash,node,hasher,hashes,size,for,stream,edge,out,edge,node,get,out,edges,if,is,chainable,out,edge,is,chaining,enabled,stream,node,chained,node,out,edge,get,target,vertex,generate,node,local,hash,chained,node,hasher,hashes,size,byte,hash,hasher,hash,as,bytes,for,stream,edge,in,edge,node,get,in,edges,byte,other,hash,hashes,get,in,edge,get,source,id,if,other,hash,null,throw,new,illegal,state,exception,missing,hash,for,input,node,in,edge,get,source,vertex,cannot,generate,hash,for,node,for,int,j,0,j,hash,length,j,hash,j,byte,hash,j,37,other,hash,j,if,log,is,debug,enabled,string,udf,class,name,if,node,get,operator,instanceof,abstract,udf,stream,operator,udf,class,name,abstract,udf,stream,operator,node,get,operator,get,user,function,get,class,get,name,log,debug,generated,hash,byte,to,hex,string,hash,for,node,node,to,string,id,node,get,id,parallelism,node,get,parallelism,user,function,udf,class,name,return,hash
StreamGraphHasherV2 -> private byte[] generateDeterministicHash( 			StreamNode node, 			Hasher hasher, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1495484544;Generates a deterministic hash from node-local properties and input and_output edges.;private byte[] generateDeterministicHash(_			StreamNode node,_			Hasher hasher,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		_		_		_		generateNodeLocalHash(node, hasher, hashes.size())___		_		for (StreamEdge outEdge : node.getOutEdges()) {_			if (isChainable(outEdge, isChainingEnabled)) {_				StreamNode chainedNode = outEdge.getTargetVertex()___				_				_				generateNodeLocalHash(chainedNode, hasher, hashes.size())__			}_		}__		byte[] hash = hasher.hash().asBytes()___		_		_		for (StreamEdge inEdge : node.getInEdges()) {_			byte[] otherHash = hashes.get(inEdge.getSourceId())___			_			if (otherHash == null) {_				throw new IllegalStateException("Missing hash for input node "_						+ inEdge.getSourceVertex() + ". Cannot generate hash for "_						+ node + ".")__			}__			for (int j = 0_ j < hash.length_ j++) {_				hash[j] = (byte) (hash[j] * 37 ^ otherHash[j])__			}_		}__		if (LOG.isDebugEnabled()) {_			String udfClassName = ""__			if (node.getOperator() instanceof AbstractUdfStreamOperator) {_				udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator())_						.getUserFunction().getClass().getName()__			}__			LOG.debug("Generated hash '" + byteToHexString(hash) + "' for node " +_					"'" + node.toString() + "' {id: " + node.getId() + ", " +_					"parallelism: " + node.getParallelism() + ", " +_					"user function: " + udfClassName + "}")__		}__		return hash__	};generates,a,deterministic,hash,from,node,local,properties,and,input,and,output,edges;private,byte,generate,deterministic,hash,stream,node,node,hasher,hasher,map,integer,byte,hashes,boolean,is,chaining,enabled,generate,node,local,hash,node,hasher,hashes,size,for,stream,edge,out,edge,node,get,out,edges,if,is,chainable,out,edge,is,chaining,enabled,stream,node,chained,node,out,edge,get,target,vertex,generate,node,local,hash,chained,node,hasher,hashes,size,byte,hash,hasher,hash,as,bytes,for,stream,edge,in,edge,node,get,in,edges,byte,other,hash,hashes,get,in,edge,get,source,id,if,other,hash,null,throw,new,illegal,state,exception,missing,hash,for,input,node,in,edge,get,source,vertex,cannot,generate,hash,for,node,for,int,j,0,j,hash,length,j,hash,j,byte,hash,j,37,other,hash,j,if,log,is,debug,enabled,string,udf,class,name,if,node,get,operator,instanceof,abstract,udf,stream,operator,udf,class,name,abstract,udf,stream,operator,node,get,operator,get,user,function,get,class,get,name,log,debug,generated,hash,byte,to,hex,string,hash,for,node,node,to,string,id,node,get,id,parallelism,node,get,parallelism,user,function,udf,class,name,return,hash
StreamGraphHasherV2 -> private byte[] generateDeterministicHash( 			StreamNode node, 			Hasher hasher, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1502726910;Generates a deterministic hash from node-local properties and input and_output edges.;private byte[] generateDeterministicHash(_			StreamNode node,_			Hasher hasher,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		_		_		_		generateNodeLocalHash(node, hasher, hashes.size())___		_		for (StreamEdge outEdge : node.getOutEdges()) {_			if (isChainable(outEdge, isChainingEnabled)) {_				StreamNode chainedNode = outEdge.getTargetVertex()___				_				_				generateNodeLocalHash(chainedNode, hasher, hashes.size())__			}_		}__		byte[] hash = hasher.hash().asBytes()___		_		_		for (StreamEdge inEdge : node.getInEdges()) {_			byte[] otherHash = hashes.get(inEdge.getSourceId())___			_			if (otherHash == null) {_				throw new IllegalStateException("Missing hash for input node "_						+ inEdge.getSourceVertex() + ". Cannot generate hash for "_						+ node + ".")__			}__			for (int j = 0_ j < hash.length_ j++) {_				hash[j] = (byte) (hash[j] * 37 ^ otherHash[j])__			}_		}__		if (LOG.isDebugEnabled()) {_			String udfClassName = ""__			if (node.getOperator() instanceof AbstractUdfStreamOperator) {_				udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator())_						.getUserFunction().getClass().getName()__			}__			LOG.debug("Generated hash '" + byteToHexString(hash) + "' for node " +_					"'" + node.toString() + "' {id: " + node.getId() + ", " +_					"parallelism: " + node.getParallelism() + ", " +_					"user function: " + udfClassName + "}")__		}__		return hash__	};generates,a,deterministic,hash,from,node,local,properties,and,input,and,output,edges;private,byte,generate,deterministic,hash,stream,node,node,hasher,hasher,map,integer,byte,hashes,boolean,is,chaining,enabled,generate,node,local,hash,node,hasher,hashes,size,for,stream,edge,out,edge,node,get,out,edges,if,is,chainable,out,edge,is,chaining,enabled,stream,node,chained,node,out,edge,get,target,vertex,generate,node,local,hash,chained,node,hasher,hashes,size,byte,hash,hasher,hash,as,bytes,for,stream,edge,in,edge,node,get,in,edges,byte,other,hash,hashes,get,in,edge,get,source,id,if,other,hash,null,throw,new,illegal,state,exception,missing,hash,for,input,node,in,edge,get,source,vertex,cannot,generate,hash,for,node,for,int,j,0,j,hash,length,j,hash,j,byte,hash,j,37,other,hash,j,if,log,is,debug,enabled,string,udf,class,name,if,node,get,operator,instanceof,abstract,udf,stream,operator,udf,class,name,abstract,udf,stream,operator,node,get,operator,get,user,function,get,class,get,name,log,debug,generated,hash,byte,to,hex,string,hash,for,node,node,to,string,id,node,get,id,parallelism,node,get,parallelism,user,function,udf,class,name,return,hash
StreamGraphHasherV2 -> private byte[] generateDeterministicHash( 			StreamNode node, 			Hasher hasher, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1539719877;Generates a deterministic hash from node-local properties and input and_output edges.;private byte[] generateDeterministicHash(_			StreamNode node,_			Hasher hasher,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		_		_		_		generateNodeLocalHash(hasher, hashes.size())___		_		for (StreamEdge outEdge : node.getOutEdges()) {_			if (isChainable(outEdge, isChainingEnabled)) {__				_				_				generateNodeLocalHash(hasher, hashes.size())__			}_		}__		byte[] hash = hasher.hash().asBytes()___		_		_		for (StreamEdge inEdge : node.getInEdges()) {_			byte[] otherHash = hashes.get(inEdge.getSourceId())___			_			if (otherHash == null) {_				throw new IllegalStateException("Missing hash for input node "_						+ inEdge.getSourceVertex() + ". Cannot generate hash for "_						+ node + ".")__			}__			for (int j = 0_ j < hash.length_ j++) {_				hash[j] = (byte) (hash[j] * 37 ^ otherHash[j])__			}_		}__		if (LOG.isDebugEnabled()) {_			String udfClassName = ""__			if (node.getOperator() instanceof AbstractUdfStreamOperator) {_				udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator())_						.getUserFunction().getClass().getName()__			}__			LOG.debug("Generated hash '" + byteToHexString(hash) + "' for node " +_					"'" + node.toString() + "' {id: " + node.getId() + ", " +_					"parallelism: " + node.getParallelism() + ", " +_					"user function: " + udfClassName + "}")__		}__		return hash__	};generates,a,deterministic,hash,from,node,local,properties,and,input,and,output,edges;private,byte,generate,deterministic,hash,stream,node,node,hasher,hasher,map,integer,byte,hashes,boolean,is,chaining,enabled,generate,node,local,hash,hasher,hashes,size,for,stream,edge,out,edge,node,get,out,edges,if,is,chainable,out,edge,is,chaining,enabled,generate,node,local,hash,hasher,hashes,size,byte,hash,hasher,hash,as,bytes,for,stream,edge,in,edge,node,get,in,edges,byte,other,hash,hashes,get,in,edge,get,source,id,if,other,hash,null,throw,new,illegal,state,exception,missing,hash,for,input,node,in,edge,get,source,vertex,cannot,generate,hash,for,node,for,int,j,0,j,hash,length,j,hash,j,byte,hash,j,37,other,hash,j,if,log,is,debug,enabled,string,udf,class,name,if,node,get,operator,instanceof,abstract,udf,stream,operator,udf,class,name,abstract,udf,stream,operator,node,get,operator,get,user,function,get,class,get,name,log,debug,generated,hash,byte,to,hex,string,hash,for,node,node,to,string,id,node,get,id,parallelism,node,get,parallelism,user,function,udf,class,name,return,hash
StreamGraphHasherV2 -> private byte[] generateDeterministicHash( 			StreamNode node, 			Hasher hasher, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1542613070;Generates a deterministic hash from node-local properties and input and_output edges.;private byte[] generateDeterministicHash(_			StreamNode node,_			Hasher hasher,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		_		_		_		generateNodeLocalHash(hasher, hashes.size())___		_		for (StreamEdge outEdge : node.getOutEdges()) {_			if (isChainable(outEdge, isChainingEnabled)) {__				_				_				generateNodeLocalHash(hasher, hashes.size())__			}_		}__		byte[] hash = hasher.hash().asBytes()___		_		_		for (StreamEdge inEdge : node.getInEdges()) {_			byte[] otherHash = hashes.get(inEdge.getSourceId())___			_			if (otherHash == null) {_				throw new IllegalStateException("Missing hash for input node "_						+ inEdge.getSourceVertex() + ". Cannot generate hash for "_						+ node + ".")__			}__			for (int j = 0_ j < hash.length_ j++) {_				hash[j] = (byte) (hash[j] * 37 ^ otherHash[j])__			}_		}__		if (LOG.isDebugEnabled()) {_			String udfClassName = ""__			if (node.getOperator() instanceof AbstractUdfStreamOperator) {_				udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator())_						.getUserFunction().getClass().getName()__			}__			LOG.debug("Generated hash '" + byteToHexString(hash) + "' for node " +_					"'" + node.toString() + "' {id: " + node.getId() + ", " +_					"parallelism: " + node.getParallelism() + ", " +_					"user function: " + udfClassName + "}")__		}__		return hash__	};generates,a,deterministic,hash,from,node,local,properties,and,input,and,output,edges;private,byte,generate,deterministic,hash,stream,node,node,hasher,hasher,map,integer,byte,hashes,boolean,is,chaining,enabled,generate,node,local,hash,hasher,hashes,size,for,stream,edge,out,edge,node,get,out,edges,if,is,chainable,out,edge,is,chaining,enabled,generate,node,local,hash,hasher,hashes,size,byte,hash,hasher,hash,as,bytes,for,stream,edge,in,edge,node,get,in,edges,byte,other,hash,hashes,get,in,edge,get,source,id,if,other,hash,null,throw,new,illegal,state,exception,missing,hash,for,input,node,in,edge,get,source,vertex,cannot,generate,hash,for,node,for,int,j,0,j,hash,length,j,hash,j,byte,hash,j,37,other,hash,j,if,log,is,debug,enabled,string,udf,class,name,if,node,get,operator,instanceof,abstract,udf,stream,operator,udf,class,name,abstract,udf,stream,operator,node,get,operator,get,user,function,get,class,get,name,log,debug,generated,hash,byte,to,hex,string,hash,for,node,node,to,string,id,node,get,id,parallelism,node,get,parallelism,user,function,udf,class,name,return,hash
StreamGraphHasherV2 -> private void generateNodeLocalHash(Hasher hasher, int id);1539719877;Applies the {@link Hasher} to the {@link StreamNode} . The hasher encapsulates_the current state of the hash.__<p>The specified ID is local to this node. We cannot use the_{@link StreamNode#id}, because it is incremented in a static counter._Therefore, the IDs for identical jobs will otherwise be different.;private void generateNodeLocalHash(Hasher hasher, int id) {_		_		_		_		hasher.putInt(id)__	};applies,the,link,hasher,to,the,link,stream,node,the,hasher,encapsulates,the,current,state,of,the,hash,p,the,specified,id,is,local,to,this,node,we,cannot,use,the,link,stream,node,id,because,it,is,incremented,in,a,static,counter,therefore,the,ids,for,identical,jobs,will,otherwise,be,different;private,void,generate,node,local,hash,hasher,hasher,int,id,hasher,put,int,id
StreamGraphHasherV2 -> private void generateNodeLocalHash(Hasher hasher, int id);1542613070;Applies the {@link Hasher} to the {@link StreamNode} . The hasher encapsulates_the current state of the hash.__<p>The specified ID is local to this node. We cannot use the_{@link StreamNode#id}, because it is incremented in a static counter._Therefore, the IDs for identical jobs will otherwise be different.;private void generateNodeLocalHash(Hasher hasher, int id) {_		_		_		_		hasher.putInt(id)__	};applies,the,link,hasher,to,the,link,stream,node,the,hasher,encapsulates,the,current,state,of,the,hash,p,the,specified,id,is,local,to,this,node,we,cannot,use,the,link,stream,node,id,because,it,is,incremented,in,a,static,counter,therefore,the,ids,for,identical,jobs,will,otherwise,be,different;private,void,generate,node,local,hash,hasher,hasher,int,id,hasher,put,int,id
StreamGraphHasherV2 -> private void generateNodeLocalHash(Hasher hasher, int id);1547905886;Applies the {@link Hasher} to the {@link StreamNode} . The hasher encapsulates_the current state of the hash.__<p>The specified ID is local to this node. We cannot use the_{@link StreamNode#id}, because it is incremented in a static counter._Therefore, the IDs for identical jobs will otherwise be different.;private void generateNodeLocalHash(Hasher hasher, int id) {_		_		_		_		hasher.putInt(id)__	};applies,the,link,hasher,to,the,link,stream,node,the,hasher,encapsulates,the,current,state,of,the,hash,p,the,specified,id,is,local,to,this,node,we,cannot,use,the,link,stream,node,id,because,it,is,incremented,in,a,static,counter,therefore,the,ids,for,identical,jobs,will,otherwise,be,different;private,void,generate,node,local,hash,hasher,hasher,int,id,hasher,put,int,id
StreamGraphHasherV2 -> @Override 	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph);1481709237;Returns a map with a hash for each {@link StreamNode} of the {@link_StreamGraph}. The hash is used as the {@link JobVertexID} in order to_identify nodes across job submissions if they didn't change.__<p>_<p>The complete {@link StreamGraph} is traversed. The hash is either_computed from the transformation's user-specified id (see_{@link StreamTransformation#getUid()}) or generated in a deterministic way.__<p>_<p>The generated hash is deterministic with respect to:_<ul>_<li>node-local properties (like parallelism, UDF, node ID),_<li>chained output nodes, and_<li>input nodes hashes_</ul>__@return A map from {@link StreamNode#id} to hash as 16-byte array.;@Override_	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph) {_		_		final HashFunction hashFunction = Hashing.murmur3_128(0)__		final Map<Integer, byte[]> hashes = new HashMap<>()___		Set<Integer> visited = new HashSet<>()__		Queue<StreamNode> remaining = new ArrayDeque<>()___		_		_		_		_		List<Integer> sources = new ArrayList<>()__		for (Integer sourceNodeId : streamGraph.getSourceIDs()) {_			sources.add(sourceNodeId)__		}_		Collections.sort(sources)___		_		_		_		__		_		for (Integer sourceNodeId : sources) {_			remaining.add(streamGraph.getStreamNode(sourceNodeId))__			visited.add(sourceNodeId)__		}__		StreamNode currentNode__		while ((currentNode = remaining.poll()) != null) {_			_			_			_			if (generateNodeHash(currentNode, hashFunction, hashes, streamGraph.isChainingEnabled())) {_				_				for (StreamEdge outEdge : currentNode.getOutEdges()) {_					StreamNode child = outEdge.getTargetVertex()___					if (!visited.contains(child.getId())) {_						remaining.add(child)__						visited.add(child.getId())__					}_				}_			} else {_				_				visited.remove(currentNode.getId())__			}_		}__		return hashes__	};returns,a,map,with,a,hash,for,each,link,stream,node,of,the,link,stream,graph,the,hash,is,used,as,the,link,job,vertex,id,in,order,to,identify,nodes,across,job,submissions,if,they,didn,t,change,p,p,the,complete,link,stream,graph,is,traversed,the,hash,is,either,computed,from,the,transformation,s,user,specified,id,see,link,stream,transformation,get,uid,or,generated,in,a,deterministic,way,p,p,the,generated,hash,is,deterministic,with,respect,to,ul,li,node,local,properties,like,parallelism,udf,node,id,li,chained,output,nodes,and,li,input,nodes,hashes,ul,return,a,map,from,link,stream,node,id,to,hash,as,16,byte,array;override,public,map,integer,byte,traverse,stream,graph,and,generate,hashes,stream,graph,stream,graph,final,hash,function,hash,function,hashing,0,final,map,integer,byte,hashes,new,hash,map,set,integer,visited,new,hash,set,queue,stream,node,remaining,new,array,deque,list,integer,sources,new,array,list,for,integer,source,node,id,stream,graph,get,source,ids,sources,add,source,node,id,collections,sort,sources,for,integer,source,node,id,sources,remaining,add,stream,graph,get,stream,node,source,node,id,visited,add,source,node,id,stream,node,current,node,while,current,node,remaining,poll,null,if,generate,node,hash,current,node,hash,function,hashes,stream,graph,is,chaining,enabled,for,stream,edge,out,edge,current,node,get,out,edges,stream,node,child,out,edge,get,target,vertex,if,visited,contains,child,get,id,remaining,add,child,visited,add,child,get,id,else,visited,remove,current,node,get,id,return,hashes
StreamGraphHasherV2 -> @Override 	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph);1485181339;Returns a map with a hash for each {@link StreamNode} of the {@link_StreamGraph}. The hash is used as the {@link JobVertexID} in order to_identify nodes across job submissions if they didn't change.__<p>_<p>The complete {@link StreamGraph} is traversed. The hash is either_computed from the transformation's user-specified id (see_{@link StreamTransformation#getUid()}) or generated in a deterministic way.__<p>_<p>The generated hash is deterministic with respect to:_<ul>_<li>node-local properties (like parallelism, UDF, node ID),_<li>chained output nodes, and_<li>input nodes hashes_</ul>__@return A map from {@link StreamNode#id} to hash as 16-byte array.;@Override_	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph) {_		_		final HashFunction hashFunction = Hashing.murmur3_128(0)__		final Map<Integer, byte[]> hashes = new HashMap<>()___		Set<Integer> visited = new HashSet<>()__		Queue<StreamNode> remaining = new ArrayDeque<>()___		_		_		_		_		List<Integer> sources = new ArrayList<>()__		for (Integer sourceNodeId : streamGraph.getSourceIDs()) {_			sources.add(sourceNodeId)__		}_		Collections.sort(sources)___		_		_		_		__		_		for (Integer sourceNodeId : sources) {_			remaining.add(streamGraph.getStreamNode(sourceNodeId))__			visited.add(sourceNodeId)__		}__		StreamNode currentNode__		while ((currentNode = remaining.poll()) != null) {_			_			_			_			if (generateNodeHash(currentNode, hashFunction, hashes, streamGraph.isChainingEnabled())) {_				_				for (StreamEdge outEdge : currentNode.getOutEdges()) {_					StreamNode child = outEdge.getTargetVertex()___					if (!visited.contains(child.getId())) {_						remaining.add(child)__						visited.add(child.getId())__					}_				}_			} else {_				_				visited.remove(currentNode.getId())__			}_		}__		return hashes__	};returns,a,map,with,a,hash,for,each,link,stream,node,of,the,link,stream,graph,the,hash,is,used,as,the,link,job,vertex,id,in,order,to,identify,nodes,across,job,submissions,if,they,didn,t,change,p,p,the,complete,link,stream,graph,is,traversed,the,hash,is,either,computed,from,the,transformation,s,user,specified,id,see,link,stream,transformation,get,uid,or,generated,in,a,deterministic,way,p,p,the,generated,hash,is,deterministic,with,respect,to,ul,li,node,local,properties,like,parallelism,udf,node,id,li,chained,output,nodes,and,li,input,nodes,hashes,ul,return,a,map,from,link,stream,node,id,to,hash,as,16,byte,array;override,public,map,integer,byte,traverse,stream,graph,and,generate,hashes,stream,graph,stream,graph,final,hash,function,hash,function,hashing,0,final,map,integer,byte,hashes,new,hash,map,set,integer,visited,new,hash,set,queue,stream,node,remaining,new,array,deque,list,integer,sources,new,array,list,for,integer,source,node,id,stream,graph,get,source,ids,sources,add,source,node,id,collections,sort,sources,for,integer,source,node,id,sources,remaining,add,stream,graph,get,stream,node,source,node,id,visited,add,source,node,id,stream,node,current,node,while,current,node,remaining,poll,null,if,generate,node,hash,current,node,hash,function,hashes,stream,graph,is,chaining,enabled,for,stream,edge,out,edge,current,node,get,out,edges,stream,node,child,out,edge,get,target,vertex,if,visited,contains,child,get,id,remaining,add,child,visited,add,child,get,id,else,visited,remove,current,node,get,id,return,hashes
StreamGraphHasherV2 -> @Override 	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph);1493195810;Returns a map with a hash for each {@link StreamNode} of the {@link_StreamGraph}. The hash is used as the {@link JobVertexID} in order to_identify nodes across job submissions if they didn't change.__<p>The complete {@link StreamGraph} is traversed. The hash is either_computed from the transformation's user-specified id (see_{@link StreamTransformation#getUid()}) or generated in a deterministic way.__<p>The generated hash is deterministic with respect to:_<ul>_<li>node-local properties (like parallelism, UDF, node ID),_<li>chained output nodes, and_<li>input nodes hashes_</ul>__@return A map from {@link StreamNode#id} to hash as 16-byte array.;@Override_	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph) {_		_		final HashFunction hashFunction = Hashing.murmur3_128(0)__		final Map<Integer, byte[]> hashes = new HashMap<>()___		Set<Integer> visited = new HashSet<>()__		Queue<StreamNode> remaining = new ArrayDeque<>()___		_		_		_		_		List<Integer> sources = new ArrayList<>()__		for (Integer sourceNodeId : streamGraph.getSourceIDs()) {_			sources.add(sourceNodeId)__		}_		Collections.sort(sources)___		_		_		_		__		_		for (Integer sourceNodeId : sources) {_			remaining.add(streamGraph.getStreamNode(sourceNodeId))__			visited.add(sourceNodeId)__		}__		StreamNode currentNode__		while ((currentNode = remaining.poll()) != null) {_			_			_			_			if (generateNodeHash(currentNode, hashFunction, hashes, streamGraph.isChainingEnabled())) {_				_				for (StreamEdge outEdge : currentNode.getOutEdges()) {_					StreamNode child = outEdge.getTargetVertex()___					if (!visited.contains(child.getId())) {_						remaining.add(child)__						visited.add(child.getId())__					}_				}_			} else {_				_				visited.remove(currentNode.getId())__			}_		}__		return hashes__	};returns,a,map,with,a,hash,for,each,link,stream,node,of,the,link,stream,graph,the,hash,is,used,as,the,link,job,vertex,id,in,order,to,identify,nodes,across,job,submissions,if,they,didn,t,change,p,the,complete,link,stream,graph,is,traversed,the,hash,is,either,computed,from,the,transformation,s,user,specified,id,see,link,stream,transformation,get,uid,or,generated,in,a,deterministic,way,p,the,generated,hash,is,deterministic,with,respect,to,ul,li,node,local,properties,like,parallelism,udf,node,id,li,chained,output,nodes,and,li,input,nodes,hashes,ul,return,a,map,from,link,stream,node,id,to,hash,as,16,byte,array;override,public,map,integer,byte,traverse,stream,graph,and,generate,hashes,stream,graph,stream,graph,final,hash,function,hash,function,hashing,0,final,map,integer,byte,hashes,new,hash,map,set,integer,visited,new,hash,set,queue,stream,node,remaining,new,array,deque,list,integer,sources,new,array,list,for,integer,source,node,id,stream,graph,get,source,ids,sources,add,source,node,id,collections,sort,sources,for,integer,source,node,id,sources,remaining,add,stream,graph,get,stream,node,source,node,id,visited,add,source,node,id,stream,node,current,node,while,current,node,remaining,poll,null,if,generate,node,hash,current,node,hash,function,hashes,stream,graph,is,chaining,enabled,for,stream,edge,out,edge,current,node,get,out,edges,stream,node,child,out,edge,get,target,vertex,if,visited,contains,child,get,id,remaining,add,child,visited,add,child,get,id,else,visited,remove,current,node,get,id,return,hashes
StreamGraphHasherV2 -> @Override 	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph);1493195810;Returns a map with a hash for each {@link StreamNode} of the {@link_StreamGraph}. The hash is used as the {@link JobVertexID} in order to_identify nodes across job submissions if they didn't change.__<p>The complete {@link StreamGraph} is traversed. The hash is either_computed from the transformation's user-specified id (see_{@link StreamTransformation#getUid()}) or generated in a deterministic way.__<p>The generated hash is deterministic with respect to:_<ul>_<li>node-local properties (like parallelism, UDF, node ID),_<li>chained output nodes, and_<li>input nodes hashes_</ul>__@return A map from {@link StreamNode#id} to hash as 16-byte array.;@Override_	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph) {_		_		final HashFunction hashFunction = Hashing.murmur3_128(0)__		final Map<Integer, byte[]> hashes = new HashMap<>()___		Set<Integer> visited = new HashSet<>()__		Queue<StreamNode> remaining = new ArrayDeque<>()___		_		_		_		_		List<Integer> sources = new ArrayList<>()__		for (Integer sourceNodeId : streamGraph.getSourceIDs()) {_			sources.add(sourceNodeId)__		}_		Collections.sort(sources)___		_		_		_		__		_		for (Integer sourceNodeId : sources) {_			remaining.add(streamGraph.getStreamNode(sourceNodeId))__			visited.add(sourceNodeId)__		}__		StreamNode currentNode__		while ((currentNode = remaining.poll()) != null) {_			_			_			_			if (generateNodeHash(currentNode, hashFunction, hashes, streamGraph.isChainingEnabled())) {_				_				for (StreamEdge outEdge : currentNode.getOutEdges()) {_					StreamNode child = outEdge.getTargetVertex()___					if (!visited.contains(child.getId())) {_						remaining.add(child)__						visited.add(child.getId())__					}_				}_			} else {_				_				visited.remove(currentNode.getId())__			}_		}__		return hashes__	};returns,a,map,with,a,hash,for,each,link,stream,node,of,the,link,stream,graph,the,hash,is,used,as,the,link,job,vertex,id,in,order,to,identify,nodes,across,job,submissions,if,they,didn,t,change,p,the,complete,link,stream,graph,is,traversed,the,hash,is,either,computed,from,the,transformation,s,user,specified,id,see,link,stream,transformation,get,uid,or,generated,in,a,deterministic,way,p,the,generated,hash,is,deterministic,with,respect,to,ul,li,node,local,properties,like,parallelism,udf,node,id,li,chained,output,nodes,and,li,input,nodes,hashes,ul,return,a,map,from,link,stream,node,id,to,hash,as,16,byte,array;override,public,map,integer,byte,traverse,stream,graph,and,generate,hashes,stream,graph,stream,graph,final,hash,function,hash,function,hashing,0,final,map,integer,byte,hashes,new,hash,map,set,integer,visited,new,hash,set,queue,stream,node,remaining,new,array,deque,list,integer,sources,new,array,list,for,integer,source,node,id,stream,graph,get,source,ids,sources,add,source,node,id,collections,sort,sources,for,integer,source,node,id,sources,remaining,add,stream,graph,get,stream,node,source,node,id,visited,add,source,node,id,stream,node,current,node,while,current,node,remaining,poll,null,if,generate,node,hash,current,node,hash,function,hashes,stream,graph,is,chaining,enabled,for,stream,edge,out,edge,current,node,get,out,edges,stream,node,child,out,edge,get,target,vertex,if,visited,contains,child,get,id,remaining,add,child,visited,add,child,get,id,else,visited,remove,current,node,get,id,return,hashes
StreamGraphHasherV2 -> @Override 	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph);1493403095;Returns a map with a hash for each {@link StreamNode} of the {@link_StreamGraph}. The hash is used as the {@link JobVertexID} in order to_identify nodes across job submissions if they didn't change.__<p>The complete {@link StreamGraph} is traversed. The hash is either_computed from the transformation's user-specified id (see_{@link StreamTransformation#getUid()}) or generated in a deterministic way.__<p>The generated hash is deterministic with respect to:_<ul>_<li>node-local properties (like parallelism, UDF, node ID),_<li>chained output nodes, and_<li>input nodes hashes_</ul>__@return A map from {@link StreamNode#id} to hash as 16-byte array.;@Override_	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph) {_		_		final HashFunction hashFunction = Hashing.murmur3_128(0)__		final Map<Integer, byte[]> hashes = new HashMap<>()___		Set<Integer> visited = new HashSet<>()__		Queue<StreamNode> remaining = new ArrayDeque<>()___		_		_		_		_		List<Integer> sources = new ArrayList<>()__		for (Integer sourceNodeId : streamGraph.getSourceIDs()) {_			sources.add(sourceNodeId)__		}_		Collections.sort(sources)___		_		_		_		__		_		for (Integer sourceNodeId : sources) {_			remaining.add(streamGraph.getStreamNode(sourceNodeId))__			visited.add(sourceNodeId)__		}__		StreamNode currentNode__		while ((currentNode = remaining.poll()) != null) {_			_			_			_			if (generateNodeHash(currentNode, hashFunction, hashes, streamGraph.isChainingEnabled())) {_				_				for (StreamEdge outEdge : currentNode.getOutEdges()) {_					StreamNode child = outEdge.getTargetVertex()___					if (!visited.contains(child.getId())) {_						remaining.add(child)__						visited.add(child.getId())__					}_				}_			} else {_				_				visited.remove(currentNode.getId())__			}_		}__		return hashes__	};returns,a,map,with,a,hash,for,each,link,stream,node,of,the,link,stream,graph,the,hash,is,used,as,the,link,job,vertex,id,in,order,to,identify,nodes,across,job,submissions,if,they,didn,t,change,p,the,complete,link,stream,graph,is,traversed,the,hash,is,either,computed,from,the,transformation,s,user,specified,id,see,link,stream,transformation,get,uid,or,generated,in,a,deterministic,way,p,the,generated,hash,is,deterministic,with,respect,to,ul,li,node,local,properties,like,parallelism,udf,node,id,li,chained,output,nodes,and,li,input,nodes,hashes,ul,return,a,map,from,link,stream,node,id,to,hash,as,16,byte,array;override,public,map,integer,byte,traverse,stream,graph,and,generate,hashes,stream,graph,stream,graph,final,hash,function,hash,function,hashing,0,final,map,integer,byte,hashes,new,hash,map,set,integer,visited,new,hash,set,queue,stream,node,remaining,new,array,deque,list,integer,sources,new,array,list,for,integer,source,node,id,stream,graph,get,source,ids,sources,add,source,node,id,collections,sort,sources,for,integer,source,node,id,sources,remaining,add,stream,graph,get,stream,node,source,node,id,visited,add,source,node,id,stream,node,current,node,while,current,node,remaining,poll,null,if,generate,node,hash,current,node,hash,function,hashes,stream,graph,is,chaining,enabled,for,stream,edge,out,edge,current,node,get,out,edges,stream,node,child,out,edge,get,target,vertex,if,visited,contains,child,get,id,remaining,add,child,visited,add,child,get,id,else,visited,remove,current,node,get,id,return,hashes
StreamGraphHasherV2 -> @Override 	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph);1495484544;Returns a map with a hash for each {@link StreamNode} of the {@link_StreamGraph}. The hash is used as the {@link JobVertexID} in order to_identify nodes across job submissions if they didn't change.__<p>The complete {@link StreamGraph} is traversed. The hash is either_computed from the transformation's user-specified id (see_{@link StreamTransformation#getUid()}) or generated in a deterministic way.__<p>The generated hash is deterministic with respect to:_<ul>_<li>node-local properties (like parallelism, UDF, node ID),_<li>chained output nodes, and_<li>input nodes hashes_</ul>__@return A map from {@link StreamNode#id} to hash as 16-byte array.;@Override_	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph) {_		_		final HashFunction hashFunction = Hashing.murmur3_128(0)__		final Map<Integer, byte[]> hashes = new HashMap<>()___		Set<Integer> visited = new HashSet<>()__		Queue<StreamNode> remaining = new ArrayDeque<>()___		_		_		_		_		List<Integer> sources = new ArrayList<>()__		for (Integer sourceNodeId : streamGraph.getSourceIDs()) {_			sources.add(sourceNodeId)__		}_		Collections.sort(sources)___		_		_		_		__		_		for (Integer sourceNodeId : sources) {_			remaining.add(streamGraph.getStreamNode(sourceNodeId))__			visited.add(sourceNodeId)__		}__		StreamNode currentNode__		while ((currentNode = remaining.poll()) != null) {_			_			_			_			if (generateNodeHash(currentNode, hashFunction, hashes, streamGraph.isChainingEnabled())) {_				_				for (StreamEdge outEdge : currentNode.getOutEdges()) {_					StreamNode child = outEdge.getTargetVertex()___					if (!visited.contains(child.getId())) {_						remaining.add(child)__						visited.add(child.getId())__					}_				}_			} else {_				_				visited.remove(currentNode.getId())__			}_		}__		return hashes__	};returns,a,map,with,a,hash,for,each,link,stream,node,of,the,link,stream,graph,the,hash,is,used,as,the,link,job,vertex,id,in,order,to,identify,nodes,across,job,submissions,if,they,didn,t,change,p,the,complete,link,stream,graph,is,traversed,the,hash,is,either,computed,from,the,transformation,s,user,specified,id,see,link,stream,transformation,get,uid,or,generated,in,a,deterministic,way,p,the,generated,hash,is,deterministic,with,respect,to,ul,li,node,local,properties,like,parallelism,udf,node,id,li,chained,output,nodes,and,li,input,nodes,hashes,ul,return,a,map,from,link,stream,node,id,to,hash,as,16,byte,array;override,public,map,integer,byte,traverse,stream,graph,and,generate,hashes,stream,graph,stream,graph,final,hash,function,hash,function,hashing,0,final,map,integer,byte,hashes,new,hash,map,set,integer,visited,new,hash,set,queue,stream,node,remaining,new,array,deque,list,integer,sources,new,array,list,for,integer,source,node,id,stream,graph,get,source,ids,sources,add,source,node,id,collections,sort,sources,for,integer,source,node,id,sources,remaining,add,stream,graph,get,stream,node,source,node,id,visited,add,source,node,id,stream,node,current,node,while,current,node,remaining,poll,null,if,generate,node,hash,current,node,hash,function,hashes,stream,graph,is,chaining,enabled,for,stream,edge,out,edge,current,node,get,out,edges,stream,node,child,out,edge,get,target,vertex,if,visited,contains,child,get,id,remaining,add,child,visited,add,child,get,id,else,visited,remove,current,node,get,id,return,hashes
StreamGraphHasherV2 -> @Override 	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph);1502726910;Returns a map with a hash for each {@link StreamNode} of the {@link_StreamGraph}. The hash is used as the {@link JobVertexID} in order to_identify nodes across job submissions if they didn't change.__<p>The complete {@link StreamGraph} is traversed. The hash is either_computed from the transformation's user-specified id (see_{@link StreamTransformation#getUid()}) or generated in a deterministic way.__<p>The generated hash is deterministic with respect to:_<ul>_<li>node-local properties (like parallelism, UDF, node ID),_<li>chained output nodes, and_<li>input nodes hashes_</ul>__@return A map from {@link StreamNode#id} to hash as 16-byte array.;@Override_	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph) {_		_		final HashFunction hashFunction = Hashing.murmur3_128(0)__		final Map<Integer, byte[]> hashes = new HashMap<>()___		Set<Integer> visited = new HashSet<>()__		Queue<StreamNode> remaining = new ArrayDeque<>()___		_		_		_		_		List<Integer> sources = new ArrayList<>()__		for (Integer sourceNodeId : streamGraph.getSourceIDs()) {_			sources.add(sourceNodeId)__		}_		Collections.sort(sources)___		_		_		_		__		_		for (Integer sourceNodeId : sources) {_			remaining.add(streamGraph.getStreamNode(sourceNodeId))__			visited.add(sourceNodeId)__		}__		StreamNode currentNode__		while ((currentNode = remaining.poll()) != null) {_			_			_			_			if (generateNodeHash(currentNode, hashFunction, hashes, streamGraph.isChainingEnabled())) {_				_				for (StreamEdge outEdge : currentNode.getOutEdges()) {_					StreamNode child = outEdge.getTargetVertex()___					if (!visited.contains(child.getId())) {_						remaining.add(child)__						visited.add(child.getId())__					}_				}_			} else {_				_				visited.remove(currentNode.getId())__			}_		}__		return hashes__	};returns,a,map,with,a,hash,for,each,link,stream,node,of,the,link,stream,graph,the,hash,is,used,as,the,link,job,vertex,id,in,order,to,identify,nodes,across,job,submissions,if,they,didn,t,change,p,the,complete,link,stream,graph,is,traversed,the,hash,is,either,computed,from,the,transformation,s,user,specified,id,see,link,stream,transformation,get,uid,or,generated,in,a,deterministic,way,p,the,generated,hash,is,deterministic,with,respect,to,ul,li,node,local,properties,like,parallelism,udf,node,id,li,chained,output,nodes,and,li,input,nodes,hashes,ul,return,a,map,from,link,stream,node,id,to,hash,as,16,byte,array;override,public,map,integer,byte,traverse,stream,graph,and,generate,hashes,stream,graph,stream,graph,final,hash,function,hash,function,hashing,0,final,map,integer,byte,hashes,new,hash,map,set,integer,visited,new,hash,set,queue,stream,node,remaining,new,array,deque,list,integer,sources,new,array,list,for,integer,source,node,id,stream,graph,get,source,ids,sources,add,source,node,id,collections,sort,sources,for,integer,source,node,id,sources,remaining,add,stream,graph,get,stream,node,source,node,id,visited,add,source,node,id,stream,node,current,node,while,current,node,remaining,poll,null,if,generate,node,hash,current,node,hash,function,hashes,stream,graph,is,chaining,enabled,for,stream,edge,out,edge,current,node,get,out,edges,stream,node,child,out,edge,get,target,vertex,if,visited,contains,child,get,id,remaining,add,child,visited,add,child,get,id,else,visited,remove,current,node,get,id,return,hashes
StreamGraphHasherV2 -> @Override 	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph);1539719877;Returns a map with a hash for each {@link StreamNode} of the {@link_StreamGraph}. The hash is used as the {@link JobVertexID} in order to_identify nodes across job submissions if they didn't change.__<p>The complete {@link StreamGraph} is traversed. The hash is either_computed from the transformation's user-specified id (see_{@link StreamTransformation#getUid()}) or generated in a deterministic way.__<p>The generated hash is deterministic with respect to:_<ul>_<li>node-local properties (node ID),_<li>chained output nodes, and_<li>input nodes hashes_</ul>__@return A map from {@link StreamNode#id} to hash as 16-byte array.;@Override_	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph) {_		_		final HashFunction hashFunction = Hashing.murmur3_128(0)__		final Map<Integer, byte[]> hashes = new HashMap<>()___		Set<Integer> visited = new HashSet<>()__		Queue<StreamNode> remaining = new ArrayDeque<>()___		_		_		_		_		List<Integer> sources = new ArrayList<>()__		for (Integer sourceNodeId : streamGraph.getSourceIDs()) {_			sources.add(sourceNodeId)__		}_		Collections.sort(sources)___		_		_		_		__		_		for (Integer sourceNodeId : sources) {_			remaining.add(streamGraph.getStreamNode(sourceNodeId))__			visited.add(sourceNodeId)__		}__		StreamNode currentNode__		while ((currentNode = remaining.poll()) != null) {_			_			_			_			if (generateNodeHash(currentNode, hashFunction, hashes, streamGraph.isChainingEnabled())) {_				_				for (StreamEdge outEdge : currentNode.getOutEdges()) {_					StreamNode child = outEdge.getTargetVertex()___					if (!visited.contains(child.getId())) {_						remaining.add(child)__						visited.add(child.getId())__					}_				}_			} else {_				_				visited.remove(currentNode.getId())__			}_		}__		return hashes__	};returns,a,map,with,a,hash,for,each,link,stream,node,of,the,link,stream,graph,the,hash,is,used,as,the,link,job,vertex,id,in,order,to,identify,nodes,across,job,submissions,if,they,didn,t,change,p,the,complete,link,stream,graph,is,traversed,the,hash,is,either,computed,from,the,transformation,s,user,specified,id,see,link,stream,transformation,get,uid,or,generated,in,a,deterministic,way,p,the,generated,hash,is,deterministic,with,respect,to,ul,li,node,local,properties,node,id,li,chained,output,nodes,and,li,input,nodes,hashes,ul,return,a,map,from,link,stream,node,id,to,hash,as,16,byte,array;override,public,map,integer,byte,traverse,stream,graph,and,generate,hashes,stream,graph,stream,graph,final,hash,function,hash,function,hashing,0,final,map,integer,byte,hashes,new,hash,map,set,integer,visited,new,hash,set,queue,stream,node,remaining,new,array,deque,list,integer,sources,new,array,list,for,integer,source,node,id,stream,graph,get,source,ids,sources,add,source,node,id,collections,sort,sources,for,integer,source,node,id,sources,remaining,add,stream,graph,get,stream,node,source,node,id,visited,add,source,node,id,stream,node,current,node,while,current,node,remaining,poll,null,if,generate,node,hash,current,node,hash,function,hashes,stream,graph,is,chaining,enabled,for,stream,edge,out,edge,current,node,get,out,edges,stream,node,child,out,edge,get,target,vertex,if,visited,contains,child,get,id,remaining,add,child,visited,add,child,get,id,else,visited,remove,current,node,get,id,return,hashes
StreamGraphHasherV2 -> @Override 	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph);1542613070;Returns a map with a hash for each {@link StreamNode} of the {@link_StreamGraph}. The hash is used as the {@link JobVertexID} in order to_identify nodes across job submissions if they didn't change.__<p>The complete {@link StreamGraph} is traversed. The hash is either_computed from the transformation's user-specified id (see_{@link StreamTransformation#getUid()}) or generated in a deterministic way.__<p>The generated hash is deterministic with respect to:_<ul>_<li>node-local properties (node ID),_<li>chained output nodes, and_<li>input nodes hashes_</ul>__@return A map from {@link StreamNode#id} to hash as 16-byte array.;@Override_	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph) {_		_		final HashFunction hashFunction = Hashing.murmur3_128(0)__		final Map<Integer, byte[]> hashes = new HashMap<>()___		Set<Integer> visited = new HashSet<>()__		Queue<StreamNode> remaining = new ArrayDeque<>()___		_		_		_		_		List<Integer> sources = new ArrayList<>()__		for (Integer sourceNodeId : streamGraph.getSourceIDs()) {_			sources.add(sourceNodeId)__		}_		Collections.sort(sources)___		_		_		_		__		_		for (Integer sourceNodeId : sources) {_			remaining.add(streamGraph.getStreamNode(sourceNodeId))__			visited.add(sourceNodeId)__		}__		StreamNode currentNode__		while ((currentNode = remaining.poll()) != null) {_			_			_			_			if (generateNodeHash(currentNode, hashFunction, hashes, streamGraph.isChainingEnabled())) {_				_				for (StreamEdge outEdge : currentNode.getOutEdges()) {_					StreamNode child = outEdge.getTargetVertex()___					if (!visited.contains(child.getId())) {_						remaining.add(child)__						visited.add(child.getId())__					}_				}_			} else {_				_				visited.remove(currentNode.getId())__			}_		}__		return hashes__	};returns,a,map,with,a,hash,for,each,link,stream,node,of,the,link,stream,graph,the,hash,is,used,as,the,link,job,vertex,id,in,order,to,identify,nodes,across,job,submissions,if,they,didn,t,change,p,the,complete,link,stream,graph,is,traversed,the,hash,is,either,computed,from,the,transformation,s,user,specified,id,see,link,stream,transformation,get,uid,or,generated,in,a,deterministic,way,p,the,generated,hash,is,deterministic,with,respect,to,ul,li,node,local,properties,node,id,li,chained,output,nodes,and,li,input,nodes,hashes,ul,return,a,map,from,link,stream,node,id,to,hash,as,16,byte,array;override,public,map,integer,byte,traverse,stream,graph,and,generate,hashes,stream,graph,stream,graph,final,hash,function,hash,function,hashing,0,final,map,integer,byte,hashes,new,hash,map,set,integer,visited,new,hash,set,queue,stream,node,remaining,new,array,deque,list,integer,sources,new,array,list,for,integer,source,node,id,stream,graph,get,source,ids,sources,add,source,node,id,collections,sort,sources,for,integer,source,node,id,sources,remaining,add,stream,graph,get,stream,node,source,node,id,visited,add,source,node,id,stream,node,current,node,while,current,node,remaining,poll,null,if,generate,node,hash,current,node,hash,function,hashes,stream,graph,is,chaining,enabled,for,stream,edge,out,edge,current,node,get,out,edges,stream,node,child,out,edge,get,target,vertex,if,visited,contains,child,get,id,remaining,add,child,visited,add,child,get,id,else,visited,remove,current,node,get,id,return,hashes
StreamGraphHasherV2 -> @Override 	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph);1547905886;Returns a map with a hash for each {@link StreamNode} of the {@link_StreamGraph}. The hash is used as the {@link JobVertexID} in order to_identify nodes across job submissions if they didn't change.__<p>The complete {@link StreamGraph} is traversed. The hash is either_computed from the transformation's user-specified id (see_{@link StreamTransformation#getUid()}) or generated in a deterministic way.__<p>The generated hash is deterministic with respect to:_<ul>_<li>node-local properties (node ID),_<li>chained output nodes, and_<li>input nodes hashes_</ul>__@return A map from {@link StreamNode#id} to hash as 16-byte array.;@Override_	public Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes(StreamGraph streamGraph) {_		_		final HashFunction hashFunction = Hashing.murmur3_128(0)__		final Map<Integer, byte[]> hashes = new HashMap<>()___		Set<Integer> visited = new HashSet<>()__		Queue<StreamNode> remaining = new ArrayDeque<>()___		_		_		_		_		List<Integer> sources = new ArrayList<>()__		for (Integer sourceNodeId : streamGraph.getSourceIDs()) {_			sources.add(sourceNodeId)__		}_		Collections.sort(sources)___		_		_		_		__		_		for (Integer sourceNodeId : sources) {_			remaining.add(streamGraph.getStreamNode(sourceNodeId))__			visited.add(sourceNodeId)__		}__		StreamNode currentNode__		while ((currentNode = remaining.poll()) != null) {_			_			_			_			if (generateNodeHash(currentNode, hashFunction, hashes, streamGraph.isChainingEnabled(), streamGraph)) {_				_				for (StreamEdge outEdge : currentNode.getOutEdges()) {_					StreamNode child = streamGraph.getTargetVertex(outEdge)___					if (!visited.contains(child.getId())) {_						remaining.add(child)__						visited.add(child.getId())__					}_				}_			} else {_				_				visited.remove(currentNode.getId())__			}_		}__		return hashes__	};returns,a,map,with,a,hash,for,each,link,stream,node,of,the,link,stream,graph,the,hash,is,used,as,the,link,job,vertex,id,in,order,to,identify,nodes,across,job,submissions,if,they,didn,t,change,p,the,complete,link,stream,graph,is,traversed,the,hash,is,either,computed,from,the,transformation,s,user,specified,id,see,link,stream,transformation,get,uid,or,generated,in,a,deterministic,way,p,the,generated,hash,is,deterministic,with,respect,to,ul,li,node,local,properties,node,id,li,chained,output,nodes,and,li,input,nodes,hashes,ul,return,a,map,from,link,stream,node,id,to,hash,as,16,byte,array;override,public,map,integer,byte,traverse,stream,graph,and,generate,hashes,stream,graph,stream,graph,final,hash,function,hash,function,hashing,0,final,map,integer,byte,hashes,new,hash,map,set,integer,visited,new,hash,set,queue,stream,node,remaining,new,array,deque,list,integer,sources,new,array,list,for,integer,source,node,id,stream,graph,get,source,ids,sources,add,source,node,id,collections,sort,sources,for,integer,source,node,id,sources,remaining,add,stream,graph,get,stream,node,source,node,id,visited,add,source,node,id,stream,node,current,node,while,current,node,remaining,poll,null,if,generate,node,hash,current,node,hash,function,hashes,stream,graph,is,chaining,enabled,stream,graph,for,stream,edge,out,edge,current,node,get,out,edges,stream,node,child,stream,graph,get,target,vertex,out,edge,if,visited,contains,child,get,id,remaining,add,child,visited,add,child,get,id,else,visited,remove,current,node,get,id,return,hashes
StreamGraphHasherV2 -> private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id);1481709237;Applies the {@link Hasher} to the {@link StreamNode} (only node local_attributes are taken into account). The hasher encapsulates the current_state of the hash.__<p>_<p>The specified ID is local to this node. We cannot use the_{@link StreamNode#id}, because it is incremented in a static counter._Therefore, the IDs for identical jobs will otherwise be different.;private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id) {_		_		_		_		hasher.putInt(id)__	};applies,the,link,hasher,to,the,link,stream,node,only,node,local,attributes,are,taken,into,account,the,hasher,encapsulates,the,current,state,of,the,hash,p,p,the,specified,id,is,local,to,this,node,we,cannot,use,the,link,stream,node,id,because,it,is,incremented,in,a,static,counter,therefore,the,ids,for,identical,jobs,will,otherwise,be,different;private,void,generate,node,local,hash,stream,node,node,hasher,hasher,int,id,hasher,put,int,id
StreamGraphHasherV2 -> private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id);1485181339;Applies the {@link Hasher} to the {@link StreamNode} (only node local_attributes are taken into account). The hasher encapsulates the current_state of the hash.__<p>_<p>The specified ID is local to this node. We cannot use the_{@link StreamNode#id}, because it is incremented in a static counter._Therefore, the IDs for identical jobs will otherwise be different.;private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id) {_		_		_		_		hasher.putInt(id)__	};applies,the,link,hasher,to,the,link,stream,node,only,node,local,attributes,are,taken,into,account,the,hasher,encapsulates,the,current,state,of,the,hash,p,p,the,specified,id,is,local,to,this,node,we,cannot,use,the,link,stream,node,id,because,it,is,incremented,in,a,static,counter,therefore,the,ids,for,identical,jobs,will,otherwise,be,different;private,void,generate,node,local,hash,stream,node,node,hasher,hasher,int,id,hasher,put,int,id
StreamGraphHasherV2 -> private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id);1493195810;Applies the {@link Hasher} to the {@link StreamNode} (only node local_attributes are taken into account). The hasher encapsulates the current_state of the hash.__<p>The specified ID is local to this node. We cannot use the_{@link StreamNode#id}, because it is incremented in a static counter._Therefore, the IDs for identical jobs will otherwise be different.;private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id) {_		_		_		_		hasher.putInt(id)__	};applies,the,link,hasher,to,the,link,stream,node,only,node,local,attributes,are,taken,into,account,the,hasher,encapsulates,the,current,state,of,the,hash,p,the,specified,id,is,local,to,this,node,we,cannot,use,the,link,stream,node,id,because,it,is,incremented,in,a,static,counter,therefore,the,ids,for,identical,jobs,will,otherwise,be,different;private,void,generate,node,local,hash,stream,node,node,hasher,hasher,int,id,hasher,put,int,id
StreamGraphHasherV2 -> private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id);1493195810;Applies the {@link Hasher} to the {@link StreamNode} (only node local_attributes are taken into account). The hasher encapsulates the current_state of the hash.__<p>The specified ID is local to this node. We cannot use the_{@link StreamNode#id}, because it is incremented in a static counter._Therefore, the IDs for identical jobs will otherwise be different.;private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id) {_		_		_		_		hasher.putInt(id)__	};applies,the,link,hasher,to,the,link,stream,node,only,node,local,attributes,are,taken,into,account,the,hasher,encapsulates,the,current,state,of,the,hash,p,the,specified,id,is,local,to,this,node,we,cannot,use,the,link,stream,node,id,because,it,is,incremented,in,a,static,counter,therefore,the,ids,for,identical,jobs,will,otherwise,be,different;private,void,generate,node,local,hash,stream,node,node,hasher,hasher,int,id,hasher,put,int,id
StreamGraphHasherV2 -> private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id);1493403095;Applies the {@link Hasher} to the {@link StreamNode} (only node local_attributes are taken into account). The hasher encapsulates the current_state of the hash.__<p>The specified ID is local to this node. We cannot use the_{@link StreamNode#id}, because it is incremented in a static counter._Therefore, the IDs for identical jobs will otherwise be different.;private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id) {_		_		_		_		hasher.putInt(id)__	};applies,the,link,hasher,to,the,link,stream,node,only,node,local,attributes,are,taken,into,account,the,hasher,encapsulates,the,current,state,of,the,hash,p,the,specified,id,is,local,to,this,node,we,cannot,use,the,link,stream,node,id,because,it,is,incremented,in,a,static,counter,therefore,the,ids,for,identical,jobs,will,otherwise,be,different;private,void,generate,node,local,hash,stream,node,node,hasher,hasher,int,id,hasher,put,int,id
StreamGraphHasherV2 -> private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id);1495484544;Applies the {@link Hasher} to the {@link StreamNode} (only node local_attributes are taken into account). The hasher encapsulates the current_state of the hash.__<p>The specified ID is local to this node. We cannot use the_{@link StreamNode#id}, because it is incremented in a static counter._Therefore, the IDs for identical jobs will otherwise be different.;private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id) {_		_		_		_		hasher.putInt(id)__	};applies,the,link,hasher,to,the,link,stream,node,only,node,local,attributes,are,taken,into,account,the,hasher,encapsulates,the,current,state,of,the,hash,p,the,specified,id,is,local,to,this,node,we,cannot,use,the,link,stream,node,id,because,it,is,incremented,in,a,static,counter,therefore,the,ids,for,identical,jobs,will,otherwise,be,different;private,void,generate,node,local,hash,stream,node,node,hasher,hasher,int,id,hasher,put,int,id
StreamGraphHasherV2 -> private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id);1502726910;Applies the {@link Hasher} to the {@link StreamNode} (only node local_attributes are taken into account). The hasher encapsulates the current_state of the hash.__<p>The specified ID is local to this node. We cannot use the_{@link StreamNode#id}, because it is incremented in a static counter._Therefore, the IDs for identical jobs will otherwise be different.;private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id) {_		_		_		_		hasher.putInt(id)__	};applies,the,link,hasher,to,the,link,stream,node,only,node,local,attributes,are,taken,into,account,the,hasher,encapsulates,the,current,state,of,the,hash,p,the,specified,id,is,local,to,this,node,we,cannot,use,the,link,stream,node,id,because,it,is,incremented,in,a,static,counter,therefore,the,ids,for,identical,jobs,will,otherwise,be,different;private,void,generate,node,local,hash,stream,node,node,hasher,hasher,int,id,hasher,put,int,id
StreamGraphHasherV2 -> private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher);1481709237;Generates a hash from a user-specified ID.;private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher) {_		hasher.putString(node.getTransformationId(), Charset.forName("UTF-8"))___		return hasher.hash().asBytes()__	};generates,a,hash,from,a,user,specified,id;private,byte,generate,user,specified,hash,stream,node,node,hasher,hasher,hasher,put,string,node,get,transformation,id,charset,for,name,utf,8,return,hasher,hash,as,bytes
StreamGraphHasherV2 -> private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher);1485181339;Generates a hash from a user-specified ID.;private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher) {_		hasher.putString(node.getTransformationUID(), Charset.forName("UTF-8"))___		return hasher.hash().asBytes()__	};generates,a,hash,from,a,user,specified,id;private,byte,generate,user,specified,hash,stream,node,node,hasher,hasher,hasher,put,string,node,get,transformation,uid,charset,for,name,utf,8,return,hasher,hash,as,bytes
StreamGraphHasherV2 -> private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher);1493195810;Generates a hash from a user-specified ID.;private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher) {_		hasher.putString(node.getTransformationUID(), Charset.forName("UTF-8"))___		return hasher.hash().asBytes()__	};generates,a,hash,from,a,user,specified,id;private,byte,generate,user,specified,hash,stream,node,node,hasher,hasher,hasher,put,string,node,get,transformation,uid,charset,for,name,utf,8,return,hasher,hash,as,bytes
StreamGraphHasherV2 -> private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher);1493195810;Generates a hash from a user-specified ID.;private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher) {_		hasher.putString(node.getTransformationUID(), Charset.forName("UTF-8"))___		return hasher.hash().asBytes()__	};generates,a,hash,from,a,user,specified,id;private,byte,generate,user,specified,hash,stream,node,node,hasher,hasher,hasher,put,string,node,get,transformation,uid,charset,for,name,utf,8,return,hasher,hash,as,bytes
StreamGraphHasherV2 -> private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher);1493403095;Generates a hash from a user-specified ID.;private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher) {_		hasher.putString(node.getTransformationUID(), Charset.forName("UTF-8"))___		return hasher.hash().asBytes()__	};generates,a,hash,from,a,user,specified,id;private,byte,generate,user,specified,hash,stream,node,node,hasher,hasher,hasher,put,string,node,get,transformation,uid,charset,for,name,utf,8,return,hasher,hash,as,bytes
StreamGraphHasherV2 -> private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher);1495484544;Generates a hash from a user-specified ID.;private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher) {_		hasher.putString(node.getTransformationUID(), Charset.forName("UTF-8"))___		return hasher.hash().asBytes()__	};generates,a,hash,from,a,user,specified,id;private,byte,generate,user,specified,hash,stream,node,node,hasher,hasher,hasher,put,string,node,get,transformation,uid,charset,for,name,utf,8,return,hasher,hash,as,bytes
StreamGraphHasherV2 -> private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher);1502726910;Generates a hash from a user-specified ID.;private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher) {_		hasher.putString(node.getTransformationUID(), Charset.forName("UTF-8"))___		return hasher.hash().asBytes()__	};generates,a,hash,from,a,user,specified,id;private,byte,generate,user,specified,hash,stream,node,node,hasher,hasher,hasher,put,string,node,get,transformation,uid,charset,for,name,utf,8,return,hasher,hash,as,bytes
StreamGraphHasherV2 -> private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher);1539719877;Generates a hash from a user-specified ID.;private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher) {_		hasher.putString(node.getTransformationUID(), Charset.forName("UTF-8"))___		return hasher.hash().asBytes()__	};generates,a,hash,from,a,user,specified,id;private,byte,generate,user,specified,hash,stream,node,node,hasher,hasher,hasher,put,string,node,get,transformation,uid,charset,for,name,utf,8,return,hasher,hash,as,bytes
StreamGraphHasherV2 -> private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher);1542613070;Generates a hash from a user-specified ID.;private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher) {_		hasher.putString(node.getTransformationUID(), Charset.forName("UTF-8"))___		return hasher.hash().asBytes()__	};generates,a,hash,from,a,user,specified,id;private,byte,generate,user,specified,hash,stream,node,node,hasher,hasher,hasher,put,string,node,get,transformation,uid,charset,for,name,utf,8,return,hasher,hash,as,bytes
StreamGraphHasherV2 -> private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher);1547905886;Generates a hash from a user-specified ID.;private byte[] generateUserSpecifiedHash(StreamNode node, Hasher hasher) {_		hasher.putString(node.getTransformationUID(), Charset.forName("UTF-8"))___		return hasher.hash().asBytes()__	};generates,a,hash,from,a,user,specified,id;private,byte,generate,user,specified,hash,stream,node,node,hasher,hasher,hasher,put,string,node,get,transformation,uid,charset,for,name,utf,8,return,hasher,hash,as,bytes
StreamGraphHasherV2 -> private boolean generateNodeHash( 			StreamNode node, 			HashFunction hashFunction, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1481709237;Generates a hash for the node and returns whether the operation was_successful.__@param node         The node to generate the hash for_@param hashFunction The hash function to use_@param hashes       The current state of generated hashes_@return <code>true</code> if the node hash has been generated._<code>false</code>, otherwise. If the operation is not successful, the_hash needs be generated at a later point when all input is available._@throws IllegalStateException If node has user-specified hash and is_intermediate node of a chain;private boolean generateNodeHash(_			StreamNode node,_			HashFunction hashFunction,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		String userSpecifiedHash = node.getTransformationId()___		if (userSpecifiedHash == null) {_			_			for (StreamEdge inEdge : node.getInEdges()) {_				_				_				_				if (!hashes.containsKey(inEdge.getSourceId())) {_					return false__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateDeterministicHash(node, hasher, hashes, isChainingEnabled)___			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		} else {_			_			_			_			_			for (StreamEdge inEdge : node.getInEdges()) {_				if (isChainable(inEdge, isChainingEnabled)) {_					throw new UnsupportedOperationException("Cannot assign user-specified hash "_							+ "to intermediate node in chain. This will be supported in future "_							+ "versions of Flink. As a work around start new chain at task "_							+ node.getOperatorName() + ".")__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateUserSpecifiedHash(node, hasher)___			for (byte[] previousHash : hashes.values()) {_				if (Arrays.equals(previousHash, hash)) {_					throw new IllegalArgumentException("Hash collision on user-specified ID. " +_							"Most likely cause is a non-unique ID. Please check that all IDs " +_							"specified via `uid(String)` are unique.")__				}_			}__			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		}_	};generates,a,hash,for,the,node,and,returns,whether,the,operation,was,successful,param,node,the,node,to,generate,the,hash,for,param,hash,function,the,hash,function,to,use,param,hashes,the,current,state,of,generated,hashes,return,code,true,code,if,the,node,hash,has,been,generated,code,false,code,otherwise,if,the,operation,is,not,successful,the,hash,needs,be,generated,at,a,later,point,when,all,input,is,available,throws,illegal,state,exception,if,node,has,user,specified,hash,and,is,intermediate,node,of,a,chain;private,boolean,generate,node,hash,stream,node,node,hash,function,hash,function,map,integer,byte,hashes,boolean,is,chaining,enabled,string,user,specified,hash,node,get,transformation,id,if,user,specified,hash,null,for,stream,edge,in,edge,node,get,in,edges,if,hashes,contains,key,in,edge,get,source,id,return,false,hasher,hasher,hash,function,new,hasher,byte,hash,generate,deterministic,hash,node,hasher,hashes,is,chaining,enabled,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true,else,for,stream,edge,in,edge,node,get,in,edges,if,is,chainable,in,edge,is,chaining,enabled,throw,new,unsupported,operation,exception,cannot,assign,user,specified,hash,to,intermediate,node,in,chain,this,will,be,supported,in,future,versions,of,flink,as,a,work,around,start,new,chain,at,task,node,get,operator,name,hasher,hasher,hash,function,new,hasher,byte,hash,generate,user,specified,hash,node,hasher,for,byte,previous,hash,hashes,values,if,arrays,equals,previous,hash,hash,throw,new,illegal,argument,exception,hash,collision,on,user,specified,id,most,likely,cause,is,a,non,unique,id,please,check,that,all,ids,specified,via,uid,string,are,unique,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true
StreamGraphHasherV2 -> private boolean generateNodeHash( 			StreamNode node, 			HashFunction hashFunction, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1485181339;Generates a hash for the node and returns whether the operation was_successful.__@param node         The node to generate the hash for_@param hashFunction The hash function to use_@param hashes       The current state of generated hashes_@return <code>true</code> if the node hash has been generated._<code>false</code>, otherwise. If the operation is not successful, the_hash needs be generated at a later point when all input is available._@throws IllegalStateException If node has user-specified hash and is_intermediate node of a chain;private boolean generateNodeHash(_			StreamNode node,_			HashFunction hashFunction,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		String userSpecifiedHash = node.getTransformationUID()___		if (userSpecifiedHash == null) {_			_			for (StreamEdge inEdge : node.getInEdges()) {_				_				_				_				if (!hashes.containsKey(inEdge.getSourceId())) {_					return false__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateDeterministicHash(node, hasher, hashes, isChainingEnabled)___			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		} else {_			_			_			_			_			for (StreamEdge inEdge : node.getInEdges()) {_				if (isChainable(inEdge, isChainingEnabled)) {_					throw new UnsupportedOperationException("Cannot assign user-specified hash "_							+ "to intermediate node in chain. This will be supported in future "_							+ "versions of Flink. As a work around start new chain at task "_							+ node.getOperatorName() + ".")__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateUserSpecifiedHash(node, hasher)___			for (byte[] previousHash : hashes.values()) {_				if (Arrays.equals(previousHash, hash)) {_					throw new IllegalArgumentException("Hash collision on user-specified ID. " +_							"Most likely cause is a non-unique ID. Please check that all IDs " +_							"specified via `uid(String)` are unique.")__				}_			}__			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		}_	};generates,a,hash,for,the,node,and,returns,whether,the,operation,was,successful,param,node,the,node,to,generate,the,hash,for,param,hash,function,the,hash,function,to,use,param,hashes,the,current,state,of,generated,hashes,return,code,true,code,if,the,node,hash,has,been,generated,code,false,code,otherwise,if,the,operation,is,not,successful,the,hash,needs,be,generated,at,a,later,point,when,all,input,is,available,throws,illegal,state,exception,if,node,has,user,specified,hash,and,is,intermediate,node,of,a,chain;private,boolean,generate,node,hash,stream,node,node,hash,function,hash,function,map,integer,byte,hashes,boolean,is,chaining,enabled,string,user,specified,hash,node,get,transformation,uid,if,user,specified,hash,null,for,stream,edge,in,edge,node,get,in,edges,if,hashes,contains,key,in,edge,get,source,id,return,false,hasher,hasher,hash,function,new,hasher,byte,hash,generate,deterministic,hash,node,hasher,hashes,is,chaining,enabled,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true,else,for,stream,edge,in,edge,node,get,in,edges,if,is,chainable,in,edge,is,chaining,enabled,throw,new,unsupported,operation,exception,cannot,assign,user,specified,hash,to,intermediate,node,in,chain,this,will,be,supported,in,future,versions,of,flink,as,a,work,around,start,new,chain,at,task,node,get,operator,name,hasher,hasher,hash,function,new,hasher,byte,hash,generate,user,specified,hash,node,hasher,for,byte,previous,hash,hashes,values,if,arrays,equals,previous,hash,hash,throw,new,illegal,argument,exception,hash,collision,on,user,specified,id,most,likely,cause,is,a,non,unique,id,please,check,that,all,ids,specified,via,uid,string,are,unique,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true
StreamGraphHasherV2 -> private boolean generateNodeHash( 			StreamNode node, 			HashFunction hashFunction, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1493195810;Generates a hash for the node and returns whether the operation was_successful.__@param node         The node to generate the hash for_@param hashFunction The hash function to use_@param hashes       The current state of generated hashes_@return <code>true</code> if the node hash has been generated._<code>false</code>, otherwise. If the operation is not successful, the_hash needs be generated at a later point when all input is available._@throws IllegalStateException If node has user-specified hash and is_intermediate node of a chain;private boolean generateNodeHash(_			StreamNode node,_			HashFunction hashFunction,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		String userSpecifiedHash = node.getTransformationUID()___		if (userSpecifiedHash == null) {_			_			for (StreamEdge inEdge : node.getInEdges()) {_				_				_				_				if (!hashes.containsKey(inEdge.getSourceId())) {_					return false__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateDeterministicHash(node, hasher, hashes, isChainingEnabled)___			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		} else {_			_			_			_			_			for (StreamEdge inEdge : node.getInEdges()) {_				if (isChainable(inEdge, isChainingEnabled)) {_					throw new UnsupportedOperationException("Cannot assign user-specified hash "_							+ "to intermediate node in chain. This will be supported in future "_							+ "versions of Flink. As a work around start new chain at task "_							+ node.getOperatorName() + ".")__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateUserSpecifiedHash(node, hasher)___			for (byte[] previousHash : hashes.values()) {_				if (Arrays.equals(previousHash, hash)) {_					throw new IllegalArgumentException("Hash collision on user-specified ID. " +_							"Most likely cause is a non-unique ID. Please check that all IDs " +_							"specified via `uid(String)` are unique.")__				}_			}__			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		}_	};generates,a,hash,for,the,node,and,returns,whether,the,operation,was,successful,param,node,the,node,to,generate,the,hash,for,param,hash,function,the,hash,function,to,use,param,hashes,the,current,state,of,generated,hashes,return,code,true,code,if,the,node,hash,has,been,generated,code,false,code,otherwise,if,the,operation,is,not,successful,the,hash,needs,be,generated,at,a,later,point,when,all,input,is,available,throws,illegal,state,exception,if,node,has,user,specified,hash,and,is,intermediate,node,of,a,chain;private,boolean,generate,node,hash,stream,node,node,hash,function,hash,function,map,integer,byte,hashes,boolean,is,chaining,enabled,string,user,specified,hash,node,get,transformation,uid,if,user,specified,hash,null,for,stream,edge,in,edge,node,get,in,edges,if,hashes,contains,key,in,edge,get,source,id,return,false,hasher,hasher,hash,function,new,hasher,byte,hash,generate,deterministic,hash,node,hasher,hashes,is,chaining,enabled,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true,else,for,stream,edge,in,edge,node,get,in,edges,if,is,chainable,in,edge,is,chaining,enabled,throw,new,unsupported,operation,exception,cannot,assign,user,specified,hash,to,intermediate,node,in,chain,this,will,be,supported,in,future,versions,of,flink,as,a,work,around,start,new,chain,at,task,node,get,operator,name,hasher,hasher,hash,function,new,hasher,byte,hash,generate,user,specified,hash,node,hasher,for,byte,previous,hash,hashes,values,if,arrays,equals,previous,hash,hash,throw,new,illegal,argument,exception,hash,collision,on,user,specified,id,most,likely,cause,is,a,non,unique,id,please,check,that,all,ids,specified,via,uid,string,are,unique,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true
StreamGraphHasherV2 -> private boolean generateNodeHash( 			StreamNode node, 			HashFunction hashFunction, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1493195810;Generates a hash for the node and returns whether the operation was_successful.__@param node         The node to generate the hash for_@param hashFunction The hash function to use_@param hashes       The current state of generated hashes_@return <code>true</code> if the node hash has been generated._<code>false</code>, otherwise. If the operation is not successful, the_hash needs be generated at a later point when all input is available._@throws IllegalStateException If node has user-specified hash and is_intermediate node of a chain;private boolean generateNodeHash(_			StreamNode node,_			HashFunction hashFunction,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		String userSpecifiedHash = node.getTransformationUID()___		if (userSpecifiedHash == null) {_			_			for (StreamEdge inEdge : node.getInEdges()) {_				_				_				_				if (!hashes.containsKey(inEdge.getSourceId())) {_					return false__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateDeterministicHash(node, hasher, hashes, isChainingEnabled)___			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		} else {_			_			_			_			_			for (StreamEdge inEdge : node.getInEdges()) {_				if (isChainable(inEdge, isChainingEnabled)) {_					throw new UnsupportedOperationException("Cannot assign user-specified hash "_							+ "to intermediate node in chain. This will be supported in future "_							+ "versions of Flink. As a work around start new chain at task "_							+ node.getOperatorName() + ".")__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateUserSpecifiedHash(node, hasher)___			for (byte[] previousHash : hashes.values()) {_				if (Arrays.equals(previousHash, hash)) {_					throw new IllegalArgumentException("Hash collision on user-specified ID. " +_							"Most likely cause is a non-unique ID. Please check that all IDs " +_							"specified via `uid(String)` are unique.")__				}_			}__			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		}_	};generates,a,hash,for,the,node,and,returns,whether,the,operation,was,successful,param,node,the,node,to,generate,the,hash,for,param,hash,function,the,hash,function,to,use,param,hashes,the,current,state,of,generated,hashes,return,code,true,code,if,the,node,hash,has,been,generated,code,false,code,otherwise,if,the,operation,is,not,successful,the,hash,needs,be,generated,at,a,later,point,when,all,input,is,available,throws,illegal,state,exception,if,node,has,user,specified,hash,and,is,intermediate,node,of,a,chain;private,boolean,generate,node,hash,stream,node,node,hash,function,hash,function,map,integer,byte,hashes,boolean,is,chaining,enabled,string,user,specified,hash,node,get,transformation,uid,if,user,specified,hash,null,for,stream,edge,in,edge,node,get,in,edges,if,hashes,contains,key,in,edge,get,source,id,return,false,hasher,hasher,hash,function,new,hasher,byte,hash,generate,deterministic,hash,node,hasher,hashes,is,chaining,enabled,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true,else,for,stream,edge,in,edge,node,get,in,edges,if,is,chainable,in,edge,is,chaining,enabled,throw,new,unsupported,operation,exception,cannot,assign,user,specified,hash,to,intermediate,node,in,chain,this,will,be,supported,in,future,versions,of,flink,as,a,work,around,start,new,chain,at,task,node,get,operator,name,hasher,hasher,hash,function,new,hasher,byte,hash,generate,user,specified,hash,node,hasher,for,byte,previous,hash,hashes,values,if,arrays,equals,previous,hash,hash,throw,new,illegal,argument,exception,hash,collision,on,user,specified,id,most,likely,cause,is,a,non,unique,id,please,check,that,all,ids,specified,via,uid,string,are,unique,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true
StreamGraphHasherV2 -> private boolean generateNodeHash( 			StreamNode node, 			HashFunction hashFunction, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1493403095;Generates a hash for the node and returns whether the operation was_successful.__@param node         The node to generate the hash for_@param hashFunction The hash function to use_@param hashes       The current state of generated hashes_@return <code>true</code> if the node hash has been generated._<code>false</code>, otherwise. If the operation is not successful, the_hash needs be generated at a later point when all input is available._@throws IllegalStateException If node has user-specified hash and is_intermediate node of a chain;private boolean generateNodeHash(_			StreamNode node,_			HashFunction hashFunction,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		String userSpecifiedHash = node.getTransformationUID()___		if (userSpecifiedHash == null) {_			_			for (StreamEdge inEdge : node.getInEdges()) {_				_				_				_				if (!hashes.containsKey(inEdge.getSourceId())) {_					return false__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateDeterministicHash(node, hasher, hashes, isChainingEnabled)___			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		} else {_			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateUserSpecifiedHash(node, hasher)___			for (byte[] previousHash : hashes.values()) {_				if (Arrays.equals(previousHash, hash)) {_					throw new IllegalArgumentException("Hash collision on user-specified ID. " +_							"Most likely cause is a non-unique ID. Please check that all IDs " +_							"specified via `uid(String)` are unique.")__				}_			}__			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		}_	};generates,a,hash,for,the,node,and,returns,whether,the,operation,was,successful,param,node,the,node,to,generate,the,hash,for,param,hash,function,the,hash,function,to,use,param,hashes,the,current,state,of,generated,hashes,return,code,true,code,if,the,node,hash,has,been,generated,code,false,code,otherwise,if,the,operation,is,not,successful,the,hash,needs,be,generated,at,a,later,point,when,all,input,is,available,throws,illegal,state,exception,if,node,has,user,specified,hash,and,is,intermediate,node,of,a,chain;private,boolean,generate,node,hash,stream,node,node,hash,function,hash,function,map,integer,byte,hashes,boolean,is,chaining,enabled,string,user,specified,hash,node,get,transformation,uid,if,user,specified,hash,null,for,stream,edge,in,edge,node,get,in,edges,if,hashes,contains,key,in,edge,get,source,id,return,false,hasher,hasher,hash,function,new,hasher,byte,hash,generate,deterministic,hash,node,hasher,hashes,is,chaining,enabled,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true,else,hasher,hasher,hash,function,new,hasher,byte,hash,generate,user,specified,hash,node,hasher,for,byte,previous,hash,hashes,values,if,arrays,equals,previous,hash,hash,throw,new,illegal,argument,exception,hash,collision,on,user,specified,id,most,likely,cause,is,a,non,unique,id,please,check,that,all,ids,specified,via,uid,string,are,unique,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true
StreamGraphHasherV2 -> private boolean generateNodeHash( 			StreamNode node, 			HashFunction hashFunction, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1495484544;Generates a hash for the node and returns whether the operation was_successful.__@param node         The node to generate the hash for_@param hashFunction The hash function to use_@param hashes       The current state of generated hashes_@return <code>true</code> if the node hash has been generated._<code>false</code>, otherwise. If the operation is not successful, the_hash needs be generated at a later point when all input is available._@throws IllegalStateException If node has user-specified hash and is_intermediate node of a chain;private boolean generateNodeHash(_			StreamNode node,_			HashFunction hashFunction,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		String userSpecifiedHash = node.getTransformationUID()___		if (userSpecifiedHash == null) {_			_			for (StreamEdge inEdge : node.getInEdges()) {_				_				_				_				if (!hashes.containsKey(inEdge.getSourceId())) {_					return false__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateDeterministicHash(node, hasher, hashes, isChainingEnabled)___			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		} else {_			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateUserSpecifiedHash(node, hasher)___			for (byte[] previousHash : hashes.values()) {_				if (Arrays.equals(previousHash, hash)) {_					throw new IllegalArgumentException("Hash collision on user-specified ID. " +_							"Most likely cause is a non-unique ID. Please check that all IDs " +_							"specified via `uid(String)` are unique.")__				}_			}__			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		}_	};generates,a,hash,for,the,node,and,returns,whether,the,operation,was,successful,param,node,the,node,to,generate,the,hash,for,param,hash,function,the,hash,function,to,use,param,hashes,the,current,state,of,generated,hashes,return,code,true,code,if,the,node,hash,has,been,generated,code,false,code,otherwise,if,the,operation,is,not,successful,the,hash,needs,be,generated,at,a,later,point,when,all,input,is,available,throws,illegal,state,exception,if,node,has,user,specified,hash,and,is,intermediate,node,of,a,chain;private,boolean,generate,node,hash,stream,node,node,hash,function,hash,function,map,integer,byte,hashes,boolean,is,chaining,enabled,string,user,specified,hash,node,get,transformation,uid,if,user,specified,hash,null,for,stream,edge,in,edge,node,get,in,edges,if,hashes,contains,key,in,edge,get,source,id,return,false,hasher,hasher,hash,function,new,hasher,byte,hash,generate,deterministic,hash,node,hasher,hashes,is,chaining,enabled,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true,else,hasher,hasher,hash,function,new,hasher,byte,hash,generate,user,specified,hash,node,hasher,for,byte,previous,hash,hashes,values,if,arrays,equals,previous,hash,hash,throw,new,illegal,argument,exception,hash,collision,on,user,specified,id,most,likely,cause,is,a,non,unique,id,please,check,that,all,ids,specified,via,uid,string,are,unique,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true
StreamGraphHasherV2 -> private boolean generateNodeHash( 			StreamNode node, 			HashFunction hashFunction, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1502726910;Generates a hash for the node and returns whether the operation was_successful.__@param node         The node to generate the hash for_@param hashFunction The hash function to use_@param hashes       The current state of generated hashes_@return <code>true</code> if the node hash has been generated._<code>false</code>, otherwise. If the operation is not successful, the_hash needs be generated at a later point when all input is available._@throws IllegalStateException If node has user-specified hash and is_intermediate node of a chain;private boolean generateNodeHash(_			StreamNode node,_			HashFunction hashFunction,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		String userSpecifiedHash = node.getTransformationUID()___		if (userSpecifiedHash == null) {_			_			for (StreamEdge inEdge : node.getInEdges()) {_				_				_				_				if (!hashes.containsKey(inEdge.getSourceId())) {_					return false__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateDeterministicHash(node, hasher, hashes, isChainingEnabled)___			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		} else {_			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateUserSpecifiedHash(node, hasher)___			for (byte[] previousHash : hashes.values()) {_				if (Arrays.equals(previousHash, hash)) {_					throw new IllegalArgumentException("Hash collision on user-specified ID. " +_							"Most likely cause is a non-unique ID. Please check that all IDs " +_							"specified via `uid(String)` are unique.")__				}_			}__			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		}_	};generates,a,hash,for,the,node,and,returns,whether,the,operation,was,successful,param,node,the,node,to,generate,the,hash,for,param,hash,function,the,hash,function,to,use,param,hashes,the,current,state,of,generated,hashes,return,code,true,code,if,the,node,hash,has,been,generated,code,false,code,otherwise,if,the,operation,is,not,successful,the,hash,needs,be,generated,at,a,later,point,when,all,input,is,available,throws,illegal,state,exception,if,node,has,user,specified,hash,and,is,intermediate,node,of,a,chain;private,boolean,generate,node,hash,stream,node,node,hash,function,hash,function,map,integer,byte,hashes,boolean,is,chaining,enabled,string,user,specified,hash,node,get,transformation,uid,if,user,specified,hash,null,for,stream,edge,in,edge,node,get,in,edges,if,hashes,contains,key,in,edge,get,source,id,return,false,hasher,hasher,hash,function,new,hasher,byte,hash,generate,deterministic,hash,node,hasher,hashes,is,chaining,enabled,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true,else,hasher,hasher,hash,function,new,hasher,byte,hash,generate,user,specified,hash,node,hasher,for,byte,previous,hash,hashes,values,if,arrays,equals,previous,hash,hash,throw,new,illegal,argument,exception,hash,collision,on,user,specified,id,most,likely,cause,is,a,non,unique,id,please,check,that,all,ids,specified,via,uid,string,are,unique,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true
StreamGraphHasherV2 -> private boolean generateNodeHash( 			StreamNode node, 			HashFunction hashFunction, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1539719877;Generates a hash for the node and returns whether the operation was_successful.__@param node         The node to generate the hash for_@param hashFunction The hash function to use_@param hashes       The current state of generated hashes_@return <code>true</code> if the node hash has been generated._<code>false</code>, otherwise. If the operation is not successful, the_hash needs be generated at a later point when all input is available._@throws IllegalStateException If node has user-specified hash and is_intermediate node of a chain;private boolean generateNodeHash(_			StreamNode node,_			HashFunction hashFunction,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		String userSpecifiedHash = node.getTransformationUID()___		if (userSpecifiedHash == null) {_			_			for (StreamEdge inEdge : node.getInEdges()) {_				_				_				_				if (!hashes.containsKey(inEdge.getSourceId())) {_					return false__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateDeterministicHash(node, hasher, hashes, isChainingEnabled)___			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		} else {_			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateUserSpecifiedHash(node, hasher)___			for (byte[] previousHash : hashes.values()) {_				if (Arrays.equals(previousHash, hash)) {_					throw new IllegalArgumentException("Hash collision on user-specified ID. " +_							"Most likely cause is a non-unique ID. Please check that all IDs " +_							"specified via `uid(String)` are unique.")__				}_			}__			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		}_	};generates,a,hash,for,the,node,and,returns,whether,the,operation,was,successful,param,node,the,node,to,generate,the,hash,for,param,hash,function,the,hash,function,to,use,param,hashes,the,current,state,of,generated,hashes,return,code,true,code,if,the,node,hash,has,been,generated,code,false,code,otherwise,if,the,operation,is,not,successful,the,hash,needs,be,generated,at,a,later,point,when,all,input,is,available,throws,illegal,state,exception,if,node,has,user,specified,hash,and,is,intermediate,node,of,a,chain;private,boolean,generate,node,hash,stream,node,node,hash,function,hash,function,map,integer,byte,hashes,boolean,is,chaining,enabled,string,user,specified,hash,node,get,transformation,uid,if,user,specified,hash,null,for,stream,edge,in,edge,node,get,in,edges,if,hashes,contains,key,in,edge,get,source,id,return,false,hasher,hasher,hash,function,new,hasher,byte,hash,generate,deterministic,hash,node,hasher,hashes,is,chaining,enabled,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true,else,hasher,hasher,hash,function,new,hasher,byte,hash,generate,user,specified,hash,node,hasher,for,byte,previous,hash,hashes,values,if,arrays,equals,previous,hash,hash,throw,new,illegal,argument,exception,hash,collision,on,user,specified,id,most,likely,cause,is,a,non,unique,id,please,check,that,all,ids,specified,via,uid,string,are,unique,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true
StreamGraphHasherV2 -> private boolean generateNodeHash( 			StreamNode node, 			HashFunction hashFunction, 			Map<Integer, byte[]> hashes, 			boolean isChainingEnabled);1542613070;Generates a hash for the node and returns whether the operation was_successful.__@param node         The node to generate the hash for_@param hashFunction The hash function to use_@param hashes       The current state of generated hashes_@return <code>true</code> if the node hash has been generated._<code>false</code>, otherwise. If the operation is not successful, the_hash needs be generated at a later point when all input is available._@throws IllegalStateException If node has user-specified hash and is_intermediate node of a chain;private boolean generateNodeHash(_			StreamNode node,_			HashFunction hashFunction,_			Map<Integer, byte[]> hashes,_			boolean isChainingEnabled) {__		_		String userSpecifiedHash = node.getTransformationUID()___		if (userSpecifiedHash == null) {_			_			for (StreamEdge inEdge : node.getInEdges()) {_				_				_				_				if (!hashes.containsKey(inEdge.getSourceId())) {_					return false__				}_			}__			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateDeterministicHash(node, hasher, hashes, isChainingEnabled)___			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		} else {_			Hasher hasher = hashFunction.newHasher()__			byte[] hash = generateUserSpecifiedHash(node, hasher)___			for (byte[] previousHash : hashes.values()) {_				if (Arrays.equals(previousHash, hash)) {_					throw new IllegalArgumentException("Hash collision on user-specified ID " +_							"\"" + userSpecifiedHash + "\". " +_							"Most likely cause is a non-unique ID. Please check that all IDs " +_							"specified via `uid(String)` are unique.")__				}_			}__			if (hashes.put(node.getId(), hash) != null) {_				_				throw new IllegalStateException("Unexpected state. Tried to add node hash " +_						"twice. This is probably a bug in the JobGraph generator.")__			}__			return true__		}_	};generates,a,hash,for,the,node,and,returns,whether,the,operation,was,successful,param,node,the,node,to,generate,the,hash,for,param,hash,function,the,hash,function,to,use,param,hashes,the,current,state,of,generated,hashes,return,code,true,code,if,the,node,hash,has,been,generated,code,false,code,otherwise,if,the,operation,is,not,successful,the,hash,needs,be,generated,at,a,later,point,when,all,input,is,available,throws,illegal,state,exception,if,node,has,user,specified,hash,and,is,intermediate,node,of,a,chain;private,boolean,generate,node,hash,stream,node,node,hash,function,hash,function,map,integer,byte,hashes,boolean,is,chaining,enabled,string,user,specified,hash,node,get,transformation,uid,if,user,specified,hash,null,for,stream,edge,in,edge,node,get,in,edges,if,hashes,contains,key,in,edge,get,source,id,return,false,hasher,hasher,hash,function,new,hasher,byte,hash,generate,deterministic,hash,node,hasher,hashes,is,chaining,enabled,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true,else,hasher,hasher,hash,function,new,hasher,byte,hash,generate,user,specified,hash,node,hasher,for,byte,previous,hash,hashes,values,if,arrays,equals,previous,hash,hash,throw,new,illegal,argument,exception,hash,collision,on,user,specified,id,user,specified,hash,most,likely,cause,is,a,non,unique,id,please,check,that,all,ids,specified,via,uid,string,are,unique,if,hashes,put,node,get,id,hash,null,throw,new,illegal,state,exception,unexpected,state,tried,to,add,node,hash,twice,this,is,probably,a,bug,in,the,job,graph,generator,return,true
