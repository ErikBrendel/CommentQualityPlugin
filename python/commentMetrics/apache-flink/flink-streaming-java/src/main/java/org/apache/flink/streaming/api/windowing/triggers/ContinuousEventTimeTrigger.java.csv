commented;modifiers;parameterAmount;loc;comment;code
false;public;4;20;;@Override public TriggerResult onElement(Object element, long timestamp, W window, TriggerContext ctx) throws Exception {     if (window.maxTimestamp() <= ctx.getCurrentWatermark()) {         // if the watermark is already past the window fire immediately         return TriggerResult.FIRE.     } else {         ctx.registerEventTimeTimer(window.maxTimestamp()).     }     ReducingState<Long> fireTimestamp = ctx.getPartitionedState(stateDesc).     if (fireTimestamp.get() == null) {         long start = timestamp - (timestamp % interval).         long nextFireTimestamp = start + interval.         ctx.registerEventTimeTimer(nextFireTimestamp).         fireTimestamp.add(nextFireTimestamp).     }     return TriggerResult.CONTINUE. }
false;public;3;20;;@Override public TriggerResult onEventTime(long time, W window, TriggerContext ctx) throws Exception {     if (time == window.maxTimestamp()) {         return TriggerResult.FIRE.     }     ReducingState<Long> fireTimestampState = ctx.getPartitionedState(stateDesc).     Long fireTimestamp = fireTimestampState.get().     if (fireTimestamp != null && fireTimestamp == time) {         fireTimestampState.clear().         fireTimestampState.add(time + interval).         ctx.registerEventTimeTimer(time + interval).         return TriggerResult.FIRE.     }     return TriggerResult.CONTINUE. }
false;public;3;4;;@Override public TriggerResult onProcessingTime(long time, W window, TriggerContext ctx) throws Exception {     return TriggerResult.CONTINUE. }
false;public;2;9;;@Override public void clear(W window, TriggerContext ctx) throws Exception {     ReducingState<Long> fireTimestamp = ctx.getPartitionedState(stateDesc).     Long timestamp = fireTimestamp.get().     if (timestamp != null) {         ctx.deleteEventTimeTimer(timestamp).         fireTimestamp.clear().     } }
false;public;0;4;;@Override public boolean canMerge() {     return true. }
false;public;2;8;;@Override public void onMerge(W window, OnMergeContext ctx) throws Exception {     ctx.mergePartitionedState(stateDesc).     Long nextFireTimestamp = ctx.getPartitionedState(stateDesc).get().     if (nextFireTimestamp != null) {         ctx.registerEventTimeTimer(nextFireTimestamp).     } }
false;public;0;4;;@Override public String toString() {     return "ContinuousEventTimeTrigger(" + interval + ")". }
false;public;0;4;;@VisibleForTesting public long getInterval() {     return interval. }
true;public,static;1;3;/**  * Creates a trigger that continuously fires based on the given interval.  *  * @param interval The time interval at which to fire.  * @param <W> The type of {@link Window Windows} on which this trigger can operate.  */ ;/**  * Creates a trigger that continuously fires based on the given interval.  *  * @param interval The time interval at which to fire.  * @param <W> The type of {@link Window Windows} on which this trigger can operate.  */ public static <W extends Window> ContinuousEventTimeTrigger<W> of(Time interval) {     return new ContinuousEventTimeTrigger<>(interval.toMilliseconds()). }
false;public;2;4;;@Override public Long reduce(Long value1, Long value2) throws Exception {     return Math.min(value1, value2). }
