commented;modifiers;parameterAmount;loc;comment;code
false;public;3;29;;@Override public void setup(StreamTask<?, ?> containingTask, StreamConfig config, Output<StreamRecord<OUT>> output) {     super.setup(containingTask, config, output).     this.checkpointingLock = getContainingTask().getCheckpointLock().     this.inStreamElementSerializer = new StreamElementSerializer<>(getOperatorConfig().<IN>getTypeSerializerIn1(getUserCodeClassloader())).     // create the operators executor for the complete operations of the queue entries     this.executor = Executors.newSingleThreadExecutor().     switch(outputMode) {         case ORDERED:             queue = new OrderedStreamElementQueue(capacity, executor, this).             break.         case UNORDERED:             queue = new UnorderedStreamElementQueue(capacity, executor, this).             break.         default:             throw new IllegalStateException("Unknown async mode: " + outputMode + '.').     } }
false;public;0;36;;@Override public void open() throws Exception {     super.open().     // create the emitter     this.emitter = new Emitter<>(checkpointingLock, output, queue, this).     // start the emitter thread     this.emitterThread = new Thread(emitter, "AsyncIO-Emitter-Thread (" + getOperatorName() + ')').     emitterThread.setDaemon(true).     emitterThread.start().     // head operator.     if (recoveredStreamElements != null) {         for (StreamElement element : recoveredStreamElements.get()) {             if (element.isRecord()) {                 processElement(element.<IN>asRecord()).             } else if (element.isWatermark()) {                 processWatermark(element.asWatermark()).             } else if (element.isLatencyMarker()) {                 processLatencyMarker(element.asLatencyMarker()).             } else {                 throw new IllegalStateException("Unknown record type " + element.getClass() + " encountered while opening the operator.").             }         }         recoveredStreamElements = null.     } }
false;public;1;4;;@Override public void onProcessingTime(long timestamp) throws Exception {     userFunction.timeout(element.getValue(), streamRecordBufferEntry). }
false;public;1;30;;@Override public void processElement(StreamRecord<IN> element) throws Exception {     final StreamRecordQueueEntry<OUT> streamRecordBufferEntry = new StreamRecordQueueEntry<>(element).     if (timeout > 0L) {         // register a timeout for this AsyncStreamRecordBufferEntry         long timeoutTimestamp = timeout + getProcessingTimeService().getCurrentProcessingTime().         final ScheduledFuture<?> timerFuture = getProcessingTimeService().registerTimer(timeoutTimestamp, new ProcessingTimeCallback() {              @Override             public void onProcessingTime(long timestamp) throws Exception {                 userFunction.timeout(element.getValue(), streamRecordBufferEntry).             }         }).         // Cancel the timer once we've completed the stream record buffer entry. This will remove         // the register trigger task         streamRecordBufferEntry.onComplete((StreamElementQueueEntry<Collection<OUT>> value) -> {             timerFuture.cancel(true).         }, executor).     }     addAsyncBufferEntry(streamRecordBufferEntry).     userFunction.asyncInvoke(element.getValue(), streamRecordBufferEntry). }
false;public;1;6;;@Override public void processWatermark(Watermark mark) throws Exception {     WatermarkQueueEntry watermarkBufferEntry = new WatermarkQueueEntry(mark).     addAsyncBufferEntry(watermarkBufferEntry). }
false;public;1;26;;@Override public void snapshotState(StateSnapshotContext context) throws Exception {     super.snapshotState(context).     ListState<StreamElement> partitionableState = getOperatorStateBackend().getListState(new ListStateDescriptor<>(STATE_NAME, inStreamElementSerializer)).     partitionableState.clear().     Collection<StreamElementQueueEntry<?>> values = queue.values().     try {         for (StreamElementQueueEntry<?> value : values) {             partitionableState.add(value.getStreamElement()).         }         // add the pending stream element queue entry if the stream element queue is currently full         if (pendingStreamElementQueueEntry != null) {             partitionableState.add(pendingStreamElementQueueEntry.getStreamElement()).         }     } catch (Exception e) {         partitionableState.clear().         throw new Exception("Could not add stream element queue entries to operator state " + "backend of operator " + getOperatorName() + '.', e).     } }
false;public;1;8;;@Override public void initializeState(StateInitializationContext context) throws Exception {     super.initializeState(context).     recoveredStreamElements = context.getOperatorStateStore().getListState(new ListStateDescriptor<>(STATE_NAME, inStreamElementSerializer)). }
false;public;0;40;;@Override public void close() throws Exception {     try {         assert (Thread.holdsLock(checkpointingLock)).         while (!queue.isEmpty()) {             // wait for the emitter thread to output the remaining elements             // for that he needs the checkpointing lock and thus we have to free it             checkpointingLock.wait().         }     } finally {         Exception exception = null.         try {             super.close().         } catch (InterruptedException interrupted) {             exception = interrupted.             Thread.currentThread().interrupt().         } catch (Exception e) {             exception = e.         }         try {             // terminate the emitter, the emitter thread and the executor             stopResources(true).         } catch (InterruptedException interrupted) {             exception = ExceptionUtils.firstOrSuppressed(interrupted, exception).             Thread.currentThread().interrupt().         } catch (Exception e) {             exception = ExceptionUtils.firstOrSuppressed(e, exception).         }         if (exception != null) {             LOG.warn("Errors occurred while closing the AsyncWaitOperator.", exception).         }     } }
false;public;0;28;;@Override public void dispose() throws Exception {     Exception exception = null.     try {         super.dispose().     } catch (InterruptedException interrupted) {         exception = interrupted.         Thread.currentThread().interrupt().     } catch (Exception e) {         exception = e.     }     try {         stopResources(false).     } catch (InterruptedException interrupted) {         exception = ExceptionUtils.firstOrSuppressed(interrupted, exception).         Thread.currentThread().interrupt().     } catch (Exception e) {         exception = ExceptionUtils.firstOrSuppressed(e, exception).     }     if (exception != null) {         throw exception.     } }
true;private;1;32;/**  * Close the operator's resources. They include the emitter thread and the executor to run  * the queue's complete operation.  *  * @param waitForShutdown is true if the method should wait for the resources to be freed.  *                           otherwise false.  * @throws InterruptedException if current thread has been interrupted  */ ;/**  * Close the operator's resources. They include the emitter thread and the executor to run  * the queue's complete operation.  *  * @param waitForShutdown is true if the method should wait for the resources to be freed.  *                           otherwise false.  * @throws InterruptedException if current thread has been interrupted  */ private void stopResources(boolean waitForShutdown) throws InterruptedException {     emitter.stop().     emitterThread.interrupt().     executor.shutdown().     if (waitForShutdown) {         try {             if (!executor.awaitTermination(365L, TimeUnit.DAYS)) {                 executor.shutdownNow().             }         } catch (InterruptedException e) {             executor.shutdownNow().             Thread.currentThread().interrupt().         }         /* 			 * FLINK-5638: If we have the checkpoint lock we might have to free it for a while so 			 * that the emitter thread can complete/react to the interrupt signal. 			 */         if (Thread.holdsLock(checkpointingLock)) {             while (emitterThread.isAlive()) {                 checkpointingLock.wait(100L).             }         }         emitterThread.join().     } else {         executor.shutdownNow().     } }
true;private;1;12;/**  * Add the given stream element queue entry to the operator's stream element queue. This  * operation blocks until the element has been added.  *  * <p>For that it tries to put the element into the queue and if not successful then it waits on  * the checkpointing lock. The checkpointing lock is also used by the {@link Emitter} to output  * elements. The emitter is also responsible for notifying this method if the queue has capacity  * left again, by calling notifyAll on the checkpointing lock.  *  * @param streamElementQueueEntry to add to the operator's queue  * @param <T> Type of the stream element queue entry's result  * @throws InterruptedException if the current thread has been interrupted  */ ;/**  * Add the given stream element queue entry to the operator's stream element queue. This  * operation blocks until the element has been added.  *  * <p>For that it tries to put the element into the queue and if not successful then it waits on  * the checkpointing lock. The checkpointing lock is also used by the {@link Emitter} to output  * elements. The emitter is also responsible for notifying this method if the queue has capacity  * left again, by calling notifyAll on the checkpointing lock.  *  * @param streamElementQueueEntry to add to the operator's queue  * @param <T> Type of the stream element queue entry's result  * @throws InterruptedException if the current thread has been interrupted  */ private <T> void addAsyncBufferEntry(StreamElementQueueEntry<T> streamElementQueueEntry) throws InterruptedException {     assert (Thread.holdsLock(checkpointingLock)).     pendingStreamElementQueueEntry = streamElementQueueEntry.     while (!queue.tryPut(streamElementQueueEntry)) {         // we wait for the emitter to notify us if the queue has space left again         checkpointingLock.wait().     }     pendingStreamElementQueueEntry = null. }
false;public;1;4;;@Override public void failOperator(Throwable throwable) {     getContainingTask().getEnvironment().failExternally(throwable). }
