commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public StreamExecutionEnvironment getExecutionEnvironment() {     return environment. }
true;public;0;3;/**  * Returns the non-broadcast {@link DataStream}.  *  * @return The stream which, by convention, is not broadcasted.  */ ;/**  * Returns the non-broadcast {@link DataStream}.  *  * @return The stream which, by convention, is not broadcasted.  */ public DataStream<IN1> getFirstInput() {     return inputStream1. }
true;public;0;3;/**  * Returns the {@link BroadcastStream}.  *  * @return The stream which, by convention, is the broadcast one.  */ ;/**  * Returns the {@link BroadcastStream}.  *  * @return The stream which, by convention, is the broadcast one.  */ public BroadcastStream<IN2> getSecondInput() {     return inputStream2. }
true;public;0;3;/**  * Gets the type of the first input.  *  * @return The type of the first input  */ ;/**  * Gets the type of the first input.  *  * @return The type of the first input  */ public TypeInformation<IN1> getType1() {     return inputStream1.getType(). }
true;public;0;3;/**  * Gets the type of the second input.  *  * @return The type of the second input  */ ;/**  * Gets the type of the second input.  *  * @return The type of the second input  */ public TypeInformation<IN2> getType2() {     return inputStream2.getType(). }
true;public;1;17;/**  * Assumes as inputs a {@link BroadcastStream} and a {@link KeyedStream} and applies the given  * {@link KeyedBroadcastProcessFunction} on them, thereby creating a transformed output stream.  *  * @param function The {@link KeyedBroadcastProcessFunction} that is called for each element in the stream.  * @param <KS> The type of the keys in the keyed stream.  * @param <OUT> The type of the output elements.  * @return The transformed {@link DataStream}.  */ ;/**  * Assumes as inputs a {@link BroadcastStream} and a {@link KeyedStream} and applies the given  * {@link KeyedBroadcastProcessFunction} on them, thereby creating a transformed output stream.  *  * @param function The {@link KeyedBroadcastProcessFunction} that is called for each element in the stream.  * @param <KS> The type of the keys in the keyed stream.  * @param <OUT> The type of the output elements.  * @return The transformed {@link DataStream}.  */ @PublicEvolving public <KS, OUT> SingleOutputStreamOperator<OUT> process(final KeyedBroadcastProcessFunction<KS, IN1, IN2, OUT> function) {     TypeInformation<OUT> outTypeInfo = TypeExtractor.getBinaryOperatorReturnType(function, KeyedBroadcastProcessFunction.class, 1, 2, 3, TypeExtractor.NO_INDEX, getType1(), getType2(), Utils.getCallLocationName(), true).     return process(function, outTypeInfo). }
true;public;2;13;/**  * Assumes as inputs a {@link BroadcastStream} and a {@link KeyedStream} and applies the given  * {@link KeyedBroadcastProcessFunction} on them, thereby creating a transformed output stream.  *  * @param function The {@link KeyedBroadcastProcessFunction} that is called for each element in the stream.  * @param outTypeInfo The type of the output elements.  * @param <KS> The type of the keys in the keyed stream.  * @param <OUT> The type of the output elements.  * @return The transformed {@link DataStream}.  */ ;/**  * Assumes as inputs a {@link BroadcastStream} and a {@link KeyedStream} and applies the given  * {@link KeyedBroadcastProcessFunction} on them, thereby creating a transformed output stream.  *  * @param function The {@link KeyedBroadcastProcessFunction} that is called for each element in the stream.  * @param outTypeInfo The type of the output elements.  * @param <KS> The type of the keys in the keyed stream.  * @param <OUT> The type of the output elements.  * @return The transformed {@link DataStream}.  */ @PublicEvolving public <KS, OUT> SingleOutputStreamOperator<OUT> process(final KeyedBroadcastProcessFunction<KS, IN1, IN2, OUT> function, final TypeInformation<OUT> outTypeInfo) {     Preconditions.checkNotNull(function).     Preconditions.checkArgument(inputStream1 instanceof KeyedStream, "A KeyedBroadcastProcessFunction can only be used on a keyed stream.").     TwoInputStreamOperator<IN1, IN2, OUT> operator = new CoBroadcastWithKeyedOperator<>(clean(function), broadcastStateDescriptors).     return transform("Co-Process-Broadcast-Keyed", outTypeInfo, operator). }
true;public;1;17;/**  * Assumes as inputs a {@link BroadcastStream} and a non-keyed {@link DataStream} and applies the given  * {@link BroadcastProcessFunction} on them, thereby creating a transformed output stream.  *  * @param function The {@link BroadcastProcessFunction} that is called for each element in the stream.  * @param <OUT> The type of the output elements.  * @return The transformed {@link DataStream}.  */ ;/**  * Assumes as inputs a {@link BroadcastStream} and a non-keyed {@link DataStream} and applies the given  * {@link BroadcastProcessFunction} on them, thereby creating a transformed output stream.  *  * @param function The {@link BroadcastProcessFunction} that is called for each element in the stream.  * @param <OUT> The type of the output elements.  * @return The transformed {@link DataStream}.  */ @PublicEvolving public <OUT> SingleOutputStreamOperator<OUT> process(final BroadcastProcessFunction<IN1, IN2, OUT> function) {     TypeInformation<OUT> outTypeInfo = TypeExtractor.getBinaryOperatorReturnType(function, BroadcastProcessFunction.class, 0, 1, 2, TypeExtractor.NO_INDEX, getType1(), getType2(), Utils.getCallLocationName(), true).     return process(function, outTypeInfo). }
true;public;2;13;/**  * Assumes as inputs a {@link BroadcastStream} and a non-keyed {@link DataStream} and applies the given  * {@link BroadcastProcessFunction} on them, thereby creating a transformed output stream.  *  * @param function The {@link BroadcastProcessFunction} that is called for each element in the stream.  * @param outTypeInfo The type of the output elements.  * @param <OUT> The type of the output elements.  * @return The transformed {@link DataStream}.  */ ;/**  * Assumes as inputs a {@link BroadcastStream} and a non-keyed {@link DataStream} and applies the given  * {@link BroadcastProcessFunction} on them, thereby creating a transformed output stream.  *  * @param function The {@link BroadcastProcessFunction} that is called for each element in the stream.  * @param outTypeInfo The type of the output elements.  * @param <OUT> The type of the output elements.  * @return The transformed {@link DataStream}.  */ @PublicEvolving public <OUT> SingleOutputStreamOperator<OUT> process(final BroadcastProcessFunction<IN1, IN2, OUT> function, final TypeInformation<OUT> outTypeInfo) {     Preconditions.checkNotNull(function).     Preconditions.checkArgument(!(inputStream1 instanceof KeyedStream), "A BroadcastProcessFunction can only be used on a non-keyed stream.").     TwoInputStreamOperator<IN1, IN2, OUT> operator = new CoBroadcastWithNonKeyedOperator<>(clean(function), broadcastStateDescriptors).     return transform("Co-Process-Broadcast", outTypeInfo, operator). }
false;private;3;32;;@Internal private <OUT> SingleOutputStreamOperator<OUT> transform(final String functionName, final TypeInformation<OUT> outTypeInfo, final TwoInputStreamOperator<IN1, IN2, OUT> operator) {     // read the output type of the input Transforms to coax out errors about MissingTypeInfo     inputStream1.getType().     inputStream2.getType().     TwoInputTransformation<IN1, IN2, OUT> transform = new TwoInputTransformation<>(inputStream1.getTransformation(), inputStream2.getTransformation(), functionName, operator, outTypeInfo, environment.getParallelism()).     if (inputStream1 instanceof KeyedStream) {         KeyedStream<IN1, ?> keyedInput1 = (KeyedStream<IN1, ?>) inputStream1.         TypeInformation<?> keyType1 = keyedInput1.getKeyType().         transform.setStateKeySelectors(keyedInput1.getKeySelector(), null).         transform.setStateKeyType(keyType1).     }     @SuppressWarnings({ "unchecked", "rawtypes" })     SingleOutputStreamOperator<OUT> returnStream = new SingleOutputStreamOperator(environment, transform).     getExecutionEnvironment().addOperator(transform).     return returnStream. }
false;protected;1;3;;protected <F> F clean(F f) {     return getExecutionEnvironment().clean(f). }
