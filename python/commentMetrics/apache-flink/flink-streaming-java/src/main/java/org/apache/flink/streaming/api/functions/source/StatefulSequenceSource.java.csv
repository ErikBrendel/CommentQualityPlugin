commented;modifiers;parameterAmount;loc;comment;code
false;public;1;36;;@Override public void initializeState(FunctionInitializationContext context) throws Exception {     Preconditions.checkState(this.checkpointedState == null, "The " + getClass().getSimpleName() + " has already been initialized.").     this.checkpointedState = context.getOperatorStateStore().getListState(new ListStateDescriptor<>("stateful-sequence-source-state", LongSerializer.INSTANCE)).     this.valuesToEmit = new ArrayDeque<>().     if (context.isRestored()) {         for (Long v : this.checkpointedState.get()) {             this.valuesToEmit.add(v).         }     } else {         // the first time the job is executed         final int stepSize = getRuntimeContext().getNumberOfParallelSubtasks().         final int taskIdx = getRuntimeContext().getIndexOfThisSubtask().         final long congruence = start + taskIdx.         long totalNoOfElements = Math.abs(end - start + 1).         final int baseSize = safeDivide(totalNoOfElements, stepSize).         final int toCollect = (totalNoOfElements % stepSize > taskIdx) ? baseSize + 1 : baseSize.         for (long collected = 0. collected < toCollect. collected++) {             this.valuesToEmit.add(collected * stepSize + congruence).         }     } }
false;public;1;8;;@Override public void run(SourceContext<Long> ctx) throws Exception {     while (isRunning && !this.valuesToEmit.isEmpty()) {         synchronized (ctx.getCheckpointLock()) {             ctx.collect(this.valuesToEmit.poll()).         }     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;1;10;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     Preconditions.checkState(this.checkpointedState != null, "The " + getClass().getSimpleName() + " state has not been properly initialized.").     this.checkpointedState.clear().     for (Long v : this.valuesToEmit) {         this.checkpointedState.add(v).     } }
false;private,static;2;6;;private static int safeDivide(long left, long right) {     Preconditions.checkArgument(right > 0).     Preconditions.checkArgument(left >= 0).     Preconditions.checkArgument(left <= Integer.MAX_VALUE * right).     return (int) (left / right). }
