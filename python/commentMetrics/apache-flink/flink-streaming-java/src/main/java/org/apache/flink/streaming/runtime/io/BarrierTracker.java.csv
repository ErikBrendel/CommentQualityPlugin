commented;modifiers;parameterAmount;loc;comment;code
false;public;0;25;;@Override public BufferOrEvent getNextNonBlocked() throws Exception {     while (true) {         Optional<BufferOrEvent> next = inputGate.getNextBufferOrEvent().         if (!next.isPresent()) {             // buffer or input exhausted             return null.         }         BufferOrEvent bufferOrEvent = next.get().         if (bufferOrEvent.isBuffer()) {             return bufferOrEvent.         } else if (bufferOrEvent.getEvent().getClass() == CheckpointBarrier.class) {             processBarrier((CheckpointBarrier) bufferOrEvent.getEvent(), bufferOrEvent.getChannelIndex()).         } else if (bufferOrEvent.getEvent().getClass() == CancelCheckpointMarker.class) {             processCheckpointAbortBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent(), bufferOrEvent.getChannelIndex()).         } else {             // some other event             return bufferOrEvent.         }     } }
false;public;1;9;;@Override public void registerCheckpointEventHandler(AbstractInvokable toNotifyOnCheckpoint) {     if (this.toNotifyOnCheckpoint == null) {         this.toNotifyOnCheckpoint = toNotifyOnCheckpoint.     } else {         throw new IllegalStateException("BarrierTracker already has a registered checkpoint notifyee").     } }
false;public;0;4;;@Override public void cleanup() {     pendingCheckpoints.clear(). }
false;public;0;4;;@Override public boolean isEmpty() {     return pendingCheckpoints.isEmpty(). }
false;public;0;5;;@Override public long getAlignmentDurationNanos() {     // this one does not do alignment at all     return 0L. }
false;private;2;63;;private void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws Exception {     final long barrierId = receivedBarrier.getId().     // fast path for single channel trackers     if (totalNumberOfInputChannels == 1) {         notifyCheckpoint(barrierId, receivedBarrier.getTimestamp(), receivedBarrier.getCheckpointOptions()).         return.     }     // general path for multiple input channels     if (LOG.isDebugEnabled()) {         LOG.debug("Received barrier for checkpoint {} from channel {}", barrierId, channelIndex).     }     // find the checkpoint barrier in the queue of pending barriers     CheckpointBarrierCount cbc = null.     int pos = 0.     for (CheckpointBarrierCount next : pendingCheckpoints) {         if (next.checkpointId == barrierId) {             cbc = next.             break.         }         pos++.     }     if (cbc != null) {         // add one to the count to that barrier and check for completion         int numBarriersNew = cbc.incrementBarrierCount().         if (numBarriersNew == totalNumberOfInputChannels) {             // checkpoints (which are now subsumed)             for (int i = 0. i <= pos. i++) {                 pendingCheckpoints.pollFirst().             }             // notify the listener             if (!cbc.isAborted()) {                 if (LOG.isDebugEnabled()) {                     LOG.debug("Received all barriers for checkpoint {}", barrierId).                 }                 notifyCheckpoint(receivedBarrier.getId(), receivedBarrier.getTimestamp(), receivedBarrier.getCheckpointOptions()).             }         }     } else {         // successful checkpoint for that ID anyways         if (barrierId > latestPendingCheckpointID) {             latestPendingCheckpointID = barrierId.             pendingCheckpoints.addLast(new CheckpointBarrierCount(barrierId)).             // make sure we do not track too many checkpoints             if (pendingCheckpoints.size() > MAX_CHECKPOINTS_TO_TRACK) {                 pendingCheckpoints.pollFirst().             }         }     } }
false;private;2;55;;private void processCheckpointAbortBarrier(CancelCheckpointMarker barrier, int channelIndex) throws Exception {     final long checkpointId = barrier.getCheckpointId().     if (LOG.isDebugEnabled()) {         LOG.debug("Received cancellation barrier for checkpoint {} from channel {}", checkpointId, channelIndex).     }     // fast path for single channel trackers     if (totalNumberOfInputChannels == 1) {         notifyAbort(checkpointId).         return.     }     // -- general path for multiple input channels --     // find the checkpoint barrier in the queue of pending barriers     // while doing this we "abort" all checkpoints before that one     CheckpointBarrierCount cbc.     while ((cbc = pendingCheckpoints.peekFirst()) != null && cbc.checkpointId() < checkpointId) {         pendingCheckpoints.removeFirst().         if (cbc.markAborted()) {             // abort the subsumed checkpoints if not already done             notifyAbort(cbc.checkpointId()).         }     }     if (cbc != null && cbc.checkpointId() == checkpointId) {         // make sure the checkpoint is remembered as aborted         if (cbc.markAborted()) {             // this was the first time the checkpoint was aborted - notify             notifyAbort(checkpointId).         }         // we still count the barriers to be able to remove the entry once all barriers have been seen         if (cbc.incrementBarrierCount() == totalNumberOfInputChannels) {             // we can remove this entry             pendingCheckpoints.removeFirst().         }     } else if (checkpointId > latestPendingCheckpointID) {         notifyAbort(checkpointId).         latestPendingCheckpointID = checkpointId.         CheckpointBarrierCount abortedMarker = new CheckpointBarrierCount(checkpointId).         abortedMarker.markAborted().         pendingCheckpoints.addFirst(abortedMarker).     // we have removed all other pending checkpoint barrier counts --> no need to check that     // we don't exceed the maximum checkpoints to track     } else {     // trailing cancellation barrier which was already cancelled     } }
false;private;3;10;;private void notifyCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) throws Exception {     if (toNotifyOnCheckpoint != null) {         CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp).         CheckpointMetrics checkpointMetrics = new CheckpointMetrics().setBytesBufferedInAlignment(0L).setAlignmentDurationNanos(0L).         toNotifyOnCheckpoint.triggerCheckpointOnBarrier(checkpointMetaData, checkpointOptions, checkpointMetrics).     } }
false;private;1;6;;private void notifyAbort(long checkpointId) throws Exception {     if (toNotifyOnCheckpoint != null) {         toNotifyOnCheckpoint.abortCheckpointOnBarrier(checkpointId, new CheckpointDeclineOnCancellationBarrierException()).     } }
false;public;0;3;;public long checkpointId() {     return checkpointId. }
false;public;0;3;;public int incrementBarrierCount() {     return ++barrierCount. }
false;public;0;3;;public boolean isAborted() {     return aborted. }
false;public;0;5;;public boolean markAborted() {     boolean firstAbort = !this.aborted.     this.aborted = true.     return firstAbort. }
false;public;0;6;;@Override public String toString() {     return isAborted() ? String.format("checkpointID=%d - ABORTED", checkpointId) : String.format("checkpointID=%d, count=%d", checkpointId, barrierCount). }
