commented;modifiers;parameterAmount;loc;comment;code
false;public;4;6;;@Override public void evictBefore(Iterable<TimestampedValue<Object>> elements, int size, W window, EvictorContext ctx) {     if (!doEvictAfter) {         evict(elements, size, ctx).     } }
false;public;4;6;;@Override public void evictAfter(Iterable<TimestampedValue<Object>> elements, int size, W window, EvictorContext ctx) {     if (doEvictAfter) {         evict(elements, size, ctx).     } }
false;private;3;15;;private void evict(Iterable<TimestampedValue<Object>> elements, int size, EvictorContext ctx) {     if (!hasTimestamp(elements)) {         return.     }     long currentTime = getMaxTimestamp(elements).     long evictCutoff = currentTime - windowSize.     for (Iterator<TimestampedValue<Object>> iterator = elements.iterator(). iterator.hasNext(). ) {         TimestampedValue<Object> record = iterator.next().         if (record.getTimestamp() <= evictCutoff) {             iterator.remove().         }     } }
true;private;1;7;/**  * Returns true if the first element in the Iterable of {@link TimestampedValue} has a timestamp.  */ ;/**  * Returns true if the first element in the Iterable of {@link TimestampedValue} has a timestamp.  */ private boolean hasTimestamp(Iterable<TimestampedValue<Object>> elements) {     Iterator<TimestampedValue<Object>> it = elements.iterator().     if (it.hasNext()) {         return it.next().hasTimestamp().     }     return false. }
true;private;1;8;/**  * @param elements The elements currently in the pane.  * @return The maximum value of timestamp among the elements.  */ ;/**  * @param elements The elements currently in the pane.  * @return The maximum value of timestamp among the elements.  */ private long getMaxTimestamp(Iterable<TimestampedValue<Object>> elements) {     long currentTime = Long.MIN_VALUE.     for (Iterator<TimestampedValue<Object>> iterator = elements.iterator(). iterator.hasNext(). ) {         TimestampedValue<Object> record = iterator.next().         currentTime = Math.max(currentTime, record.getTimestamp()).     }     return currentTime. }
false;public;0;4;;@Override public String toString() {     return "TimeEvictor(" + windowSize + ")". }
false;public;0;4;;@VisibleForTesting public long getWindowSize() {     return windowSize. }
true;public,static;1;3;/**  * Creates a {@code TimeEvictor} that keeps the given number of elements.  * Eviction is done before the window function.  *  * @param windowSize The amount of time for which to keep elements.  */ ;/**  * Creates a {@code TimeEvictor} that keeps the given number of elements.  * Eviction is done before the window function.  *  * @param windowSize The amount of time for which to keep elements.  */ public static <W extends Window> TimeEvictor<W> of(Time windowSize) {     return new TimeEvictor<>(windowSize.toMilliseconds()). }
true;public,static;2;3;/**  * Creates a {@code TimeEvictor} that keeps the given number of elements.  * Eviction is done before/after the window function based on the value of doEvictAfter.  *  * @param windowSize The amount of time for which to keep elements.  * @param doEvictAfter Whether eviction is done after window function.  */ ;/**  * Creates a {@code TimeEvictor} that keeps the given number of elements.  * Eviction is done before/after the window function based on the value of doEvictAfter.  *  * @param windowSize The amount of time for which to keep elements.  * @param doEvictAfter Whether eviction is done after window function.  */ public static <W extends Window> TimeEvictor<W> of(Time windowSize, boolean doEvictAfter) {     return new TimeEvictor<>(windowSize.toMilliseconds(), doEvictAfter). }
