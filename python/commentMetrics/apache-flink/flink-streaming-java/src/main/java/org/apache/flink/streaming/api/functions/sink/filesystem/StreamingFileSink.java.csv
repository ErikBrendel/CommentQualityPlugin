commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;4;/**  * Creates the builder for a {@code StreamingFileSink} with row-encoding format.  * @param basePath the base path where all the buckets are going to be created as sub-directories.  * @param encoder the {@link Encoder} to be used when writing elements in the buckets.  * @param <IN> the type of incoming elements  * @return The builder where the remaining of the configuration parameters for the sink can be configured.  * In order to instantiate the sink, call {@link RowFormatBuilder#build()} after specifying the desired parameters.  */ ;// ------------------------------------------------------------------------ // --------------------------- Sink Builders  ----------------------------- /**  * Creates the builder for a {@code StreamingFileSink} with row-encoding format.  * @param basePath the base path where all the buckets are going to be created as sub-directories.  * @param encoder the {@link Encoder} to be used when writing elements in the buckets.  * @param <IN> the type of incoming elements  * @return The builder where the remaining of the configuration parameters for the sink can be configured.  * In order to instantiate the sink, call {@link RowFormatBuilder#build()} after specifying the desired parameters.  */ public static <IN> StreamingFileSink.RowFormatBuilder<IN, String> forRowFormat(final Path basePath, final Encoder<IN> encoder) {     return new StreamingFileSink.RowFormatBuilder<>(basePath, encoder, new DateTimeBucketAssigner<>()). }
true;public,static;2;4;/**  * Creates the builder for a {@link StreamingFileSink} with row-encoding format.  * @param basePath the base path where all the buckets are going to be created as sub-directories.  * @param writerFactory the {@link BulkWriter.Factory} to be used when writing elements in the buckets.  * @param <IN> the type of incoming elements  * @return The builder where the remaining of the configuration parameters for the sink can be configured.  * In order to instantiate the sink, call {@link RowFormatBuilder#build()} after specifying the desired parameters.  */ ;/**  * Creates the builder for a {@link StreamingFileSink} with row-encoding format.  * @param basePath the base path where all the buckets are going to be created as sub-directories.  * @param writerFactory the {@link BulkWriter.Factory} to be used when writing elements in the buckets.  * @param <IN> the type of incoming elements  * @return The builder where the remaining of the configuration parameters for the sink can be configured.  * In order to instantiate the sink, call {@link RowFormatBuilder#build()} after specifying the desired parameters.  */ public static <IN> StreamingFileSink.BulkFormatBuilder<IN, String> forBulkFormat(final Path basePath, final BulkWriter.Factory<IN> writerFactory) {     return new StreamingFileSink.BulkFormatBuilder<>(basePath, writerFactory, new DateTimeBucketAssigner<>()). }
false;abstract;1;1;;abstract Buckets<IN, BucketID> createBuckets(final int subtaskIndex) throws IOException.
false;public;1;3;;public StreamingFileSink.RowFormatBuilder<IN, BucketID> withBucketCheckInterval(final long interval) {     return new RowFormatBuilder<>(basePath, encoder, bucketAssigner, rollingPolicy, interval, bucketFactory). }
false;public;1;3;;public StreamingFileSink.RowFormatBuilder<IN, BucketID> withBucketAssigner(final BucketAssigner<IN, BucketID> assigner) {     return new RowFormatBuilder<>(basePath, encoder, Preconditions.checkNotNull(assigner), rollingPolicy, bucketCheckInterval, bucketFactory). }
false;public;1;3;;public StreamingFileSink.RowFormatBuilder<IN, BucketID> withRollingPolicy(final RollingPolicy<IN, BucketID> policy) {     return new RowFormatBuilder<>(basePath, encoder, bucketAssigner, Preconditions.checkNotNull(policy), bucketCheckInterval, bucketFactory). }
false;public;2;3;;public <ID> StreamingFileSink.RowFormatBuilder<IN, ID> withBucketAssignerAndPolicy(final BucketAssigner<IN, ID> assigner, final RollingPolicy<IN, ID> policy) {     return new RowFormatBuilder<>(basePath, encoder, Preconditions.checkNotNull(assigner), Preconditions.checkNotNull(policy), bucketCheckInterval, new DefaultBucketFactoryImpl<>()). }
true;public;0;3;/**  * Creates the actual sink.  */ ;/**  * Creates the actual sink.  */ public StreamingFileSink<IN> build() {     return new StreamingFileSink<>(this, bucketCheckInterval). }
false;;1;10;;@Override Buckets<IN, BucketID> createBuckets(int subtaskIndex) throws IOException {     return new Buckets<>(basePath, bucketAssigner, bucketFactory, new RowWisePartWriter.Factory<>(encoder), rollingPolicy, subtaskIndex). }
false;;1;4;;@VisibleForTesting StreamingFileSink.RowFormatBuilder<IN, BucketID> withBucketFactory(final BucketFactory<IN, BucketID> factory) {     return new RowFormatBuilder<>(basePath, encoder, bucketAssigner, rollingPolicy, bucketCheckInterval, Preconditions.checkNotNull(factory)). }
false;public;1;3;;public StreamingFileSink.BulkFormatBuilder<IN, BucketID> withBucketCheckInterval(long interval) {     return new BulkFormatBuilder<>(basePath, writerFactory, bucketAssigner, interval, bucketFactory). }
false;public;1;3;;public <ID> StreamingFileSink.BulkFormatBuilder<IN, ID> withBucketAssigner(BucketAssigner<IN, ID> assigner) {     return new BulkFormatBuilder<>(basePath, writerFactory, Preconditions.checkNotNull(assigner), bucketCheckInterval, new DefaultBucketFactoryImpl<>()). }
false;;1;4;;@VisibleForTesting StreamingFileSink.BulkFormatBuilder<IN, BucketID> withBucketFactory(final BucketFactory<IN, BucketID> factory) {     return new BulkFormatBuilder<>(basePath, writerFactory, bucketAssigner, bucketCheckInterval, Preconditions.checkNotNull(factory)). }
true;public;0;3;/**  * Creates the actual sink.  */ ;/**  * Creates the actual sink.  */ public StreamingFileSink<IN> build() {     return new StreamingFileSink<>(this, bucketCheckInterval). }
false;;1;10;;@Override Buckets<IN, BucketID> createBuckets(int subtaskIndex) throws IOException {     return new Buckets<>(basePath, bucketAssigner, bucketFactory, new BulkPartWriter.Factory<>(writerFactory), OnCheckpointRollingPolicy.build(), subtaskIndex). }
false;public;1;13;;// --------------------------- Sink Methods ----------------------------- @Override public void initializeState(FunctionInitializationContext context) throws Exception {     final int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask().     this.buckets = bucketsBuilder.createBuckets(subtaskIndex).     final OperatorStateStore stateStore = context.getOperatorStateStore().     bucketStates = stateStore.getListState(BUCKET_STATE_DESC).     maxPartCountersState = stateStore.getUnionListState(MAX_PART_COUNTER_STATE_DESC).     if (context.isRestored()) {         buckets.initializeState(bucketStates, maxPartCountersState).     } }
false;public;1;4;;@Override public void notifyCheckpointComplete(long checkpointId) throws Exception {     buckets.commitUpToCheckpoint(checkpointId). }
false;public;1;9;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     Preconditions.checkState(bucketStates != null && maxPartCountersState != null, "sink has not been initialized").     buckets.snapshotState(context.getCheckpointId(), bucketStates, maxPartCountersState). }
false;public;1;7;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     this.processingTimeService = ((StreamingRuntimeContext) getRuntimeContext()).getProcessingTimeService().     long currentProcessingTime = processingTimeService.getCurrentProcessingTime().     processingTimeService.registerTimer(currentProcessingTime + bucketCheckInterval, this). }
false;public;1;6;;@Override public void onProcessingTime(long timestamp) throws Exception {     final long currentTime = processingTimeService.getCurrentProcessingTime().     buckets.onProcessingTime(currentTime).     processingTimeService.registerTimer(currentTime + bucketCheckInterval, this). }
false;public;2;4;;@Override public void invoke(IN value, SinkFunction.Context context) throws Exception {     buckets.onElement(value, context). }
false;public;0;6;;@Override public void close() throws Exception {     if (buckets != null) {         buckets.close().     } }
