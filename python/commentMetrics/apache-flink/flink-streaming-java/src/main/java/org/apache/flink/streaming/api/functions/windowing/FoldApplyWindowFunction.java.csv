commented;modifiers;parameterAmount;loc;comment;code
false;public;1;18;;@Override public void open(Configuration configuration) throws Exception {     super.open(configuration).     if (accSerializer == null) {         throw new RuntimeException("No serializer set for the fold accumulator type. " + "Probably the setOutputType method was not called.").     }     if (serializedInitialValue == null) {         throw new RuntimeException("No initial value was serialized for the fold " + "window function. Probably the setOutputType method was not called.").     }     ByteArrayInputStream bais = new ByteArrayInputStream(serializedInitialValue).     DataInputViewStreamWrapper in = new DataInputViewStreamWrapper(bais).     initialValue = accSerializer.deserialize(in). }
false;public;4;10;;@Override public void apply(K key, W window, Iterable<T> values, Collector<R> out) throws Exception {     ACC result = accSerializer.copy(initialValue).     for (T val : values) {         result = foldFunction.fold(result, val).     }     wrappedFunction.apply(key, window, Collections.singletonList(result), out). }
false;public;2;17;;@Override public void setOutputType(TypeInformation<R> outTypeInfo, ExecutionConfig executionConfig) {     // out type is not used, just use this for the execution config     accSerializer = accTypeInformation.createSerializer(executionConfig).     ByteArrayOutputStream baos = new ByteArrayOutputStream().     DataOutputViewStreamWrapper out = new DataOutputViewStreamWrapper(baos).     try {         accSerializer.serialize(initialValue, out).     } catch (IOException ioe) {         throw new RuntimeException("Unable to serialize initial value of type " + initialValue.getClass().getSimpleName() + " of fold window function.", ioe).     }     serializedInitialValue = baos.toByteArray(). }
