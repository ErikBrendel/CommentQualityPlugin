commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public long getCurrentProcessingTime() {     return System.currentTimeMillis(). }
true;public;2;28;/**  * Registers a task to be executed no sooner than time {@code timestamp}, but without strong  * guarantees of order.  *  * @param timestamp Time when the task is to be enabled (in processing time)  * @param target    The task to be executed  * @return The future that represents the scheduled task. This always returns some future,  *         even if the timer was shut down  */ ;/**  * Registers a task to be executed no sooner than time {@code timestamp}, but without strong  * guarantees of order.  *  * @param timestamp Time when the task is to be enabled (in processing time)  * @param target    The task to be executed  * @return The future that represents the scheduled task. This always returns some future,  *         even if the timer was shut down  */ @Override public ScheduledFuture<?> registerTimer(long timestamp, ProcessingTimeCallback target) {     // delay the firing of the timer by 1 ms to align the semantics with watermark. A watermark     // T says we won't see elements in the future with a timestamp smaller or equal to T.     // With processing time, we therefore need to delay firing the timer by one ms.     long delay = Math.max(timestamp - getCurrentProcessingTime(), 0) + 1.     // that way we save unnecessary volatile accesses for each timer     try {         return timerService.schedule(new TriggerTask(status, task, checkpointLock, target, timestamp), delay, TimeUnit.MILLISECONDS).     } catch (RejectedExecutionException e) {         final int status = this.status.get().         if (status == STATUS_QUIESCED) {             return new NeverCompleteFuture(delay).         } else if (status == STATUS_SHUTDOWN) {             throw new IllegalStateException("Timer service is shut down").         } else {             // something else happened, so propagate the exception             throw e.         }     } }
false;public;3;26;;@Override public ScheduledFuture<?> scheduleAtFixedRate(ProcessingTimeCallback callback, long initialDelay, long period) {     long nextTimestamp = getCurrentProcessingTime() + initialDelay.     // that way we save unnecessary volatile accesses for each timer     try {         return timerService.scheduleAtFixedRate(new RepeatedTriggerTask(status, task, checkpointLock, callback, nextTimestamp, period), initialDelay, period, TimeUnit.MILLISECONDS).     } catch (RejectedExecutionException e) {         final int status = this.status.get().         if (status == STATUS_QUIESCED) {             return new NeverCompleteFuture(initialDelay).         } else if (status == STATUS_SHUTDOWN) {             throw new IllegalStateException("Timer service is shut down").         } else {             // something else happened, so propagate the exception             throw e.         }     } }
true;;0;4;/**  * @return {@code true} is the status of the service  * is {@link #STATUS_ALIVE}, {@code false} otherwise.  */ ;/**  * @return {@code true} is the status of the service  * is {@link #STATUS_ALIVE}, {@code false} otherwise.  */ @VisibleForTesting boolean isAlive() {     return status.get() == STATUS_ALIVE. }
false;public;0;4;;@Override public boolean isTerminated() {     return status.get() == STATUS_SHUTDOWN. }
false;public;0;6;;@Override public void quiesce() throws InterruptedException {     if (status.compareAndSet(STATUS_ALIVE, STATUS_QUIESCED)) {         timerService.shutdown().     } }
false;public;0;9;;@Override public void awaitPendingAfterQuiesce() throws InterruptedException {     if (!timerService.isTerminated()) {         Preconditions.checkState(timerService.isTerminating() || timerService.isShutdown()).         // await forever (almost)         timerService.awaitTermination(365L, TimeUnit.DAYS).     } }
false;public;0;7;;@Override public void shutdownService() {     if (status.compareAndSet(STATUS_ALIVE, STATUS_SHUTDOWN) || status.compareAndSet(STATUS_QUIESCED, STATUS_SHUTDOWN)) {         timerService.shutdownNow().     } }
false;public;2;5;;@Override public boolean shutdownAndAwaitPending(long time, TimeUnit timeUnit) throws InterruptedException {     shutdownService().     return timerService.awaitTermination(time, timeUnit). }
false;public;1;24;;@Override public boolean shutdownServiceUninterruptible(long timeoutMs) {     final Deadline deadline = Deadline.fromNow(Duration.ofMillis(timeoutMs)).     boolean shutdownComplete = false.     boolean receivedInterrupt = false.     do {         try {             // wait for a reasonable time for all pending timer threads to finish             shutdownComplete = shutdownAndAwaitPending(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS).         } catch (InterruptedException iex) {             receivedInterrupt = true.             LOG.trace("Intercepted attempt to interrupt timer service shutdown.", iex).         }     } while (deadline.hasTimeLeft() && !shutdownComplete).     if (receivedInterrupt) {         Thread.currentThread().interrupt().     }     return shutdownComplete. }
true;protected;0;5;// safety net to destroy the thread pool ;// safety net to destroy the thread pool @Override protected void finalize() throws Throwable {     super.finalize().     timerService.shutdownNow(). }
false;;0;9;;@VisibleForTesting int getNumTasksScheduled() {     BlockingQueue<?> queue = timerService.getQueue().     if (queue == null) {         return 0.     } else {         return queue.size().     } }
false;public;0;13;;@Override public void run() {     synchronized (lock) {         try {             if (serviceStatus.get() == STATUS_ALIVE) {                 target.onProcessingTime(timestamp).             }         } catch (Throwable t) {             TimerException asyncException = new TimerException(t).             exceptionHandler.handleAsyncException("Caught exception while processing timer.", asyncException).         }     } }
false;public;0;15;;@Override public void run() {     synchronized (lock) {         try {             if (serviceStatus.get() == STATUS_ALIVE) {                 target.onProcessingTime(nextTimestamp).             }             nextTimestamp += period.         } catch (Throwable t) {             TimerException asyncException = new TimerException(t).             exceptionHandler.handleAsyncException("Caught exception while processing repeated timer task.", asyncException).         }     } }
false;public;1;4;;@Override public long getDelay(@Nonnull TimeUnit unit) {     return unit.convert(delayMillis, TimeUnit.MILLISECONDS). }
false;public;1;5;;@Override public int compareTo(@Nonnull Delayed o) {     long otherMillis = o.getDelay(TimeUnit.MILLISECONDS).     return Long.compare(this.delayMillis, otherMillis). }
false;public;1;8;;@Override public boolean cancel(boolean mayInterruptIfRunning) {     synchronized (lock) {         canceled = true.         lock.notifyAll().     }     return true. }
false;public;0;4;;@Override public boolean isCancelled() {     return canceled. }
false;public;0;4;;@Override public boolean isDone() {     return false. }
false;public;0;9;;@Override public Object get() throws InterruptedException {     synchronized (lock) {         while (!canceled) {             lock.wait().         }     }     throw new CancellationException(). }
false;public;2;14;;@Override public Object get(long timeout, @Nonnull TimeUnit unit) throws InterruptedException, TimeoutException {     synchronized (lock) {         while (!canceled) {             unit.timedWait(lock, timeout).         }         if (canceled) {             throw new CancellationException().         } else {             throw new TimeoutException().         }     } }
