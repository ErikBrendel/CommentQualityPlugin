# id;timestamp;commentText;codeText;commentWords;codeWords
MergingWindowSet -> public W getStateWindow(W window);1459869538;Returns the state window for the given in-flight {@code Window}. The state window is the_{@code Window} in which we keep the actual state of a given in-flight window. Windows_might expand but we keep to original state window for keeping the elements of the window_to avoid costly state juggling.__@param window The window for which to get the state window.;public W getStateWindow(W window) {_		W result = windows.get(window)__		if (result == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}__		return result__	};returns,the,state,window,for,the,given,in,flight,code,window,the,state,window,is,the,code,window,in,which,we,keep,the,actual,state,of,a,given,in,flight,window,windows,might,expand,but,we,keep,to,original,state,window,for,keeping,the,elements,of,the,window,to,avoid,costly,state,juggling,param,window,the,window,for,which,to,get,the,state,window;public,w,get,state,window,w,window,w,result,windows,get,window,if,result,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set,return,result
MergingWindowSet -> public W getStateWindow(W window);1461572320;Returns the state window for the given in-flight {@code Window}. The state window is the_{@code Window} in which we keep the actual state of a given in-flight window. Windows_might expand but we keep to original state window for keeping the elements of the window_to avoid costly state juggling.__@param window The window for which to get the state window.;public W getStateWindow(W window) {_		W result = windows.get(window)__		if (result == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}__		return result__	};returns,the,state,window,for,the,given,in,flight,code,window,the,state,window,is,the,code,window,in,which,we,keep,the,actual,state,of,a,given,in,flight,window,windows,might,expand,but,we,keep,to,original,state,window,for,keeping,the,elements,of,the,window,to,avoid,costly,state,juggling,param,window,the,window,for,which,to,get,the,state,window;public,w,get,state,window,w,window,w,result,windows,get,window,if,result,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set,return,result
MergingWindowSet -> public W getStateWindow(W window);1467040572;Returns the state window for the given in-flight {@code Window}. The state window is the_{@code Window} in which we keep the actual state of a given in-flight window. Windows_might expand but we keep to original state window for keeping the elements of the window_to avoid costly state juggling.__@param window The window for which to get the state window.;public W getStateWindow(W window) {_		W result = windows.get(window)__		if (result == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}__		return result__	};returns,the,state,window,for,the,given,in,flight,code,window,the,state,window,is,the,code,window,in,which,we,keep,the,actual,state,of,a,given,in,flight,window,windows,might,expand,but,we,keep,to,original,state,window,for,keeping,the,elements,of,the,window,to,avoid,costly,state,juggling,param,window,the,window,for,which,to,get,the,state,window;public,w,get,state,window,w,window,w,result,windows,get,window,if,result,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set,return,result
MergingWindowSet -> public W getStateWindow(W window);1469560325;Returns the state window for the given in-flight {@code Window}. The state window is the_{@code Window} in which we keep the actual state of a given in-flight window. Windows_might expand but we keep to original state window for keeping the elements of the window_to avoid costly state juggling.__@param window The window for which to get the state window.;public W getStateWindow(W window) {_		return windows.get(window)__	};returns,the,state,window,for,the,given,in,flight,code,window,the,state,window,is,the,code,window,in,which,we,keep,the,actual,state,of,a,given,in,flight,window,windows,might,expand,but,we,keep,to,original,state,window,for,keeping,the,elements,of,the,window,to,avoid,costly,state,juggling,param,window,the,window,for,which,to,get,the,state,window;public,w,get,state,window,w,window,return,windows,get,window
MergingWindowSet -> public W getStateWindow(W window);1473960699;Returns the state window for the given in-flight {@code Window}. The state window is the_{@code Window} in which we keep the actual state of a given in-flight window. Windows_might expand but we keep to original state window for keeping the elements of the window_to avoid costly state juggling.__@param window The window for which to get the state window.;public W getStateWindow(W window) {_		return windows.get(window)__	};returns,the,state,window,for,the,given,in,flight,code,window,the,state,window,is,the,code,window,in,which,we,keep,the,actual,state,of,a,given,in,flight,window,windows,might,expand,but,we,keep,to,original,state,window,for,keeping,the,elements,of,the,window,to,avoid,costly,state,juggling,param,window,the,window,for,which,to,get,the,state,window;public,w,get,state,window,w,window,return,windows,get,window
MergingWindowSet -> public W getStateWindow(W window);1478005374;Returns the state window for the given in-flight {@code Window}. The state window is the_{@code Window} in which we keep the actual state of a given in-flight window. Windows_might expand but we keep to original state window for keeping the elements of the window_to avoid costly state juggling.__@param window The window for which to get the state window.;public W getStateWindow(W window) {_		return mapping.get(window)__	};returns,the,state,window,for,the,given,in,flight,code,window,the,state,window,is,the,code,window,in,which,we,keep,the,actual,state,of,a,given,in,flight,window,windows,might,expand,but,we,keep,to,original,state,window,for,keeping,the,elements,of,the,window,to,avoid,costly,state,juggling,param,window,the,window,for,which,to,get,the,state,window;public,w,get,state,window,w,window,return,mapping,get,window
MergingWindowSet -> public W getStateWindow(W window);1485170307;Returns the state window for the given in-flight {@code Window}. The state window is the_{@code Window} in which we keep the actual state of a given in-flight window. Windows_might expand but we keep to original state window for keeping the elements of the window_to avoid costly state juggling.__@param window The window for which to get the state window.;public W getStateWindow(W window) {_		return mapping.get(window)__	};returns,the,state,window,for,the,given,in,flight,code,window,the,state,window,is,the,code,window,in,which,we,keep,the,actual,state,of,a,given,in,flight,window,windows,might,expand,but,we,keep,to,original,state,window,for,keeping,the,elements,of,the,window,to,avoid,costly,state,juggling,param,window,the,window,for,which,to,get,the,state,window;public,w,get,state,window,w,window,return,mapping,get,window
MergingWindowSet -> public W getStateWindow(W window);1487868265;Returns the state window for the given in-flight {@code Window}. The state window is the_{@code Window} in which we keep the actual state of a given in-flight window. Windows_might expand but we keep to original state window for keeping the elements of the window_to avoid costly state juggling.__@param window The window for which to get the state window.;public W getStateWindow(W window) {_		return mapping.get(window)__	};returns,the,state,window,for,the,given,in,flight,code,window,the,state,window,is,the,code,window,in,which,we,keep,the,actual,state,of,a,given,in,flight,window,windows,might,expand,but,we,keep,to,original,state,window,for,keeping,the,elements,of,the,window,to,avoid,costly,state,juggling,param,window,the,window,for,which,to,get,the,state,window;public,w,get,state,window,w,window,return,mapping,get,window
MergingWindowSet -> public W getStateWindow(W window);1493195810;Returns the state window for the given in-flight {@code Window}. The state window is the_{@code Window} in which we keep the actual state of a given in-flight window. Windows_might expand but we keep to original state window for keeping the elements of the window_to avoid costly state juggling.__@param window The window for which to get the state window.;public W getStateWindow(W window) {_		return mapping.get(window)__	};returns,the,state,window,for,the,given,in,flight,code,window,the,state,window,is,the,code,window,in,which,we,keep,the,actual,state,of,a,given,in,flight,window,windows,might,expand,but,we,keep,to,original,state,window,for,keeping,the,elements,of,the,window,to,avoid,costly,state,juggling,param,window,the,window,for,which,to,get,the,state,window;public,w,get,state,window,w,window,return,mapping,get,window
MergingWindowSet -> public W getStateWindow(W window);1495484544;Returns the state window for the given in-flight {@code Window}. The state window is the_{@code Window} in which we keep the actual state of a given in-flight window. Windows_might expand but we keep to original state window for keeping the elements of the window_to avoid costly state juggling.__@param window The window for which to get the state window.;public W getStateWindow(W window) {_		return mapping.get(window)__	};returns,the,state,window,for,the,given,in,flight,code,window,the,state,window,is,the,code,window,in,which,we,keep,the,actual,state,of,a,given,in,flight,window,windows,might,expand,but,we,keep,to,original,state,window,for,keeping,the,elements,of,the,window,to,avoid,costly,state,juggling,param,window,the,window,for,which,to,get,the,state,window;public,w,get,state,window,w,window,return,mapping,get,window
MergingWindowSet -> public W getStateWindow(W window);1515177485;Returns the state window for the given in-flight {@code Window}. The state window is the_{@code Window} in which we keep the actual state of a given in-flight window. Windows_might expand but we keep to original state window for keeping the elements of the window_to avoid costly state juggling.__@param window The window for which to get the state window.;public W getStateWindow(W window) {_		return mapping.get(window)__	};returns,the,state,window,for,the,given,in,flight,code,window,the,state,window,is,the,code,window,in,which,we,keep,the,actual,state,of,a,given,in,flight,window,windows,might,expand,but,we,keep,to,original,state,window,for,keeping,the,elements,of,the,window,to,avoid,costly,state,juggling,param,window,the,window,for,which,to,get,the,state,window;public,w,get,state,window,w,window,return,mapping,get,window
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner);1459869538;Creates a new {@link MergingWindowSet} that uses the given {@link MergingWindowAssigner}.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner) {_		this.windowAssigner = windowAssigner___		windows = new HashMap<>()__	};creates,a,new,link,merging,window,set,that,uses,the,given,link,merging,window,assigner;public,merging,window,set,merging,window,assigner,w,window,assigner,this,window,assigner,window,assigner,windows,new,hash,map
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner);1461572320;Creates a new {@link MergingWindowSet} that uses the given {@link MergingWindowAssigner}.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner) {_		this.windowAssigner = windowAssigner___		windows = new HashMap<>()__	};creates,a,new,link,merging,window,set,that,uses,the,given,link,merging,window,assigner;public,merging,window,set,merging,window,assigner,w,window,assigner,this,window,assigner,window,assigner,windows,new,hash,map
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner);1467040572;Creates a new {@link MergingWindowSet} that uses the given {@link MergingWindowAssigner}.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner) {_		this.windowAssigner = windowAssigner__		windows = new HashMap<>()__	};creates,a,new,link,merging,window,set,that,uses,the,given,link,merging,window,assigner;public,merging,window,set,merging,window,assigner,w,window,assigner,this,window,assigner,window,assigner,windows,new,hash,map
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner);1469560325;Creates a new {@link MergingWindowSet} that uses the given {@link MergingWindowAssigner}.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner) {_		this.windowAssigner = windowAssigner__		windows = new HashMap<>()__	};creates,a,new,link,merging,window,set,that,uses,the,given,link,merging,window,assigner;public,merging,window,set,merging,window,assigner,w,window,assigner,this,window,assigner,window,assigner,windows,new,hash,map
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner);1473960699;Creates a new {@link MergingWindowSet} that uses the given {@link MergingWindowAssigner}.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner) {_		this.windowAssigner = windowAssigner__		windows = new HashMap<>()__	};creates,a,new,link,merging,window,set,that,uses,the,given,link,merging,window,assigner;public,merging,window,set,merging,window,assigner,w,window,assigner,this,window,assigner,window,assigner,windows,new,hash,map
MergingWindowSet -> MergeFunction -> void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;1459869538;This gets called when a merge occurs.__@param mergeResult The newly resulting merged {@code Window}._@param mergedWindows The merged {@code Window Windows}._@param stateWindowResult The state window of the merge result._@param mergedStateWindows The merged state windows._@throws Exception;void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;this,gets,called,when,a,merge,occurs,param,merge,result,the,newly,resulting,merged,code,window,param,merged,windows,the,merged,code,window,windows,param,state,window,result,the,state,window,of,the,merge,result,param,merged,state,windows,the,merged,state,windows,throws,exception;void,merge,w,merge,result,collection,w,merged,windows,w,state,window,result,collection,w,merged,state,windows,throws,exception
MergingWindowSet -> MergeFunction -> void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;1461572320;This gets called when a merge occurs.__@param mergeResult The newly resulting merged {@code Window}._@param mergedWindows The merged {@code Window Windows}._@param stateWindowResult The state window of the merge result._@param mergedStateWindows The merged state windows._@throws Exception;void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;this,gets,called,when,a,merge,occurs,param,merge,result,the,newly,resulting,merged,code,window,param,merged,windows,the,merged,code,window,windows,param,state,window,result,the,state,window,of,the,merge,result,param,merged,state,windows,the,merged,state,windows,throws,exception;void,merge,w,merge,result,collection,w,merged,windows,w,state,window,result,collection,w,merged,state,windows,throws,exception
MergingWindowSet -> MergeFunction -> void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;1467040572;This gets called when a merge occurs.__@param mergeResult The newly resulting merged {@code Window}._@param mergedWindows The merged {@code Window Windows}._@param stateWindowResult The state window of the merge result._@param mergedStateWindows The merged state windows._@throws Exception;void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;this,gets,called,when,a,merge,occurs,param,merge,result,the,newly,resulting,merged,code,window,param,merged,windows,the,merged,code,window,windows,param,state,window,result,the,state,window,of,the,merge,result,param,merged,state,windows,the,merged,state,windows,throws,exception;void,merge,w,merge,result,collection,w,merged,windows,w,state,window,result,collection,w,merged,state,windows,throws,exception
MergingWindowSet -> MergeFunction -> void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;1469560325;This gets called when a merge occurs.__@param mergeResult The newly resulting merged {@code Window}._@param mergedWindows The merged {@code Window Windows}._@param stateWindowResult The state window of the merge result._@param mergedStateWindows The merged state windows._@throws Exception;void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;this,gets,called,when,a,merge,occurs,param,merge,result,the,newly,resulting,merged,code,window,param,merged,windows,the,merged,code,window,windows,param,state,window,result,the,state,window,of,the,merge,result,param,merged,state,windows,the,merged,state,windows,throws,exception;void,merge,w,merge,result,collection,w,merged,windows,w,state,window,result,collection,w,merged,state,windows,throws,exception
MergingWindowSet -> MergeFunction -> void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;1473960699;This gets called when a merge occurs.__@param mergeResult The newly resulting merged {@code Window}._@param mergedWindows The merged {@code Window Windows}._@param stateWindowResult The state window of the merge result._@param mergedStateWindows The merged state windows._@throws Exception;void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;this,gets,called,when,a,merge,occurs,param,merge,result,the,newly,resulting,merged,code,window,param,merged,windows,the,merged,code,window,windows,param,state,window,result,the,state,window,of,the,merge,result,param,merged,state,windows,the,merged,state,windows,throws,exception;void,merge,w,merge,result,collection,w,merged,windows,w,state,window,result,collection,w,merged,state,windows,throws,exception
MergingWindowSet -> MergeFunction -> void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;1478005374;This gets called when a merge occurs.__@param mergeResult The newly resulting merged {@code Window}._@param mergedWindows The merged {@code Window Windows}._@param stateWindowResult The state window of the merge result._@param mergedStateWindows The merged state windows._@throws Exception;void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;this,gets,called,when,a,merge,occurs,param,merge,result,the,newly,resulting,merged,code,window,param,merged,windows,the,merged,code,window,windows,param,state,window,result,the,state,window,of,the,merge,result,param,merged,state,windows,the,merged,state,windows,throws,exception;void,merge,w,merge,result,collection,w,merged,windows,w,state,window,result,collection,w,merged,state,windows,throws,exception
MergingWindowSet -> MergeFunction -> void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;1485170307;This gets called when a merge occurs.__@param mergeResult The newly resulting merged {@code Window}._@param mergedWindows The merged {@code Window Windows}._@param stateWindowResult The state window of the merge result._@param mergedStateWindows The merged state windows._@throws Exception;void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;this,gets,called,when,a,merge,occurs,param,merge,result,the,newly,resulting,merged,code,window,param,merged,windows,the,merged,code,window,windows,param,state,window,result,the,state,window,of,the,merge,result,param,merged,state,windows,the,merged,state,windows,throws,exception;void,merge,w,merge,result,collection,w,merged,windows,w,state,window,result,collection,w,merged,state,windows,throws,exception
MergingWindowSet -> MergeFunction -> void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;1487868265;This gets called when a merge occurs.__@param mergeResult The newly resulting merged {@code Window}._@param mergedWindows The merged {@code Window Windows}._@param stateWindowResult The state window of the merge result._@param mergedStateWindows The merged state windows._@throws Exception;void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;this,gets,called,when,a,merge,occurs,param,merge,result,the,newly,resulting,merged,code,window,param,merged,windows,the,merged,code,window,windows,param,state,window,result,the,state,window,of,the,merge,result,param,merged,state,windows,the,merged,state,windows,throws,exception;void,merge,w,merge,result,collection,w,merged,windows,w,state,window,result,collection,w,merged,state,windows,throws,exception
MergingWindowSet -> MergeFunction -> void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;1493195810;This gets called when a merge occurs.__@param mergeResult The newly resulting merged {@code Window}._@param mergedWindows The merged {@code Window Windows}._@param stateWindowResult The state window of the merge result._@param mergedStateWindows The merged state windows._@throws Exception;void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;this,gets,called,when,a,merge,occurs,param,merge,result,the,newly,resulting,merged,code,window,param,merged,windows,the,merged,code,window,windows,param,state,window,result,the,state,window,of,the,merge,result,param,merged,state,windows,the,merged,state,windows,throws,exception;void,merge,w,merge,result,collection,w,merged,windows,w,state,window,result,collection,w,merged,state,windows,throws,exception
MergingWindowSet -> MergeFunction -> void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;1495484544;This gets called when a merge occurs.__@param mergeResult The newly resulting merged {@code Window}._@param mergedWindows The merged {@code Window Windows}._@param stateWindowResult The state window of the merge result._@param mergedStateWindows The merged state windows._@throws Exception;void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;this,gets,called,when,a,merge,occurs,param,merge,result,the,newly,resulting,merged,code,window,param,merged,windows,the,merged,code,window,windows,param,state,window,result,the,state,window,of,the,merge,result,param,merged,state,windows,the,merged,state,windows,throws,exception;void,merge,w,merge,result,collection,w,merged,windows,w,state,window,result,collection,w,merged,state,windows,throws,exception
MergingWindowSet -> MergeFunction -> void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;1515177485;This gets called when a merge occurs.__@param mergeResult The newly resulting merged {@code Window}._@param mergedWindows The merged {@code Window Windows}._@param stateWindowResult The state window of the merge result._@param mergedStateWindows The merged state windows._@throws Exception;void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception_;this,gets,called,when,a,merge,occurs,param,merge,result,the,newly,resulting,merged,code,window,param,merged,windows,the,merged,code,window,windows,param,state,window,result,the,state,window,of,the,merge,result,param,merged,state,windows,the,merged,state,windows,throws,exception;void,merge,w,merge,result,collection,w,merged,windows,w,state,window,result,collection,w,merged,state,windows,throws,exception
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception;1461572320;Restores a {@link MergingWindowSet} from the given state.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {_		this.windowAssigner = windowAssigner__		windows = new HashMap<>()___		for (Tuple2<W, W> window: state.get()) {_			windows.put(window.f0, window.f1)__		}_	};restores,a,link,merging,window,set,from,the,given,state;public,merging,window,set,merging,window,assigner,w,window,assigner,list,state,tuple2,w,w,state,throws,exception,this,window,assigner,window,assigner,windows,new,hash,map,for,tuple2,w,w,window,state,get,windows,put,window,f0,window,f1
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception;1467040572;Restores a {@link MergingWindowSet} from the given state.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {_		this.windowAssigner = windowAssigner__		windows = new HashMap<>()___		for (Tuple2<W, W> window: state.get()) {_			windows.put(window.f0, window.f1)__		}_	};restores,a,link,merging,window,set,from,the,given,state;public,merging,window,set,merging,window,assigner,w,window,assigner,list,state,tuple2,w,w,state,throws,exception,this,window,assigner,window,assigner,windows,new,hash,map,for,tuple2,w,w,window,state,get,windows,put,window,f0,window,f1
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception;1469560325;Restores a {@link MergingWindowSet} from the given state.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {_		this.windowAssigner = windowAssigner__		windows = new HashMap<>()___		Iterable<Tuple2<W, W>> windowState = state.get()__		if (windowState != null) {_			for (Tuple2<W, W> window: windowState) {_				windows.put(window.f0, window.f1)__			}_		}_	};restores,a,link,merging,window,set,from,the,given,state;public,merging,window,set,merging,window,assigner,w,window,assigner,list,state,tuple2,w,w,state,throws,exception,this,window,assigner,window,assigner,windows,new,hash,map,iterable,tuple2,w,w,window,state,state,get,if,window,state,null,for,tuple2,w,w,window,window,state,windows,put,window,f0,window,f1
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception;1473960699;Restores a {@link MergingWindowSet} from the given state.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {_		this.windowAssigner = windowAssigner__		windows = new HashMap<>()___		Iterable<Tuple2<W, W>> windowState = state.get()__		if (windowState != null) {_			for (Tuple2<W, W> window: windowState) {_				windows.put(window.f0, window.f1)__			}_		}_	};restores,a,link,merging,window,set,from,the,given,state;public,merging,window,set,merging,window,assigner,w,window,assigner,list,state,tuple2,w,w,state,throws,exception,this,window,assigner,window,assigner,windows,new,hash,map,iterable,tuple2,w,w,window,state,state,get,if,window,state,null,for,tuple2,w,w,window,window,state,windows,put,window,f0,window,f1
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception;1478005374;Restores a {@link MergingWindowSet} from the given state.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {_		this.windowAssigner = windowAssigner__		mapping = new HashMap<>()___		Iterable<Tuple2<W, W>> windowState = state.get()__		if (windowState != null) {_			for (Tuple2<W, W> window: windowState) {_				mapping.put(window.f0, window.f1)__			}_		}__		this.state = state___		initialMapping = new HashMap<>()__		initialMapping.putAll(mapping)__	};restores,a,link,merging,window,set,from,the,given,state;public,merging,window,set,merging,window,assigner,w,window,assigner,list,state,tuple2,w,w,state,throws,exception,this,window,assigner,window,assigner,mapping,new,hash,map,iterable,tuple2,w,w,window,state,state,get,if,window,state,null,for,tuple2,w,w,window,window,state,mapping,put,window,f0,window,f1,this,state,state,initial,mapping,new,hash,map,initial,mapping,put,all,mapping
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception;1485170307;Restores a {@link MergingWindowSet} from the given state.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {_		this.windowAssigner = windowAssigner__		mapping = new HashMap<>()___		Iterable<Tuple2<W, W>> windowState = state.get()__		if (windowState != null) {_			for (Tuple2<W, W> window: windowState) {_				mapping.put(window.f0, window.f1)__			}_		}__		this.state = state___		initialMapping = new HashMap<>()__		initialMapping.putAll(mapping)__	};restores,a,link,merging,window,set,from,the,given,state;public,merging,window,set,merging,window,assigner,w,window,assigner,list,state,tuple2,w,w,state,throws,exception,this,window,assigner,window,assigner,mapping,new,hash,map,iterable,tuple2,w,w,window,state,state,get,if,window,state,null,for,tuple2,w,w,window,window,state,mapping,put,window,f0,window,f1,this,state,state,initial,mapping,new,hash,map,initial,mapping,put,all,mapping
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception;1487868265;Restores a {@link MergingWindowSet} from the given state.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {_		this.windowAssigner = windowAssigner__		mapping = new HashMap<>()___		Iterable<Tuple2<W, W>> windowState = state.get()__		if (windowState != null) {_			for (Tuple2<W, W> window: windowState) {_				mapping.put(window.f0, window.f1)__			}_		}__		this.state = state___		initialMapping = new HashMap<>()__		initialMapping.putAll(mapping)__	};restores,a,link,merging,window,set,from,the,given,state;public,merging,window,set,merging,window,assigner,w,window,assigner,list,state,tuple2,w,w,state,throws,exception,this,window,assigner,window,assigner,mapping,new,hash,map,iterable,tuple2,w,w,window,state,state,get,if,window,state,null,for,tuple2,w,w,window,window,state,mapping,put,window,f0,window,f1,this,state,state,initial,mapping,new,hash,map,initial,mapping,put,all,mapping
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception;1493195810;Restores a {@link MergingWindowSet} from the given state.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {_		this.windowAssigner = windowAssigner__		mapping = new HashMap<>()___		Iterable<Tuple2<W, W>> windowState = state.get()__		if (windowState != null) {_			for (Tuple2<W, W> window: windowState) {_				mapping.put(window.f0, window.f1)__			}_		}__		this.state = state___		initialMapping = new HashMap<>()__		initialMapping.putAll(mapping)__	};restores,a,link,merging,window,set,from,the,given,state;public,merging,window,set,merging,window,assigner,w,window,assigner,list,state,tuple2,w,w,state,throws,exception,this,window,assigner,window,assigner,mapping,new,hash,map,iterable,tuple2,w,w,window,state,state,get,if,window,state,null,for,tuple2,w,w,window,window,state,mapping,put,window,f0,window,f1,this,state,state,initial,mapping,new,hash,map,initial,mapping,put,all,mapping
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception;1495484544;Restores a {@link MergingWindowSet} from the given state.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {_		this.windowAssigner = windowAssigner__		mapping = new HashMap<>()___		Iterable<Tuple2<W, W>> windowState = state.get()__		if (windowState != null) {_			for (Tuple2<W, W> window: windowState) {_				mapping.put(window.f0, window.f1)__			}_		}__		this.state = state___		initialMapping = new HashMap<>()__		initialMapping.putAll(mapping)__	};restores,a,link,merging,window,set,from,the,given,state;public,merging,window,set,merging,window,assigner,w,window,assigner,list,state,tuple2,w,w,state,throws,exception,this,window,assigner,window,assigner,mapping,new,hash,map,iterable,tuple2,w,w,window,state,state,get,if,window,state,null,for,tuple2,w,w,window,window,state,mapping,put,window,f0,window,f1,this,state,state,initial,mapping,new,hash,map,initial,mapping,put,all,mapping
MergingWindowSet -> public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception;1515177485;Restores a {@link MergingWindowSet} from the given state.;public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {_		this.windowAssigner = windowAssigner__		mapping = new HashMap<>()___		Iterable<Tuple2<W, W>> windowState = state.get()__		if (windowState != null) {_			for (Tuple2<W, W> window: windowState) {_				mapping.put(window.f0, window.f1)__			}_		}__		this.state = state___		initialMapping = new HashMap<>()__		initialMapping.putAll(mapping)__	};restores,a,link,merging,window,set,from,the,given,state;public,merging,window,set,merging,window,assigner,w,window,assigner,list,state,tuple2,w,w,state,throws,exception,this,window,assigner,window,assigner,mapping,new,hash,map,iterable,tuple2,w,w,window,state,state,get,if,window,state,null,for,tuple2,w,w,window,window,state,mapping,put,window,f0,window,f1,this,state,state,initial,mapping,new,hash,map,initial,mapping,put,all,mapping
MergingWindowSet -> public void persist() throws Exception;1478005374;Persist the updated mapping to the given state if the mapping changed since_initialization.;public void persist() throws Exception {_		if (!mapping.equals(initialMapping)) {_			state.clear()__			for (Map.Entry<W, W> window : mapping.entrySet()) {_				state.add(new Tuple2<>(window.getKey(), window.getValue()))__			}_		}_	};persist,the,updated,mapping,to,the,given,state,if,the,mapping,changed,since,initialization;public,void,persist,throws,exception,if,mapping,equals,initial,mapping,state,clear,for,map,entry,w,w,window,mapping,entry,set,state,add,new,tuple2,window,get,key,window,get,value
MergingWindowSet -> public void persist() throws Exception;1485170307;Persist the updated mapping to the given state if the mapping changed since_initialization.;public void persist() throws Exception {_		if (!mapping.equals(initialMapping)) {_			state.clear()__			for (Map.Entry<W, W> window : mapping.entrySet()) {_				state.add(new Tuple2<>(window.getKey(), window.getValue()))__			}_		}_	};persist,the,updated,mapping,to,the,given,state,if,the,mapping,changed,since,initialization;public,void,persist,throws,exception,if,mapping,equals,initial,mapping,state,clear,for,map,entry,w,w,window,mapping,entry,set,state,add,new,tuple2,window,get,key,window,get,value
MergingWindowSet -> public void persist() throws Exception;1487868265;Persist the updated mapping to the given state if the mapping changed since_initialization.;public void persist() throws Exception {_		if (!mapping.equals(initialMapping)) {_			state.clear()__			for (Map.Entry<W, W> window : mapping.entrySet()) {_				state.add(new Tuple2<>(window.getKey(), window.getValue()))__			}_		}_	};persist,the,updated,mapping,to,the,given,state,if,the,mapping,changed,since,initialization;public,void,persist,throws,exception,if,mapping,equals,initial,mapping,state,clear,for,map,entry,w,w,window,mapping,entry,set,state,add,new,tuple2,window,get,key,window,get,value
MergingWindowSet -> public void persist() throws Exception;1493195810;Persist the updated mapping to the given state if the mapping changed since_initialization.;public void persist() throws Exception {_		if (!mapping.equals(initialMapping)) {_			state.clear()__			for (Map.Entry<W, W> window : mapping.entrySet()) {_				state.add(new Tuple2<>(window.getKey(), window.getValue()))__			}_		}_	};persist,the,updated,mapping,to,the,given,state,if,the,mapping,changed,since,initialization;public,void,persist,throws,exception,if,mapping,equals,initial,mapping,state,clear,for,map,entry,w,w,window,mapping,entry,set,state,add,new,tuple2,window,get,key,window,get,value
MergingWindowSet -> public void persist() throws Exception;1495484544;Persist the updated mapping to the given state if the mapping changed since_initialization.;public void persist() throws Exception {_		if (!mapping.equals(initialMapping)) {_			state.clear()__			for (Map.Entry<W, W> window : mapping.entrySet()) {_				state.add(new Tuple2<>(window.getKey(), window.getValue()))__			}_		}_	};persist,the,updated,mapping,to,the,given,state,if,the,mapping,changed,since,initialization;public,void,persist,throws,exception,if,mapping,equals,initial,mapping,state,clear,for,map,entry,w,w,window,mapping,entry,set,state,add,new,tuple2,window,get,key,window,get,value
MergingWindowSet -> public void persist() throws Exception;1515177485;Persist the updated mapping to the given state if the mapping changed since_initialization.;public void persist() throws Exception {_		if (!mapping.equals(initialMapping)) {_			state.clear()__			for (Map.Entry<W, W> window : mapping.entrySet()) {_				state.add(new Tuple2<>(window.getKey(), window.getValue()))__			}_		}_	};persist,the,updated,mapping,to,the,given,state,if,the,mapping,changed,since,initialization;public,void,persist,throws,exception,if,mapping,equals,initial,mapping,state,clear,for,map,entry,w,w,window,mapping,entry,set,state,add,new,tuple2,window,get,key,window,get,value
MergingWindowSet -> public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception;1459869538;Adds a new {@code Window} to the set of in-flight windows. It might happen that this_triggers merging of previously in-flight windows. In that case, the provided_{@link MergeFunction} is called.__<p>This returns the window that is the representative of the added window after adding._This can either be the new window itself, if no merge occured, or the newly merged_window. Adding an element to a window or calling trigger functions should only_happen on the returned representative. This way, we never have to deal with a new window_that is immediately swallowed up by another window.__<p>If the new window is merged the {@code MergeFunction} callback arguments also don't_contain the new window as part of the list of merged windows.__@param newWindow The new {@code Window} to add._@param mergeFunction The callback to be invoked in case a merge occurs.__@return The {@code Window} that new new {@code Window} ended up in. This can also be the_the new {@code Window} itself in case no merge occurred._@throws Exception;public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception {__		List<W> windows = new ArrayList<>()___		windows.addAll(this.windows.keySet())__		windows.add(newWindow)___		final Map<W, Collection<W>> mergeResults = new HashMap<>()__		windowAssigner.mergeWindows(windows,_				new MergingWindowAssigner.MergeCallback<W>() {_					@Override_					public void merge(Collection<W> toBeMerged, W mergeResult) {_						if (LOG.isDebugEnabled()) {_							LOG.debug("Merging {} into {}", toBeMerged, mergeResult)__						}_						mergeResults.put(mergeResult, toBeMerged)__					}_				})___		W resultWindow = newWindow___		_		for (Map.Entry<W, Collection<W>> c: mergeResults.entrySet()) {_			W mergeResult = c.getKey()__			Collection<W> mergedWindows = c.getValue()___			_			_			if (mergedWindows.remove(newWindow)) {_				resultWindow = mergeResult__			}__			_			_			W mergedStateWindow = this.windows.get(mergedWindows.iterator().next())___			_			List<W> mergedStateWindows = new ArrayList<>()__			for (W mergedWindow: mergedWindows) {_				W res = this.windows.remove(mergedWindow)__				if (res != null) {_					mergedStateWindows.add(res)__				}_			}__			this.windows.put(mergeResult, mergedStateWindow)___			_			mergedStateWindows.remove(mergedStateWindow)___			_			_			_			if (!(mergedWindows.contains(mergeResult) && mergedWindows.size() == 1)) {_				mergeFunction.merge(mergeResult,_						mergedWindows,_						this.windows.get(mergeResult),_						mergedStateWindows)__			}_		}__		_		if (resultWindow.equals(newWindow)) {_			this.windows.put(resultWindow, resultWindow)__		}__		return resultWindow__	};adds,a,new,code,window,to,the,set,of,in,flight,windows,it,might,happen,that,this,triggers,merging,of,previously,in,flight,windows,in,that,case,the,provided,link,merge,function,is,called,p,this,returns,the,window,that,is,the,representative,of,the,added,window,after,adding,this,can,either,be,the,new,window,itself,if,no,merge,occured,or,the,newly,merged,window,adding,an,element,to,a,window,or,calling,trigger,functions,should,only,happen,on,the,returned,representative,this,way,we,never,have,to,deal,with,a,new,window,that,is,immediately,swallowed,up,by,another,window,p,if,the,new,window,is,merged,the,code,merge,function,callback,arguments,also,don,t,contain,the,new,window,as,part,of,the,list,of,merged,windows,param,new,window,the,new,code,window,to,add,param,merge,function,the,callback,to,be,invoked,in,case,a,merge,occurs,return,the,code,window,that,new,new,code,window,ended,up,in,this,can,also,be,the,the,new,code,window,itself,in,case,no,merge,occurred,throws,exception;public,w,add,window,w,new,window,merge,function,w,merge,function,throws,exception,list,w,windows,new,array,list,windows,add,all,this,windows,key,set,windows,add,new,window,final,map,w,collection,w,merge,results,new,hash,map,window,assigner,merge,windows,windows,new,merging,window,assigner,merge,callback,w,override,public,void,merge,collection,w,to,be,merged,w,merge,result,if,log,is,debug,enabled,log,debug,merging,into,to,be,merged,merge,result,merge,results,put,merge,result,to,be,merged,w,result,window,new,window,for,map,entry,w,collection,w,c,merge,results,entry,set,w,merge,result,c,get,key,collection,w,merged,windows,c,get,value,if,merged,windows,remove,new,window,result,window,merge,result,w,merged,state,window,this,windows,get,merged,windows,iterator,next,list,w,merged,state,windows,new,array,list,for,w,merged,window,merged,windows,w,res,this,windows,remove,merged,window,if,res,null,merged,state,windows,add,res,this,windows,put,merge,result,merged,state,window,merged,state,windows,remove,merged,state,window,if,merged,windows,contains,merge,result,merged,windows,size,1,merge,function,merge,merge,result,merged,windows,this,windows,get,merge,result,merged,state,windows,if,result,window,equals,new,window,this,windows,put,result,window,result,window,return,result,window
MergingWindowSet -> public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception;1461572320;Adds a new {@code Window} to the set of in-flight windows. It might happen that this_triggers merging of previously in-flight windows. In that case, the provided_{@link MergeFunction} is called.__<p>This returns the window that is the representative of the added window after adding._This can either be the new window itself, if no merge occured, or the newly merged_window. Adding an element to a window or calling trigger functions should only_happen on the returned representative. This way, we never have to deal with a new window_that is immediately swallowed up by another window.__<p>If the new window is merged the {@code MergeFunction} callback arguments also don't_contain the new window as part of the list of merged windows.__@param newWindow The new {@code Window} to add._@param mergeFunction The callback to be invoked in case a merge occurs.__@return The {@code Window} that new new {@code Window} ended up in. This can also be the_the new {@code Window} itself in case no merge occurred._@throws Exception;public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception {__		List<W> windows = new ArrayList<>()___		windows.addAll(this.windows.keySet())__		windows.add(newWindow)___		final Map<W, Collection<W>> mergeResults = new HashMap<>()__		windowAssigner.mergeWindows(windows,_				new MergingWindowAssigner.MergeCallback<W>() {_					@Override_					public void merge(Collection<W> toBeMerged, W mergeResult) {_						if (LOG.isDebugEnabled()) {_							LOG.debug("Merging {} into {}", toBeMerged, mergeResult)__						}_						mergeResults.put(mergeResult, toBeMerged)__					}_				})___		W resultWindow = newWindow___		_		for (Map.Entry<W, Collection<W>> c: mergeResults.entrySet()) {_			W mergeResult = c.getKey()__			Collection<W> mergedWindows = c.getValue()___			_			_			if (mergedWindows.remove(newWindow)) {_				resultWindow = mergeResult__			}__			_			_			W mergedStateWindow = this.windows.get(mergedWindows.iterator().next())___			_			List<W> mergedStateWindows = new ArrayList<>()__			for (W mergedWindow: mergedWindows) {_				W res = this.windows.remove(mergedWindow)__				if (res != null) {_					mergedStateWindows.add(res)__				}_			}__			this.windows.put(mergeResult, mergedStateWindow)___			_			mergedStateWindows.remove(mergedStateWindow)___			_			_			_			if (!(mergedWindows.contains(mergeResult) && mergedWindows.size() == 1)) {_				mergeFunction.merge(mergeResult,_						mergedWindows,_						this.windows.get(mergeResult),_						mergedStateWindows)__			}_		}__		_		if (resultWindow.equals(newWindow)) {_			this.windows.put(resultWindow, resultWindow)__		}__		return resultWindow__	};adds,a,new,code,window,to,the,set,of,in,flight,windows,it,might,happen,that,this,triggers,merging,of,previously,in,flight,windows,in,that,case,the,provided,link,merge,function,is,called,p,this,returns,the,window,that,is,the,representative,of,the,added,window,after,adding,this,can,either,be,the,new,window,itself,if,no,merge,occured,or,the,newly,merged,window,adding,an,element,to,a,window,or,calling,trigger,functions,should,only,happen,on,the,returned,representative,this,way,we,never,have,to,deal,with,a,new,window,that,is,immediately,swallowed,up,by,another,window,p,if,the,new,window,is,merged,the,code,merge,function,callback,arguments,also,don,t,contain,the,new,window,as,part,of,the,list,of,merged,windows,param,new,window,the,new,code,window,to,add,param,merge,function,the,callback,to,be,invoked,in,case,a,merge,occurs,return,the,code,window,that,new,new,code,window,ended,up,in,this,can,also,be,the,the,new,code,window,itself,in,case,no,merge,occurred,throws,exception;public,w,add,window,w,new,window,merge,function,w,merge,function,throws,exception,list,w,windows,new,array,list,windows,add,all,this,windows,key,set,windows,add,new,window,final,map,w,collection,w,merge,results,new,hash,map,window,assigner,merge,windows,windows,new,merging,window,assigner,merge,callback,w,override,public,void,merge,collection,w,to,be,merged,w,merge,result,if,log,is,debug,enabled,log,debug,merging,into,to,be,merged,merge,result,merge,results,put,merge,result,to,be,merged,w,result,window,new,window,for,map,entry,w,collection,w,c,merge,results,entry,set,w,merge,result,c,get,key,collection,w,merged,windows,c,get,value,if,merged,windows,remove,new,window,result,window,merge,result,w,merged,state,window,this,windows,get,merged,windows,iterator,next,list,w,merged,state,windows,new,array,list,for,w,merged,window,merged,windows,w,res,this,windows,remove,merged,window,if,res,null,merged,state,windows,add,res,this,windows,put,merge,result,merged,state,window,merged,state,windows,remove,merged,state,window,if,merged,windows,contains,merge,result,merged,windows,size,1,merge,function,merge,merge,result,merged,windows,this,windows,get,merge,result,merged,state,windows,if,result,window,equals,new,window,this,windows,put,result,window,result,window,return,result,window
MergingWindowSet -> public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception;1467040572;Adds a new {@code Window} to the set of in-flight windows. It might happen that this_triggers merging of previously in-flight windows. In that case, the provided_{@link MergeFunction} is called.__<p>This returns the window that is the representative of the added window after adding._This can either be the new window itself, if no merge occurred, or the newly merged_window. Adding an element to a window or calling trigger functions should only_happen on the returned representative. This way, we never have to deal with a new window_that is immediately swallowed up by another window.__<p>If the new window is merged, the {@code MergeFunction} callback arguments also don't_contain the new window as part of the list of merged windows.__@param newWindow The new {@code Window} to add._@param mergeFunction The callback to be invoked in case a merge occurs.__@return The {@code Window} that new new {@code Window} ended up in. This can also be the_the new {@code Window} itself in case no merge occurred._@throws Exception;public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception {__		List<W> windows = new ArrayList<>()___		windows.addAll(this.windows.keySet())__		windows.add(newWindow)___		final Map<W, Collection<W>> mergeResults = new HashMap<>()__		windowAssigner.mergeWindows(windows,_				new MergingWindowAssigner.MergeCallback<W>() {_					@Override_					public void merge(Collection<W> toBeMerged, W mergeResult) {_						if (LOG.isDebugEnabled()) {_							LOG.debug("Merging {} into {}", toBeMerged, mergeResult)__						}_						mergeResults.put(mergeResult, toBeMerged)__					}_				})___		W resultWindow = newWindow___		_		for (Map.Entry<W, Collection<W>> c: mergeResults.entrySet()) {_			W mergeResult = c.getKey()__			Collection<W> mergedWindows = c.getValue()___			_			_			if (mergedWindows.remove(newWindow)) {_				resultWindow = mergeResult__			}__			_			_			W mergedStateWindow = this.windows.get(mergedWindows.iterator().next())___			_			List<W> mergedStateWindows = new ArrayList<>()__			for (W mergedWindow: mergedWindows) {_				W res = this.windows.remove(mergedWindow)__				if (res != null) {_					mergedStateWindows.add(res)__				}_			}__			this.windows.put(mergeResult, mergedStateWindow)___			_			mergedStateWindows.remove(mergedStateWindow)___			_			_			_			if (!(mergedWindows.contains(mergeResult) && mergedWindows.size() == 1)) {_				mergeFunction.merge(mergeResult,_						mergedWindows,_						this.windows.get(mergeResult),_						mergedStateWindows)__			}_		}__		_		if (resultWindow.equals(newWindow)) {_			this.windows.put(resultWindow, resultWindow)__		}__		return resultWindow__	};adds,a,new,code,window,to,the,set,of,in,flight,windows,it,might,happen,that,this,triggers,merging,of,previously,in,flight,windows,in,that,case,the,provided,link,merge,function,is,called,p,this,returns,the,window,that,is,the,representative,of,the,added,window,after,adding,this,can,either,be,the,new,window,itself,if,no,merge,occurred,or,the,newly,merged,window,adding,an,element,to,a,window,or,calling,trigger,functions,should,only,happen,on,the,returned,representative,this,way,we,never,have,to,deal,with,a,new,window,that,is,immediately,swallowed,up,by,another,window,p,if,the,new,window,is,merged,the,code,merge,function,callback,arguments,also,don,t,contain,the,new,window,as,part,of,the,list,of,merged,windows,param,new,window,the,new,code,window,to,add,param,merge,function,the,callback,to,be,invoked,in,case,a,merge,occurs,return,the,code,window,that,new,new,code,window,ended,up,in,this,can,also,be,the,the,new,code,window,itself,in,case,no,merge,occurred,throws,exception;public,w,add,window,w,new,window,merge,function,w,merge,function,throws,exception,list,w,windows,new,array,list,windows,add,all,this,windows,key,set,windows,add,new,window,final,map,w,collection,w,merge,results,new,hash,map,window,assigner,merge,windows,windows,new,merging,window,assigner,merge,callback,w,override,public,void,merge,collection,w,to,be,merged,w,merge,result,if,log,is,debug,enabled,log,debug,merging,into,to,be,merged,merge,result,merge,results,put,merge,result,to,be,merged,w,result,window,new,window,for,map,entry,w,collection,w,c,merge,results,entry,set,w,merge,result,c,get,key,collection,w,merged,windows,c,get,value,if,merged,windows,remove,new,window,result,window,merge,result,w,merged,state,window,this,windows,get,merged,windows,iterator,next,list,w,merged,state,windows,new,array,list,for,w,merged,window,merged,windows,w,res,this,windows,remove,merged,window,if,res,null,merged,state,windows,add,res,this,windows,put,merge,result,merged,state,window,merged,state,windows,remove,merged,state,window,if,merged,windows,contains,merge,result,merged,windows,size,1,merge,function,merge,merge,result,merged,windows,this,windows,get,merge,result,merged,state,windows,if,result,window,equals,new,window,this,windows,put,result,window,result,window,return,result,window
MergingWindowSet -> public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception;1469560325;Adds a new {@code Window} to the set of in-flight windows. It might happen that this_triggers merging of previously in-flight windows. In that case, the provided_{@link MergeFunction} is called.__<p>This returns the window that is the representative of the added window after adding._This can either be the new window itself, if no merge occurred, or the newly merged_window. Adding an element to a window or calling trigger functions should only_happen on the returned representative. This way, we never have to deal with a new window_that is immediately swallowed up by another window.__<p>If the new window is merged, the {@code MergeFunction} callback arguments also don't_contain the new window as part of the list of merged windows.__@param newWindow The new {@code Window} to add._@param mergeFunction The callback to be invoked in case a merge occurs.__@return The {@code Window} that new new {@code Window} ended up in. This can also be the_the new {@code Window} itself in case no merge occurred._@throws Exception;public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception {__		List<W> windows = new ArrayList<>()___		windows.addAll(this.windows.keySet())__		windows.add(newWindow)___		final Map<W, Collection<W>> mergeResults = new HashMap<>()__		windowAssigner.mergeWindows(windows,_				new MergingWindowAssigner.MergeCallback<W>() {_					@Override_					public void merge(Collection<W> toBeMerged, W mergeResult) {_						if (LOG.isDebugEnabled()) {_							LOG.debug("Merging {} into {}", toBeMerged, mergeResult)__						}_						mergeResults.put(mergeResult, toBeMerged)__					}_				})___		W resultWindow = newWindow___		_		for (Map.Entry<W, Collection<W>> c: mergeResults.entrySet()) {_			W mergeResult = c.getKey()__			Collection<W> mergedWindows = c.getValue()___			_			_			if (mergedWindows.remove(newWindow)) {_				resultWindow = mergeResult__			}__			_			_			W mergedStateWindow = this.windows.get(mergedWindows.iterator().next())___			_			List<W> mergedStateWindows = new ArrayList<>()__			for (W mergedWindow: mergedWindows) {_				W res = this.windows.remove(mergedWindow)__				if (res != null) {_					mergedStateWindows.add(res)__				}_			}__			this.windows.put(mergeResult, mergedStateWindow)___			_			mergedStateWindows.remove(mergedStateWindow)___			_			_			_			if (!(mergedWindows.contains(mergeResult) && mergedWindows.size() == 1)) {_				mergeFunction.merge(mergeResult,_						mergedWindows,_						this.windows.get(mergeResult),_						mergedStateWindows)__			}_		}__		_		if (resultWindow.equals(newWindow)) {_			this.windows.put(resultWindow, resultWindow)__		}__		return resultWindow__	};adds,a,new,code,window,to,the,set,of,in,flight,windows,it,might,happen,that,this,triggers,merging,of,previously,in,flight,windows,in,that,case,the,provided,link,merge,function,is,called,p,this,returns,the,window,that,is,the,representative,of,the,added,window,after,adding,this,can,either,be,the,new,window,itself,if,no,merge,occurred,or,the,newly,merged,window,adding,an,element,to,a,window,or,calling,trigger,functions,should,only,happen,on,the,returned,representative,this,way,we,never,have,to,deal,with,a,new,window,that,is,immediately,swallowed,up,by,another,window,p,if,the,new,window,is,merged,the,code,merge,function,callback,arguments,also,don,t,contain,the,new,window,as,part,of,the,list,of,merged,windows,param,new,window,the,new,code,window,to,add,param,merge,function,the,callback,to,be,invoked,in,case,a,merge,occurs,return,the,code,window,that,new,new,code,window,ended,up,in,this,can,also,be,the,the,new,code,window,itself,in,case,no,merge,occurred,throws,exception;public,w,add,window,w,new,window,merge,function,w,merge,function,throws,exception,list,w,windows,new,array,list,windows,add,all,this,windows,key,set,windows,add,new,window,final,map,w,collection,w,merge,results,new,hash,map,window,assigner,merge,windows,windows,new,merging,window,assigner,merge,callback,w,override,public,void,merge,collection,w,to,be,merged,w,merge,result,if,log,is,debug,enabled,log,debug,merging,into,to,be,merged,merge,result,merge,results,put,merge,result,to,be,merged,w,result,window,new,window,for,map,entry,w,collection,w,c,merge,results,entry,set,w,merge,result,c,get,key,collection,w,merged,windows,c,get,value,if,merged,windows,remove,new,window,result,window,merge,result,w,merged,state,window,this,windows,get,merged,windows,iterator,next,list,w,merged,state,windows,new,array,list,for,w,merged,window,merged,windows,w,res,this,windows,remove,merged,window,if,res,null,merged,state,windows,add,res,this,windows,put,merge,result,merged,state,window,merged,state,windows,remove,merged,state,window,if,merged,windows,contains,merge,result,merged,windows,size,1,merge,function,merge,merge,result,merged,windows,this,windows,get,merge,result,merged,state,windows,if,result,window,equals,new,window,this,windows,put,result,window,result,window,return,result,window
MergingWindowSet -> public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception;1473960699;Adds a new {@code Window} to the set of in-flight windows. It might happen that this_triggers merging of previously in-flight windows. In that case, the provided_{@link MergeFunction} is called.__<p>This returns the window that is the representative of the added window after adding._This can either be the new window itself, if no merge occurred, or the newly merged_window. Adding an element to a window or calling trigger functions should only_happen on the returned representative. This way, we never have to deal with a new window_that is immediately swallowed up by another window.__<p>If the new window is merged, the {@code MergeFunction} callback arguments also don't_contain the new window as part of the list of merged windows.__@param newWindow The new {@code Window} to add._@param mergeFunction The callback to be invoked in case a merge occurs.__@return The {@code Window} that new new {@code Window} ended up in. This can also be the_the new {@code Window} itself in case no merge occurred._@throws Exception;public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception {__		List<W> windows = new ArrayList<>()___		windows.addAll(this.windows.keySet())__		windows.add(newWindow)___		final Map<W, Collection<W>> mergeResults = new HashMap<>()__		windowAssigner.mergeWindows(windows,_				new MergingWindowAssigner.MergeCallback<W>() {_					@Override_					public void merge(Collection<W> toBeMerged, W mergeResult) {_						if (LOG.isDebugEnabled()) {_							LOG.debug("Merging {} into {}", toBeMerged, mergeResult)__						}_						mergeResults.put(mergeResult, toBeMerged)__					}_				})___		W resultWindow = newWindow___		_		for (Map.Entry<W, Collection<W>> c: mergeResults.entrySet()) {_			W mergeResult = c.getKey()__			Collection<W> mergedWindows = c.getValue()___			_			_			if (mergedWindows.remove(newWindow)) {_				resultWindow = mergeResult__			}__			_			_			W mergedStateWindow = this.windows.get(mergedWindows.iterator().next())___			_			List<W> mergedStateWindows = new ArrayList<>()__			for (W mergedWindow: mergedWindows) {_				W res = this.windows.remove(mergedWindow)__				if (res != null) {_					mergedStateWindows.add(res)__				}_			}__			this.windows.put(mergeResult, mergedStateWindow)___			_			mergedStateWindows.remove(mergedStateWindow)___			_			_			_			if (!(mergedWindows.contains(mergeResult) && mergedWindows.size() == 1)) {_				mergeFunction.merge(mergeResult,_						mergedWindows,_						this.windows.get(mergeResult),_						mergedStateWindows)__			}_		}__		_		if (resultWindow.equals(newWindow) && mergeResults.isEmpty()) {_			this.windows.put(resultWindow, resultWindow)__		}__		return resultWindow__	};adds,a,new,code,window,to,the,set,of,in,flight,windows,it,might,happen,that,this,triggers,merging,of,previously,in,flight,windows,in,that,case,the,provided,link,merge,function,is,called,p,this,returns,the,window,that,is,the,representative,of,the,added,window,after,adding,this,can,either,be,the,new,window,itself,if,no,merge,occurred,or,the,newly,merged,window,adding,an,element,to,a,window,or,calling,trigger,functions,should,only,happen,on,the,returned,representative,this,way,we,never,have,to,deal,with,a,new,window,that,is,immediately,swallowed,up,by,another,window,p,if,the,new,window,is,merged,the,code,merge,function,callback,arguments,also,don,t,contain,the,new,window,as,part,of,the,list,of,merged,windows,param,new,window,the,new,code,window,to,add,param,merge,function,the,callback,to,be,invoked,in,case,a,merge,occurs,return,the,code,window,that,new,new,code,window,ended,up,in,this,can,also,be,the,the,new,code,window,itself,in,case,no,merge,occurred,throws,exception;public,w,add,window,w,new,window,merge,function,w,merge,function,throws,exception,list,w,windows,new,array,list,windows,add,all,this,windows,key,set,windows,add,new,window,final,map,w,collection,w,merge,results,new,hash,map,window,assigner,merge,windows,windows,new,merging,window,assigner,merge,callback,w,override,public,void,merge,collection,w,to,be,merged,w,merge,result,if,log,is,debug,enabled,log,debug,merging,into,to,be,merged,merge,result,merge,results,put,merge,result,to,be,merged,w,result,window,new,window,for,map,entry,w,collection,w,c,merge,results,entry,set,w,merge,result,c,get,key,collection,w,merged,windows,c,get,value,if,merged,windows,remove,new,window,result,window,merge,result,w,merged,state,window,this,windows,get,merged,windows,iterator,next,list,w,merged,state,windows,new,array,list,for,w,merged,window,merged,windows,w,res,this,windows,remove,merged,window,if,res,null,merged,state,windows,add,res,this,windows,put,merge,result,merged,state,window,merged,state,windows,remove,merged,state,window,if,merged,windows,contains,merge,result,merged,windows,size,1,merge,function,merge,merge,result,merged,windows,this,windows,get,merge,result,merged,state,windows,if,result,window,equals,new,window,merge,results,is,empty,this,windows,put,result,window,result,window,return,result,window
MergingWindowSet -> public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception;1478005374;Adds a new {@code Window} to the set of in-flight windows. It might happen that this_triggers merging of previously in-flight windows. In that case, the provided_{@link MergeFunction} is called.__<p>This returns the window that is the representative of the added window after adding._This can either be the new window itself, if no merge occurred, or the newly merged_window. Adding an element to a window or calling trigger functions should only_happen on the returned representative. This way, we never have to deal with a new window_that is immediately swallowed up by another window.__<p>If the new window is merged, the {@code MergeFunction} callback arguments also don't_contain the new window as part of the list of merged windows.__@param newWindow The new {@code Window} to add._@param mergeFunction The callback to be invoked in case a merge occurs.__@return The {@code Window} that new new {@code Window} ended up in. This can also be the_the new {@code Window} itself in case no merge occurred._@throws Exception;public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception {__		List<W> windows = new ArrayList<>()___		windows.addAll(this.mapping.keySet())__		windows.add(newWindow)___		final Map<W, Collection<W>> mergeResults = new HashMap<>()__		windowAssigner.mergeWindows(windows,_				new MergingWindowAssigner.MergeCallback<W>() {_					@Override_					public void merge(Collection<W> toBeMerged, W mergeResult) {_						if (LOG.isDebugEnabled()) {_							LOG.debug("Merging {} into {}", toBeMerged, mergeResult)__						}_						mergeResults.put(mergeResult, toBeMerged)__					}_				})___		W resultWindow = newWindow___		_		for (Map.Entry<W, Collection<W>> c: mergeResults.entrySet()) {_			W mergeResult = c.getKey()__			Collection<W> mergedWindows = c.getValue()___			_			_			if (mergedWindows.remove(newWindow)) {_				resultWindow = mergeResult__			}__			_			_			W mergedStateWindow = this.mapping.get(mergedWindows.iterator().next())___			_			List<W> mergedStateWindows = new ArrayList<>()__			for (W mergedWindow: mergedWindows) {_				W res = this.mapping.remove(mergedWindow)__				if (res != null) {_					mergedStateWindows.add(res)__				}_			}__			this.mapping.put(mergeResult, mergedStateWindow)___			_			mergedStateWindows.remove(mergedStateWindow)___			_			_			_			if (!(mergedWindows.contains(mergeResult) && mergedWindows.size() == 1)) {_				mergeFunction.merge(mergeResult,_						mergedWindows,_						this.mapping.get(mergeResult),_						mergedStateWindows)__			}_		}__		_		if (resultWindow.equals(newWindow) && mergeResults.isEmpty()) {_			this.mapping.put(resultWindow, resultWindow)__		}__		return resultWindow__	};adds,a,new,code,window,to,the,set,of,in,flight,windows,it,might,happen,that,this,triggers,merging,of,previously,in,flight,windows,in,that,case,the,provided,link,merge,function,is,called,p,this,returns,the,window,that,is,the,representative,of,the,added,window,after,adding,this,can,either,be,the,new,window,itself,if,no,merge,occurred,or,the,newly,merged,window,adding,an,element,to,a,window,or,calling,trigger,functions,should,only,happen,on,the,returned,representative,this,way,we,never,have,to,deal,with,a,new,window,that,is,immediately,swallowed,up,by,another,window,p,if,the,new,window,is,merged,the,code,merge,function,callback,arguments,also,don,t,contain,the,new,window,as,part,of,the,list,of,merged,windows,param,new,window,the,new,code,window,to,add,param,merge,function,the,callback,to,be,invoked,in,case,a,merge,occurs,return,the,code,window,that,new,new,code,window,ended,up,in,this,can,also,be,the,the,new,code,window,itself,in,case,no,merge,occurred,throws,exception;public,w,add,window,w,new,window,merge,function,w,merge,function,throws,exception,list,w,windows,new,array,list,windows,add,all,this,mapping,key,set,windows,add,new,window,final,map,w,collection,w,merge,results,new,hash,map,window,assigner,merge,windows,windows,new,merging,window,assigner,merge,callback,w,override,public,void,merge,collection,w,to,be,merged,w,merge,result,if,log,is,debug,enabled,log,debug,merging,into,to,be,merged,merge,result,merge,results,put,merge,result,to,be,merged,w,result,window,new,window,for,map,entry,w,collection,w,c,merge,results,entry,set,w,merge,result,c,get,key,collection,w,merged,windows,c,get,value,if,merged,windows,remove,new,window,result,window,merge,result,w,merged,state,window,this,mapping,get,merged,windows,iterator,next,list,w,merged,state,windows,new,array,list,for,w,merged,window,merged,windows,w,res,this,mapping,remove,merged,window,if,res,null,merged,state,windows,add,res,this,mapping,put,merge,result,merged,state,window,merged,state,windows,remove,merged,state,window,if,merged,windows,contains,merge,result,merged,windows,size,1,merge,function,merge,merge,result,merged,windows,this,mapping,get,merge,result,merged,state,windows,if,result,window,equals,new,window,merge,results,is,empty,this,mapping,put,result,window,result,window,return,result,window
MergingWindowSet -> public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception;1485170307;Adds a new {@code Window} to the set of in-flight windows. It might happen that this_triggers merging of previously in-flight windows. In that case, the provided_{@link MergeFunction} is called.__<p>This returns the window that is the representative of the added window after adding._This can either be the new window itself, if no merge occurred, or the newly merged_window. Adding an element to a window or calling trigger functions should only_happen on the returned representative. This way, we never have to deal with a new window_that is immediately swallowed up by another window.__<p>If the new window is merged, the {@code MergeFunction} callback arguments also don't_contain the new window as part of the list of merged windows.__@param newWindow The new {@code Window} to add._@param mergeFunction The callback to be invoked in case a merge occurs.__@return The {@code Window} that new new {@code Window} ended up in. This can also be the_the new {@code Window} itself in case no merge occurred._@throws Exception;public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception {__		List<W> windows = new ArrayList<>()___		windows.addAll(this.mapping.keySet())__		windows.add(newWindow)___		final Map<W, Collection<W>> mergeResults = new HashMap<>()__		windowAssigner.mergeWindows(windows,_				new MergingWindowAssigner.MergeCallback<W>() {_					@Override_					public void merge(Collection<W> toBeMerged, W mergeResult) {_						if (LOG.isDebugEnabled()) {_							LOG.debug("Merging {} into {}", toBeMerged, mergeResult)__						}_						mergeResults.put(mergeResult, toBeMerged)__					}_				})___		W resultWindow = newWindow__		boolean mergedNewWindow = false___		_		for (Map.Entry<W, Collection<W>> c: mergeResults.entrySet()) {_			W mergeResult = c.getKey()__			Collection<W> mergedWindows = c.getValue()___			_			_			if (mergedWindows.remove(newWindow)) {_				mergedNewWindow = true__				resultWindow = mergeResult__			}__			_			_			W mergedStateWindow = this.mapping.get(mergedWindows.iterator().next())___			_			List<W> mergedStateWindows = new ArrayList<>()__			for (W mergedWindow: mergedWindows) {_				W res = this.mapping.remove(mergedWindow)__				if (res != null) {_					mergedStateWindows.add(res)__				}_			}__			this.mapping.put(mergeResult, mergedStateWindow)___			_			mergedStateWindows.remove(mergedStateWindow)___			_			_			_			if (!(mergedWindows.contains(mergeResult) && mergedWindows.size() == 1)) {_				mergeFunction.merge(mergeResult,_						mergedWindows,_						this.mapping.get(mergeResult),_						mergedStateWindows)__			}_		}__		_		if (mergeResults.isEmpty() || (resultWindow.equals(newWindow) && !mergedNewWindow)) {_			this.mapping.put(resultWindow, resultWindow)__		}__		return resultWindow__	};adds,a,new,code,window,to,the,set,of,in,flight,windows,it,might,happen,that,this,triggers,merging,of,previously,in,flight,windows,in,that,case,the,provided,link,merge,function,is,called,p,this,returns,the,window,that,is,the,representative,of,the,added,window,after,adding,this,can,either,be,the,new,window,itself,if,no,merge,occurred,or,the,newly,merged,window,adding,an,element,to,a,window,or,calling,trigger,functions,should,only,happen,on,the,returned,representative,this,way,we,never,have,to,deal,with,a,new,window,that,is,immediately,swallowed,up,by,another,window,p,if,the,new,window,is,merged,the,code,merge,function,callback,arguments,also,don,t,contain,the,new,window,as,part,of,the,list,of,merged,windows,param,new,window,the,new,code,window,to,add,param,merge,function,the,callback,to,be,invoked,in,case,a,merge,occurs,return,the,code,window,that,new,new,code,window,ended,up,in,this,can,also,be,the,the,new,code,window,itself,in,case,no,merge,occurred,throws,exception;public,w,add,window,w,new,window,merge,function,w,merge,function,throws,exception,list,w,windows,new,array,list,windows,add,all,this,mapping,key,set,windows,add,new,window,final,map,w,collection,w,merge,results,new,hash,map,window,assigner,merge,windows,windows,new,merging,window,assigner,merge,callback,w,override,public,void,merge,collection,w,to,be,merged,w,merge,result,if,log,is,debug,enabled,log,debug,merging,into,to,be,merged,merge,result,merge,results,put,merge,result,to,be,merged,w,result,window,new,window,boolean,merged,new,window,false,for,map,entry,w,collection,w,c,merge,results,entry,set,w,merge,result,c,get,key,collection,w,merged,windows,c,get,value,if,merged,windows,remove,new,window,merged,new,window,true,result,window,merge,result,w,merged,state,window,this,mapping,get,merged,windows,iterator,next,list,w,merged,state,windows,new,array,list,for,w,merged,window,merged,windows,w,res,this,mapping,remove,merged,window,if,res,null,merged,state,windows,add,res,this,mapping,put,merge,result,merged,state,window,merged,state,windows,remove,merged,state,window,if,merged,windows,contains,merge,result,merged,windows,size,1,merge,function,merge,merge,result,merged,windows,this,mapping,get,merge,result,merged,state,windows,if,merge,results,is,empty,result,window,equals,new,window,merged,new,window,this,mapping,put,result,window,result,window,return,result,window
MergingWindowSet -> public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception;1487868265;Adds a new {@code Window} to the set of in-flight windows. It might happen that this_triggers merging of previously in-flight windows. In that case, the provided_{@link MergeFunction} is called.__<p>This returns the window that is the representative of the added window after adding._This can either be the new window itself, if no merge occurred, or the newly merged_window. Adding an element to a window or calling trigger functions should only_happen on the returned representative. This way, we never have to deal with a new window_that is immediately swallowed up by another window.__<p>If the new window is merged, the {@code MergeFunction} callback arguments also don't_contain the new window as part of the list of merged windows.__@param newWindow The new {@code Window} to add._@param mergeFunction The callback to be invoked in case a merge occurs.__@return The {@code Window} that new new {@code Window} ended up in. This can also be the_the new {@code Window} itself in case no merge occurred._@throws Exception;public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception {__		List<W> windows = new ArrayList<>()___		windows.addAll(this.mapping.keySet())__		windows.add(newWindow)___		final Map<W, Collection<W>> mergeResults = new HashMap<>()__		windowAssigner.mergeWindows(windows,_				new MergingWindowAssigner.MergeCallback<W>() {_					@Override_					public void merge(Collection<W> toBeMerged, W mergeResult) {_						if (LOG.isDebugEnabled()) {_							LOG.debug("Merging {} into {}", toBeMerged, mergeResult)__						}_						mergeResults.put(mergeResult, toBeMerged)__					}_				})___		W resultWindow = newWindow__		boolean mergedNewWindow = false___		_		for (Map.Entry<W, Collection<W>> c: mergeResults.entrySet()) {_			W mergeResult = c.getKey()__			Collection<W> mergedWindows = c.getValue()___			_			_			if (mergedWindows.remove(newWindow)) {_				mergedNewWindow = true__				resultWindow = mergeResult__			}__			_			_			W mergedStateWindow = this.mapping.get(mergedWindows.iterator().next())___			_			List<W> mergedStateWindows = new ArrayList<>()__			for (W mergedWindow: mergedWindows) {_				W res = this.mapping.remove(mergedWindow)__				if (res != null) {_					mergedStateWindows.add(res)__				}_			}__			this.mapping.put(mergeResult, mergedStateWindow)___			_			mergedStateWindows.remove(mergedStateWindow)___			_			_			_			if (!(mergedWindows.contains(mergeResult) && mergedWindows.size() == 1)) {_				mergeFunction.merge(mergeResult,_						mergedWindows,_						this.mapping.get(mergeResult),_						mergedStateWindows)__			}_		}__		_		if (mergeResults.isEmpty() || (resultWindow.equals(newWindow) && !mergedNewWindow)) {_			this.mapping.put(resultWindow, resultWindow)__		}__		return resultWindow__	};adds,a,new,code,window,to,the,set,of,in,flight,windows,it,might,happen,that,this,triggers,merging,of,previously,in,flight,windows,in,that,case,the,provided,link,merge,function,is,called,p,this,returns,the,window,that,is,the,representative,of,the,added,window,after,adding,this,can,either,be,the,new,window,itself,if,no,merge,occurred,or,the,newly,merged,window,adding,an,element,to,a,window,or,calling,trigger,functions,should,only,happen,on,the,returned,representative,this,way,we,never,have,to,deal,with,a,new,window,that,is,immediately,swallowed,up,by,another,window,p,if,the,new,window,is,merged,the,code,merge,function,callback,arguments,also,don,t,contain,the,new,window,as,part,of,the,list,of,merged,windows,param,new,window,the,new,code,window,to,add,param,merge,function,the,callback,to,be,invoked,in,case,a,merge,occurs,return,the,code,window,that,new,new,code,window,ended,up,in,this,can,also,be,the,the,new,code,window,itself,in,case,no,merge,occurred,throws,exception;public,w,add,window,w,new,window,merge,function,w,merge,function,throws,exception,list,w,windows,new,array,list,windows,add,all,this,mapping,key,set,windows,add,new,window,final,map,w,collection,w,merge,results,new,hash,map,window,assigner,merge,windows,windows,new,merging,window,assigner,merge,callback,w,override,public,void,merge,collection,w,to,be,merged,w,merge,result,if,log,is,debug,enabled,log,debug,merging,into,to,be,merged,merge,result,merge,results,put,merge,result,to,be,merged,w,result,window,new,window,boolean,merged,new,window,false,for,map,entry,w,collection,w,c,merge,results,entry,set,w,merge,result,c,get,key,collection,w,merged,windows,c,get,value,if,merged,windows,remove,new,window,merged,new,window,true,result,window,merge,result,w,merged,state,window,this,mapping,get,merged,windows,iterator,next,list,w,merged,state,windows,new,array,list,for,w,merged,window,merged,windows,w,res,this,mapping,remove,merged,window,if,res,null,merged,state,windows,add,res,this,mapping,put,merge,result,merged,state,window,merged,state,windows,remove,merged,state,window,if,merged,windows,contains,merge,result,merged,windows,size,1,merge,function,merge,merge,result,merged,windows,this,mapping,get,merge,result,merged,state,windows,if,merge,results,is,empty,result,window,equals,new,window,merged,new,window,this,mapping,put,result,window,result,window,return,result,window
MergingWindowSet -> public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception;1493195810;Adds a new {@code Window} to the set of in-flight windows. It might happen that this_triggers merging of previously in-flight windows. In that case, the provided_{@link MergeFunction} is called.__<p>This returns the window that is the representative of the added window after adding._This can either be the new window itself, if no merge occurred, or the newly merged_window. Adding an element to a window or calling trigger functions should only_happen on the returned representative. This way, we never have to deal with a new window_that is immediately swallowed up by another window.__<p>If the new window is merged, the {@code MergeFunction} callback arguments also don't_contain the new window as part of the list of merged windows.__@param newWindow The new {@code Window} to add._@param mergeFunction The callback to be invoked in case a merge occurs.__@return The {@code Window} that new new {@code Window} ended up in. This can also be the_the new {@code Window} itself in case no merge occurred._@throws Exception;public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception {__		List<W> windows = new ArrayList<>()___		windows.addAll(this.mapping.keySet())__		windows.add(newWindow)___		final Map<W, Collection<W>> mergeResults = new HashMap<>()__		windowAssigner.mergeWindows(windows,_				new MergingWindowAssigner.MergeCallback<W>() {_					@Override_					public void merge(Collection<W> toBeMerged, W mergeResult) {_						if (LOG.isDebugEnabled()) {_							LOG.debug("Merging {} into {}", toBeMerged, mergeResult)__						}_						mergeResults.put(mergeResult, toBeMerged)__					}_				})___		W resultWindow = newWindow__		boolean mergedNewWindow = false___		_		for (Map.Entry<W, Collection<W>> c: mergeResults.entrySet()) {_			W mergeResult = c.getKey()__			Collection<W> mergedWindows = c.getValue()___			_			_			if (mergedWindows.remove(newWindow)) {_				mergedNewWindow = true__				resultWindow = mergeResult__			}__			_			_			W mergedStateWindow = this.mapping.get(mergedWindows.iterator().next())___			_			List<W> mergedStateWindows = new ArrayList<>()__			for (W mergedWindow: mergedWindows) {_				W res = this.mapping.remove(mergedWindow)__				if (res != null) {_					mergedStateWindows.add(res)__				}_			}__			this.mapping.put(mergeResult, mergedStateWindow)___			_			mergedStateWindows.remove(mergedStateWindow)___			_			_			_			if (!(mergedWindows.contains(mergeResult) && mergedWindows.size() == 1)) {_				mergeFunction.merge(mergeResult,_						mergedWindows,_						this.mapping.get(mergeResult),_						mergedStateWindows)__			}_		}__		_		if (mergeResults.isEmpty() || (resultWindow.equals(newWindow) && !mergedNewWindow)) {_			this.mapping.put(resultWindow, resultWindow)__		}__		return resultWindow__	};adds,a,new,code,window,to,the,set,of,in,flight,windows,it,might,happen,that,this,triggers,merging,of,previously,in,flight,windows,in,that,case,the,provided,link,merge,function,is,called,p,this,returns,the,window,that,is,the,representative,of,the,added,window,after,adding,this,can,either,be,the,new,window,itself,if,no,merge,occurred,or,the,newly,merged,window,adding,an,element,to,a,window,or,calling,trigger,functions,should,only,happen,on,the,returned,representative,this,way,we,never,have,to,deal,with,a,new,window,that,is,immediately,swallowed,up,by,another,window,p,if,the,new,window,is,merged,the,code,merge,function,callback,arguments,also,don,t,contain,the,new,window,as,part,of,the,list,of,merged,windows,param,new,window,the,new,code,window,to,add,param,merge,function,the,callback,to,be,invoked,in,case,a,merge,occurs,return,the,code,window,that,new,new,code,window,ended,up,in,this,can,also,be,the,the,new,code,window,itself,in,case,no,merge,occurred,throws,exception;public,w,add,window,w,new,window,merge,function,w,merge,function,throws,exception,list,w,windows,new,array,list,windows,add,all,this,mapping,key,set,windows,add,new,window,final,map,w,collection,w,merge,results,new,hash,map,window,assigner,merge,windows,windows,new,merging,window,assigner,merge,callback,w,override,public,void,merge,collection,w,to,be,merged,w,merge,result,if,log,is,debug,enabled,log,debug,merging,into,to,be,merged,merge,result,merge,results,put,merge,result,to,be,merged,w,result,window,new,window,boolean,merged,new,window,false,for,map,entry,w,collection,w,c,merge,results,entry,set,w,merge,result,c,get,key,collection,w,merged,windows,c,get,value,if,merged,windows,remove,new,window,merged,new,window,true,result,window,merge,result,w,merged,state,window,this,mapping,get,merged,windows,iterator,next,list,w,merged,state,windows,new,array,list,for,w,merged,window,merged,windows,w,res,this,mapping,remove,merged,window,if,res,null,merged,state,windows,add,res,this,mapping,put,merge,result,merged,state,window,merged,state,windows,remove,merged,state,window,if,merged,windows,contains,merge,result,merged,windows,size,1,merge,function,merge,merge,result,merged,windows,this,mapping,get,merge,result,merged,state,windows,if,merge,results,is,empty,result,window,equals,new,window,merged,new,window,this,mapping,put,result,window,result,window,return,result,window
MergingWindowSet -> public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception;1495484544;Adds a new {@code Window} to the set of in-flight windows. It might happen that this_triggers merging of previously in-flight windows. In that case, the provided_{@link MergeFunction} is called.__<p>This returns the window that is the representative of the added window after adding._This can either be the new window itself, if no merge occurred, or the newly merged_window. Adding an element to a window or calling trigger functions should only_happen on the returned representative. This way, we never have to deal with a new window_that is immediately swallowed up by another window.__<p>If the new window is merged, the {@code MergeFunction} callback arguments also don't_contain the new window as part of the list of merged windows.__@param newWindow The new {@code Window} to add._@param mergeFunction The callback to be invoked in case a merge occurs.__@return The {@code Window} that new new {@code Window} ended up in. This can also be the_the new {@code Window} itself in case no merge occurred._@throws Exception;public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception {__		List<W> windows = new ArrayList<>()___		windows.addAll(this.mapping.keySet())__		windows.add(newWindow)___		final Map<W, Collection<W>> mergeResults = new HashMap<>()__		windowAssigner.mergeWindows(windows,_				new MergingWindowAssigner.MergeCallback<W>() {_					@Override_					public void merge(Collection<W> toBeMerged, W mergeResult) {_						if (LOG.isDebugEnabled()) {_							LOG.debug("Merging {} into {}", toBeMerged, mergeResult)__						}_						mergeResults.put(mergeResult, toBeMerged)__					}_				})___		W resultWindow = newWindow__		boolean mergedNewWindow = false___		_		for (Map.Entry<W, Collection<W>> c: mergeResults.entrySet()) {_			W mergeResult = c.getKey()__			Collection<W> mergedWindows = c.getValue()___			_			_			if (mergedWindows.remove(newWindow)) {_				mergedNewWindow = true__				resultWindow = mergeResult__			}__			_			_			W mergedStateWindow = this.mapping.get(mergedWindows.iterator().next())___			_			List<W> mergedStateWindows = new ArrayList<>()__			for (W mergedWindow: mergedWindows) {_				W res = this.mapping.remove(mergedWindow)__				if (res != null) {_					mergedStateWindows.add(res)__				}_			}__			this.mapping.put(mergeResult, mergedStateWindow)___			_			mergedStateWindows.remove(mergedStateWindow)___			_			_			_			if (!(mergedWindows.contains(mergeResult) && mergedWindows.size() == 1)) {_				mergeFunction.merge(mergeResult,_						mergedWindows,_						this.mapping.get(mergeResult),_						mergedStateWindows)__			}_		}__		_		if (mergeResults.isEmpty() || (resultWindow.equals(newWindow) && !mergedNewWindow)) {_			this.mapping.put(resultWindow, resultWindow)__		}__		return resultWindow__	};adds,a,new,code,window,to,the,set,of,in,flight,windows,it,might,happen,that,this,triggers,merging,of,previously,in,flight,windows,in,that,case,the,provided,link,merge,function,is,called,p,this,returns,the,window,that,is,the,representative,of,the,added,window,after,adding,this,can,either,be,the,new,window,itself,if,no,merge,occurred,or,the,newly,merged,window,adding,an,element,to,a,window,or,calling,trigger,functions,should,only,happen,on,the,returned,representative,this,way,we,never,have,to,deal,with,a,new,window,that,is,immediately,swallowed,up,by,another,window,p,if,the,new,window,is,merged,the,code,merge,function,callback,arguments,also,don,t,contain,the,new,window,as,part,of,the,list,of,merged,windows,param,new,window,the,new,code,window,to,add,param,merge,function,the,callback,to,be,invoked,in,case,a,merge,occurs,return,the,code,window,that,new,new,code,window,ended,up,in,this,can,also,be,the,the,new,code,window,itself,in,case,no,merge,occurred,throws,exception;public,w,add,window,w,new,window,merge,function,w,merge,function,throws,exception,list,w,windows,new,array,list,windows,add,all,this,mapping,key,set,windows,add,new,window,final,map,w,collection,w,merge,results,new,hash,map,window,assigner,merge,windows,windows,new,merging,window,assigner,merge,callback,w,override,public,void,merge,collection,w,to,be,merged,w,merge,result,if,log,is,debug,enabled,log,debug,merging,into,to,be,merged,merge,result,merge,results,put,merge,result,to,be,merged,w,result,window,new,window,boolean,merged,new,window,false,for,map,entry,w,collection,w,c,merge,results,entry,set,w,merge,result,c,get,key,collection,w,merged,windows,c,get,value,if,merged,windows,remove,new,window,merged,new,window,true,result,window,merge,result,w,merged,state,window,this,mapping,get,merged,windows,iterator,next,list,w,merged,state,windows,new,array,list,for,w,merged,window,merged,windows,w,res,this,mapping,remove,merged,window,if,res,null,merged,state,windows,add,res,this,mapping,put,merge,result,merged,state,window,merged,state,windows,remove,merged,state,window,if,merged,windows,contains,merge,result,merged,windows,size,1,merge,function,merge,merge,result,merged,windows,this,mapping,get,merge,result,merged,state,windows,if,merge,results,is,empty,result,window,equals,new,window,merged,new,window,this,mapping,put,result,window,result,window,return,result,window
MergingWindowSet -> public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception;1515177485;Adds a new {@code Window} to the set of in-flight windows. It might happen that this_triggers merging of previously in-flight windows. In that case, the provided_{@link MergeFunction} is called.__<p>This returns the window that is the representative of the added window after adding._This can either be the new window itself, if no merge occurred, or the newly merged_window. Adding an element to a window or calling trigger functions should only_happen on the returned representative. This way, we never have to deal with a new window_that is immediately swallowed up by another window.__<p>If the new window is merged, the {@code MergeFunction} callback arguments also don't_contain the new window as part of the list of merged windows.__@param newWindow The new {@code Window} to add._@param mergeFunction The callback to be invoked in case a merge occurs.__@return The {@code Window} that new new {@code Window} ended up in. This can also be the_the new {@code Window} itself in case no merge occurred._@throws Exception;public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception {__		List<W> windows = new ArrayList<>()___		windows.addAll(this.mapping.keySet())__		windows.add(newWindow)___		final Map<W, Collection<W>> mergeResults = new HashMap<>()__		windowAssigner.mergeWindows(windows,_				new MergingWindowAssigner.MergeCallback<W>() {_					@Override_					public void merge(Collection<W> toBeMerged, W mergeResult) {_						if (LOG.isDebugEnabled()) {_							LOG.debug("Merging {} into {}", toBeMerged, mergeResult)__						}_						mergeResults.put(mergeResult, toBeMerged)__					}_				})___		W resultWindow = newWindow__		boolean mergedNewWindow = false___		_		for (Map.Entry<W, Collection<W>> c: mergeResults.entrySet()) {_			W mergeResult = c.getKey()__			Collection<W> mergedWindows = c.getValue()___			_			_			if (mergedWindows.remove(newWindow)) {_				mergedNewWindow = true__				resultWindow = mergeResult__			}__			_			_			W mergedStateWindow = this.mapping.get(mergedWindows.iterator().next())___			_			List<W> mergedStateWindows = new ArrayList<>()__			for (W mergedWindow: mergedWindows) {_				W res = this.mapping.remove(mergedWindow)__				if (res != null) {_					mergedStateWindows.add(res)__				}_			}__			this.mapping.put(mergeResult, mergedStateWindow)___			_			mergedStateWindows.remove(mergedStateWindow)___			_			_			_			if (!(mergedWindows.contains(mergeResult) && mergedWindows.size() == 1)) {_				mergeFunction.merge(mergeResult,_						mergedWindows,_						this.mapping.get(mergeResult),_						mergedStateWindows)__			}_		}__		_		if (mergeResults.isEmpty() || (resultWindow.equals(newWindow) && !mergedNewWindow)) {_			this.mapping.put(resultWindow, resultWindow)__		}__		return resultWindow__	};adds,a,new,code,window,to,the,set,of,in,flight,windows,it,might,happen,that,this,triggers,merging,of,previously,in,flight,windows,in,that,case,the,provided,link,merge,function,is,called,p,this,returns,the,window,that,is,the,representative,of,the,added,window,after,adding,this,can,either,be,the,new,window,itself,if,no,merge,occurred,or,the,newly,merged,window,adding,an,element,to,a,window,or,calling,trigger,functions,should,only,happen,on,the,returned,representative,this,way,we,never,have,to,deal,with,a,new,window,that,is,immediately,swallowed,up,by,another,window,p,if,the,new,window,is,merged,the,code,merge,function,callback,arguments,also,don,t,contain,the,new,window,as,part,of,the,list,of,merged,windows,param,new,window,the,new,code,window,to,add,param,merge,function,the,callback,to,be,invoked,in,case,a,merge,occurs,return,the,code,window,that,new,new,code,window,ended,up,in,this,can,also,be,the,the,new,code,window,itself,in,case,no,merge,occurred,throws,exception;public,w,add,window,w,new,window,merge,function,w,merge,function,throws,exception,list,w,windows,new,array,list,windows,add,all,this,mapping,key,set,windows,add,new,window,final,map,w,collection,w,merge,results,new,hash,map,window,assigner,merge,windows,windows,new,merging,window,assigner,merge,callback,w,override,public,void,merge,collection,w,to,be,merged,w,merge,result,if,log,is,debug,enabled,log,debug,merging,into,to,be,merged,merge,result,merge,results,put,merge,result,to,be,merged,w,result,window,new,window,boolean,merged,new,window,false,for,map,entry,w,collection,w,c,merge,results,entry,set,w,merge,result,c,get,key,collection,w,merged,windows,c,get,value,if,merged,windows,remove,new,window,merged,new,window,true,result,window,merge,result,w,merged,state,window,this,mapping,get,merged,windows,iterator,next,list,w,merged,state,windows,new,array,list,for,w,merged,window,merged,windows,w,res,this,mapping,remove,merged,window,if,res,null,merged,state,windows,add,res,this,mapping,put,merge,result,merged,state,window,merged,state,windows,remove,merged,state,window,if,merged,windows,contains,merge,result,merged,windows,size,1,merge,function,merge,merge,result,merged,windows,this,mapping,get,merge,result,merged,state,windows,if,merge,results,is,empty,result,window,equals,new,window,merged,new,window,this,mapping,put,result,window,result,window,return,result,window
MergingWindowSet -> public void retireWindow(W window);1459869538;Removes the given window from the set of in-flight windows.__@param window The {@code Window} to remove.;public void retireWindow(W window) {_		W removed = this.windows.remove(window)__		if (removed == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}_	};removes,the,given,window,from,the,set,of,in,flight,windows,param,window,the,code,window,to,remove;public,void,retire,window,w,window,w,removed,this,windows,remove,window,if,removed,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set
MergingWindowSet -> public void retireWindow(W window);1461572320;Removes the given window from the set of in-flight windows.__@param window The {@code Window} to remove.;public void retireWindow(W window) {_		W removed = this.windows.remove(window)__		if (removed == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}_	};removes,the,given,window,from,the,set,of,in,flight,windows,param,window,the,code,window,to,remove;public,void,retire,window,w,window,w,removed,this,windows,remove,window,if,removed,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set
MergingWindowSet -> public void retireWindow(W window);1467040572;Removes the given window from the set of in-flight windows.__@param window The {@code Window} to remove.;public void retireWindow(W window) {_		W removed = this.windows.remove(window)__		if (removed == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}_	};removes,the,given,window,from,the,set,of,in,flight,windows,param,window,the,code,window,to,remove;public,void,retire,window,w,window,w,removed,this,windows,remove,window,if,removed,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set
MergingWindowSet -> public void retireWindow(W window);1469560325;Removes the given window from the set of in-flight windows.__@param window The {@code Window} to remove.;public void retireWindow(W window) {_		W removed = this.windows.remove(window)__		if (removed == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}_	};removes,the,given,window,from,the,set,of,in,flight,windows,param,window,the,code,window,to,remove;public,void,retire,window,w,window,w,removed,this,windows,remove,window,if,removed,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set
MergingWindowSet -> public void retireWindow(W window);1473960699;Removes the given window from the set of in-flight windows.__@param window The {@code Window} to remove.;public void retireWindow(W window) {_		W removed = this.windows.remove(window)__		if (removed == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}_	};removes,the,given,window,from,the,set,of,in,flight,windows,param,window,the,code,window,to,remove;public,void,retire,window,w,window,w,removed,this,windows,remove,window,if,removed,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set
MergingWindowSet -> public void retireWindow(W window);1478005374;Removes the given window from the set of in-flight windows.__@param window The {@code Window} to remove.;public void retireWindow(W window) {_		W removed = this.mapping.remove(window)__		if (removed == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}_	};removes,the,given,window,from,the,set,of,in,flight,windows,param,window,the,code,window,to,remove;public,void,retire,window,w,window,w,removed,this,mapping,remove,window,if,removed,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set
MergingWindowSet -> public void retireWindow(W window);1485170307;Removes the given window from the set of in-flight windows.__@param window The {@code Window} to remove.;public void retireWindow(W window) {_		W removed = this.mapping.remove(window)__		if (removed == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}_	};removes,the,given,window,from,the,set,of,in,flight,windows,param,window,the,code,window,to,remove;public,void,retire,window,w,window,w,removed,this,mapping,remove,window,if,removed,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set
MergingWindowSet -> public void retireWindow(W window);1487868265;Removes the given window from the set of in-flight windows.__@param window The {@code Window} to remove.;public void retireWindow(W window) {_		W removed = this.mapping.remove(window)__		if (removed == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}_	};removes,the,given,window,from,the,set,of,in,flight,windows,param,window,the,code,window,to,remove;public,void,retire,window,w,window,w,removed,this,mapping,remove,window,if,removed,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set
MergingWindowSet -> public void retireWindow(W window);1493195810;Removes the given window from the set of in-flight windows.__@param window The {@code Window} to remove.;public void retireWindow(W window) {_		W removed = this.mapping.remove(window)__		if (removed == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}_	};removes,the,given,window,from,the,set,of,in,flight,windows,param,window,the,code,window,to,remove;public,void,retire,window,w,window,w,removed,this,mapping,remove,window,if,removed,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set
MergingWindowSet -> public void retireWindow(W window);1495484544;Removes the given window from the set of in-flight windows.__@param window The {@code Window} to remove.;public void retireWindow(W window) {_		W removed = this.mapping.remove(window)__		if (removed == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}_	};removes,the,given,window,from,the,set,of,in,flight,windows,param,window,the,code,window,to,remove;public,void,retire,window,w,window,w,removed,this,mapping,remove,window,if,removed,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set
MergingWindowSet -> public void retireWindow(W window);1515177485;Removes the given window from the set of in-flight windows.__@param window The {@code Window} to remove.;public void retireWindow(W window) {_		W removed = this.mapping.remove(window)__		if (removed == null) {_			throw new IllegalStateException("Window " + window + " is not in in-flight window set.")__		}_	};removes,the,given,window,from,the,set,of,in,flight,windows,param,window,the,code,window,to,remove;public,void,retire,window,w,window,w,removed,this,mapping,remove,window,if,removed,null,throw,new,illegal,state,exception,window,window,is,not,in,in,flight,window,set
