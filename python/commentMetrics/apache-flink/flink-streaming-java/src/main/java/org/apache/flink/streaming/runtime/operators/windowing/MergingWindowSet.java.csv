commented;modifiers;parameterAmount;loc;comment;code
true;public;0;8;/**  * Persist the updated mapping to the given state if the mapping changed since  * initialization.  */ ;/**  * Persist the updated mapping to the given state if the mapping changed since  * initialization.  */ public void persist() throws Exception {     if (!mapping.equals(initialMapping)) {         state.clear().         for (Map.Entry<W, W> window : mapping.entrySet()) {             state.add(new Tuple2<>(window.getKey(), window.getValue())).         }     } }
true;public;1;3;/**  * Returns the state window for the given in-flight {@code Window}. The state window is the  * {@code Window} in which we keep the actual state of a given in-flight window. Windows  * might expand but we keep to original state window for keeping the elements of the window  * to avoid costly state juggling.  *  * @param window The window for which to get the state window.  */ ;/**  * Returns the state window for the given in-flight {@code Window}. The state window is the  * {@code Window} in which we keep the actual state of a given in-flight window. Windows  * might expand but we keep to original state window for keeping the elements of the window  * to avoid costly state juggling.  *  * @param window The window for which to get the state window.  */ public W getStateWindow(W window) {     return mapping.get(window). }
true;public;1;6;/**  * Removes the given window from the set of in-flight windows.  *  * @param window The {@code Window} to remove.  */ ;/**  * Removes the given window from the set of in-flight windows.  *  * @param window The {@code Window} to remove.  */ public void retireWindow(W window) {     W removed = this.mapping.remove(window).     if (removed == null) {         throw new IllegalStateException("Window " + window + " is not in in-flight window set.").     } }
false;public;2;7;;@Override public void merge(Collection<W> toBeMerged, W mergeResult) {     if (LOG.isDebugEnabled()) {         LOG.debug("Merging {} into {}", toBeMerged, mergeResult).     }     mergeResults.put(mergeResult, toBeMerged). }
true;public;2;70;/**  * Adds a new {@code Window} to the set of in-flight windows. It might happen that this  * triggers merging of previously in-flight windows. In that case, the provided  * {@link MergeFunction} is called.  *  * <p>This returns the window that is the representative of the added window after adding.  * This can either be the new window itself, if no merge occurred, or the newly merged  * window. Adding an element to a window or calling trigger functions should only  * happen on the returned representative. This way, we never have to deal with a new window  * that is immediately swallowed up by another window.  *  * <p>If the new window is merged, the {@code MergeFunction} callback arguments also don't  * contain the new window as part of the list of merged windows.  *  * @param newWindow The new {@code Window} to add.  * @param mergeFunction The callback to be invoked in case a merge occurs.  *  * @return The {@code Window} that new new {@code Window} ended up in. This can also be the  *          the new {@code Window} itself in case no merge occurred.  * @throws Exception  */ ;/**  * Adds a new {@code Window} to the set of in-flight windows. It might happen that this  * triggers merging of previously in-flight windows. In that case, the provided  * {@link MergeFunction} is called.  *  * <p>This returns the window that is the representative of the added window after adding.  * This can either be the new window itself, if no merge occurred, or the newly merged  * window. Adding an element to a window or calling trigger functions should only  * happen on the returned representative. This way, we never have to deal with a new window  * that is immediately swallowed up by another window.  *  * <p>If the new window is merged, the {@code MergeFunction} callback arguments also don't  * contain the new window as part of the list of merged windows.  *  * @param newWindow The new {@code Window} to add.  * @param mergeFunction The callback to be invoked in case a merge occurs.  *  * @return The {@code Window} that new new {@code Window} ended up in. This can also be the  *          the new {@code Window} itself in case no merge occurred.  * @throws Exception  */ public W addWindow(W newWindow, MergeFunction<W> mergeFunction) throws Exception {     List<W> windows = new ArrayList<>().     windows.addAll(this.mapping.keySet()).     windows.add(newWindow).     final Map<W, Collection<W>> mergeResults = new HashMap<>().     windowAssigner.mergeWindows(windows, new MergingWindowAssigner.MergeCallback<W>() {          @Override         public void merge(Collection<W> toBeMerged, W mergeResult) {             if (LOG.isDebugEnabled()) {                 LOG.debug("Merging {} into {}", toBeMerged, mergeResult).             }             mergeResults.put(mergeResult, toBeMerged).         }     }).     W resultWindow = newWindow.     boolean mergedNewWindow = false.     // perform the merge     for (Map.Entry<W, Collection<W>> c : mergeResults.entrySet()) {         W mergeResult = c.getKey().         Collection<W> mergedWindows = c.getValue().         // result window         if (mergedWindows.remove(newWindow)) {             mergedNewWindow = true.             resultWindow = mergeResult.         }         // pick any of the merged windows and choose that window's state window         // as the state window for the merge result         W mergedStateWindow = this.mapping.get(mergedWindows.iterator().next()).         // figure out the state windows that we are merging         List<W> mergedStateWindows = new ArrayList<>().         for (W mergedWindow : mergedWindows) {             W res = this.mapping.remove(mergedWindow).             if (res != null) {                 mergedStateWindows.add(res).             }         }         this.mapping.put(mergeResult, mergedStateWindow).         // don't put the target state window into the merged windows         mergedStateWindows.remove(mergedStateWindow).         // without extending the pre-existing window         if (!(mergedWindows.contains(mergeResult) && mergedWindows.size() == 1)) {             mergeFunction.merge(mergeResult, mergedWindows, this.mapping.get(mergeResult), mergedStateWindows).         }     }     // the new window created a new, self-contained window without merging     if (mergeResults.isEmpty() || (resultWindow.equals(newWindow) && !mergedNewWindow)) {         this.mapping.put(resultWindow, resultWindow).     }     return resultWindow. }
true;;4;1;/**  * This gets called when a merge occurs.  *  * @param mergeResult The newly resulting merged {@code Window}.  * @param mergedWindows The merged {@code Window Windows}.  * @param stateWindowResult The state window of the merge result.  * @param mergedStateWindows The merged state windows.  * @throws Exception  */ ;/**  * This gets called when a merge occurs.  *  * @param mergeResult The newly resulting merged {@code Window}.  * @param mergedWindows The merged {@code Window Windows}.  * @param stateWindowResult The state window of the merge result.  * @param mergedStateWindows The merged state windows.  * @throws Exception  */ void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception.
false;public;0;6;;@Override public String toString() {     return "MergingWindowSet{" + "windows=" + mapping + '}'. }
