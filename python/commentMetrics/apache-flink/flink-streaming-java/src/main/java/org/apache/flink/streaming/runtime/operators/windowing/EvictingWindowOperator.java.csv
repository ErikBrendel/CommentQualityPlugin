commented;modifiers;parameterAmount;loc;comment;code
false;public;4;31;;@Override public void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {     if ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {         throw new UnsupportedOperationException("The end timestamp of an " + "event-time window cannot become earlier than the current watermark " + "by merging. Current watermark: " + internalTimerService.currentWatermark() + " window: " + mergeResult).     } else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {         throw new UnsupportedOperationException("The end timestamp of a " + "processing-time window cannot become earlier than the current processing time " + "by merging. Current processing time: " + internalTimerService.currentProcessingTime() + " window: " + mergeResult).     }     triggerContext.key = key.     triggerContext.window = mergeResult.     triggerContext.onMerge(mergedWindows).     for (W m : mergedWindows) {         triggerContext.window = m.         triggerContext.clear().         deleteCleanupTimer(m).     }     // merge the merged state windows into the newly resulting state window     evictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows). }
false;public;1;139;;@Override public void processElement(StreamRecord<IN> element) throws Exception {     final Collection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp(), windowAssignerContext).     // if element is handled by none of assigned elementWindows     boolean isSkippedElement = true.     final K key = this.<K>getKeyedStateBackend().getCurrentKey().     if (windowAssigner instanceof MergingWindowAssigner) {         MergingWindowSet<W> mergingWindows = getMergingWindowSet().         for (W window : elementWindows) {             // adding the new window might result in a merge, in that case the actualWindow             // is the merged window and we work with that. If we don't merge then             // actualWindow == window             W actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {                  @Override                 public void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {                     if ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {                         throw new UnsupportedOperationException("The end timestamp of an " + "event-time window cannot become earlier than the current watermark " + "by merging. Current watermark: " + internalTimerService.currentWatermark() + " window: " + mergeResult).                     } else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {                         throw new UnsupportedOperationException("The end timestamp of a " + "processing-time window cannot become earlier than the current processing time " + "by merging. Current processing time: " + internalTimerService.currentProcessingTime() + " window: " + mergeResult).                     }                     triggerContext.key = key.                     triggerContext.window = mergeResult.                     triggerContext.onMerge(mergedWindows).                     for (W m : mergedWindows) {                         triggerContext.window = m.                         triggerContext.clear().                         deleteCleanupTimer(m).                     }                     // merge the merged state windows into the newly resulting state window                     evictingWindowState.mergeNamespaces(stateWindowResult, mergedStateWindows).                 }             }).             // drop if the window is already late             if (isWindowLate(actualWindow)) {                 mergingWindows.retireWindow(actualWindow).                 continue.             }             isSkippedElement = false.             W stateWindow = mergingWindows.getStateWindow(actualWindow).             if (stateWindow == null) {                 throw new IllegalStateException("Window " + window + " is not in in-flight window set.").             }             evictingWindowState.setCurrentNamespace(stateWindow).             evictingWindowState.add(element).             triggerContext.key = key.             triggerContext.window = actualWindow.             evictorContext.key = key.             evictorContext.window = actualWindow.             TriggerResult triggerResult = triggerContext.onElement(element).             if (triggerResult.isFire()) {                 Iterable<StreamRecord<IN>> contents = evictingWindowState.get().                 if (contents == null) {                     // if we have no state, there is nothing to do                     continue.                 }                 emitWindowContents(actualWindow, contents, evictingWindowState).             }             if (triggerResult.isPurge()) {                 evictingWindowState.clear().             }             registerCleanupTimer(actualWindow).         }         // need to make sure to update the merging state in state         mergingWindows.persist().     } else {         for (W window : elementWindows) {             // check if the window is already inactive             if (isWindowLate(window)) {                 continue.             }             isSkippedElement = false.             evictingWindowState.setCurrentNamespace(window).             evictingWindowState.add(element).             triggerContext.key = key.             triggerContext.window = window.             evictorContext.key = key.             evictorContext.window = window.             TriggerResult triggerResult = triggerContext.onElement(element).             if (triggerResult.isFire()) {                 Iterable<StreamRecord<IN>> contents = evictingWindowState.get().                 if (contents == null) {                     // if we have no state, there is nothing to do                     continue.                 }                 emitWindowContents(window, contents, evictingWindowState).             }             if (triggerResult.isPurge()) {                 evictingWindowState.clear().             }             registerCleanupTimer(window).         }     }     // windowAssigner is event time and current timestamp + allowed lateness no less than element timestamp     if (isSkippedElement && isElementLate(element)) {         if (lateDataOutputTag != null) {             sideOutput(element).         } else {             this.numLateRecordsDropped.inc().         }     } }
false;public;1;47;;@Override public void onEventTime(InternalTimer<K, W> timer) throws Exception {     triggerContext.key = timer.getKey().     triggerContext.window = timer.getNamespace().     evictorContext.key = timer.getKey().     evictorContext.window = timer.getNamespace().     MergingWindowSet<W> mergingWindows = null.     if (windowAssigner instanceof MergingWindowAssigner) {         mergingWindows = getMergingWindowSet().         W stateWindow = mergingWindows.getStateWindow(triggerContext.window).         if (stateWindow == null) {             // window and therefore the Trigger state, however, so nothing to do.             return.         } else {             evictingWindowState.setCurrentNamespace(stateWindow).         }     } else {         evictingWindowState.setCurrentNamespace(triggerContext.window).     }     TriggerResult triggerResult = triggerContext.onEventTime(timer.getTimestamp()).     if (triggerResult.isFire()) {         Iterable<StreamRecord<IN>> contents = evictingWindowState.get().         if (contents != null) {             emitWindowContents(triggerContext.window, contents, evictingWindowState).         }     }     if (triggerResult.isPurge()) {         evictingWindowState.clear().     }     if (windowAssigner.isEventTime() && isCleanupTime(triggerContext.window, timer.getTimestamp())) {         clearAllState(triggerContext.window, evictingWindowState, mergingWindows).     }     if (mergingWindows != null) {         // need to make sure to update the merging state in state         mergingWindows.persist().     } }
false;public;1;46;;@Override public void onProcessingTime(InternalTimer<K, W> timer) throws Exception {     triggerContext.key = timer.getKey().     triggerContext.window = timer.getNamespace().     evictorContext.key = timer.getKey().     evictorContext.window = timer.getNamespace().     MergingWindowSet<W> mergingWindows = null.     if (windowAssigner instanceof MergingWindowAssigner) {         mergingWindows = getMergingWindowSet().         W stateWindow = mergingWindows.getStateWindow(triggerContext.window).         if (stateWindow == null) {             // window and therefore the Trigger state, however, so nothing to do.             return.         } else {             evictingWindowState.setCurrentNamespace(stateWindow).         }     } else {         evictingWindowState.setCurrentNamespace(triggerContext.window).     }     TriggerResult triggerResult = triggerContext.onProcessingTime(timer.getTimestamp()).     if (triggerResult.isFire()) {         Iterable<StreamRecord<IN>> contents = evictingWindowState.get().         if (contents != null) {             emitWindowContents(triggerContext.window, contents, evictingWindowState).         }     }     if (triggerResult.isPurge()) {         evictingWindowState.clear().     }     if (!windowAssigner.isEventTime() && isCleanupTime(triggerContext.window, timer.getTimestamp())) {         clearAllState(triggerContext.window, evictingWindowState, mergingWindows).     }     if (mergingWindows != null) {         // need to make sure to update the merging state in state         mergingWindows.persist().     } }
false;public;1;4;;@Override public TimestampedValue<IN> apply(StreamRecord<IN> input) {     return TimestampedValue.from(input). }
false;public;1;4;;@Override public IN apply(TimestampedValue<IN> input) {     return input.getValue(). }
false;private;3;33;;private void emitWindowContents(W window, Iterable<StreamRecord<IN>> contents, ListState<StreamRecord<IN>> windowState) throws Exception {     timestampedCollector.setAbsoluteTimestamp(window.maxTimestamp()).     // Work around type system restrictions...     FluentIterable<TimestampedValue<IN>> recordsWithTimestamp = FluentIterable.from(contents).transform(new Function<StreamRecord<IN>, TimestampedValue<IN>>() {          @Override         public TimestampedValue<IN> apply(StreamRecord<IN> input) {             return TimestampedValue.from(input).         }     }).     evictorContext.evictBefore(recordsWithTimestamp, Iterables.size(recordsWithTimestamp)).     FluentIterable<IN> projectedContents = recordsWithTimestamp.transform(new Function<TimestampedValue<IN>, IN>() {          @Override         public IN apply(TimestampedValue<IN> input) {             return input.getValue().         }     }).     processContext.window = triggerContext.window.     userFunction.process(triggerContext.key, triggerContext.window, processContext, projectedContents, timestampedCollector).     evictorContext.evictAfter(recordsWithTimestamp, Iterables.size(recordsWithTimestamp)).     // work around to fix FLINK-4369, remove the evicted elements from the windowState.     // this is inefficient, but there is no other way to remove elements from ListState, which is an AppendingState.     windowState.clear().     for (TimestampedValue<IN> record : recordsWithTimestamp) {         windowState.add(record.getStreamRecord()).     } }
false;private;3;13;;private void clearAllState(W window, ListState<StreamRecord<IN>> windowState, MergingWindowSet<W> mergingWindows) throws Exception {     windowState.clear().     triggerContext.clear().     processContext.window = window.     processContext.clear().     if (mergingWindows != null) {         mergingWindows.retireWindow(window).         mergingWindows.persist().     } }
false;public;0;4;;@Override public long getCurrentProcessingTime() {     return internalTimerService.currentProcessingTime(). }
false;public;0;4;;@Override public long getCurrentWatermark() {     return internalTimerService.currentWatermark(). }
false;public;0;4;;@Override public MetricGroup getMetricGroup() {     return EvictingWindowOperator.this.getMetricGroup(). }
false;public;0;3;;public K getKey() {     return key. }
false;;2;3;;void evictBefore(Iterable<TimestampedValue<IN>> elements, int size) {     evictor.evictBefore((Iterable) elements, size, window, this). }
false;;2;3;;void evictAfter(Iterable<TimestampedValue<IN>> elements, int size) {     evictor.evictAfter((Iterable) elements, size, window, this). }
false;public;0;8;;@Override public void open() throws Exception {     super.open().     evictorContext = new EvictorContext(null, null).     evictingWindowState = (InternalListState<K, W, StreamRecord<IN>>) getOrCreateKeyedState(windowSerializer, evictingWindowStateDescriptor). }
false;public;0;5;;@Override public void close() throws Exception {     super.close().     evictorContext = null. }
false;public;0;5;;@Override public void dispose() throws Exception {     super.dispose().     evictorContext = null. }
false;public;0;4;;// ------------------------------------------------------------------------ // Getters for testing // ------------------------------------------------------------------------ @VisibleForTesting public Evictor<? super IN, ? super W> getEvictor() {     return evictor. }
false;public;0;6;;@Override @VisibleForTesting @SuppressWarnings("unchecked, rawtypes") public StateDescriptor<? extends AppendingState<IN, Iterable<IN>>, ?> getStateDescriptor() {     return (StateDescriptor<? extends AppendingState<IN, Iterable<IN>>, ?>) evictingWindowStateDescriptor. }
