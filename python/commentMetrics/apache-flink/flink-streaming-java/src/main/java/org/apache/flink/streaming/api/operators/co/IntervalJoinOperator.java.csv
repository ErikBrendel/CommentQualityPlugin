commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Override public void open() throws Exception {     super.open().     collector = new TimestampedCollector<>(output).     context = new ContextImpl(userFunction).     internalTimerService = getInternalTimerService(CLEANUP_TIMER_NAME, StringSerializer.INSTANCE, this). }
false;public;1;16;;@Override public void initializeState(StateInitializationContext context) throws Exception {     super.initializeState(context).     this.leftBuffer = context.getKeyedStateStore().getMapState(new MapStateDescriptor<>(LEFT_BUFFER, LongSerializer.INSTANCE, new ListSerializer<>(new BufferEntrySerializer<>(leftTypeSerializer)))).     this.rightBuffer = context.getKeyedStateStore().getMapState(new MapStateDescriptor<>(RIGHT_BUFFER, LongSerializer.INSTANCE, new ListSerializer<>(new BufferEntrySerializer<>(rightTypeSerializer)))). }
true;public;1;4;/**  * Process a {@link StreamRecord} from the left stream. Whenever an {@link StreamRecord}  * arrives at the left stream, it will get added to the left buffer. Possible join candidates  * for that element will be looked up from the right buffer and if the pair lies within the  * user defined boundaries, it gets passed to the {@link ProcessJoinFunction}.  *  * @param record An incoming record to be joined  * @throws Exception Can throw an Exception during state access  */ ;/**  * Process a {@link StreamRecord} from the left stream. Whenever an {@link StreamRecord}  * arrives at the left stream, it will get added to the left buffer. Possible join candidates  * for that element will be looked up from the right buffer and if the pair lies within the  * user defined boundaries, it gets passed to the {@link ProcessJoinFunction}.  *  * @param record An incoming record to be joined  * @throws Exception Can throw an Exception during state access  */ @Override public void processElement1(StreamRecord<T1> record) throws Exception {     processElement(record, leftBuffer, rightBuffer, lowerBound, upperBound, true). }
true;public;1;4;/**  * Process a {@link StreamRecord} from the right stream. Whenever a {@link StreamRecord}  * arrives at the right stream, it will get added to the right buffer. Possible join candidates  * for that element will be looked up from the left buffer and if the pair lies within the user  * defined boundaries, it gets passed to the {@link ProcessJoinFunction}.  *  * @param record An incoming record to be joined  * @throws Exception Can throw an exception during state access  */ ;/**  * Process a {@link StreamRecord} from the right stream. Whenever a {@link StreamRecord}  * arrives at the right stream, it will get added to the right buffer. Possible join candidates  * for that element will be looked up from the left buffer and if the pair lies within the user  * defined boundaries, it gets passed to the {@link ProcessJoinFunction}.  *  * @param record An incoming record to be joined  * @throws Exception Can throw an exception during state access  */ @Override public void processElement2(StreamRecord<T2> record) throws Exception {     processElement(record, rightBuffer, leftBuffer, -upperBound, -lowerBound, false). }
false;private;6;47;;@SuppressWarnings("unchecked") private <THIS, OTHER> void processElement(final StreamRecord<THIS> record, final MapState<Long, List<IntervalJoinOperator.BufferEntry<THIS>>> ourBuffer, final MapState<Long, List<IntervalJoinOperator.BufferEntry<OTHER>>> otherBuffer, final long relativeLowerBound, final long relativeUpperBound, final boolean isLeft) throws Exception {     final THIS ourValue = record.getValue().     final long ourTimestamp = record.getTimestamp().     if (ourTimestamp == Long.MIN_VALUE) {         throw new FlinkException("Long.MIN_VALUE timestamp: Elements used in " + "interval stream joins need to have timestamps meaningful timestamps.").     }     if (isLate(ourTimestamp)) {         return.     }     addToBuffer(ourBuffer, ourValue, ourTimestamp).     for (Map.Entry<Long, List<BufferEntry<OTHER>>> bucket : otherBuffer.entries()) {         final long timestamp = bucket.getKey().         if (timestamp < ourTimestamp + relativeLowerBound || timestamp > ourTimestamp + relativeUpperBound) {             continue.         }         for (BufferEntry<OTHER> entry : bucket.getValue()) {             if (isLeft) {                 collect((T1) ourValue, (T2) entry.element, ourTimestamp, timestamp).             } else {                 collect((T1) entry.element, (T2) ourValue, timestamp, ourTimestamp).             }         }     }     long cleanupTime = (relativeUpperBound > 0L) ? ourTimestamp + relativeUpperBound : ourTimestamp.     if (isLeft) {         internalTimerService.registerEventTimeTimer(CLEANUP_NAMESPACE_LEFT, cleanupTime).     } else {         internalTimerService.registerEventTimeTimer(CLEANUP_NAMESPACE_RIGHT, cleanupTime).     } }
false;private;1;4;;private boolean isLate(long timestamp) {     long currentWatermark = internalTimerService.currentWatermark().     return currentWatermark != Long.MIN_VALUE && timestamp < currentWatermark. }
false;private;4;8;;private void collect(T1 left, T2 right, long leftTimestamp, long rightTimestamp) throws Exception {     final long resultTimestamp = Math.max(leftTimestamp, rightTimestamp).     collector.setAbsoluteTimestamp(resultTimestamp).     context.updateTimestamps(leftTimestamp, rightTimestamp, resultTimestamp).     userFunction.processElement(left, right, context, collector). }
false;private,static;3;11;;private static <T> void addToBuffer(final MapState<Long, List<IntervalJoinOperator.BufferEntry<T>>> buffer, final T value, final long timestamp) throws Exception {     List<BufferEntry<T>> elemsInBucket = buffer.get(timestamp).     if (elemsInBucket == null) {         elemsInBucket = new ArrayList<>().     }     elemsInBucket.add(new BufferEntry<>(value, false)).     buffer.put(timestamp, elemsInBucket). }
false;public;1;25;;@Override public void onEventTime(InternalTimer<K, String> timer) throws Exception {     long timerTimestamp = timer.getTimestamp().     String namespace = timer.getNamespace().     logger.trace("onEventTime @ {}", timerTimestamp).     switch(namespace) {         case CLEANUP_NAMESPACE_LEFT:             {                 long timestamp = (upperBound <= 0L) ? timerTimestamp : timerTimestamp - upperBound.                 logger.trace("Removing from left buffer @ {}", timestamp).                 leftBuffer.remove(timestamp).                 break.             }         case CLEANUP_NAMESPACE_RIGHT:             {                 long timestamp = (lowerBound <= 0L) ? timerTimestamp + lowerBound : timerTimestamp.                 logger.trace("Removing from right buffer @ {}", timestamp).                 rightBuffer.remove(timestamp).                 break.             }         default:             throw new RuntimeException("Invalid namespace " + namespace).     } }
false;public;1;4;;@Override public void onProcessingTime(InternalTimer<K, String> timer) throws Exception { // do nothing. }
false;private;3;5;;private void updateTimestamps(long left, long right, long result) {     this.leftTimestamp = left.     this.rightTimestamp = right.     this.resultTimestamp = result. }
false;public;0;4;;@Override public long getLeftTimestamp() {     return leftTimestamp. }
false;public;0;4;;@Override public long getRightTimestamp() {     return rightTimestamp. }
false;public;0;4;;@Override public long getTimestamp() {     return resultTimestamp. }
false;public;2;5;;@Override public <X> void output(OutputTag<X> outputTag, X value) {     Preconditions.checkArgument(outputTag != null, "OutputTag must not be null").     output.collect(outputTag, new StreamRecord<>(value, getTimestamp())). }
false;public;0;4;;@Override public boolean isImmutableType() {     return true. }
false;public;0;4;;@Override public TypeSerializer<BufferEntry<T>> duplicate() {     return new BufferEntrySerializer<>(elementSerializer.duplicate()). }
false;public;0;4;;@Override public BufferEntry<T> createInstance() {     return null. }
false;public;1;4;;@Override public BufferEntry<T> copy(BufferEntry<T> from) {     return new BufferEntry<>(from.element, from.hasBeenJoined). }
false;public;2;4;;@Override public BufferEntry<T> copy(BufferEntry<T> from, BufferEntry<T> reuse) {     return copy(from). }
false;public;0;4;;@Override public int getLength() {     return -1. }
false;public;2;5;;@Override public void serialize(BufferEntry<T> record, DataOutputView target) throws IOException {     target.writeBoolean(record.hasBeenJoined).     elementSerializer.serialize(record.element, target). }
false;public;1;6;;@Override public BufferEntry<T> deserialize(DataInputView source) throws IOException {     boolean hasBeenJoined = source.readBoolean().     T element = elementSerializer.deserialize(source).     return new BufferEntry<>(element, hasBeenJoined). }
false;public;2;4;;@Override public BufferEntry<T> deserialize(BufferEntry<T> reuse, DataInputView source) throws IOException {     return deserialize(source). }
false;public;2;5;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     target.writeBoolean(source.readBoolean()).     elementSerializer.copy(source, target). }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     BufferEntrySerializer<?> that = (BufferEntrySerializer<?>) o.     return Objects.equals(elementSerializer, that.elementSerializer). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(elementSerializer). }
false;public;0;4;;@Override public TypeSerializerSnapshot<BufferEntry<T>> snapshotConfiguration() {     return new BufferEntrySerializerSnapshot<>(this). }
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
false;public;1;8;;@Override public TypeSerializerSchemaCompatibility<BufferEntry<T>> resolveSchemaCompatibility(TypeSerializer<BufferEntry<T>> newSerializer) {     return CompositeTypeSerializerUtil.delegateCompatibilityCheckToNewSnapshot(newSerializer, new BufferEntrySerializerSnapshot<>(), getSingleNestedSerializerAndConfig().f1). }
false;protected;0;4;;@Override protected int getCurrentOuterSnapshotVersion() {     return VERSION. }
false;protected;1;4;;@Override protected TypeSerializer<?>[] getNestedSerializers(BufferEntrySerializer<T> outerSerializer) {     return new TypeSerializer[] { outerSerializer.elementSerializer }. }
false;protected;1;5;;@Override @SuppressWarnings("unchecked") protected BufferEntrySerializer<T> createOuterSerializerWithNestedSerializers(TypeSerializer<?>[] nestedSerializers) {     return new BufferEntrySerializer<>((TypeSerializer<T>) nestedSerializers[0]). }
false;;0;4;;@VisibleForTesting MapState<Long, List<BufferEntry<T1>>> getLeftBuffer() {     return leftBuffer. }
false;;0;4;;@VisibleForTesting MapState<Long, List<BufferEntry<T2>>> getRightBuffer() {     return rightBuffer. }
