commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public void setOutputType(TypeInformation<OUT> outTypeInfo, ExecutionConfig executionConfig) {     this.serializer = outTypeInfo.createSerializer(executionConfig). }
false;public;1;27;;@Override public void initializeState(StateInitializationContext context) throws Exception {     super.initializeState(context).     checkState(checkpointedState == null, "The reader state has already been initialized.").     checkpointedState = context.getOperatorStateStore().getSerializableListState("splits").     int subtaskIdx = getRuntimeContext().getIndexOfThisSubtask().     if (context.isRestored()) {         LOG.info("Restoring state for the {} (taskIdx={}).", getClass().getSimpleName(), subtaskIdx).         // this may not be null in case we migrate from a previous Flink version.         if (restoredReaderState == null) {             restoredReaderState = new ArrayList<>().             for (TimestampedFileInputSplit split : checkpointedState.get()) {                 restoredReaderState.add(split).             }             if (LOG.isDebugEnabled()) {                 LOG.debug("{} (taskIdx={}) restored {}.", getClass().getSimpleName(), subtaskIdx, restoredReaderState).             }         }     } else {         LOG.info("No state to restore for the {} (taskIdx={}).", getClass().getSimpleName(), subtaskIdx).     } }
false;public;0;29;;@Override public void open() throws Exception {     super.open().     checkState(this.reader == null, "The reader is already initialized.").     checkState(this.serializer != null, "The serializer has not been set. " + "Probably the setOutputType() was not called. Please report it.").     this.format.setRuntimeContext(getRuntimeContext()).     this.format.configure(new Configuration()).     this.checkpointLock = getContainingTask().getCheckpointLock().     // set the reader context based on the time characteristic     final TimeCharacteristic timeCharacteristic = getOperatorConfig().getTimeCharacteristic().     final long watermarkInterval = getRuntimeContext().getExecutionConfig().getAutoWatermarkInterval().     this.readerContext = StreamSourceContexts.getSourceContext(timeCharacteristic, getProcessingTimeService(), checkpointLock, getContainingTask().getStreamStatusMaintainer(), output, watermarkInterval, -1).     // and initialize the split reading thread     this.reader = new SplitReader<>(format, serializer, readerContext, checkpointLock, restoredReaderState).     this.restoredReaderState = null.     this.reader.start(). }
false;public;1;4;;@Override public void processElement(StreamRecord<TimestampedFileInputSplit> element) throws Exception {     reader.addSplit(element.getValue()). }
false;public;1;4;;@Override public void processWatermark(Watermark mark) throws Exception { // we do nothing because we emit our own watermarks if needed. }
false;public;0;36;;@Override public void dispose() throws Exception {     super.dispose().     // first try to cancel it properly and     // give it some time until it finishes     reader.cancel().     try {         reader.join(200).     } catch (InterruptedException e) {     // we can ignore this     }     // if the above did not work, then interrupt the thread repeatedly     while (reader.isAlive()) {         StringBuilder bld = new StringBuilder().         StackTraceElement[] stack = reader.getStackTrace().         for (StackTraceElement e : stack) {             bld.append(e).append('\n').         }         LOG.warn("The reader is stuck in method:\n {}", bld.toString()).         reader.interrupt().         try {             reader.join(50).         } catch (InterruptedException e) {         // we can ignore this         }     }     reader = null.     readerContext = null.     restoredReaderState = null.     format = null.     serializer = null. }
false;public;0;26;;@Override public void close() throws Exception {     super.close().     // make sure that we hold the checkpointing lock     Thread.holdsLock(checkpointLock).     while (reader != null && reader.isAlive() && reader.isRunning()) {         reader.close().         checkpointLock.wait().     }     if (readerContext != null) {         readerContext.emitWatermark(Watermark.MAX_WATERMARK).         readerContext.close().     }     output.close(). }
false;private;1;6;;private void addSplit(TimestampedFileInputSplit split) {     checkNotNull(split, "Cannot insert a null value in the pending splits queue.").     synchronized (checkpointLock) {         this.pendingSplits.add(split).     } }
false;public;0;3;;public boolean isRunning() {     return this.isRunning. }
false;public;0;92;;@Override public void run() {     try {         Counter completedSplitsCounter = getMetricGroup().counter("numSplitsProcessed").         this.format.openInputFormat().         while (this.isRunning) {             synchronized (checkpointLock) {                 if (currentSplit == null) {                     currentSplit = this.pendingSplits.poll().                     if (currentSplit == null) {                         if (this.shouldClose) {                             isRunning = false.                         } else {                             checkpointLock.wait(50).                         }                         continue.                     }                 }                 if (this.format instanceof CheckpointableInputFormat && currentSplit.getSplitState() != null) {                     // recovering after a node failure with an input                     // format that supports resetting the offset                     ((CheckpointableInputFormat<TimestampedFileInputSplit, Serializable>) this.format).reopen(currentSplit, currentSplit.getSplitState()).                 } else {                     // we either have a new split, or we recovered from a node                     // failure but the input format does not support resetting the offset.                     this.format.open(currentSplit).                 }                 // reset the restored state to null for the next iteration                 this.currentSplit.resetSplitState().                 this.isSplitOpen = true.             }             LOG.debug("Reading split: " + currentSplit).             try {                 OT nextElement = serializer.createInstance().                 while (!format.reachedEnd()) {                     synchronized (checkpointLock) {                         nextElement = format.nextRecord(nextElement).                         if (nextElement != null) {                             readerContext.collect(nextElement).                         } else {                             break.                         }                     }                 }                 completedSplitsCounter.inc().             } finally {                 // close and prepare for the next iteration                 synchronized (checkpointLock) {                     this.format.close().                     this.isSplitOpen = false.                     this.currentSplit = null.                 }             }         }     } catch (Throwable e) {         getContainingTask().handleAsyncException("Caught exception when processing split: " + currentSplit, e).     } finally {         synchronized (checkpointLock) {             LOG.debug("Reader terminated, and exiting...").             try {                 this.format.closeInputFormat().             } catch (IOException e) {                 getContainingTask().handleAsyncException("Caught exception from " + this.format.getClass().getName() + ".closeInputFormat() : " + e.getMessage(), e).             }             this.isSplitOpen = false.             this.currentSplit = null.             this.isRunning = false.             checkpointLock.notifyAll().         }     } }
false;private;0;13;;private List<TimestampedFileInputSplit> getReaderState() throws IOException {     List<TimestampedFileInputSplit> snapshot = new ArrayList<>(this.pendingSplits.size()).     if (currentSplit != null) {         if (this.format instanceof CheckpointableInputFormat && this.isSplitOpen) {             Serializable formatState = ((CheckpointableInputFormat<TimestampedFileInputSplit, Serializable>) this.format).getCurrentState().             this.currentSplit.setSplitState(formatState).         }         snapshot.add(this.currentSplit).     }     snapshot.addAll(this.pendingSplits).     return snapshot. }
false;public;0;3;;public void cancel() {     this.isRunning = false. }
false;public;0;3;;public void close() {     this.shouldClose = true. }
false;public;1;30;;// ---------------------			Checkpointing			-------------------------- @Override public void snapshotState(StateSnapshotContext context) throws Exception {     super.snapshotState(context).     checkState(checkpointedState != null, "The operator state has not been properly initialized.").     int subtaskIdx = getRuntimeContext().getIndexOfThisSubtask().     checkpointedState.clear().     List<TimestampedFileInputSplit> readerState = reader.getReaderState().     try {         for (TimestampedFileInputSplit split : readerState) {             // create a new partition for each entry.             checkpointedState.add(split).         }     } catch (Exception e) {         checkpointedState.clear().         throw new Exception("Could not add timestamped file input splits to to operator " + "state backend of operator " + getOperatorName() + '.', e).     }     if (LOG.isDebugEnabled()) {         LOG.debug("{} (taskIdx={}) checkpointed {} splits: {}.", getClass().getSimpleName(), subtaskIdx, readerState.size(), readerState).     } }
