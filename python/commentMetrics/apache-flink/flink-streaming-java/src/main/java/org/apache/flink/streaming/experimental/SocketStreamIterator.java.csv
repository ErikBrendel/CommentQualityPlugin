commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the port on which the iterator is getting the data. (Used internally.)  * @return The port  */ ;// ------------------------------------------------------------------------ // properties // ------------------------------------------------------------------------ /**  * Returns the port on which the iterator is getting the data. (Used internally.)  * @return The port  */ public int getPort() {     return socket.getLocalPort(). }
false;public;0;3;;public InetAddress getBindAddress() {     return socket.getInetAddress(). }
false;public;0;11;;public void close() {     if (connectedSocket != null) {         try {             connectedSocket.close().         } catch (Throwable ignored) {         }     }     try {         socket.close().     } catch (Throwable ignored) {     } }
true;public;0;12;/**  * Returns true if the DataStream has more elements.  * (Note: blocks if there will be more elements, but they are not available yet.)  * @return true if the DataStream has more elements  */ ;// ------------------------------------------------------------------------ // iterator semantics // ------------------------------------------------------------------------ /**  * Returns true if the DataStream has more elements.  * (Note: blocks if there will be more elements, but they are not available yet.)  * @return true if the DataStream has more elements  */ @Override public boolean hasNext() {     if (next == null) {         try {             next = readNextFromStream().         } catch (Exception e) {             throw new RuntimeException("Failed to receive next element: " + e.getMessage(), e).         }     }     return next != null. }
true;public;0;10;/**  * Returns the next element of the DataStream. (Blocks if it is not available yet.)  * @return The element  * @throws NoSuchElementException if the stream has already ended  */ ;/**  * Returns the next element of the DataStream. (Blocks if it is not available yet.)  * @return The element  * @throws NoSuchElementException if the stream has already ended  */ @Override public T next() {     if (hasNext()) {         T current = next.         next = null.         return current.     } else {         throw new NoSuchElementException().     } }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;private;0;30;;private T readNextFromStream() throws Exception {     try {         if (inStream == null) {             connectedSocket = socket.accept().             inStream = new DataInputViewStreamWrapper(connectedSocket.getInputStream()).         }         return serializer.deserialize(inStream).     } catch (EOFException e) {         try {             connectedSocket.close().         } catch (Throwable ignored) {         }         try {             socket.close().         } catch (Throwable ignored) {         }         return null.     } catch (Exception e) {         if (error == null) {             throw e.         } else {             // throw the root cause error             throw new Exception("Receiving stream failed: " + error.getMessage(), error).         }     } }
false;public;1;13;;// ------------------------------------------------------------------------ // errors // ------------------------------------------------------------------------ public void notifyOfError(Throwable error) {     if (error != null && this.error == null) {         this.error = error.         // this should wake up any blocking calls         try {             connectedSocket.close().         } catch (Throwable ignored) {         }         try {             socket.close().         } catch (Throwable ignored) {         }     } }
