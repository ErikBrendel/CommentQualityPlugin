commented;modifiers;parameterAmount;loc;comment;code
false;public;1;14;;@Override public <T> void put(StreamElementQueueEntry<T> streamElementQueueEntry) throws InterruptedException {     lock.lockInterruptibly().     try {         while (numberEntries >= capacity) {             notFull.await().         }         addEntry(streamElementQueueEntry).     } finally {         lock.unlock().     } }
false;public;1;22;;@Override public <T> boolean tryPut(StreamElementQueueEntry<T> streamElementQueueEntry) throws InterruptedException {     lock.lockInterruptibly().     try {         if (numberEntries < capacity) {             addEntry(streamElementQueueEntry).             LOG.debug("Put element into unordered stream element queue. New filling degree " + "({}/{}).", numberEntries, capacity).             return true.         } else {             LOG.debug("Failed to put element into unordered stream element queue because it " + "was full ({}/{}).", numberEntries, capacity).             return false.         }     } finally {         lock.unlock().     } }
false;public;0;17;;@Override public AsyncResult peekBlockingly() throws InterruptedException {     lock.lockInterruptibly().     try {         while (completedQueue.isEmpty()) {             hasCompletedEntries.await().         }         LOG.debug("Peeked head element from unordered stream element queue with filling degree " + "({}/{}).", numberEntries, capacity).         return completedQueue.peek().     } finally {         lock.unlock().     } }
false;public;0;20;;@Override public AsyncResult poll() throws InterruptedException {     lock.lockInterruptibly().     try {         while (completedQueue.isEmpty()) {             hasCompletedEntries.await().         }         numberEntries--.         notFull.signalAll().         LOG.debug("Polled element from unordered stream element queue. New filling degree " + "({}/{}).", numberEntries, capacity).         return completedQueue.poll().     } finally {         lock.unlock().     } }
false;public;0;29;;@Override public Collection<StreamElementQueueEntry<?>> values() throws InterruptedException {     lock.lockInterruptibly().     try {         StreamElementQueueEntry<?>[] array = new StreamElementQueueEntry[numberEntries].         array = completedQueue.toArray(array).         int counter = completedQueue.size().         for (StreamElementQueueEntry<?> entry : firstSet) {             array[counter] = entry.             counter++.         }         for (Set<StreamElementQueueEntry<?>> asyncBufferEntries : uncompletedQueue) {             for (StreamElementQueueEntry<?> streamElementQueueEntry : asyncBufferEntries) {                 array[counter] = streamElementQueueEntry.                 counter++.             }         }         return Arrays.asList(array).     } finally {         lock.unlock().     } }
false;public;0;4;;@Override public boolean isEmpty() {     return numberEntries == 0. }
false;public;0;4;;@Override public int size() {     return numberEntries. }
true;public;1;29;/**  * Callback for onComplete events for the given stream element queue entry. Whenever a queue  * entry is completed, it is checked whether this entry belongs to the first set. If this is the  * case, then the element is added to the completed entries queue from where it can be consumed.  * If the first set becomes empty, then the next set is polled from the uncompleted entries  * queue. Completed entries from this new set are then added to the completed entries queue.  *  * @param streamElementQueueEntry which has been completed  * @throws InterruptedException if the current thread has been interrupted while performing the  * 	on complete callback.  */ ;/**  * Callback for onComplete events for the given stream element queue entry. Whenever a queue  * entry is completed, it is checked whether this entry belongs to the first set. If this is the  * case, then the element is added to the completed entries queue from where it can be consumed.  * If the first set becomes empty, then the next set is polled from the uncompleted entries  * queue. Completed entries from this new set are then added to the completed entries queue.  *  * @param streamElementQueueEntry which has been completed  * @throws InterruptedException if the current thread has been interrupted while performing the  * 	on complete callback.  */ public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException {     lock.lockInterruptibly().     try {         if (firstSet.remove(streamElementQueueEntry)) {             completedQueue.offer(streamElementQueueEntry).             while (firstSet.isEmpty() && firstSet != lastSet) {                 firstSet = uncompletedQueue.poll().                 Iterator<StreamElementQueueEntry<?>> it = firstSet.iterator().                 while (it.hasNext()) {                     StreamElementQueueEntry<?> bufferEntry = it.next().                     if (bufferEntry.isDone()) {                         completedQueue.offer(bufferEntry).                         it.remove().                     }                 }             }             LOG.debug("Signal unordered stream element queue has completed entries.").             hasCompletedEntries.signalAll().         }     } finally {         lock.unlock().     } }
true;private;1;36;/**  * Add the given stream element queue entry to the current last set if it is not a watermark.  * If it is a watermark, then stop adding to the current last set, insert the watermark into its  * own set and add a new last set.  *  * @param streamElementQueueEntry to be inserted  * @param <T> Type of the stream element queue entry's result  */ ;/**  * Add the given stream element queue entry to the current last set if it is not a watermark.  * If it is a watermark, then stop adding to the current last set, insert the watermark into its  * own set and add a new last set.  *  * @param streamElementQueueEntry to be inserted  * @param <T> Type of the stream element queue entry's result  */ private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry) {     assert (lock.isHeldByCurrentThread()).     if (streamElementQueueEntry.isWatermark()) {         lastSet = new HashSet<>(capacity).         if (firstSet.isEmpty()) {             firstSet.add(streamElementQueueEntry).         } else {             Set<StreamElementQueueEntry<?>> watermarkSet = new HashSet<>(1).             watermarkSet.add(streamElementQueueEntry).             uncompletedQueue.offer(watermarkSet).         }         uncompletedQueue.offer(lastSet).     } else {         lastSet.add(streamElementQueueEntry).     }     streamElementQueueEntry.onComplete((StreamElementQueueEntry<T> value) -> {         try {             onCompleteHandler(value).         } catch (InterruptedException e) {             // The accept executor thread got interrupted. This is probably cause by             // the shutdown of the executor.             LOG.debug("AsyncBufferEntry could not be properly completed because the " + "executor thread has been interrupted.", e).         } catch (Throwable t) {             operatorActions.failOperator(new Exception("Could not complete the " + "stream element queue entry: " + value + '.', t)).         }     }, executor).     numberEntries++. }
