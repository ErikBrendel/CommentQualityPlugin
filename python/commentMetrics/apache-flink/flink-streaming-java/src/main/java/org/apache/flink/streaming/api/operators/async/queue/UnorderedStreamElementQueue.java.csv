# id;timestamp;commentText;codeText;commentWords;codeWords
UnorderedStreamElementQueue -> public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException;1482206691;Callback for onComplete events for the given stream element queue entry. Whenever a queue_entry is completed, it is checked whether this entry belogns to the first set. If this is the_case, then the element is added to the completed entries queue from where it can be consumed._If the first set becomes empty, then the next set is polled from the uncompleted entries_queue. Completed entries from this new set are then added to the completed entries queue.__@param streamElementQueueEntry which has been completed_@throws InterruptedException if the current thread has been interrupted while performing the_on complete callback.;public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException {_		lock.lockInterruptibly()___		try {_			if (firstSet.remove(streamElementQueueEntry)) {_				completedQueue.offer(streamElementQueueEntry)___				while (firstSet.isEmpty() && firstSet != lastSet) {_					firstSet = uncompletedQueue.poll()___					Iterator<StreamElementQueueEntry<?>> it = firstSet.iterator()___					while (it.hasNext()) {_						StreamElementQueueEntry<?> bufferEntry = it.next()___						if (bufferEntry.isDone()) {_							completedQueue.offer(bufferEntry)__							it.remove()__						}_					}_				}__				LOG.debug("Signal unordered stream element queue has completed entries.")__				hasCompletedEntries.signalAll()__			}_		} finally {_			lock.unlock()__		}_	};callback,for,on,complete,events,for,the,given,stream,element,queue,entry,whenever,a,queue,entry,is,completed,it,is,checked,whether,this,entry,belogns,to,the,first,set,if,this,is,the,case,then,the,element,is,added,to,the,completed,entries,queue,from,where,it,can,be,consumed,if,the,first,set,becomes,empty,then,the,next,set,is,polled,from,the,uncompleted,entries,queue,completed,entries,from,this,new,set,are,then,added,to,the,completed,entries,queue,param,stream,element,queue,entry,which,has,been,completed,throws,interrupted,exception,if,the,current,thread,has,been,interrupted,while,performing,the,on,complete,callback;public,void,on,complete,handler,stream,element,queue,entry,stream,element,queue,entry,throws,interrupted,exception,lock,lock,interruptibly,try,if,first,set,remove,stream,element,queue,entry,completed,queue,offer,stream,element,queue,entry,while,first,set,is,empty,first,set,last,set,first,set,uncompleted,queue,poll,iterator,stream,element,queue,entry,it,first,set,iterator,while,it,has,next,stream,element,queue,entry,buffer,entry,it,next,if,buffer,entry,is,done,completed,queue,offer,buffer,entry,it,remove,log,debug,signal,unordered,stream,element,queue,has,completed,entries,has,completed,entries,signal,all,finally,lock,unlock
UnorderedStreamElementQueue -> public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException;1482206691;Callback for onComplete events for the given stream element queue entry. Whenever a queue_entry is completed, it is checked whether this entry belogns to the first set. If this is the_case, then the element is added to the completed entries queue from where it can be consumed._If the first set becomes empty, then the next set is polled from the uncompleted entries_queue. Completed entries from this new set are then added to the completed entries queue.__@param streamElementQueueEntry which has been completed_@throws InterruptedException if the current thread has been interrupted while performing the_on complete callback.;public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException {_		lock.lockInterruptibly()___		try {_			if (firstSet.remove(streamElementQueueEntry)) {_				completedQueue.offer(streamElementQueueEntry)___				while (firstSet.isEmpty() && firstSet != lastSet) {_					firstSet = uncompletedQueue.poll()___					Iterator<StreamElementQueueEntry<?>> it = firstSet.iterator()___					while (it.hasNext()) {_						StreamElementQueueEntry<?> bufferEntry = it.next()___						if (bufferEntry.isDone()) {_							completedQueue.offer(bufferEntry)__							it.remove()__						}_					}_				}__				LOG.debug("Signal unordered stream element queue has completed entries.")__				hasCompletedEntries.signalAll()__			}_		} finally {_			lock.unlock()__		}_	};callback,for,on,complete,events,for,the,given,stream,element,queue,entry,whenever,a,queue,entry,is,completed,it,is,checked,whether,this,entry,belogns,to,the,first,set,if,this,is,the,case,then,the,element,is,added,to,the,completed,entries,queue,from,where,it,can,be,consumed,if,the,first,set,becomes,empty,then,the,next,set,is,polled,from,the,uncompleted,entries,queue,completed,entries,from,this,new,set,are,then,added,to,the,completed,entries,queue,param,stream,element,queue,entry,which,has,been,completed,throws,interrupted,exception,if,the,current,thread,has,been,interrupted,while,performing,the,on,complete,callback;public,void,on,complete,handler,stream,element,queue,entry,stream,element,queue,entry,throws,interrupted,exception,lock,lock,interruptibly,try,if,first,set,remove,stream,element,queue,entry,completed,queue,offer,stream,element,queue,entry,while,first,set,is,empty,first,set,last,set,first,set,uncompleted,queue,poll,iterator,stream,element,queue,entry,it,first,set,iterator,while,it,has,next,stream,element,queue,entry,buffer,entry,it,next,if,buffer,entry,is,done,completed,queue,offer,buffer,entry,it,remove,log,debug,signal,unordered,stream,element,queue,has,completed,entries,has,completed,entries,signal,all,finally,lock,unlock
UnorderedStreamElementQueue -> public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException;1485357390;Callback for onComplete events for the given stream element queue entry. Whenever a queue_entry is completed, it is checked whether this entry belogns to the first set. If this is the_case, then the element is added to the completed entries queue from where it can be consumed._If the first set becomes empty, then the next set is polled from the uncompleted entries_queue. Completed entries from this new set are then added to the completed entries queue.__@param streamElementQueueEntry which has been completed_@throws InterruptedException if the current thread has been interrupted while performing the_on complete callback.;public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException {_		lock.lockInterruptibly()___		try {_			if (firstSet.remove(streamElementQueueEntry)) {_				completedQueue.offer(streamElementQueueEntry)___				while (firstSet.isEmpty() && firstSet != lastSet) {_					firstSet = uncompletedQueue.poll()___					Iterator<StreamElementQueueEntry<?>> it = firstSet.iterator()___					while (it.hasNext()) {_						StreamElementQueueEntry<?> bufferEntry = it.next()___						if (bufferEntry.isDone()) {_							completedQueue.offer(bufferEntry)__							it.remove()__						}_					}_				}__				LOG.debug("Signal unordered stream element queue has completed entries.")__				hasCompletedEntries.signalAll()__			}_		} finally {_			lock.unlock()__		}_	};callback,for,on,complete,events,for,the,given,stream,element,queue,entry,whenever,a,queue,entry,is,completed,it,is,checked,whether,this,entry,belogns,to,the,first,set,if,this,is,the,case,then,the,element,is,added,to,the,completed,entries,queue,from,where,it,can,be,consumed,if,the,first,set,becomes,empty,then,the,next,set,is,polled,from,the,uncompleted,entries,queue,completed,entries,from,this,new,set,are,then,added,to,the,completed,entries,queue,param,stream,element,queue,entry,which,has,been,completed,throws,interrupted,exception,if,the,current,thread,has,been,interrupted,while,performing,the,on,complete,callback;public,void,on,complete,handler,stream,element,queue,entry,stream,element,queue,entry,throws,interrupted,exception,lock,lock,interruptibly,try,if,first,set,remove,stream,element,queue,entry,completed,queue,offer,stream,element,queue,entry,while,first,set,is,empty,first,set,last,set,first,set,uncompleted,queue,poll,iterator,stream,element,queue,entry,it,first,set,iterator,while,it,has,next,stream,element,queue,entry,buffer,entry,it,next,if,buffer,entry,is,done,completed,queue,offer,buffer,entry,it,remove,log,debug,signal,unordered,stream,element,queue,has,completed,entries,has,completed,entries,signal,all,finally,lock,unlock
UnorderedStreamElementQueue -> public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException;1491500150;Callback for onComplete events for the given stream element queue entry. Whenever a queue_entry is completed, it is checked whether this entry belogns to the first set. If this is the_case, then the element is added to the completed entries queue from where it can be consumed._If the first set becomes empty, then the next set is polled from the uncompleted entries_queue. Completed entries from this new set are then added to the completed entries queue.__@param streamElementQueueEntry which has been completed_@throws InterruptedException if the current thread has been interrupted while performing the_on complete callback.;public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException {_		lock.lockInterruptibly()___		try {_			if (firstSet.remove(streamElementQueueEntry)) {_				completedQueue.offer(streamElementQueueEntry)___				while (firstSet.isEmpty() && firstSet != lastSet) {_					firstSet = uncompletedQueue.poll()___					Iterator<StreamElementQueueEntry<?>> it = firstSet.iterator()___					while (it.hasNext()) {_						StreamElementQueueEntry<?> bufferEntry = it.next()___						if (bufferEntry.isDone()) {_							completedQueue.offer(bufferEntry)__							it.remove()__						}_					}_				}__				LOG.debug("Signal unordered stream element queue has completed entries.")__				hasCompletedEntries.signalAll()__			}_		} finally {_			lock.unlock()__		}_	};callback,for,on,complete,events,for,the,given,stream,element,queue,entry,whenever,a,queue,entry,is,completed,it,is,checked,whether,this,entry,belogns,to,the,first,set,if,this,is,the,case,then,the,element,is,added,to,the,completed,entries,queue,from,where,it,can,be,consumed,if,the,first,set,becomes,empty,then,the,next,set,is,polled,from,the,uncompleted,entries,queue,completed,entries,from,this,new,set,are,then,added,to,the,completed,entries,queue,param,stream,element,queue,entry,which,has,been,completed,throws,interrupted,exception,if,the,current,thread,has,been,interrupted,while,performing,the,on,complete,callback;public,void,on,complete,handler,stream,element,queue,entry,stream,element,queue,entry,throws,interrupted,exception,lock,lock,interruptibly,try,if,first,set,remove,stream,element,queue,entry,completed,queue,offer,stream,element,queue,entry,while,first,set,is,empty,first,set,last,set,first,set,uncompleted,queue,poll,iterator,stream,element,queue,entry,it,first,set,iterator,while,it,has,next,stream,element,queue,entry,buffer,entry,it,next,if,buffer,entry,is,done,completed,queue,offer,buffer,entry,it,remove,log,debug,signal,unordered,stream,element,queue,has,completed,entries,has,completed,entries,signal,all,finally,lock,unlock
UnorderedStreamElementQueue -> public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException;1493195810;Callback for onComplete events for the given stream element queue entry. Whenever a queue_entry is completed, it is checked whether this entry belogns to the first set. If this is the_case, then the element is added to the completed entries queue from where it can be consumed._If the first set becomes empty, then the next set is polled from the uncompleted entries_queue. Completed entries from this new set are then added to the completed entries queue.__@param streamElementQueueEntry which has been completed_@throws InterruptedException if the current thread has been interrupted while performing the_on complete callback.;public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException {_		lock.lockInterruptibly()___		try {_			if (firstSet.remove(streamElementQueueEntry)) {_				completedQueue.offer(streamElementQueueEntry)___				while (firstSet.isEmpty() && firstSet != lastSet) {_					firstSet = uncompletedQueue.poll()___					Iterator<StreamElementQueueEntry<?>> it = firstSet.iterator()___					while (it.hasNext()) {_						StreamElementQueueEntry<?> bufferEntry = it.next()___						if (bufferEntry.isDone()) {_							completedQueue.offer(bufferEntry)__							it.remove()__						}_					}_				}__				LOG.debug("Signal unordered stream element queue has completed entries.")__				hasCompletedEntries.signalAll()__			}_		} finally {_			lock.unlock()__		}_	};callback,for,on,complete,events,for,the,given,stream,element,queue,entry,whenever,a,queue,entry,is,completed,it,is,checked,whether,this,entry,belogns,to,the,first,set,if,this,is,the,case,then,the,element,is,added,to,the,completed,entries,queue,from,where,it,can,be,consumed,if,the,first,set,becomes,empty,then,the,next,set,is,polled,from,the,uncompleted,entries,queue,completed,entries,from,this,new,set,are,then,added,to,the,completed,entries,queue,param,stream,element,queue,entry,which,has,been,completed,throws,interrupted,exception,if,the,current,thread,has,been,interrupted,while,performing,the,on,complete,callback;public,void,on,complete,handler,stream,element,queue,entry,stream,element,queue,entry,throws,interrupted,exception,lock,lock,interruptibly,try,if,first,set,remove,stream,element,queue,entry,completed,queue,offer,stream,element,queue,entry,while,first,set,is,empty,first,set,last,set,first,set,uncompleted,queue,poll,iterator,stream,element,queue,entry,it,first,set,iterator,while,it,has,next,stream,element,queue,entry,buffer,entry,it,next,if,buffer,entry,is,done,completed,queue,offer,buffer,entry,it,remove,log,debug,signal,unordered,stream,element,queue,has,completed,entries,has,completed,entries,signal,all,finally,lock,unlock
UnorderedStreamElementQueue -> public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException;1493195810;Callback for onComplete events for the given stream element queue entry. Whenever a queue_entry is completed, it is checked whether this entry belogns to the first set. If this is the_case, then the element is added to the completed entries queue from where it can be consumed._If the first set becomes empty, then the next set is polled from the uncompleted entries_queue. Completed entries from this new set are then added to the completed entries queue.__@param streamElementQueueEntry which has been completed_@throws InterruptedException if the current thread has been interrupted while performing the_on complete callback.;public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException {_		lock.lockInterruptibly()___		try {_			if (firstSet.remove(streamElementQueueEntry)) {_				completedQueue.offer(streamElementQueueEntry)___				while (firstSet.isEmpty() && firstSet != lastSet) {_					firstSet = uncompletedQueue.poll()___					Iterator<StreamElementQueueEntry<?>> it = firstSet.iterator()___					while (it.hasNext()) {_						StreamElementQueueEntry<?> bufferEntry = it.next()___						if (bufferEntry.isDone()) {_							completedQueue.offer(bufferEntry)__							it.remove()__						}_					}_				}__				LOG.debug("Signal unordered stream element queue has completed entries.")__				hasCompletedEntries.signalAll()__			}_		} finally {_			lock.unlock()__		}_	};callback,for,on,complete,events,for,the,given,stream,element,queue,entry,whenever,a,queue,entry,is,completed,it,is,checked,whether,this,entry,belogns,to,the,first,set,if,this,is,the,case,then,the,element,is,added,to,the,completed,entries,queue,from,where,it,can,be,consumed,if,the,first,set,becomes,empty,then,the,next,set,is,polled,from,the,uncompleted,entries,queue,completed,entries,from,this,new,set,are,then,added,to,the,completed,entries,queue,param,stream,element,queue,entry,which,has,been,completed,throws,interrupted,exception,if,the,current,thread,has,been,interrupted,while,performing,the,on,complete,callback;public,void,on,complete,handler,stream,element,queue,entry,stream,element,queue,entry,throws,interrupted,exception,lock,lock,interruptibly,try,if,first,set,remove,stream,element,queue,entry,completed,queue,offer,stream,element,queue,entry,while,first,set,is,empty,first,set,last,set,first,set,uncompleted,queue,poll,iterator,stream,element,queue,entry,it,first,set,iterator,while,it,has,next,stream,element,queue,entry,buffer,entry,it,next,if,buffer,entry,is,done,completed,queue,offer,buffer,entry,it,remove,log,debug,signal,unordered,stream,element,queue,has,completed,entries,has,completed,entries,signal,all,finally,lock,unlock
UnorderedStreamElementQueue -> public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException;1495484544;Callback for onComplete events for the given stream element queue entry. Whenever a queue_entry is completed, it is checked whether this entry belogns to the first set. If this is the_case, then the element is added to the completed entries queue from where it can be consumed._If the first set becomes empty, then the next set is polled from the uncompleted entries_queue. Completed entries from this new set are then added to the completed entries queue.__@param streamElementQueueEntry which has been completed_@throws InterruptedException if the current thread has been interrupted while performing the_on complete callback.;public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException {_		lock.lockInterruptibly()___		try {_			if (firstSet.remove(streamElementQueueEntry)) {_				completedQueue.offer(streamElementQueueEntry)___				while (firstSet.isEmpty() && firstSet != lastSet) {_					firstSet = uncompletedQueue.poll()___					Iterator<StreamElementQueueEntry<?>> it = firstSet.iterator()___					while (it.hasNext()) {_						StreamElementQueueEntry<?> bufferEntry = it.next()___						if (bufferEntry.isDone()) {_							completedQueue.offer(bufferEntry)__							it.remove()__						}_					}_				}__				LOG.debug("Signal unordered stream element queue has completed entries.")__				hasCompletedEntries.signalAll()__			}_		} finally {_			lock.unlock()__		}_	};callback,for,on,complete,events,for,the,given,stream,element,queue,entry,whenever,a,queue,entry,is,completed,it,is,checked,whether,this,entry,belogns,to,the,first,set,if,this,is,the,case,then,the,element,is,added,to,the,completed,entries,queue,from,where,it,can,be,consumed,if,the,first,set,becomes,empty,then,the,next,set,is,polled,from,the,uncompleted,entries,queue,completed,entries,from,this,new,set,are,then,added,to,the,completed,entries,queue,param,stream,element,queue,entry,which,has,been,completed,throws,interrupted,exception,if,the,current,thread,has,been,interrupted,while,performing,the,on,complete,callback;public,void,on,complete,handler,stream,element,queue,entry,stream,element,queue,entry,throws,interrupted,exception,lock,lock,interruptibly,try,if,first,set,remove,stream,element,queue,entry,completed,queue,offer,stream,element,queue,entry,while,first,set,is,empty,first,set,last,set,first,set,uncompleted,queue,poll,iterator,stream,element,queue,entry,it,first,set,iterator,while,it,has,next,stream,element,queue,entry,buffer,entry,it,next,if,buffer,entry,is,done,completed,queue,offer,buffer,entry,it,remove,log,debug,signal,unordered,stream,element,queue,has,completed,entries,has,completed,entries,signal,all,finally,lock,unlock
UnorderedStreamElementQueue -> public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException;1495637163;Callback for onComplete events for the given stream element queue entry. Whenever a queue_entry is completed, it is checked whether this entry belogns to the first set. If this is the_case, then the element is added to the completed entries queue from where it can be consumed._If the first set becomes empty, then the next set is polled from the uncompleted entries_queue. Completed entries from this new set are then added to the completed entries queue.__@param streamElementQueueEntry which has been completed_@throws InterruptedException if the current thread has been interrupted while performing the_on complete callback.;public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException {_		lock.lockInterruptibly()___		try {_			if (firstSet.remove(streamElementQueueEntry)) {_				completedQueue.offer(streamElementQueueEntry)___				while (firstSet.isEmpty() && firstSet != lastSet) {_					firstSet = uncompletedQueue.poll()___					Iterator<StreamElementQueueEntry<?>> it = firstSet.iterator()___					while (it.hasNext()) {_						StreamElementQueueEntry<?> bufferEntry = it.next()___						if (bufferEntry.isDone()) {_							completedQueue.offer(bufferEntry)__							it.remove()__						}_					}_				}__				LOG.debug("Signal unordered stream element queue has completed entries.")__				hasCompletedEntries.signalAll()__			}_		} finally {_			lock.unlock()__		}_	};callback,for,on,complete,events,for,the,given,stream,element,queue,entry,whenever,a,queue,entry,is,completed,it,is,checked,whether,this,entry,belogns,to,the,first,set,if,this,is,the,case,then,the,element,is,added,to,the,completed,entries,queue,from,where,it,can,be,consumed,if,the,first,set,becomes,empty,then,the,next,set,is,polled,from,the,uncompleted,entries,queue,completed,entries,from,this,new,set,are,then,added,to,the,completed,entries,queue,param,stream,element,queue,entry,which,has,been,completed,throws,interrupted,exception,if,the,current,thread,has,been,interrupted,while,performing,the,on,complete,callback;public,void,on,complete,handler,stream,element,queue,entry,stream,element,queue,entry,throws,interrupted,exception,lock,lock,interruptibly,try,if,first,set,remove,stream,element,queue,entry,completed,queue,offer,stream,element,queue,entry,while,first,set,is,empty,first,set,last,set,first,set,uncompleted,queue,poll,iterator,stream,element,queue,entry,it,first,set,iterator,while,it,has,next,stream,element,queue,entry,buffer,entry,it,next,if,buffer,entry,is,done,completed,queue,offer,buffer,entry,it,remove,log,debug,signal,unordered,stream,element,queue,has,completed,entries,has,completed,entries,signal,all,finally,lock,unlock
UnorderedStreamElementQueue -> public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException;1501589083;Callback for onComplete events for the given stream element queue entry. Whenever a queue_entry is completed, it is checked whether this entry belogns to the first set. If this is the_case, then the element is added to the completed entries queue from where it can be consumed._If the first set becomes empty, then the next set is polled from the uncompleted entries_queue. Completed entries from this new set are then added to the completed entries queue.__@param streamElementQueueEntry which has been completed_@throws InterruptedException if the current thread has been interrupted while performing the_on complete callback.;public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException {_		lock.lockInterruptibly()___		try {_			if (firstSet.remove(streamElementQueueEntry)) {_				completedQueue.offer(streamElementQueueEntry)___				while (firstSet.isEmpty() && firstSet != lastSet) {_					firstSet = uncompletedQueue.poll()___					Iterator<StreamElementQueueEntry<?>> it = firstSet.iterator()___					while (it.hasNext()) {_						StreamElementQueueEntry<?> bufferEntry = it.next()___						if (bufferEntry.isDone()) {_							completedQueue.offer(bufferEntry)__							it.remove()__						}_					}_				}__				LOG.debug("Signal unordered stream element queue has completed entries.")__				hasCompletedEntries.signalAll()__			}_		} finally {_			lock.unlock()__		}_	};callback,for,on,complete,events,for,the,given,stream,element,queue,entry,whenever,a,queue,entry,is,completed,it,is,checked,whether,this,entry,belogns,to,the,first,set,if,this,is,the,case,then,the,element,is,added,to,the,completed,entries,queue,from,where,it,can,be,consumed,if,the,first,set,becomes,empty,then,the,next,set,is,polled,from,the,uncompleted,entries,queue,completed,entries,from,this,new,set,are,then,added,to,the,completed,entries,queue,param,stream,element,queue,entry,which,has,been,completed,throws,interrupted,exception,if,the,current,thread,has,been,interrupted,while,performing,the,on,complete,callback;public,void,on,complete,handler,stream,element,queue,entry,stream,element,queue,entry,throws,interrupted,exception,lock,lock,interruptibly,try,if,first,set,remove,stream,element,queue,entry,completed,queue,offer,stream,element,queue,entry,while,first,set,is,empty,first,set,last,set,first,set,uncompleted,queue,poll,iterator,stream,element,queue,entry,it,first,set,iterator,while,it,has,next,stream,element,queue,entry,buffer,entry,it,next,if,buffer,entry,is,done,completed,queue,offer,buffer,entry,it,remove,log,debug,signal,unordered,stream,element,queue,has,completed,entries,has,completed,entries,signal,all,finally,lock,unlock
UnorderedStreamElementQueue -> public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException;1515177485;Callback for onComplete events for the given stream element queue entry. Whenever a queue_entry is completed, it is checked whether this entry belongs to the first set. If this is the_case, then the element is added to the completed entries queue from where it can be consumed._If the first set becomes empty, then the next set is polled from the uncompleted entries_queue. Completed entries from this new set are then added to the completed entries queue.__@param streamElementQueueEntry which has been completed_@throws InterruptedException if the current thread has been interrupted while performing the_on complete callback.;public void onCompleteHandler(StreamElementQueueEntry<?> streamElementQueueEntry) throws InterruptedException {_		lock.lockInterruptibly()___		try {_			if (firstSet.remove(streamElementQueueEntry)) {_				completedQueue.offer(streamElementQueueEntry)___				while (firstSet.isEmpty() && firstSet != lastSet) {_					firstSet = uncompletedQueue.poll()___					Iterator<StreamElementQueueEntry<?>> it = firstSet.iterator()___					while (it.hasNext()) {_						StreamElementQueueEntry<?> bufferEntry = it.next()___						if (bufferEntry.isDone()) {_							completedQueue.offer(bufferEntry)__							it.remove()__						}_					}_				}__				LOG.debug("Signal unordered stream element queue has completed entries.")__				hasCompletedEntries.signalAll()__			}_		} finally {_			lock.unlock()__		}_	};callback,for,on,complete,events,for,the,given,stream,element,queue,entry,whenever,a,queue,entry,is,completed,it,is,checked,whether,this,entry,belongs,to,the,first,set,if,this,is,the,case,then,the,element,is,added,to,the,completed,entries,queue,from,where,it,can,be,consumed,if,the,first,set,becomes,empty,then,the,next,set,is,polled,from,the,uncompleted,entries,queue,completed,entries,from,this,new,set,are,then,added,to,the,completed,entries,queue,param,stream,element,queue,entry,which,has,been,completed,throws,interrupted,exception,if,the,current,thread,has,been,interrupted,while,performing,the,on,complete,callback;public,void,on,complete,handler,stream,element,queue,entry,stream,element,queue,entry,throws,interrupted,exception,lock,lock,interruptibly,try,if,first,set,remove,stream,element,queue,entry,completed,queue,offer,stream,element,queue,entry,while,first,set,is,empty,first,set,last,set,first,set,uncompleted,queue,poll,iterator,stream,element,queue,entry,it,first,set,iterator,while,it,has,next,stream,element,queue,entry,buffer,entry,it,next,if,buffer,entry,is,done,completed,queue,offer,buffer,entry,it,remove,log,debug,signal,unordered,stream,element,queue,has,completed,entries,has,completed,entries,signal,all,finally,lock,unlock
UnorderedStreamElementQueue -> private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry);1482206691;Add the given stream element queue entry to the current last set if it is not a watermark._If it is a watermark, then stop adding to the current last set, insert the watermark into its_own set and add a new last set.__@param streamElementQueueEntry to be inserted_@param <T> Type of the stream element queue entry's result;private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry) {_		assert(lock.isHeldByCurrentThread())___		if (streamElementQueueEntry.isWatermark()) {_			lastSet = new HashSet<>(capacity)___			if (firstSet.isEmpty()) {_				firstSet.add(streamElementQueueEntry)__			} else {_				Set<StreamElementQueueEntry<?>> watermarkSet = new HashSet<>(1)__				watermarkSet.add(streamElementQueueEntry)__				uncompletedQueue.offer(watermarkSet)__			}_			uncompletedQueue.offer(lastSet)__		} else {_			lastSet.add(streamElementQueueEntry)__		}__		streamElementQueueEntry.onComplete(new AcceptFunction<StreamElementQueueEntry<T>>() {_			@Override_			public void accept(StreamElementQueueEntry<T> value) {_				try {_					onCompleteHandler(value)__				} catch (InterruptedException e) {_					_					_					LOG.debug("AsyncBufferEntry could not be properly completed because the " +_						"executor thread has been interrupted.", e)__				} catch (Throwable t) {_					operatorActions.failOperator(new Exception("Could not complete the " +_						"stream element queue entry: " + value + '.', t))__				}_			}_		}, executor)___		numberEntries++__	};add,the,given,stream,element,queue,entry,to,the,current,last,set,if,it,is,not,a,watermark,if,it,is,a,watermark,then,stop,adding,to,the,current,last,set,insert,the,watermark,into,its,own,set,and,add,a,new,last,set,param,stream,element,queue,entry,to,be,inserted,param,t,type,of,the,stream,element,queue,entry,s,result;private,t,void,add,entry,stream,element,queue,entry,t,stream,element,queue,entry,assert,lock,is,held,by,current,thread,if,stream,element,queue,entry,is,watermark,last,set,new,hash,set,capacity,if,first,set,is,empty,first,set,add,stream,element,queue,entry,else,set,stream,element,queue,entry,watermark,set,new,hash,set,1,watermark,set,add,stream,element,queue,entry,uncompleted,queue,offer,watermark,set,uncompleted,queue,offer,last,set,else,last,set,add,stream,element,queue,entry,stream,element,queue,entry,on,complete,new,accept,function,stream,element,queue,entry,t,override,public,void,accept,stream,element,queue,entry,t,value,try,on,complete,handler,value,catch,interrupted,exception,e,log,debug,async,buffer,entry,could,not,be,properly,completed,because,the,executor,thread,has,been,interrupted,e,catch,throwable,t,operator,actions,fail,operator,new,exception,could,not,complete,the,stream,element,queue,entry,value,t,executor,number,entries
UnorderedStreamElementQueue -> private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry);1482206691;Add the given stream element queue entry to the current last set if it is not a watermark._If it is a watermark, then stop adding to the current last set, insert the watermark into its_own set and add a new last set.__@param streamElementQueueEntry to be inserted_@param <T> Type of the stream element queue entry's result;private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry) {_		assert(lock.isHeldByCurrentThread())___		if (streamElementQueueEntry.isWatermark()) {_			lastSet = new HashSet<>(capacity)___			if (firstSet.isEmpty()) {_				firstSet.add(streamElementQueueEntry)__			} else {_				Set<StreamElementQueueEntry<?>> watermarkSet = new HashSet<>(1)__				watermarkSet.add(streamElementQueueEntry)__				uncompletedQueue.offer(watermarkSet)__			}_			uncompletedQueue.offer(lastSet)__		} else {_			lastSet.add(streamElementQueueEntry)__		}__		streamElementQueueEntry.onComplete(new AcceptFunction<StreamElementQueueEntry<T>>() {_			@Override_			public void accept(StreamElementQueueEntry<T> value) {_				try {_					onCompleteHandler(value)__				} catch (InterruptedException e) {_					_					_					LOG.debug("AsyncBufferEntry could not be properly completed because the " +_						"executor thread has been interrupted.", e)__				} catch (Throwable t) {_					operatorActions.failOperator(new Exception("Could not complete the " +_						"stream element queue entry: " + value + '.', t))__				}_			}_		}, executor)___		numberEntries++__	};add,the,given,stream,element,queue,entry,to,the,current,last,set,if,it,is,not,a,watermark,if,it,is,a,watermark,then,stop,adding,to,the,current,last,set,insert,the,watermark,into,its,own,set,and,add,a,new,last,set,param,stream,element,queue,entry,to,be,inserted,param,t,type,of,the,stream,element,queue,entry,s,result;private,t,void,add,entry,stream,element,queue,entry,t,stream,element,queue,entry,assert,lock,is,held,by,current,thread,if,stream,element,queue,entry,is,watermark,last,set,new,hash,set,capacity,if,first,set,is,empty,first,set,add,stream,element,queue,entry,else,set,stream,element,queue,entry,watermark,set,new,hash,set,1,watermark,set,add,stream,element,queue,entry,uncompleted,queue,offer,watermark,set,uncompleted,queue,offer,last,set,else,last,set,add,stream,element,queue,entry,stream,element,queue,entry,on,complete,new,accept,function,stream,element,queue,entry,t,override,public,void,accept,stream,element,queue,entry,t,value,try,on,complete,handler,value,catch,interrupted,exception,e,log,debug,async,buffer,entry,could,not,be,properly,completed,because,the,executor,thread,has,been,interrupted,e,catch,throwable,t,operator,actions,fail,operator,new,exception,could,not,complete,the,stream,element,queue,entry,value,t,executor,number,entries
UnorderedStreamElementQueue -> private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry);1485357390;Add the given stream element queue entry to the current last set if it is not a watermark._If it is a watermark, then stop adding to the current last set, insert the watermark into its_own set and add a new last set.__@param streamElementQueueEntry to be inserted_@param <T> Type of the stream element queue entry's result;private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry) {_		assert(lock.isHeldByCurrentThread())___		if (streamElementQueueEntry.isWatermark()) {_			lastSet = new HashSet<>(capacity)___			if (firstSet.isEmpty()) {_				firstSet.add(streamElementQueueEntry)__			} else {_				Set<StreamElementQueueEntry<?>> watermarkSet = new HashSet<>(1)__				watermarkSet.add(streamElementQueueEntry)__				uncompletedQueue.offer(watermarkSet)__			}_			uncompletedQueue.offer(lastSet)__		} else {_			lastSet.add(streamElementQueueEntry)__		}__		streamElementQueueEntry.onComplete(new AcceptFunction<StreamElementQueueEntry<T>>() {_			@Override_			public void accept(StreamElementQueueEntry<T> value) {_				try {_					onCompleteHandler(value)__				} catch (InterruptedException e) {_					_					_					LOG.debug("AsyncBufferEntry could not be properly completed because the " +_						"executor thread has been interrupted.", e)__				} catch (Throwable t) {_					operatorActions.failOperator(new Exception("Could not complete the " +_						"stream element queue entry: " + value + '.', t))__				}_			}_		}, executor)___		numberEntries++__	};add,the,given,stream,element,queue,entry,to,the,current,last,set,if,it,is,not,a,watermark,if,it,is,a,watermark,then,stop,adding,to,the,current,last,set,insert,the,watermark,into,its,own,set,and,add,a,new,last,set,param,stream,element,queue,entry,to,be,inserted,param,t,type,of,the,stream,element,queue,entry,s,result;private,t,void,add,entry,stream,element,queue,entry,t,stream,element,queue,entry,assert,lock,is,held,by,current,thread,if,stream,element,queue,entry,is,watermark,last,set,new,hash,set,capacity,if,first,set,is,empty,first,set,add,stream,element,queue,entry,else,set,stream,element,queue,entry,watermark,set,new,hash,set,1,watermark,set,add,stream,element,queue,entry,uncompleted,queue,offer,watermark,set,uncompleted,queue,offer,last,set,else,last,set,add,stream,element,queue,entry,stream,element,queue,entry,on,complete,new,accept,function,stream,element,queue,entry,t,override,public,void,accept,stream,element,queue,entry,t,value,try,on,complete,handler,value,catch,interrupted,exception,e,log,debug,async,buffer,entry,could,not,be,properly,completed,because,the,executor,thread,has,been,interrupted,e,catch,throwable,t,operator,actions,fail,operator,new,exception,could,not,complete,the,stream,element,queue,entry,value,t,executor,number,entries
UnorderedStreamElementQueue -> private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry);1491500150;Add the given stream element queue entry to the current last set if it is not a watermark._If it is a watermark, then stop adding to the current last set, insert the watermark into its_own set and add a new last set.__@param streamElementQueueEntry to be inserted_@param <T> Type of the stream element queue entry's result;private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry) {_		assert(lock.isHeldByCurrentThread())___		if (streamElementQueueEntry.isWatermark()) {_			lastSet = new HashSet<>(capacity)___			if (firstSet.isEmpty()) {_				firstSet.add(streamElementQueueEntry)__			} else {_				Set<StreamElementQueueEntry<?>> watermarkSet = new HashSet<>(1)__				watermarkSet.add(streamElementQueueEntry)__				uncompletedQueue.offer(watermarkSet)__			}_			uncompletedQueue.offer(lastSet)__		} else {_			lastSet.add(streamElementQueueEntry)__		}__		streamElementQueueEntry.onComplete(new AcceptFunction<StreamElementQueueEntry<T>>() {_			@Override_			public void accept(StreamElementQueueEntry<T> value) {_				try {_					onCompleteHandler(value)__				} catch (InterruptedException e) {_					_					_					LOG.debug("AsyncBufferEntry could not be properly completed because the " +_						"executor thread has been interrupted.", e)__				} catch (Throwable t) {_					operatorActions.failOperator(new Exception("Could not complete the " +_						"stream element queue entry: " + value + '.', t))__				}_			}_		}, executor)___		numberEntries++__	};add,the,given,stream,element,queue,entry,to,the,current,last,set,if,it,is,not,a,watermark,if,it,is,a,watermark,then,stop,adding,to,the,current,last,set,insert,the,watermark,into,its,own,set,and,add,a,new,last,set,param,stream,element,queue,entry,to,be,inserted,param,t,type,of,the,stream,element,queue,entry,s,result;private,t,void,add,entry,stream,element,queue,entry,t,stream,element,queue,entry,assert,lock,is,held,by,current,thread,if,stream,element,queue,entry,is,watermark,last,set,new,hash,set,capacity,if,first,set,is,empty,first,set,add,stream,element,queue,entry,else,set,stream,element,queue,entry,watermark,set,new,hash,set,1,watermark,set,add,stream,element,queue,entry,uncompleted,queue,offer,watermark,set,uncompleted,queue,offer,last,set,else,last,set,add,stream,element,queue,entry,stream,element,queue,entry,on,complete,new,accept,function,stream,element,queue,entry,t,override,public,void,accept,stream,element,queue,entry,t,value,try,on,complete,handler,value,catch,interrupted,exception,e,log,debug,async,buffer,entry,could,not,be,properly,completed,because,the,executor,thread,has,been,interrupted,e,catch,throwable,t,operator,actions,fail,operator,new,exception,could,not,complete,the,stream,element,queue,entry,value,t,executor,number,entries
UnorderedStreamElementQueue -> private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry);1493195810;Add the given stream element queue entry to the current last set if it is not a watermark._If it is a watermark, then stop adding to the current last set, insert the watermark into its_own set and add a new last set.__@param streamElementQueueEntry to be inserted_@param <T> Type of the stream element queue entry's result;private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry) {_		assert(lock.isHeldByCurrentThread())___		if (streamElementQueueEntry.isWatermark()) {_			lastSet = new HashSet<>(capacity)___			if (firstSet.isEmpty()) {_				firstSet.add(streamElementQueueEntry)__			} else {_				Set<StreamElementQueueEntry<?>> watermarkSet = new HashSet<>(1)__				watermarkSet.add(streamElementQueueEntry)__				uncompletedQueue.offer(watermarkSet)__			}_			uncompletedQueue.offer(lastSet)__		} else {_			lastSet.add(streamElementQueueEntry)__		}__		streamElementQueueEntry.onComplete(new AcceptFunction<StreamElementQueueEntry<T>>() {_			@Override_			public void accept(StreamElementQueueEntry<T> value) {_				try {_					onCompleteHandler(value)__				} catch (InterruptedException e) {_					_					_					LOG.debug("AsyncBufferEntry could not be properly completed because the " +_						"executor thread has been interrupted.", e)__				} catch (Throwable t) {_					operatorActions.failOperator(new Exception("Could not complete the " +_						"stream element queue entry: " + value + '.', t))__				}_			}_		}, executor)___		numberEntries++__	};add,the,given,stream,element,queue,entry,to,the,current,last,set,if,it,is,not,a,watermark,if,it,is,a,watermark,then,stop,adding,to,the,current,last,set,insert,the,watermark,into,its,own,set,and,add,a,new,last,set,param,stream,element,queue,entry,to,be,inserted,param,t,type,of,the,stream,element,queue,entry,s,result;private,t,void,add,entry,stream,element,queue,entry,t,stream,element,queue,entry,assert,lock,is,held,by,current,thread,if,stream,element,queue,entry,is,watermark,last,set,new,hash,set,capacity,if,first,set,is,empty,first,set,add,stream,element,queue,entry,else,set,stream,element,queue,entry,watermark,set,new,hash,set,1,watermark,set,add,stream,element,queue,entry,uncompleted,queue,offer,watermark,set,uncompleted,queue,offer,last,set,else,last,set,add,stream,element,queue,entry,stream,element,queue,entry,on,complete,new,accept,function,stream,element,queue,entry,t,override,public,void,accept,stream,element,queue,entry,t,value,try,on,complete,handler,value,catch,interrupted,exception,e,log,debug,async,buffer,entry,could,not,be,properly,completed,because,the,executor,thread,has,been,interrupted,e,catch,throwable,t,operator,actions,fail,operator,new,exception,could,not,complete,the,stream,element,queue,entry,value,t,executor,number,entries
UnorderedStreamElementQueue -> private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry);1493195810;Add the given stream element queue entry to the current last set if it is not a watermark._If it is a watermark, then stop adding to the current last set, insert the watermark into its_own set and add a new last set.__@param streamElementQueueEntry to be inserted_@param <T> Type of the stream element queue entry's result;private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry) {_		assert(lock.isHeldByCurrentThread())___		if (streamElementQueueEntry.isWatermark()) {_			lastSet = new HashSet<>(capacity)___			if (firstSet.isEmpty()) {_				firstSet.add(streamElementQueueEntry)__			} else {_				Set<StreamElementQueueEntry<?>> watermarkSet = new HashSet<>(1)__				watermarkSet.add(streamElementQueueEntry)__				uncompletedQueue.offer(watermarkSet)__			}_			uncompletedQueue.offer(lastSet)__		} else {_			lastSet.add(streamElementQueueEntry)__		}__		streamElementQueueEntry.onComplete(new AcceptFunction<StreamElementQueueEntry<T>>() {_			@Override_			public void accept(StreamElementQueueEntry<T> value) {_				try {_					onCompleteHandler(value)__				} catch (InterruptedException e) {_					_					_					LOG.debug("AsyncBufferEntry could not be properly completed because the " +_						"executor thread has been interrupted.", e)__				} catch (Throwable t) {_					operatorActions.failOperator(new Exception("Could not complete the " +_						"stream element queue entry: " + value + '.', t))__				}_			}_		}, executor)___		numberEntries++__	};add,the,given,stream,element,queue,entry,to,the,current,last,set,if,it,is,not,a,watermark,if,it,is,a,watermark,then,stop,adding,to,the,current,last,set,insert,the,watermark,into,its,own,set,and,add,a,new,last,set,param,stream,element,queue,entry,to,be,inserted,param,t,type,of,the,stream,element,queue,entry,s,result;private,t,void,add,entry,stream,element,queue,entry,t,stream,element,queue,entry,assert,lock,is,held,by,current,thread,if,stream,element,queue,entry,is,watermark,last,set,new,hash,set,capacity,if,first,set,is,empty,first,set,add,stream,element,queue,entry,else,set,stream,element,queue,entry,watermark,set,new,hash,set,1,watermark,set,add,stream,element,queue,entry,uncompleted,queue,offer,watermark,set,uncompleted,queue,offer,last,set,else,last,set,add,stream,element,queue,entry,stream,element,queue,entry,on,complete,new,accept,function,stream,element,queue,entry,t,override,public,void,accept,stream,element,queue,entry,t,value,try,on,complete,handler,value,catch,interrupted,exception,e,log,debug,async,buffer,entry,could,not,be,properly,completed,because,the,executor,thread,has,been,interrupted,e,catch,throwable,t,operator,actions,fail,operator,new,exception,could,not,complete,the,stream,element,queue,entry,value,t,executor,number,entries
UnorderedStreamElementQueue -> private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry);1495484544;Add the given stream element queue entry to the current last set if it is not a watermark._If it is a watermark, then stop adding to the current last set, insert the watermark into its_own set and add a new last set.__@param streamElementQueueEntry to be inserted_@param <T> Type of the stream element queue entry's result;private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry) {_		assert(lock.isHeldByCurrentThread())___		if (streamElementQueueEntry.isWatermark()) {_			lastSet = new HashSet<>(capacity)___			if (firstSet.isEmpty()) {_				firstSet.add(streamElementQueueEntry)__			} else {_				Set<StreamElementQueueEntry<?>> watermarkSet = new HashSet<>(1)__				watermarkSet.add(streamElementQueueEntry)__				uncompletedQueue.offer(watermarkSet)__			}_			uncompletedQueue.offer(lastSet)__		} else {_			lastSet.add(streamElementQueueEntry)__		}__		streamElementQueueEntry.onComplete(new AcceptFunction<StreamElementQueueEntry<T>>() {_			@Override_			public void accept(StreamElementQueueEntry<T> value) {_				try {_					onCompleteHandler(value)__				} catch (InterruptedException e) {_					_					_					LOG.debug("AsyncBufferEntry could not be properly completed because the " +_						"executor thread has been interrupted.", e)__				} catch (Throwable t) {_					operatorActions.failOperator(new Exception("Could not complete the " +_						"stream element queue entry: " + value + '.', t))__				}_			}_		}, executor)___		numberEntries++__	};add,the,given,stream,element,queue,entry,to,the,current,last,set,if,it,is,not,a,watermark,if,it,is,a,watermark,then,stop,adding,to,the,current,last,set,insert,the,watermark,into,its,own,set,and,add,a,new,last,set,param,stream,element,queue,entry,to,be,inserted,param,t,type,of,the,stream,element,queue,entry,s,result;private,t,void,add,entry,stream,element,queue,entry,t,stream,element,queue,entry,assert,lock,is,held,by,current,thread,if,stream,element,queue,entry,is,watermark,last,set,new,hash,set,capacity,if,first,set,is,empty,first,set,add,stream,element,queue,entry,else,set,stream,element,queue,entry,watermark,set,new,hash,set,1,watermark,set,add,stream,element,queue,entry,uncompleted,queue,offer,watermark,set,uncompleted,queue,offer,last,set,else,last,set,add,stream,element,queue,entry,stream,element,queue,entry,on,complete,new,accept,function,stream,element,queue,entry,t,override,public,void,accept,stream,element,queue,entry,t,value,try,on,complete,handler,value,catch,interrupted,exception,e,log,debug,async,buffer,entry,could,not,be,properly,completed,because,the,executor,thread,has,been,interrupted,e,catch,throwable,t,operator,actions,fail,operator,new,exception,could,not,complete,the,stream,element,queue,entry,value,t,executor,number,entries
UnorderedStreamElementQueue -> private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry);1495637163;Add the given stream element queue entry to the current last set if it is not a watermark._If it is a watermark, then stop adding to the current last set, insert the watermark into its_own set and add a new last set.__@param streamElementQueueEntry to be inserted_@param <T> Type of the stream element queue entry's result;private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry) {_		assert(lock.isHeldByCurrentThread())___		if (streamElementQueueEntry.isWatermark()) {_			lastSet = new HashSet<>(capacity)___			if (firstSet.isEmpty()) {_				firstSet.add(streamElementQueueEntry)__			} else {_				Set<StreamElementQueueEntry<?>> watermarkSet = new HashSet<>(1)__				watermarkSet.add(streamElementQueueEntry)__				uncompletedQueue.offer(watermarkSet)__			}_			uncompletedQueue.offer(lastSet)__		} else {_			lastSet.add(streamElementQueueEntry)__		}__		streamElementQueueEntry.onComplete(new AcceptFunction<StreamElementQueueEntry<T>>() {_			@Override_			public void accept(StreamElementQueueEntry<T> value) {_				try {_					onCompleteHandler(value)__				} catch (InterruptedException e) {_					_					_					LOG.debug("AsyncBufferEntry could not be properly completed because the " +_						"executor thread has been interrupted.", e)__				} catch (Throwable t) {_					operatorActions.failOperator(new Exception("Could not complete the " +_						"stream element queue entry: " + value + '.', t))__				}_			}_		}, executor)___		numberEntries++__	};add,the,given,stream,element,queue,entry,to,the,current,last,set,if,it,is,not,a,watermark,if,it,is,a,watermark,then,stop,adding,to,the,current,last,set,insert,the,watermark,into,its,own,set,and,add,a,new,last,set,param,stream,element,queue,entry,to,be,inserted,param,t,type,of,the,stream,element,queue,entry,s,result;private,t,void,add,entry,stream,element,queue,entry,t,stream,element,queue,entry,assert,lock,is,held,by,current,thread,if,stream,element,queue,entry,is,watermark,last,set,new,hash,set,capacity,if,first,set,is,empty,first,set,add,stream,element,queue,entry,else,set,stream,element,queue,entry,watermark,set,new,hash,set,1,watermark,set,add,stream,element,queue,entry,uncompleted,queue,offer,watermark,set,uncompleted,queue,offer,last,set,else,last,set,add,stream,element,queue,entry,stream,element,queue,entry,on,complete,new,accept,function,stream,element,queue,entry,t,override,public,void,accept,stream,element,queue,entry,t,value,try,on,complete,handler,value,catch,interrupted,exception,e,log,debug,async,buffer,entry,could,not,be,properly,completed,because,the,executor,thread,has,been,interrupted,e,catch,throwable,t,operator,actions,fail,operator,new,exception,could,not,complete,the,stream,element,queue,entry,value,t,executor,number,entries
UnorderedStreamElementQueue -> private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry);1501589083;Add the given stream element queue entry to the current last set if it is not a watermark._If it is a watermark, then stop adding to the current last set, insert the watermark into its_own set and add a new last set.__@param streamElementQueueEntry to be inserted_@param <T> Type of the stream element queue entry's result;private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry) {_		assert(lock.isHeldByCurrentThread())___		if (streamElementQueueEntry.isWatermark()) {_			lastSet = new HashSet<>(capacity)___			if (firstSet.isEmpty()) {_				firstSet.add(streamElementQueueEntry)__			} else {_				Set<StreamElementQueueEntry<?>> watermarkSet = new HashSet<>(1)__				watermarkSet.add(streamElementQueueEntry)__				uncompletedQueue.offer(watermarkSet)__			}_			uncompletedQueue.offer(lastSet)__		} else {_			lastSet.add(streamElementQueueEntry)__		}__		streamElementQueueEntry.onComplete(_			(StreamElementQueueEntry<T> value) -> {_				try {_					onCompleteHandler(value)__				} catch (InterruptedException e) {_					_					_					LOG.debug("AsyncBufferEntry could not be properly completed because the " +_						"executor thread has been interrupted.", e)__				} catch (Throwable t) {_					operatorActions.failOperator(new Exception("Could not complete the " +_						"stream element queue entry: " + value + '.', t))__				}_			},_			executor)___		numberEntries++__	};add,the,given,stream,element,queue,entry,to,the,current,last,set,if,it,is,not,a,watermark,if,it,is,a,watermark,then,stop,adding,to,the,current,last,set,insert,the,watermark,into,its,own,set,and,add,a,new,last,set,param,stream,element,queue,entry,to,be,inserted,param,t,type,of,the,stream,element,queue,entry,s,result;private,t,void,add,entry,stream,element,queue,entry,t,stream,element,queue,entry,assert,lock,is,held,by,current,thread,if,stream,element,queue,entry,is,watermark,last,set,new,hash,set,capacity,if,first,set,is,empty,first,set,add,stream,element,queue,entry,else,set,stream,element,queue,entry,watermark,set,new,hash,set,1,watermark,set,add,stream,element,queue,entry,uncompleted,queue,offer,watermark,set,uncompleted,queue,offer,last,set,else,last,set,add,stream,element,queue,entry,stream,element,queue,entry,on,complete,stream,element,queue,entry,t,value,try,on,complete,handler,value,catch,interrupted,exception,e,log,debug,async,buffer,entry,could,not,be,properly,completed,because,the,executor,thread,has,been,interrupted,e,catch,throwable,t,operator,actions,fail,operator,new,exception,could,not,complete,the,stream,element,queue,entry,value,t,executor,number,entries
UnorderedStreamElementQueue -> private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry);1515177485;Add the given stream element queue entry to the current last set if it is not a watermark._If it is a watermark, then stop adding to the current last set, insert the watermark into its_own set and add a new last set.__@param streamElementQueueEntry to be inserted_@param <T> Type of the stream element queue entry's result;private <T> void addEntry(StreamElementQueueEntry<T> streamElementQueueEntry) {_		assert(lock.isHeldByCurrentThread())___		if (streamElementQueueEntry.isWatermark()) {_			lastSet = new HashSet<>(capacity)___			if (firstSet.isEmpty()) {_				firstSet.add(streamElementQueueEntry)__			} else {_				Set<StreamElementQueueEntry<?>> watermarkSet = new HashSet<>(1)__				watermarkSet.add(streamElementQueueEntry)__				uncompletedQueue.offer(watermarkSet)__			}_			uncompletedQueue.offer(lastSet)__		} else {_			lastSet.add(streamElementQueueEntry)__		}__		streamElementQueueEntry.onComplete(_			(StreamElementQueueEntry<T> value) -> {_				try {_					onCompleteHandler(value)__				} catch (InterruptedException e) {_					_					_					LOG.debug("AsyncBufferEntry could not be properly completed because the " +_						"executor thread has been interrupted.", e)__				} catch (Throwable t) {_					operatorActions.failOperator(new Exception("Could not complete the " +_						"stream element queue entry: " + value + '.', t))__				}_			},_			executor)___		numberEntries++__	};add,the,given,stream,element,queue,entry,to,the,current,last,set,if,it,is,not,a,watermark,if,it,is,a,watermark,then,stop,adding,to,the,current,last,set,insert,the,watermark,into,its,own,set,and,add,a,new,last,set,param,stream,element,queue,entry,to,be,inserted,param,t,type,of,the,stream,element,queue,entry,s,result;private,t,void,add,entry,stream,element,queue,entry,t,stream,element,queue,entry,assert,lock,is,held,by,current,thread,if,stream,element,queue,entry,is,watermark,last,set,new,hash,set,capacity,if,first,set,is,empty,first,set,add,stream,element,queue,entry,else,set,stream,element,queue,entry,watermark,set,new,hash,set,1,watermark,set,add,stream,element,queue,entry,uncompleted,queue,offer,watermark,set,uncompleted,queue,offer,last,set,else,last,set,add,stream,element,queue,entry,stream,element,queue,entry,on,complete,stream,element,queue,entry,t,value,try,on,complete,handler,value,catch,interrupted,exception,e,log,debug,async,buffer,entry,could,not,be,properly,completed,because,the,executor,thread,has,been,interrupted,e,catch,throwable,t,operator,actions,fail,operator,new,exception,could,not,complete,the,stream,element,queue,entry,value,t,executor,number,entries
