commented;modifiers;parameterAmount;loc;comment;code
true;public;1;14;/**  * Closes the iteration. This method defines the end of the iterative  * program part that will be fed back to the start of the iteration.  *  * <p>A common usage pattern for streaming iterations is to use output  * splitting to send a part of the closing data stream to the head. Refer to  * {@link DataStream#split(org.apache.flink.streaming.api.collector.selector.OutputSelector)}  * for more information.  *  * @param feedbackStream  *            {@link DataStream} that will be used as input to the iteration  *            head.  *  * @return The feedback stream.  */ ;/**  * Closes the iteration. This method defines the end of the iterative  * program part that will be fed back to the start of the iteration.  *  * <p>A common usage pattern for streaming iterations is to use output  * splitting to send a part of the closing data stream to the head. Refer to  * {@link DataStream#split(org.apache.flink.streaming.api.collector.selector.OutputSelector)}  * for more information.  *  * @param feedbackStream  *            {@link DataStream} that will be used as input to the iteration  *            head.  *  * @return The feedback stream.  */ @SuppressWarnings({ "unchecked", "rawtypes" }) public DataStream<T> closeWith(DataStream<T> feedbackStream) {     Collection<StreamTransformation<?>> predecessors = feedbackStream.getTransformation().getTransitivePredecessors().     if (!predecessors.contains(this.transformation)) {         throw new UnsupportedOperationException("Cannot close an iteration with a feedback DataStream that does not originate from said iteration.").     }     ((FeedbackTransformation) getTransformation()).addFeedbackEdge(feedbackStream.getTransformation()).     return feedbackStream. }
true;public;1;3;/**  * Changes the feedback type of the iteration and allows the user to apply  * co-transformations on the input and feedback stream, as in a  * {@link ConnectedStreams}.  *  * <p>For type safety the user needs to define the feedback type  *  * @param feedbackTypeClass  *            Class of the elements in the feedback stream.  * @return A {@link ConnectedIterativeStreams}.  */ ;/**  * Changes the feedback type of the iteration and allows the user to apply  * co-transformations on the input and feedback stream, as in a  * {@link ConnectedStreams}.  *  * <p>For type safety the user needs to define the feedback type  *  * @param feedbackTypeClass  *            Class of the elements in the feedback stream.  * @return A {@link ConnectedIterativeStreams}.  */ public <F> ConnectedIterativeStreams<T, F> withFeedbackType(Class<F> feedbackTypeClass) {     return withFeedbackType(TypeInformation.of(feedbackTypeClass)). }
true;public;1;3;/**  * Changes the feedback type of the iteration and allows the user to apply  * co-transformations on the input and feedback stream, as in a  * {@link ConnectedStreams}.  *  * <p>For type safety the user needs to define the feedback type  *  * @param feedbackTypeHint  *            Class of the elements in the feedback stream.  * @return A {@link ConnectedIterativeStreams}.  */ ;/**  * Changes the feedback type of the iteration and allows the user to apply  * co-transformations on the input and feedback stream, as in a  * {@link ConnectedStreams}.  *  * <p>For type safety the user needs to define the feedback type  *  * @param feedbackTypeHint  *            Class of the elements in the feedback stream.  * @return A {@link ConnectedIterativeStreams}.  */ public <F> ConnectedIterativeStreams<T, F> withFeedbackType(TypeHint<F> feedbackTypeHint) {     return withFeedbackType(TypeInformation.of(feedbackTypeHint)). }
true;public;1;3;/**  * Changes the feedback type of the iteration and allows the user to apply  * co-transformations on the input and feedback stream, as in a  * {@link ConnectedStreams}.  *  * <p>For type safety the user needs to define the feedback type  *  * @param feedbackType  *            The type information of the feedback stream.  * @return A {@link ConnectedIterativeStreams}.  */ ;/**  * Changes the feedback type of the iteration and allows the user to apply  * co-transformations on the input and feedback stream, as in a  * {@link ConnectedStreams}.  *  * <p>For type safety the user needs to define the feedback type  *  * @param feedbackType  *            The type information of the feedback stream.  * @return A {@link ConnectedIterativeStreams}.  */ public <F> ConnectedIterativeStreams<T, F> withFeedbackType(TypeInformation<F> feedbackType) {     return new ConnectedIterativeStreams<>(originalInput, feedbackType, maxWaitTime). }
true;public;1;13;/**  * Closes the iteration. This method defines the end of the iterative  * program part that will be fed back to the start of the iteration as  * the second input in the {@link ConnectedStreams}.  *  * @param feedbackStream  *            {@link DataStream} that will be used as second input to  *            the iteration head.  * @return The feedback stream.  */ ;/**  * Closes the iteration. This method defines the end of the iterative  * program part that will be fed back to the start of the iteration as  * the second input in the {@link ConnectedStreams}.  *  * @param feedbackStream  *            {@link DataStream} that will be used as second input to  *            the iteration head.  * @return The feedback stream.  */ public DataStream<F> closeWith(DataStream<F> feedbackStream) {     Collection<StreamTransformation<?>> predecessors = feedbackStream.getTransformation().getTransitivePredecessors().     if (!predecessors.contains(this.coFeedbackTransformation)) {         throw new UnsupportedOperationException("Cannot close an iteration with a feedback DataStream that does not originate from said iteration.").     }     coFeedbackTransformation.addFeedbackEdge(feedbackStream.getTransformation()).     return feedbackStream. }
false;public;2;4;;@Override public ConnectedStreams<I, F> keyBy(int[] keyPositions1, int[] keyPositions2) {     throw groupingException. }
false;public;2;4;;@Override public ConnectedStreams<I, F> keyBy(String field1, String field2) {     throw groupingException. }
false;public;2;4;;@Override public ConnectedStreams<I, F> keyBy(String[] fields1, String[] fields2) {     throw groupingException. }
false;public;2;4;;@Override public ConnectedStreams<I, F> keyBy(KeySelector<I, ?> keySelector1, KeySelector<F, ?> keySelector2) {     throw groupingException. }
false;public;3;4;;@Override public <KEY> ConnectedStreams<I, F> keyBy(KeySelector<I, KEY> keySelector1, KeySelector<F, KEY> keySelector2, TypeInformation<KEY> keyType) {     throw groupingException. }
