commented;modifiers;parameterAmount;loc;comment;code
false;public,static;3;23;;@SuppressWarnings("unchecked") public static <T> void setOutputType(Function userFunction, TypeInformation<T> outTypeInfo, ExecutionConfig executionConfig) {     Preconditions.checkNotNull(outTypeInfo).     Preconditions.checkNotNull(executionConfig).     while (true) {         if (trySetOutputType(userFunction, outTypeInfo, executionConfig)) {             break.         }         // inspect if the user function is wrapped, then unwrap and try again if we can snapshot the inner function         if (userFunction instanceof WrappingFunction) {             userFunction = ((WrappingFunction<?>) userFunction).getWrappedFunction().         } else {             break.         }     } }
false;private,static;3;15;;@SuppressWarnings("unchecked") private static <T> boolean trySetOutputType(Function userFunction, TypeInformation<T> outTypeInfo, ExecutionConfig executionConfig) {     Preconditions.checkNotNull(outTypeInfo).     Preconditions.checkNotNull(executionConfig).     if (OutputTypeConfigurable.class.isAssignableFrom(userFunction.getClass())) {         ((OutputTypeConfigurable<T>) userFunction).setOutputType(outTypeInfo, executionConfig).         return true.     }     return false. }
false;public,static;3;22;;public static void snapshotFunctionState(StateSnapshotContext context, OperatorStateBackend backend, Function userFunction) throws Exception {     Preconditions.checkNotNull(context).     Preconditions.checkNotNull(backend).     while (true) {         if (trySnapshotFunctionState(context, backend, userFunction)) {             break.         }         // inspect if the user function is wrapped, then unwrap and try again if we can snapshot the inner function         if (userFunction instanceof WrappingFunction) {             userFunction = ((WrappingFunction<?>) userFunction).getWrappedFunction().         } else {             break.         }     } }
false;private,static;3;39;;private static boolean trySnapshotFunctionState(StateSnapshotContext context, OperatorStateBackend backend, Function userFunction) throws Exception {     if (userFunction instanceof CheckpointedFunction) {         ((CheckpointedFunction) userFunction).snapshotState(context).         return true.     }     if (userFunction instanceof ListCheckpointed) {         @SuppressWarnings("unchecked")         List<Serializable> partitionableState = ((ListCheckpointed<Serializable>) userFunction).snapshotState(context.getCheckpointId(), context.getCheckpointTimestamp()).         ListState<Serializable> listState = backend.getSerializableListState(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME).         listState.clear().         if (null != partitionableState) {             try {                 for (Serializable statePartition : partitionableState) {                     listState.add(statePartition).                 }             } catch (Exception e) {                 listState.clear().                 throw new Exception("Could not write partitionable state to operator " + "state backend.", e).             }         }         return true.     }     return false. }
false;public,static;2;20;;public static void restoreFunctionState(StateInitializationContext context, Function userFunction) throws Exception {     Preconditions.checkNotNull(context).     while (true) {         if (tryRestoreFunction(context, userFunction)) {             break.         }         // inspect if the user function is wrapped, then unwrap and try again if we can restore the inner function         if (userFunction instanceof WrappingFunction) {             userFunction = ((WrappingFunction<?>) userFunction).getWrappedFunction().         } else {             break.         }     } }
false;private,static;2;35;;private static boolean tryRestoreFunction(StateInitializationContext context, Function userFunction) throws Exception {     if (userFunction instanceof CheckpointedFunction) {         ((CheckpointedFunction) userFunction).initializeState(context).         return true.     }     if (context.isRestored() && userFunction instanceof ListCheckpointed) {         @SuppressWarnings("unchecked")         ListCheckpointed<Serializable> listCheckpointedFun = (ListCheckpointed<Serializable>) userFunction.         ListState<Serializable> listState = context.getOperatorStateStore().getSerializableListState(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME).         List<Serializable> list = new ArrayList<>().         for (Serializable serializable : listState.get()) {             list.add(serializable).         }         try {             listCheckpointedFun.restoreState(list).         } catch (Exception e) {             throw new Exception("Failed to restore state to function: " + e.getMessage(), e).         }         return true.     }     return false. }
