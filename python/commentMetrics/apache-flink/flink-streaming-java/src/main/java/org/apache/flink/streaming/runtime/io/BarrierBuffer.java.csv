commented;modifiers;parameterAmount;loc;comment;code
false;public;0;55;;// ------------------------------------------------------------------------ // Buffer and barrier handling // ------------------------------------------------------------------------ @Override public BufferOrEvent getNextNonBlocked() throws Exception {     while (true) {         // process buffered BufferOrEvents before grabbing new ones         Optional<BufferOrEvent> next.         if (currentBuffered == null) {             next = inputGate.getNextBufferOrEvent().         } else {             next = Optional.ofNullable(currentBuffered.getNext()).             if (!next.isPresent()) {                 completeBufferedSequence().                 return getNextNonBlocked().             }         }         if (!next.isPresent()) {             if (!endOfStream) {                 // end of input stream. stream continues with the buffered data                 endOfStream = true.                 releaseBlocksAndResetBarriers().                 return getNextNonBlocked().             } else {                 // final end of both input and buffered data                 return null.             }         }         BufferOrEvent bufferOrEvent = next.get().         if (isBlocked(bufferOrEvent.getChannelIndex())) {             // if the channel is blocked, we just store the BufferOrEvent             bufferBlocker.add(bufferOrEvent).             checkSizeLimit().         } else if (bufferOrEvent.isBuffer()) {             return bufferOrEvent.         } else if (bufferOrEvent.getEvent().getClass() == CheckpointBarrier.class) {             if (!endOfStream) {                 // process barriers only if there is a chance of the checkpoint completing                 processBarrier((CheckpointBarrier) bufferOrEvent.getEvent(), bufferOrEvent.getChannelIndex()).             }         } else if (bufferOrEvent.getEvent().getClass() == CancelCheckpointMarker.class) {             processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent()).         } else {             if (bufferOrEvent.getEvent().getClass() == EndOfPartitionEvent.class) {                 processEndOfPartition().             }             return bufferOrEvent.         }     } }
false;private;0;10;;private void completeBufferedSequence() throws IOException {     LOG.debug("{}: Finished feeding back buffered data.", inputGate.getOwningTaskName()).     currentBuffered.cleanup().     currentBuffered = queuedBuffered.pollFirst().     if (currentBuffered != null) {         currentBuffered.open().         numQueuedBytes -= currentBuffered.size().     } }
false;private;2;69;;private void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws Exception {     final long barrierId = receivedBarrier.getId().     // fast path for single channel cases     if (totalNumberOfInputChannels == 1) {         if (barrierId > currentCheckpointId) {             // new checkpoint             currentCheckpointId = barrierId.             notifyCheckpoint(receivedBarrier).         }         return.     }     if (numBarriersReceived > 0) {         if (barrierId == currentCheckpointId) {             // regular case             onBarrier(channelIndex).         } else if (barrierId > currentCheckpointId) {             // we did not complete the current checkpoint, another started before             LOG.warn("{}: Received checkpoint barrier for checkpoint {} before completing current checkpoint {}. " + "Skipping current checkpoint.", inputGate.getOwningTaskName(), barrierId, currentCheckpointId).             // let the task know we are not completing this             notifyAbort(currentCheckpointId, new CheckpointDeclineSubsumedException(barrierId)).             // abort the current checkpoint             releaseBlocksAndResetBarriers().             // begin a the new checkpoint             beginNewAlignment(barrierId, channelIndex).         } else {             // ignore trailing barrier from an earlier checkpoint (obsolete now)             return.         }     } else if (barrierId > currentCheckpointId) {         // first barrier of a new checkpoint         beginNewAlignment(barrierId, channelIndex).     } else {         // this barrier is from an old subsumed checkpoint         return.     }     // this can only happen on a non canceled checkpoint     if (numBarriersReceived + numClosedChannels == totalNumberOfInputChannels) {         // actually trigger checkpoint         if (LOG.isDebugEnabled()) {             LOG.debug("{}: Received all barriers, triggering checkpoint {} at {}.", inputGate.getOwningTaskName(), receivedBarrier.getId(), receivedBarrier.getTimestamp()).         }         releaseBlocksAndResetBarriers().         notifyCheckpoint(receivedBarrier).     } }
false;private;1;76;;private void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {     final long barrierId = cancelBarrier.getCheckpointId().     // fast path for single channel cases     if (totalNumberOfInputChannels == 1) {         if (barrierId > currentCheckpointId) {             // new checkpoint             currentCheckpointId = barrierId.             notifyAbortOnCancellationBarrier(barrierId).         }         return.     }     if (numBarriersReceived > 0) {         if (barrierId == currentCheckpointId) {             // cancel this alignment             if (LOG.isDebugEnabled()) {                 LOG.debug("{}: Checkpoint {} canceled, aborting alignment.", inputGate.getOwningTaskName(), barrierId).             }             releaseBlocksAndResetBarriers().             notifyAbortOnCancellationBarrier(barrierId).         } else if (barrierId > currentCheckpointId) {             // we canceled the next which also cancels the current             LOG.warn("{}: Received cancellation barrier for checkpoint {} before completing current checkpoint {}. " + "Skipping current checkpoint.", inputGate.getOwningTaskName(), barrierId, currentCheckpointId).             // this stops the current alignment             releaseBlocksAndResetBarriers().             // the next checkpoint starts as canceled             currentCheckpointId = barrierId.             startOfAlignmentTimestamp = 0L.             latestAlignmentDurationNanos = 0L.             notifyAbort(currentCheckpointId, new CheckpointDeclineSubsumedException(barrierId)).             notifyAbortOnCancellationBarrier(barrierId).         }     // else: ignore trailing (cancellation) barrier from an earlier checkpoint (obsolete now)     } else if (barrierId > currentCheckpointId) {         // first barrier of a new checkpoint is directly a cancellation         // by setting the currentCheckpointId to this checkpoint while keeping the numBarriers         // at zero means that no checkpoint barrier can start a new alignment         currentCheckpointId = barrierId.         startOfAlignmentTimestamp = 0L.         latestAlignmentDurationNanos = 0L.         if (LOG.isDebugEnabled()) {             LOG.debug("{}: Checkpoint {} canceled, skipping alignment.", inputGate.getOwningTaskName(), barrierId).         }         notifyAbortOnCancellationBarrier(barrierId).     } // else: trailing barrier from either // - a previous (subsumed) checkpoint // - the current checkpoint if it was already canceled }
false;private;0;11;;private void processEndOfPartition() throws Exception {     numClosedChannels++.     if (numBarriersReceived > 0) {         // let the task know we skip a checkpoint         notifyAbort(currentCheckpointId, new InputEndOfStreamException()).         // no chance to complete this checkpoint         releaseBlocksAndResetBarriers().     } }
false;private;1;17;;private void notifyCheckpoint(CheckpointBarrier checkpointBarrier) throws Exception {     if (toNotifyOnCheckpoint != null) {         CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointBarrier.getId(), checkpointBarrier.getTimestamp()).         long bytesBuffered = currentBuffered != null ? currentBuffered.size() : 0L.         CheckpointMetrics checkpointMetrics = new CheckpointMetrics().setBytesBufferedInAlignment(bytesBuffered).setAlignmentDurationNanos(latestAlignmentDurationNanos).         toNotifyOnCheckpoint.triggerCheckpointOnBarrier(checkpointMetaData, checkpointBarrier.getCheckpointOptions(), checkpointMetrics).     } }
false;private;1;3;;private void notifyAbortOnCancellationBarrier(long checkpointId) throws Exception {     notifyAbort(checkpointId, new CheckpointDeclineOnCancellationBarrierException()). }
false;private;2;5;;private void notifyAbort(long checkpointId, CheckpointDeclineException cause) throws Exception {     if (toNotifyOnCheckpoint != null) {         toNotifyOnCheckpoint.abortCheckpointOnBarrier(checkpointId, cause).     } }
false;private;0;12;;private void checkSizeLimit() throws Exception {     if (maxBufferedBytes > 0 && (numQueuedBytes + bufferBlocker.getBytesBlocked()) > maxBufferedBytes) {         // exceeded our limit - abort this checkpoint         LOG.info("{}: Checkpoint {} aborted because alignment volume limit ({} bytes) exceeded.", inputGate.getOwningTaskName(), currentCheckpointId, maxBufferedBytes).         releaseBlocksAndResetBarriers().         notifyAbort(currentCheckpointId, new AlignmentLimitExceededException(maxBufferedBytes)).     } }
false;public;1;9;;@Override public void registerCheckpointEventHandler(AbstractInvokable toNotifyOnCheckpoint) {     if (this.toNotifyOnCheckpoint == null) {         this.toNotifyOnCheckpoint = toNotifyOnCheckpoint.     } else {         throw new IllegalStateException("BarrierBuffer already has a registered checkpoint notifyee").     } }
false;public;0;4;;@Override public boolean isEmpty() {     return currentBuffered == null. }
false;public;0;12;;@Override public void cleanup() throws IOException {     bufferBlocker.close().     if (currentBuffered != null) {         currentBuffered.cleanup().     }     for (BufferOrEventSequence seq : queuedBuffered) {         seq.cleanup().     }     queuedBuffered.clear().     numQueuedBytes = 0L. }
false;private;2;12;;private void beginNewAlignment(long checkpointId, int channelIndex) throws IOException {     currentCheckpointId = checkpointId.     onBarrier(channelIndex).     startOfAlignmentTimestamp = System.nanoTime().     if (LOG.isDebugEnabled()) {         LOG.debug("{}: Starting stream alignment for checkpoint {}.", inputGate.getOwningTaskName(), checkpointId).     } }
true;private;1;3;/**  * Checks whether the channel with the given index is blocked.  *  * @param channelIndex The channel index to check.  * @return True if the channel is blocked, false if not.  */ ;/**  * Checks whether the channel with the given index is blocked.  *  * @param channelIndex The channel index to check.  * @return True if the channel is blocked, false if not.  */ private boolean isBlocked(int channelIndex) {     return blockedChannels[channelIndex]. }
true;private;1;16;/**  * Blocks the given channel index, from which a barrier has been received.  *  * @param channelIndex The channel index to block.  */ ;/**  * Blocks the given channel index, from which a barrier has been received.  *  * @param channelIndex The channel index to block.  */ private void onBarrier(int channelIndex) throws IOException {     if (!blockedChannels[channelIndex]) {         blockedChannels[channelIndex] = true.         numBarriersReceived++.         if (LOG.isDebugEnabled()) {             LOG.debug("{}: Received barrier from channel {}.", inputGate.getOwningTaskName(), channelIndex).         }     } else {         throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex).     } }
true;private;0;46;/**  * Releases the blocks on all channels and resets the barrier count.  * Makes sure the just written data is the next to be consumed.  */ ;/**  * Releases the blocks on all channels and resets the barrier count.  * Makes sure the just written data is the next to be consumed.  */ private void releaseBlocksAndResetBarriers() throws IOException {     LOG.debug("{}: End of stream alignment, feeding buffered data back.", inputGate.getOwningTaskName()).     for (int i = 0. i < blockedChannels.length. i++) {         blockedChannels[i] = false.     }     if (currentBuffered == null) {         // common case: no more buffered data         currentBuffered = bufferBlocker.rollOverReusingResources().         if (currentBuffered != null) {             currentBuffered.open().         }     } else {         // uncommon case: buffered data pending         // push back the pending data, if we have any         LOG.debug("{}: Checkpoint skipped via buffered data:" + "Pushing back current alignment buffers and feeding back new alignment data first.", inputGate.getOwningTaskName()).         // since we did not fully drain the previous sequence, we need to allocate a new buffer for this one         BufferOrEventSequence bufferedNow = bufferBlocker.rollOverWithoutReusingResources().         if (bufferedNow != null) {             bufferedNow.open().             queuedBuffered.addFirst(currentBuffered).             numQueuedBytes += currentBuffered.size().             currentBuffered = bufferedNow.         }     }     if (LOG.isDebugEnabled()) {         LOG.debug("{}: Size of buffered data: {} bytes", inputGate.getOwningTaskName(), currentBuffered == null ? 0L : currentBuffered.size()).     }     // the next barrier that comes must assume it is the first     numBarriersReceived = 0.     if (startOfAlignmentTimestamp > 0) {         latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp.         startOfAlignmentTimestamp = 0.     } }
true;public;0;3;/**  * Gets the ID defining the current pending, or just completed, checkpoint.  *  * @return The ID of the pending of completed checkpoint.  */ ;// ------------------------------------------------------------------------ // Properties // ------------------------------------------------------------------------ /**  * Gets the ID defining the current pending, or just completed, checkpoint.  *  * @return The ID of the pending of completed checkpoint.  */ public long getCurrentCheckpointId() {     return this.currentCheckpointId. }
false;public;0;9;;@Override public long getAlignmentDurationNanos() {     long start = this.startOfAlignmentTimestamp.     if (start <= 0) {         return latestAlignmentDurationNanos.     } else {         return System.nanoTime() - start.     } }
false;public;0;8;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ @Override public String toString() {     return String.format("%s: last checkpoint: %d, current barriers: %d, closed channels: %d", inputGate.getOwningTaskName(), currentCheckpointId, numBarriersReceived, numClosedChannels). }
