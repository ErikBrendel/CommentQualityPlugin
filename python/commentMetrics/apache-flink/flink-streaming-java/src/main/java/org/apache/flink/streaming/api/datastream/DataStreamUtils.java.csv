commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;39;/**  * Returns an iterator to iterate over the elements of the DataStream.  * @return The iterator  */ ;/**  * Returns an iterator to iterate over the elements of the DataStream.  * @return The iterator  */ public static <OUT> Iterator<OUT> collect(DataStream<OUT> stream) throws IOException {     TypeSerializer<OUT> serializer = stream.getType().createSerializer(stream.getExecutionEnvironment().getConfig()).     SocketStreamIterator<OUT> iter = new SocketStreamIterator<OUT>(serializer).     // Find out what IP of us should be given to CollectSink, that it will be able to connect to     StreamExecutionEnvironment env = stream.getExecutionEnvironment().     InetAddress clientAddress.     if (env instanceof RemoteStreamEnvironment) {         String host = ((RemoteStreamEnvironment) env).getHost().         int port = ((RemoteStreamEnvironment) env).getPort().         try {             clientAddress = ConnectionUtils.findConnectingAddress(new InetSocketAddress(host, port), 2000, 400).         } catch (Exception e) {             throw new IOException("Could not determine an suitable network address to " + "receive back data from the streaming program.", e).         }     } else if (env instanceof LocalStreamEnvironment) {         clientAddress = InetAddress.getLoopbackAddress().     } else {         try {             clientAddress = InetAddress.getLocalHost().         } catch (UnknownHostException e) {             throw new IOException("Could not determine this machines own local address to " + "receive back data from the streaming program.", e).         }     }     DataStreamSink<OUT> sink = stream.addSink(new CollectSink<OUT>(clientAddress, iter.getPort(), serializer)).     // It would not work if multiple instances would connect to the same port     sink.setParallelism(1).     (new CallExecute(env, iter)).start().     return iter. }
true;public,static;2;9;/**  * Reinterprets the given {@link DataStream} as a {@link KeyedStream}, which extracts keys with the given  * {@link KeySelector}.  *  * <p>IMPORTANT: For every partition of the base stream, the keys of events in the base stream must be  * partitioned exactly in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}.  *  * @param stream      The data stream to reinterpret. For every partition, this stream must be partitioned exactly  *                    in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}.  * @param keySelector Function that defines how keys are extracted from the data stream.  * @param <T>         Type of events in the data stream.  * @param <K>         Type of the extracted keys.  * @return The reinterpretation of the {@link DataStream} as a {@link KeyedStream}.  */ ;/**  * Reinterprets the given {@link DataStream} as a {@link KeyedStream}, which extracts keys with the given  * {@link KeySelector}.  *  * <p>IMPORTANT: For every partition of the base stream, the keys of events in the base stream must be  * partitioned exactly in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}.  *  * @param stream      The data stream to reinterpret. For every partition, this stream must be partitioned exactly  *                    in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}.  * @param keySelector Function that defines how keys are extracted from the data stream.  * @param <T>         Type of events in the data stream.  * @param <K>         Type of the extracted keys.  * @return The reinterpretation of the {@link DataStream} as a {@link KeyedStream}.  */ public static <T, K> KeyedStream<T, K> reinterpretAsKeyedStream(DataStream<T> stream, KeySelector<T, K> keySelector) {     return reinterpretAsKeyedStream(stream, keySelector, TypeExtractor.getKeySelectorTypes(keySelector, stream.getType())). }
true;public,static;3;15;/**  * Reinterprets the given {@link DataStream} as a {@link KeyedStream}, which extracts keys with the given  * {@link KeySelector}.  *  * <p>IMPORTANT: For every partition of the base stream, the keys of events in the base stream must be  * partitioned exactly in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}.  *  * @param stream      The data stream to reinterpret. For every partition, this stream must be partitioned exactly  *                    in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}.  * @param keySelector Function that defines how keys are extracted from the data stream.  * @param typeInfo    Explicit type information about the key type.  * @param <T>         Type of events in the data stream.  * @param <K>         Type of the extracted keys.  * @return The reinterpretation of the {@link DataStream} as a {@link KeyedStream}.  */ ;/**  * Reinterprets the given {@link DataStream} as a {@link KeyedStream}, which extracts keys with the given  * {@link KeySelector}.  *  * <p>IMPORTANT: For every partition of the base stream, the keys of events in the base stream must be  * partitioned exactly in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}.  *  * @param stream      The data stream to reinterpret. For every partition, this stream must be partitioned exactly  *                    in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}.  * @param keySelector Function that defines how keys are extracted from the data stream.  * @param typeInfo    Explicit type information about the key type.  * @param <T>         Type of events in the data stream.  * @param <K>         Type of the extracted keys.  * @return The reinterpretation of the {@link DataStream} as a {@link KeyedStream}.  */ public static <T, K> KeyedStream<T, K> reinterpretAsKeyedStream(DataStream<T> stream, KeySelector<T, K> keySelector, TypeInformation<K> typeInfo) {     PartitionTransformation<T> partitionTransformation = new PartitionTransformation<>(stream.getTransformation(), new ForwardPartitioner<>()).     return new KeyedStream<>(stream, partitionTransformation, keySelector, typeInfo). }
false;public;0;9;;@Override public void run() {     try {         toTrigger.execute().     } catch (Throwable t) {         toNotify.notifyOfError(t).     } }
