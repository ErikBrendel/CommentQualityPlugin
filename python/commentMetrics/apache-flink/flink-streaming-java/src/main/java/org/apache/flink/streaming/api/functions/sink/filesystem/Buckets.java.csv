commented;modifiers;parameterAmount;loc;comment;code
true;;2;8;/**  * Initializes the state after recovery from a failure.  *  * <p>During this process:  * <ol>  *     <li>we set the initial value for part counter to the maximum value used before across all tasks and buckets.  *     This guarantees that we do not overwrite valid data,</li>  *     <li>we commit any pending files for previous checkpoints (previous to the last successful one from which we restore),</li>  *     <li>we resume writing to the previous in-progress file of each bucket, and</li>  *     <li>if we receive multiple states for the same bucket, we merge them.</li>  * </ol>  * @param bucketStates the state holding recovered state about active buckets.  * @param partCounterState the state holding the max previously used part counters.  * @throws Exception if anything goes wrong during retrieving the state or restoring/committing of any  * in-progress/pending part files  */ ;/**  * Initializes the state after recovery from a failure.  *  * <p>During this process:  * <ol>  *     <li>we set the initial value for part counter to the maximum value used before across all tasks and buckets.  *     This guarantees that we do not overwrite valid data,</li>  *     <li>we commit any pending files for previous checkpoints (previous to the last successful one from which we restore),</li>  *     <li>we resume writing to the previous in-progress file of each bucket, and</li>  *     <li>if we receive multiple states for the same bucket, we merge them.</li>  * </ol>  * @param bucketStates the state holding recovered state about active buckets.  * @param partCounterState the state holding the max previously used part counters.  * @throws Exception if anything goes wrong during retrieving the state or restoring/committing of any  * in-progress/pending part files  */ void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception {     initializePartCounter(partCounterState).     LOG.info("Subtask {} initializing its state (max part counter={}).", subtaskIndex, maxPartCounter).     initializeActiveBuckets(bucketStates). }
false;private;1;7;;private void initializePartCounter(final ListState<Long> partCounterState) throws Exception {     long maxCounter = 0L.     for (long partCounter : partCounterState.get()) {         maxCounter = Math.max(partCounter, maxCounter).     }     maxPartCounter = maxCounter. }
false;private;1;8;;private void initializeActiveBuckets(final ListState<byte[]> bucketStates) throws Exception {     for (byte[] serializedRecoveredState : bucketStates.get()) {         final BucketState<BucketID> recoveredState = SimpleVersionedSerialization.readVersionAndDeSerialize(bucketStateSerializer, serializedRecoveredState).         handleRestoredBucketState(recoveredState).     } }
false;private;1;19;;private void handleRestoredBucketState(final BucketState<BucketID> recoveredState) throws Exception {     final BucketID bucketId = recoveredState.getBucketId().     if (LOG.isDebugEnabled()) {         LOG.debug("Subtask {} restoring: {}", subtaskIndex, recoveredState).     }     final Bucket<IN, BucketID> restoredBucket = bucketFactory.restoreBucket(fsWriter, subtaskIndex, maxPartCounter, partFileWriterFactory, rollingPolicy, recoveredState).     updateActiveBucketId(bucketId, restoredBucket). }
false;private;2;12;;private void updateActiveBucketId(final BucketID bucketId, final Bucket<IN, BucketID> restoredBucket) throws IOException {     if (!restoredBucket.isActive()) {         return.     }     final Bucket<IN, BucketID> bucket = activeBuckets.get(bucketId).     if (bucket != null) {         bucket.merge(restoredBucket).     } else {         activeBuckets.put(bucketId, restoredBucket).     } }
false;;1;17;;void commitUpToCheckpoint(final long checkpointId) throws IOException {     final Iterator<Map.Entry<BucketID, Bucket<IN, BucketID>>> activeBucketIt = activeBuckets.entrySet().iterator().     LOG.info("Subtask {} received completion notification for checkpoint with id={}.", subtaskIndex, checkpointId).     while (activeBucketIt.hasNext()) {         final Bucket<IN, BucketID> bucket = activeBucketIt.next().getValue().         bucket.onSuccessfulCompletionOfCheckpoint(checkpointId).         if (!bucket.isActive()) {             // We've dealt with all the pending files and the writer for this bucket is not currently open.             // Therefore this bucket is currently inactive and we can remove it from our state.             activeBucketIt.remove().         }     } }
false;;3;18;;void snapshotState(final long checkpointId, final ListState<byte[]> bucketStatesContainer, final ListState<Long> partCounterStateContainer) throws Exception {     Preconditions.checkState(fsWriter != null && bucketStateSerializer != null, "sink has not been initialized").     LOG.info("Subtask {} checkpointing for checkpoint with id={} (max part counter={}).", subtaskIndex, checkpointId, maxPartCounter).     bucketStatesContainer.clear().     partCounterStateContainer.clear().     snapshotActiveBuckets(checkpointId, bucketStatesContainer).     partCounterStateContainer.add(maxPartCounter). }
false;private;2;17;;private void snapshotActiveBuckets(final long checkpointId, final ListState<byte[]> bucketStatesContainer) throws Exception {     for (Bucket<IN, BucketID> bucket : activeBuckets.values()) {         final BucketState<BucketID> bucketState = bucket.onReceptionOfCheckpoint(checkpointId).         final byte[] serializedBucketState = SimpleVersionedSerialization.writeVersionAndSerialize(bucketStateSerializer, bucketState).         bucketStatesContainer.add(serializedBucketState).         if (LOG.isDebugEnabled()) {             LOG.debug("Subtask {} checkpointing: {}", subtaskIndex, bucketState).         }     } }
false;;2;20;;Bucket<IN, BucketID> onElement(final IN value, final SinkFunction.Context context) throws Exception {     final long currentProcessingTime = context.currentProcessingTime().     // setting the values in the bucketer context     bucketerContext.update(context.timestamp(), context.currentWatermark(), currentProcessingTime).     final BucketID bucketId = bucketAssigner.getBucketId(value, bucketerContext).     final Bucket<IN, BucketID> bucket = getOrCreateBucketForBucketId(bucketId).     bucket.write(value, currentProcessingTime).     // we update the global max counter here because as buckets become inactive and     // get removed from the list of active buckets, at the time when we want to create     // another part file for the bucket, if we start from 0 we may overwrite previous parts.     this.maxPartCounter = Math.max(maxPartCounter, bucket.getPartCounter()).     return bucket. }
false;private;1;16;;private Bucket<IN, BucketID> getOrCreateBucketForBucketId(final BucketID bucketId) throws IOException {     Bucket<IN, BucketID> bucket = activeBuckets.get(bucketId).     if (bucket == null) {         final Path bucketPath = assembleBucketPath(bucketId).         bucket = bucketFactory.getNewBucket(fsWriter, subtaskIndex, bucketId, bucketPath, maxPartCounter, partFileWriterFactory, rollingPolicy).         activeBuckets.put(bucketId, bucket).     }     return bucket. }
false;;1;5;;void onProcessingTime(long timestamp) throws Exception {     for (Bucket<IN, BucketID> bucket : activeBuckets.values()) {         bucket.onProcessingTime(timestamp).     } }
false;;0;5;;void close() {     if (activeBuckets != null) {         activeBuckets.values().forEach(Bucket::disposePartFile).     } }
false;private;1;7;;private Path assembleBucketPath(BucketID bucketId) {     final String child = bucketId.toString().     if ("".equals(child)) {         return basePath.     }     return new Path(basePath, child). }
false;;3;5;;void update(@Nullable Long elementTimestamp, long watermark, long processingTime) {     this.elementTimestamp = elementTimestamp.     this.currentWatermark = watermark.     this.currentProcessingTime = processingTime. }
false;public;0;4;;@Override public long currentProcessingTime() {     return currentProcessingTime. }
false;public;0;4;;@Override public long currentWatermark() {     return currentWatermark. }
false;public;0;5;;@Override @Nullable public Long timestamp() {     return elementTimestamp. }
false;public;0;4;;// --------------------------- Testing Methods ----------------------------- @VisibleForTesting public long getMaxPartCounter() {     return maxPartCounter. }
false;;0;4;;@VisibleForTesting Map<BucketID, Bucket<IN, BucketID>> getActiveBuckets() {     return activeBuckets. }
