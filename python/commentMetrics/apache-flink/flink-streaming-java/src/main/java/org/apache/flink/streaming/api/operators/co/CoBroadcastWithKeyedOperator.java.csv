commented;modifiers;parameterAmount;loc;comment;code
false;public;0;20;;@Override public void open() throws Exception {     super.open().     InternalTimerService<VoidNamespace> internalTimerService = getInternalTimerService("user-timers", VoidNamespaceSerializer.INSTANCE, this).     TimerService timerService = new SimpleTimerService(internalTimerService).     collector = new TimestampedCollector<>(output).     this.broadcastStates = new HashMap<>(broadcastStateDescriptors.size()).     for (MapStateDescriptor<?, ?> descriptor : broadcastStateDescriptors) {         broadcastStates.put(descriptor, getOperatorStateBackend().getBroadcastState(descriptor)).     }     rwContext = new ReadWriteContextImpl(getExecutionConfig(), getKeyedStateBackend(), userFunction, broadcastStates, timerService).     rContext = new ReadOnlyContextImpl(getExecutionConfig(), userFunction, broadcastStates, timerService).     onTimerContext = new OnTimerContextImpl(getExecutionConfig(), userFunction, broadcastStates, timerService). }
false;public;1;7;;@Override public void processElement1(StreamRecord<IN1> element) throws Exception {     collector.setTimestamp(element).     rContext.setElement(element).     userFunction.processElement(element.getValue(), rContext, collector).     rContext.setElement(null). }
false;public;1;7;;@Override public void processElement2(StreamRecord<IN2> element) throws Exception {     collector.setTimestamp(element).     rwContext.setElement(element).     userFunction.processBroadcastElement(element.getValue(), rwContext, collector).     rwContext.setElement(null). }
false;public;1;9;;@Override public void onEventTime(InternalTimer<KS, VoidNamespace> timer) throws Exception {     collector.setAbsoluteTimestamp(timer.getTimestamp()).     onTimerContext.timeDomain = TimeDomain.EVENT_TIME.     onTimerContext.timer = timer.     userFunction.onTimer(timer.getTimestamp(), onTimerContext, collector).     onTimerContext.timeDomain = null.     onTimerContext.timer = null. }
false;public;1;9;;@Override public void onProcessingTime(InternalTimer<KS, VoidNamespace> timer) throws Exception {     collector.eraseTimestamp().     onTimerContext.timeDomain = TimeDomain.PROCESSING_TIME.     onTimerContext.timer = timer.     userFunction.onTimer(timer.getTimestamp(), onTimerContext, collector).     onTimerContext.timeDomain = null.     onTimerContext.timer = null. }
false;;1;3;;void setElement(StreamRecord<IN2> e) {     this.element = e. }
false;public;0;5;;@Override public Long timestamp() {     checkState(element != null).     return element.getTimestamp(). }
false;public;1;13;;@Override public <K, V> BroadcastState<K, V> getBroadcastState(MapStateDescriptor<K, V> stateDescriptor) {     Preconditions.checkNotNull(stateDescriptor).     stateDescriptor.initializeSerializerUnlessSet(config).     BroadcastState<K, V> state = (BroadcastState<K, V>) states.get(stateDescriptor).     if (state == null) {         throw new IllegalArgumentException("The requested state does not exist. " + "Check for typos in your state descriptor, or specify the state descriptor " + "in the datastream.broadcast(...) call if you forgot to register it.").     }     return state. }
false;public;2;5;;@Override public <X> void output(OutputTag<X> outputTag, X value) {     checkArgument(outputTag != null, "OutputTag must not be null.").     output.collect(outputTag, new StreamRecord<>(value, element.getTimestamp())). }
false;public;0;4;;@Override public long currentProcessingTime() {     return timerService.currentProcessingTime(). }
false;public;0;4;;@Override public long currentWatermark() {     return timerService.currentWatermark(). }
false;public;2;11;;@Override public <VS, S extends State> void applyToKeyedState(final StateDescriptor<S, VS> stateDescriptor, final KeyedStateFunction<KS, S> function) throws Exception {     keyedStateBackend.applyToAllKeys(VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, Preconditions.checkNotNull(stateDescriptor), Preconditions.checkNotNull(function)). }
false;;1;3;;void setElement(StreamRecord<IN1> e) {     this.element = e. }
false;public;0;5;;@Override public Long timestamp() {     checkState(element != null).     return element.hasTimestamp() ? element.getTimestamp() : null. }
false;public;0;4;;@Override public TimerService timerService() {     return timerService. }
false;public;0;4;;@Override public long currentProcessingTime() {     return timerService.currentProcessingTime(). }
false;public;0;4;;@Override public long currentWatermark() {     return timerService.currentWatermark(). }
false;public;2;5;;@Override public <X> void output(OutputTag<X> outputTag, X value) {     checkArgument(outputTag != null, "OutputTag must not be null.").     output.collect(outputTag, new StreamRecord<>(value, element.getTimestamp())). }
false;public;1;13;;@Override public <K, V> ReadOnlyBroadcastState<K, V> getBroadcastState(MapStateDescriptor<K, V> stateDescriptor) {     Preconditions.checkNotNull(stateDescriptor).     stateDescriptor.initializeSerializerUnlessSet(config).     ReadOnlyBroadcastState<K, V> state = (ReadOnlyBroadcastState<K, V>) states.get(stateDescriptor).     if (state == null) {         throw new IllegalArgumentException("The requested state does not exist. " + "Check for typos in your state descriptor, or specify the state descriptor " + "in the datastream.broadcast(...) call if you forgot to register it.").     }     return state. }
false;public;0;5;;@Override @SuppressWarnings("unchecked") public KS getCurrentKey() {     return (KS) CoBroadcastWithKeyedOperator.this.getCurrentKey(). }
false;public;0;5;;@Override public Long timestamp() {     checkState(timer != null).     return timer.getTimestamp(). }
false;public;0;5;;@Override public TimeDomain timeDomain() {     checkState(timeDomain != null).     return timeDomain. }
false;public;0;4;;@Override public KS getCurrentKey() {     return timer.getKey(). }
false;public;0;4;;@Override public TimerService timerService() {     return timerService. }
false;public;0;4;;@Override public long currentProcessingTime() {     return timerService.currentProcessingTime(). }
false;public;0;4;;@Override public long currentWatermark() {     return timerService.currentWatermark(). }
false;public;2;5;;@Override public <X> void output(OutputTag<X> outputTag, X value) {     checkArgument(outputTag != null, "OutputTag must not be null.").     output.collect(outputTag, new StreamRecord<>(value, timer.getTimestamp())). }
false;public;1;13;;@Override public <K, V> ReadOnlyBroadcastState<K, V> getBroadcastState(MapStateDescriptor<K, V> stateDescriptor) {     Preconditions.checkNotNull(stateDescriptor).     stateDescriptor.initializeSerializerUnlessSet(config).     ReadOnlyBroadcastState<K, V> state = (ReadOnlyBroadcastState<K, V>) states.get(stateDescriptor).     if (state == null) {         throw new IllegalArgumentException("The requested state does not exist. " + "Check for typos in your state descriptor, or specify the state descriptor " + "in the datastream.broadcast(...) call if you forgot to register it.").     }     return state. }
