commented;modifiers;parameterAmount;loc;comment;code
false;public;0;109;;public boolean processInput() throws Exception {     if (isFinished) {         return false.     }     if (numRecordsIn == null) {         try {             numRecordsIn = ((OperatorMetricGroup) streamOperator.getMetricGroup()).getIOMetricGroup().getNumRecordsInCounter().         } catch (Exception e) {             LOG.warn("An exception occurred during the metrics setup.", e).             numRecordsIn = new SimpleCounter().         }     }     while (true) {         if (currentRecordDeserializer != null) {             DeserializationResult result.             if (currentChannel < numInputChannels1) {                 result = currentRecordDeserializer.getNextRecord(deserializationDelegate1).             } else {                 result = currentRecordDeserializer.getNextRecord(deserializationDelegate2).             }             if (result.isBufferConsumed()) {                 currentRecordDeserializer.getCurrentBuffer().recycleBuffer().                 currentRecordDeserializer = null.             }             if (result.isFullRecord()) {                 if (currentChannel < numInputChannels1) {                     StreamElement recordOrWatermark = deserializationDelegate1.getInstance().                     if (recordOrWatermark.isWatermark()) {                         statusWatermarkValve1.inputWatermark(recordOrWatermark.asWatermark(), currentChannel).                         continue.                     } else if (recordOrWatermark.isStreamStatus()) {                         statusWatermarkValve1.inputStreamStatus(recordOrWatermark.asStreamStatus(), currentChannel).                         continue.                     } else if (recordOrWatermark.isLatencyMarker()) {                         synchronized (lock) {                             streamOperator.processLatencyMarker1(recordOrWatermark.asLatencyMarker()).                         }                         continue.                     } else {                         StreamRecord<IN1> record = recordOrWatermark.asRecord().                         synchronized (lock) {                             numRecordsIn.inc().                             streamOperator.setKeyContextElement1(record).                             streamOperator.processElement1(record).                         }                         return true.                     }                 } else {                     StreamElement recordOrWatermark = deserializationDelegate2.getInstance().                     if (recordOrWatermark.isWatermark()) {                         statusWatermarkValve2.inputWatermark(recordOrWatermark.asWatermark(), currentChannel - numInputChannels1).                         continue.                     } else if (recordOrWatermark.isStreamStatus()) {                         statusWatermarkValve2.inputStreamStatus(recordOrWatermark.asStreamStatus(), currentChannel - numInputChannels1).                         continue.                     } else if (recordOrWatermark.isLatencyMarker()) {                         synchronized (lock) {                             streamOperator.processLatencyMarker2(recordOrWatermark.asLatencyMarker()).                         }                         continue.                     } else {                         StreamRecord<IN2> record = recordOrWatermark.asRecord().                         synchronized (lock) {                             numRecordsIn.inc().                             streamOperator.setKeyContextElement2(record).                             streamOperator.processElement2(record).                         }                         return true.                     }                 }             }         }         final BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked().         if (bufferOrEvent != null) {             if (bufferOrEvent.isBuffer()) {                 currentChannel = bufferOrEvent.getChannelIndex().                 currentRecordDeserializer = recordDeserializers[currentChannel].                 currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer()).             } else {                 // Event received                 final AbstractEvent event = bufferOrEvent.getEvent().                 if (event.getClass() != EndOfPartitionEvent.class) {                     throw new IOException("Unexpected event: " + event).                 }             }         } else {             isFinished = true.             if (!barrierHandler.isEmpty()) {                 throw new IllegalStateException("Trailing data in checkpoint barrier handler.").             }             return false.         }     } }
false;public;0;13;;public void cleanup() throws IOException {     // clear the buffers first. this part should not ever fail     for (RecordDeserializer<?> deserializer : recordDeserializers) {         Buffer buffer = deserializer.getCurrentBuffer().         if (buffer != null && !buffer.isRecycled()) {             buffer.recycleBuffer().         }         deserializer.clear().     }     // cleanup the barrier handler resources     barrierHandler.cleanup(). }
false;public;1;11;;@Override public void handleWatermark(Watermark watermark) {     try {         synchronized (lock) {             input1WatermarkGauge.setCurrentWatermark(watermark.getTimestamp()).             operator.processWatermark1(watermark).         }     } catch (Exception e) {         throw new RuntimeException("Exception occurred while processing valve output watermark: ", e).     } }
false;public;1;21;;@Override public void handleStreamStatus(StreamStatus streamStatus) {     try {         synchronized (lock) {             firstStatus = streamStatus.             // check if we need to toggle the task's stream status             if (!streamStatus.equals(streamStatusMaintainer.getStreamStatus())) {                 if (streamStatus.isActive()) {                     // we're no longer idle if at least one input has become active                     streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE).                 } else if (secondStatus.isIdle()) {                     // we're idle once both inputs are idle                     streamStatusMaintainer.toggleStreamStatus(StreamStatus.IDLE).                 }             }         }     } catch (Exception e) {         throw new RuntimeException("Exception occurred while processing valve output stream status: ", e).     } }
false;public;1;11;;@Override public void handleWatermark(Watermark watermark) {     try {         synchronized (lock) {             input2WatermarkGauge.setCurrentWatermark(watermark.getTimestamp()).             operator.processWatermark2(watermark).         }     } catch (Exception e) {         throw new RuntimeException("Exception occurred while processing valve output watermark: ", e).     } }
false;public;1;21;;@Override public void handleStreamStatus(StreamStatus streamStatus) {     try {         synchronized (lock) {             secondStatus = streamStatus.             // check if we need to toggle the task's stream status             if (!streamStatus.equals(streamStatusMaintainer.getStreamStatus())) {                 if (streamStatus.isActive()) {                     // we're no longer idle if at least one input has become active                     streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE).                 } else if (firstStatus.isIdle()) {                     // we're idle once both inputs are idle                     streamStatusMaintainer.toggleStreamStatus(StreamStatus.IDLE).                 }             }         }     } catch (Exception e) {         throw new RuntimeException("Exception occurred while processing valve output stream status: ", e).     } }
