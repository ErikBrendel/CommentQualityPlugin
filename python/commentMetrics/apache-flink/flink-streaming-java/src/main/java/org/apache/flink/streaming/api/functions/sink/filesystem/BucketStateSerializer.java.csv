commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int getVersion() {     return 1. }
false;public;1;7;;@Override public byte[] serialize(BucketState<BucketID> state) throws IOException {     DataOutputSerializer out = new DataOutputSerializer(256).     out.writeInt(MAGIC_NUMBER).     serializeV1(state, out).     return out.getCopyOfBuffer(). }
false;public;2;11;;@Override public BucketState<BucketID> deserialize(int version, byte[] serialized) throws IOException {     switch(version) {         case 1:             DataInputDeserializer in = new DataInputDeserializer(serialized).             validateMagicNumber(in).             return deserializeV1(in).         default:             throw new IOException("Unrecognized version or corrupt state: " + version).     } }
false;;2;36;;@VisibleForTesting void serializeV1(BucketState<BucketID> state, DataOutputView out) throws IOException {     SimpleVersionedSerialization.writeVersionAndSerialize(bucketIdSerializer, state.getBucketId(), out).     out.writeUTF(state.getBucketPath().toString()).     out.writeLong(state.getInProgressFileCreationTime()).     // put the current open part file     if (state.hasInProgressResumableFile()) {         final RecoverableWriter.ResumeRecoverable resumable = state.getInProgressResumableFile().         out.writeBoolean(true).         SimpleVersionedSerialization.writeVersionAndSerialize(resumableSerializer, resumable, out).     } else {         out.writeBoolean(false).     }     // put the map of pending files per checkpoint     final Map<Long, List<RecoverableWriter.CommitRecoverable>> pendingCommitters = state.getCommittableFilesPerCheckpoint().     // manually keep the version here to safe some bytes     out.writeInt(commitableSerializer.getVersion()).     out.writeInt(pendingCommitters.size()).     for (Entry<Long, List<RecoverableWriter.CommitRecoverable>> resumablesForCheckpoint : pendingCommitters.entrySet()) {         List<RecoverableWriter.CommitRecoverable> resumables = resumablesForCheckpoint.getValue().         out.writeLong(resumablesForCheckpoint.getKey()).         out.writeInt(resumables.size()).         for (RecoverableWriter.CommitRecoverable resumable : resumables) {             byte[] serialized = commitableSerializer.serialize(resumable).             out.writeInt(serialized.length).             out.write(serialized).         }     } }
false;;1;36;;@VisibleForTesting BucketState<BucketID> deserializeV1(DataInputView in) throws IOException {     final BucketID bucketId = SimpleVersionedSerialization.readVersionAndDeSerialize(bucketIdSerializer, in).     final String bucketPathStr = in.readUTF().     final long creationTime = in.readLong().     // then get the current resumable stream     RecoverableWriter.ResumeRecoverable current = null.     if (in.readBoolean()) {         current = SimpleVersionedSerialization.readVersionAndDeSerialize(resumableSerializer, in).     }     final int committableVersion = in.readInt().     final int numCheckpoints = in.readInt().     final HashMap<Long, List<RecoverableWriter.CommitRecoverable>> resumablesPerCheckpoint = new HashMap<>(numCheckpoints).     for (int i = 0. i < numCheckpoints. i++) {         final long checkpointId = in.readLong().         final int noOfResumables = in.readInt().         final List<RecoverableWriter.CommitRecoverable> resumables = new ArrayList<>(noOfResumables).         for (int j = 0. j < noOfResumables. j++) {             final byte[] bytes = new byte[in.readInt()].             in.readFully(bytes).             resumables.add(commitableSerializer.deserialize(committableVersion, bytes)).         }         resumablesPerCheckpoint.put(checkpointId, resumables).     }     return new BucketState<>(bucketId, new Path(bucketPathStr), creationTime, current, resumablesPerCheckpoint). }
false;private,static;1;6;;private static void validateMagicNumber(DataInputView in) throws IOException {     final int magicNumber = in.readInt().     if (magicNumber != MAGIC_NUMBER) {         throw new IOException(String.format("Corrupt data: Unexpected magic number %08X", magicNumber)).     } }
