commented;modifiers;parameterAmount;loc;comment;code
false;public;6;94;;// ----------------------------------------------------------------------------------------------------------------- @Override public StreamOperatorStateContext streamOperatorStateContext(@Nonnull OperatorID operatorID, @Nonnull String operatorClassName, @Nonnull KeyContext keyContext, @Nullable TypeSerializer<?> keySerializer, @Nonnull CloseableRegistry streamTaskCloseableRegistry, @Nonnull MetricGroup metricGroup) throws Exception {     TaskInfo taskInfo = environment.getTaskInfo().     OperatorSubtaskDescriptionText operatorSubtaskDescription = new OperatorSubtaskDescriptionText(operatorID, operatorClassName, taskInfo.getIndexOfThisSubtask(), taskInfo.getNumberOfParallelSubtasks()).     final String operatorIdentifierText = operatorSubtaskDescription.toString().     final PrioritizedOperatorSubtaskState prioritizedOperatorSubtaskStates = taskStateManager.prioritizedOperatorState(operatorID).     AbstractKeyedStateBackend<?> keyedStatedBackend = null.     OperatorStateBackend operatorStateBackend = null.     CloseableIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStateInputs = null.     CloseableIterable<StatePartitionStreamProvider> rawOperatorStateInputs = null.     InternalTimeServiceManager<?> timeServiceManager.     try {         // -------------- Keyed State Backend --------------         keyedStatedBackend = keyedStatedBackend(keySerializer, operatorIdentifierText, prioritizedOperatorSubtaskStates, streamTaskCloseableRegistry, metricGroup).         // -------------- Operator State Backend --------------         operatorStateBackend = operatorStateBackend(operatorIdentifierText, prioritizedOperatorSubtaskStates, streamTaskCloseableRegistry).         // -------------- Raw State Streams --------------         rawKeyedStateInputs = rawKeyedStateInputs(prioritizedOperatorSubtaskStates.getPrioritizedRawKeyedState().iterator()).         streamTaskCloseableRegistry.registerCloseable(rawKeyedStateInputs).         rawOperatorStateInputs = rawOperatorStateInputs(prioritizedOperatorSubtaskStates.getPrioritizedRawOperatorState().iterator()).         streamTaskCloseableRegistry.registerCloseable(rawOperatorStateInputs).         // -------------- Internal Timer Service Manager --------------         timeServiceManager = internalTimeServiceManager(keyedStatedBackend, keyContext, rawKeyedStateInputs).         return new StreamOperatorStateContextImpl(prioritizedOperatorSubtaskStates.isRestored(), operatorStateBackend, keyedStatedBackend, timeServiceManager, rawOperatorStateInputs, rawKeyedStateInputs).     } catch (Exception ex) {         // cleanup if something went wrong before results got published.         if (keyedStatedBackend != null) {             if (streamTaskCloseableRegistry.unregisterCloseable(keyedStatedBackend)) {                 IOUtils.closeQuietly(keyedStatedBackend).             }             // release resource (e.g native resource)             keyedStatedBackend.dispose().         }         if (operatorStateBackend != null) {             if (streamTaskCloseableRegistry.unregisterCloseable(operatorStateBackend)) {                 IOUtils.closeQuietly(operatorStateBackend).             }             operatorStateBackend.dispose().         }         if (streamTaskCloseableRegistry.unregisterCloseable(rawKeyedStateInputs)) {             IOUtils.closeQuietly(rawKeyedStateInputs).         }         if (streamTaskCloseableRegistry.unregisterCloseable(rawOperatorStateInputs)) {             IOUtils.closeQuietly(rawOperatorStateInputs).         }         throw new Exception("Exception while creating StreamOperatorStateContext.", ex).     } }
false;protected;3;32;;protected <K> InternalTimeServiceManager<K> internalTimeServiceManager(AbstractKeyedStateBackend<K> keyedStatedBackend, // the operator KeyContext keyContext, Iterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) throws Exception {     if (keyedStatedBackend == null) {         return null.     }     final KeyGroupRange keyGroupRange = keyedStatedBackend.getKeyGroupRange().     final InternalTimeServiceManager<K> timeServiceManager = new InternalTimeServiceManager<>(keyGroupRange, keyContext, keyedStatedBackend, processingTimeService, keyedStatedBackend.requiresLegacySynchronousTimerSnapshots()).     // and then initialize the timer services     for (KeyGroupStatePartitionStreamProvider streamProvider : rawKeyedStates) {         int keyGroupIdx = streamProvider.getKeyGroupId().         Preconditions.checkArgument(keyGroupRange.contains(keyGroupIdx), "Key Group " + keyGroupIdx + " does not belong to the local range.").         timeServiceManager.restoreStateForKeyGroup(streamProvider.getStream(), keyGroupIdx, environment.getUserClassLoader()).     }     return timeServiceManager. }
false;protected;3;16;;protected OperatorStateBackend operatorStateBackend(String operatorIdentifierText, PrioritizedOperatorSubtaskState prioritizedOperatorSubtaskStates, CloseableRegistry backendCloseableRegistry) throws Exception {     String logDescription = "operator state backend for " + operatorIdentifierText.     BackendRestorerProcedure<OperatorStateBackend, OperatorStateHandle> backendRestorer = new BackendRestorerProcedure<>((stateHandles) -> stateBackend.createOperatorStateBackend(environment, operatorIdentifierText), backendCloseableRegistry, logDescription).     return backendRestorer.createAndRestore(prioritizedOperatorSubtaskStates.getPrioritizedManagedOperatorState()). }
false;protected;5;39;;protected <K> AbstractKeyedStateBackend<K> keyedStatedBackend(TypeSerializer<K> keySerializer, String operatorIdentifierText, PrioritizedOperatorSubtaskState prioritizedOperatorSubtaskStates, CloseableRegistry backendCloseableRegistry, MetricGroup metricGroup) throws Exception {     if (keySerializer == null) {         return null.     }     String logDescription = "keyed state backend for " + operatorIdentifierText.     TaskInfo taskInfo = environment.getTaskInfo().     final KeyGroupRange keyGroupRange = KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(taskInfo.getMaxNumberOfParallelSubtasks(), taskInfo.getNumberOfParallelSubtasks(), taskInfo.getIndexOfThisSubtask()).     BackendRestorerProcedure<AbstractKeyedStateBackend<K>, KeyedStateHandle> backendRestorer = new BackendRestorerProcedure<>((stateHandles) -> stateBackend.createKeyedStateBackend(environment, environment.getJobID(), operatorIdentifierText, keySerializer, taskInfo.getMaxNumberOfParallelSubtasks(), keyGroupRange, environment.getTaskKvStateRegistry(), TtlTimeProvider.DEFAULT, metricGroup, stateHandles), backendCloseableRegistry, logDescription).     return backendRestorer.createAndRestore(prioritizedOperatorSubtaskStates.getPrioritizedManagedKeyedState()). }
false;public;0;4;;@Override public void close() throws IOException {     closeableRegistry.close(). }
false;public;0;7;;@Nonnull @Override public Iterator<StatePartitionStreamProvider> iterator() {     return new OperatorStateStreamIterator(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, rawOperatorState.iterator(), closeableRegistry). }
false;protected;1;34;;protected CloseableIterable<StatePartitionStreamProvider> rawOperatorStateInputs(Iterator<StateObjectCollection<OperatorStateHandle>> restoreStateAlternatives) {     if (restoreStateAlternatives.hasNext()) {         Collection<OperatorStateHandle> rawOperatorState = restoreStateAlternatives.next().         // TODO currently this does not support local state recovery, so we expect there is only one handle.         Preconditions.checkState(!restoreStateAlternatives.hasNext(), "Local recovery is currently not implemented for raw operator state, but found state alternative.").         if (rawOperatorState != null) {             return new CloseableIterable<StatePartitionStreamProvider>() {                  final CloseableRegistry closeableRegistry = new CloseableRegistry().                  @Override                 public void close() throws IOException {                     closeableRegistry.close().                 }                  @Nonnull                 @Override                 public Iterator<StatePartitionStreamProvider> iterator() {                     return new OperatorStateStreamIterator(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, rawOperatorState.iterator(), closeableRegistry).                 }             }.         }     }     return CloseableIterable.empty(). }
false;public;0;4;;@Override public void close() throws IOException {     closeableRegistry.close(). }
false;public;0;4;;@Override public Iterator<KeyGroupStatePartitionStreamProvider> iterator() {     return new KeyGroupStreamIterator(keyGroupsStateHandles.iterator(), closeableRegistry). }
false;protected;1;31;;protected CloseableIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStateInputs(Iterator<StateObjectCollection<KeyedStateHandle>> restoreStateAlternatives) {     if (restoreStateAlternatives.hasNext()) {         Collection<KeyedStateHandle> rawKeyedState = restoreStateAlternatives.next().         // TODO currently this does not support local state recovery, so we expect there is only one handle.         Preconditions.checkState(!restoreStateAlternatives.hasNext(), "Local recovery is currently not implemented for raw keyed state, but found state alternative.").         if (rawKeyedState != null) {             Collection<KeyGroupsStateHandle> keyGroupsStateHandles = transform(rawKeyedState).             final CloseableRegistry closeableRegistry = new CloseableRegistry().             return new CloseableIterable<KeyGroupStatePartitionStreamProvider>() {                  @Override                 public void close() throws IOException {                     closeableRegistry.close().                 }                  @Override                 public Iterator<KeyGroupStatePartitionStreamProvider> iterator() {                     return new KeyGroupStreamIterator(keyGroupsStateHandles.iterator(), closeableRegistry).                 }             }.         }     }     return CloseableIterable.empty(). }
false;public;0;21;;@Override public boolean hasNext() {     if (null != currentStateHandle && currentOffsetsIterator.hasNext()) {         return true.     }     closeCurrentStream().     while (stateHandleIterator.hasNext()) {         currentStateHandle = stateHandleIterator.next().         if (currentStateHandle.getKeyGroupRange().getNumberOfKeyGroups() > 0) {             currentOffsetsIterator = currentStateHandle.getGroupRangeOffsets().iterator().             return true.         }     }     return false. }
false;public;0;21;;@Override public KeyGroupStatePartitionStreamProvider next() {     if (!hasNext()) {         throw new NoSuchElementException("Iterator exhausted").     }     Tuple2<Integer, Long> keyGroupOffset = currentOffsetsIterator.next().     try {         if (null == currentStream) {             openCurrentStream().         }         currentStream.seek(keyGroupOffset.f1).         return new KeyGroupStatePartitionStreamProvider(currentStream, keyGroupOffset.f0).     } catch (IOException ioex) {         return new KeyGroupStatePartitionStreamProvider(ioex, keyGroupOffset.f0).     } }
false;public;0;33;;@Override public boolean hasNext() {     if (null != offsets && offPos < offsets.length) {         return true.     }     closeCurrentStream().     while (stateHandleIterator.hasNext()) {         currentStateHandle = stateHandleIterator.next().         OperatorStateHandle.StateMetaInfo metaInfo = currentStateHandle.getStateNameToPartitionOffsets().get(stateName).         if (null != metaInfo) {             long[] metaOffsets = metaInfo.getOffsets().             if (null != metaOffsets && metaOffsets.length > 0) {                 this.offsets = metaOffsets.                 this.offPos = 0.                 if (closableRegistry.unregisterCloseable(currentStream)) {                     IOUtils.closeQuietly(currentStream).                     currentStream = null.                 }                 return true.             }         }     }     return false. }
false;public;0;22;;@Override public StatePartitionStreamProvider next() {     if (!hasNext()) {         throw new NoSuchElementException("Iterator exhausted").     }     long offset = offsets[offPos++].     try {         if (null == currentStream) {             openCurrentStream().         }         currentStream.seek(offset).         return new StatePartitionStreamProvider(currentStream).     } catch (IOException ioex) {         return new StatePartitionStreamProvider(ioex).     } }
false;protected;0;8;;protected void openCurrentStream() throws IOException {     Preconditions.checkState(currentStream == null).     FSDataInputStream stream = currentStateHandle.openInputStream().     closableRegistry.registerCloseable(stream).     currentStream = stream. }
false;protected;0;6;;protected void closeCurrentStream() {     if (closableRegistry.unregisterCloseable(currentStream)) {         IOUtils.closeQuietly(currentStream).     }     currentStream = null. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException("Read only Iterator"). }
false;private,static;1;21;;private static Collection<KeyGroupsStateHandle> transform(Collection<KeyedStateHandle> keyedStateHandles) {     if (keyedStateHandles == null) {         return null.     }     List<KeyGroupsStateHandle> keyGroupsStateHandles = new ArrayList<>(keyedStateHandles.size()).     for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {         if (keyedStateHandle instanceof KeyGroupsStateHandle) {             keyGroupsStateHandles.add((KeyGroupsStateHandle) keyedStateHandle).         } else if (keyedStateHandle != null) {             throw new IllegalStateException("Unexpected state handle type, " + "expected: " + KeyGroupsStateHandle.class + ", but found: " + keyedStateHandle.getClass() + ".").         }     }     return keyGroupsStateHandles. }
false;public;0;4;;@Override public boolean isRestored() {     return restored. }
false;public;0;4;;@Override public AbstractKeyedStateBackend<?> keyedStateBackend() {     return keyedStateBackend. }
false;public;0;4;;@Override public OperatorStateBackend operatorStateBackend() {     return operatorStateBackend. }
false;public;0;4;;@Override public InternalTimeServiceManager<?> internalTimerServiceManager() {     return internalTimeServiceManager. }
false;public;0;4;;@Override public CloseableIterable<StatePartitionStreamProvider> rawOperatorStateInputs() {     return rawOperatorStateInputs. }
false;public;0;4;;@Override public CloseableIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStateInputs() {     return rawKeyedStateInputs. }
