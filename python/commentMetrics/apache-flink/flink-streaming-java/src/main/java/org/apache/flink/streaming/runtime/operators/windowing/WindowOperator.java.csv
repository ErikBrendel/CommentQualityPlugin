commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public long getCurrentProcessingTime() {     return internalTimerService.currentProcessingTime(). }
false;public;0;57;;@Override public void open() throws Exception {     super.open().     this.numLateRecordsDropped = metrics.counter(LATE_ELEMENTS_DROPPED_METRIC_NAME).     timestampedCollector = new TimestampedCollector<>(output).     internalTimerService = getInternalTimerService("window-timers", windowSerializer, this).     triggerContext = new Context(null, null).     processContext = new WindowContext(null).     windowAssignerContext = new WindowAssigner.WindowAssignerContext() {          @Override         public long getCurrentProcessingTime() {             return internalTimerService.currentProcessingTime().         }     }.     // NOTE - the state may be null in the case of the overriding evicting window operator     if (windowStateDescriptor != null) {         windowState = (InternalAppendingState<K, W, IN, ACC, ACC>) getOrCreateKeyedState(windowSerializer, windowStateDescriptor).     }     // create the typed and helper states for merging windows     if (windowAssigner instanceof MergingWindowAssigner) {         // store a typed reference for the state of merging windows - sanity check         if (windowState instanceof InternalMergingState) {             windowMergingState = (InternalMergingState<K, W, IN, ACC, ACC>) windowState.         }         // TODO this sanity check should be here, but is prevented by an incorrect test (pending validation)         // TODO see WindowOperatorTest.testCleanupTimerWithEmptyFoldingStateForSessionWindows()         // TODO activate the sanity check once resolved         // else if (windowState != null) {         // throw new IllegalStateException(         // "The window uses a merging assigner, but the window state is not mergeable.").         // }         @SuppressWarnings("unchecked")         final Class<Tuple2<W, W>> typedTuple = (Class<Tuple2<W, W>>) (Class<?>) Tuple2.class.         final TupleSerializer<Tuple2<W, W>> tupleSerializer = new TupleSerializer<>(typedTuple, new TypeSerializer[] { windowSerializer, windowSerializer }).         final ListStateDescriptor<Tuple2<W, W>> mergingSetsStateDescriptor = new ListStateDescriptor<>("merging-window-set", tupleSerializer).         // get the state that stores the merging sets         mergingSetsState = (InternalListState<K, VoidNamespace, Tuple2<W, W>>) getOrCreateKeyedState(VoidNamespaceSerializer.INSTANCE, mergingSetsStateDescriptor).         mergingSetsState.setCurrentNamespace(VoidNamespace.INSTANCE).     } }
false;public;0;8;;@Override public void close() throws Exception {     super.close().     timestampedCollector = null.     triggerContext = null.     processContext = null.     windowAssignerContext = null. }
false;public;0;8;;@Override public void dispose() throws Exception {     super.dispose().     timestampedCollector = null.     triggerContext = null.     processContext = null.     windowAssignerContext = null. }
false;public;4;31;;@Override public void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {     if ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {         throw new UnsupportedOperationException("The end timestamp of an " + "event-time window cannot become earlier than the current watermark " + "by merging. Current watermark: " + internalTimerService.currentWatermark() + " window: " + mergeResult).     } else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {         throw new UnsupportedOperationException("The end timestamp of a " + "processing-time window cannot become earlier than the current processing time " + "by merging. Current processing time: " + internalTimerService.currentProcessingTime() + " window: " + mergeResult).     }     triggerContext.key = key.     triggerContext.window = mergeResult.     triggerContext.onMerge(mergedWindows).     for (W m : mergedWindows) {         triggerContext.window = m.         triggerContext.clear().         deleteCleanupTimer(m).     }     // merge the merged state windows into the newly resulting state window     windowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows). }
false;public;1;132;;@Override public void processElement(StreamRecord<IN> element) throws Exception {     final Collection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp(), windowAssignerContext).     // if element is handled by none of assigned elementWindows     boolean isSkippedElement = true.     final K key = this.<K>getKeyedStateBackend().getCurrentKey().     if (windowAssigner instanceof MergingWindowAssigner) {         MergingWindowSet<W> mergingWindows = getMergingWindowSet().         for (W window : elementWindows) {             // adding the new window might result in a merge, in that case the actualWindow             // is the merged window and we work with that. If we don't merge then             // actualWindow == window             W actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {                  @Override                 public void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {                     if ((windowAssigner.isEventTime() && mergeResult.maxTimestamp() + allowedLateness <= internalTimerService.currentWatermark())) {                         throw new UnsupportedOperationException("The end timestamp of an " + "event-time window cannot become earlier than the current watermark " + "by merging. Current watermark: " + internalTimerService.currentWatermark() + " window: " + mergeResult).                     } else if (!windowAssigner.isEventTime() && mergeResult.maxTimestamp() <= internalTimerService.currentProcessingTime()) {                         throw new UnsupportedOperationException("The end timestamp of a " + "processing-time window cannot become earlier than the current processing time " + "by merging. Current processing time: " + internalTimerService.currentProcessingTime() + " window: " + mergeResult).                     }                     triggerContext.key = key.                     triggerContext.window = mergeResult.                     triggerContext.onMerge(mergedWindows).                     for (W m : mergedWindows) {                         triggerContext.window = m.                         triggerContext.clear().                         deleteCleanupTimer(m).                     }                     // merge the merged state windows into the newly resulting state window                     windowMergingState.mergeNamespaces(stateWindowResult, mergedStateWindows).                 }             }).             // drop if the window is already late             if (isWindowLate(actualWindow)) {                 mergingWindows.retireWindow(actualWindow).                 continue.             }             isSkippedElement = false.             W stateWindow = mergingWindows.getStateWindow(actualWindow).             if (stateWindow == null) {                 throw new IllegalStateException("Window " + window + " is not in in-flight window set.").             }             windowState.setCurrentNamespace(stateWindow).             windowState.add(element.getValue()).             triggerContext.key = key.             triggerContext.window = actualWindow.             TriggerResult triggerResult = triggerContext.onElement(element).             if (triggerResult.isFire()) {                 ACC contents = windowState.get().                 if (contents == null) {                     continue.                 }                 emitWindowContents(actualWindow, contents).             }             if (triggerResult.isPurge()) {                 windowState.clear().             }             registerCleanupTimer(actualWindow).         }         // need to make sure to update the merging state in state         mergingWindows.persist().     } else {         for (W window : elementWindows) {             // drop if the window is already late             if (isWindowLate(window)) {                 continue.             }             isSkippedElement = false.             windowState.setCurrentNamespace(window).             windowState.add(element.getValue()).             triggerContext.key = key.             triggerContext.window = window.             TriggerResult triggerResult = triggerContext.onElement(element).             if (triggerResult.isFire()) {                 ACC contents = windowState.get().                 if (contents == null) {                     continue.                 }                 emitWindowContents(window, contents).             }             if (triggerResult.isPurge()) {                 windowState.clear().             }             registerCleanupTimer(window).         }     }     // windowAssigner is event time and current timestamp + allowed lateness no less than element timestamp     if (isSkippedElement && isElementLate(element)) {         if (lateDataOutputTag != null) {             sideOutput(element).         } else {             this.numLateRecordsDropped.inc().         }     } }
false;public;1;45;;@Override public void onEventTime(InternalTimer<K, W> timer) throws Exception {     triggerContext.key = timer.getKey().     triggerContext.window = timer.getNamespace().     MergingWindowSet<W> mergingWindows.     if (windowAssigner instanceof MergingWindowAssigner) {         mergingWindows = getMergingWindowSet().         W stateWindow = mergingWindows.getStateWindow(triggerContext.window).         if (stateWindow == null) {             // window and therefore the Trigger state, however, so nothing to do.             return.         } else {             windowState.setCurrentNamespace(stateWindow).         }     } else {         windowState.setCurrentNamespace(triggerContext.window).         mergingWindows = null.     }     TriggerResult triggerResult = triggerContext.onEventTime(timer.getTimestamp()).     if (triggerResult.isFire()) {         ACC contents = windowState.get().         if (contents != null) {             emitWindowContents(triggerContext.window, contents).         }     }     if (triggerResult.isPurge()) {         windowState.clear().     }     if (windowAssigner.isEventTime() && isCleanupTime(triggerContext.window, timer.getTimestamp())) {         clearAllState(triggerContext.window, windowState, mergingWindows).     }     if (mergingWindows != null) {         // need to make sure to update the merging state in state         mergingWindows.persist().     } }
false;public;1;45;;@Override public void onProcessingTime(InternalTimer<K, W> timer) throws Exception {     triggerContext.key = timer.getKey().     triggerContext.window = timer.getNamespace().     MergingWindowSet<W> mergingWindows.     if (windowAssigner instanceof MergingWindowAssigner) {         mergingWindows = getMergingWindowSet().         W stateWindow = mergingWindows.getStateWindow(triggerContext.window).         if (stateWindow == null) {             // window and therefore the Trigger state, however, so nothing to do.             return.         } else {             windowState.setCurrentNamespace(stateWindow).         }     } else {         windowState.setCurrentNamespace(triggerContext.window).         mergingWindows = null.     }     TriggerResult triggerResult = triggerContext.onProcessingTime(timer.getTimestamp()).     if (triggerResult.isFire()) {         ACC contents = windowState.get().         if (contents != null) {             emitWindowContents(triggerContext.window, contents).         }     }     if (triggerResult.isPurge()) {         windowState.clear().     }     if (!windowAssigner.isEventTime() && isCleanupTime(triggerContext.window, timer.getTimestamp())) {         clearAllState(triggerContext.window, windowState, mergingWindows).     }     if (mergingWindows != null) {         // need to make sure to update the merging state in state         mergingWindows.persist().     } }
true;private;3;13;/**  * Drops all state for the given window and calls  * {@link Trigger#clear(Window, Trigger.TriggerContext)}.  *  * <p>The caller must ensure that the  * correct key is set in the state backend and the triggerContext object.  */ ;/**  * Drops all state for the given window and calls  * {@link Trigger#clear(Window, Trigger.TriggerContext)}.  *  * <p>The caller must ensure that the  * correct key is set in the state backend and the triggerContext object.  */ private void clearAllState(W window, AppendingState<IN, ACC> windowState, MergingWindowSet<W> mergingWindows) throws Exception {     windowState.clear().     triggerContext.clear().     processContext.window = window.     processContext.clear().     if (mergingWindows != null) {         mergingWindows.retireWindow(window).         mergingWindows.persist().     } }
true;private;2;6;/**  * Emits the contents of the given window using the {@link InternalWindowFunction}.  */ ;/**  * Emits the contents of the given window using the {@link InternalWindowFunction}.  */ @SuppressWarnings("unchecked") private void emitWindowContents(W window, ACC contents) throws Exception {     timestampedCollector.setAbsoluteTimestamp(window.maxTimestamp()).     processContext.window = window.     userFunction.process(triggerContext.key, window, processContext, contents, timestampedCollector). }
true;protected;1;3;/**  * Write skipped late arriving element to SideOutput.  *  * @param element skipped late arriving element to side output  */ ;/**  * Write skipped late arriving element to SideOutput.  *  * @param element skipped late arriving element to side output  */ protected void sideOutput(StreamRecord<IN> element) {     output.collect(lateDataOutputTag, element). }
true;protected;0;5;/**  * Retrieves the {@link MergingWindowSet} for the currently active key.  * The caller must ensure that the correct key is set in the state backend.  *  * <p>The caller must also ensure to properly persist changes to state using  * {@link MergingWindowSet#persist()}.  */ ;/**  * Retrieves the {@link MergingWindowSet} for the currently active key.  * The caller must ensure that the correct key is set in the state backend.  *  * <p>The caller must also ensure to properly persist changes to state using  * {@link MergingWindowSet#persist()}.  */ protected MergingWindowSet<W> getMergingWindowSet() throws Exception {     @SuppressWarnings("unchecked")     MergingWindowAssigner<? super IN, W> mergingAssigner = (MergingWindowAssigner<? super IN, W>) windowAssigner.     return new MergingWindowSet<>(mergingAssigner, mergingSetsState). }
true;protected;1;3;/**  * Returns {@code true} if the watermark is after the end timestamp plus the allowed lateness  * of the given window.  */ ;/**  * Returns {@code true} if the watermark is after the end timestamp plus the allowed lateness  * of the given window.  */ protected boolean isWindowLate(W window) {     return (windowAssigner.isEventTime() && (cleanupTime(window) <= internalTimerService.currentWatermark())). }
true;protected;1;4;/**  * Decide if a record is currently late, based on current watermark and allowed lateness.  *  * @param element The element to check  * @return The element for which should be considered when sideoutputs  */ ;/**  * Decide if a record is currently late, based on current watermark and allowed lateness.  *  * @param element The element to check  * @return The element for which should be considered when sideoutputs  */ protected boolean isElementLate(StreamRecord<IN> element) {     return (windowAssigner.isEventTime()) && (element.getTimestamp() + allowedLateness <= internalTimerService.currentWatermark()). }
true;protected;1;13;/**  * Registers a timer to cleanup the content of the window.  * @param window  * 					the window whose state to discard  */ ;/**  * Registers a timer to cleanup the content of the window.  * @param window  * 					the window whose state to discard  */ protected void registerCleanupTimer(W window) {     long cleanupTime = cleanupTime(window).     if (cleanupTime == Long.MAX_VALUE) {         // don't set a GC timer for "end of time"         return.     }     if (windowAssigner.isEventTime()) {         triggerContext.registerEventTimeTimer(cleanupTime).     } else {         triggerContext.registerProcessingTimeTimer(cleanupTime).     } }
true;protected;1;12;/**  * Deletes the cleanup timer set for the contents of the provided window.  * @param window  * 					the window whose state to discard  */ ;/**  * Deletes the cleanup timer set for the contents of the provided window.  * @param window  * 					the window whose state to discard  */ protected void deleteCleanupTimer(W window) {     long cleanupTime = cleanupTime(window).     if (cleanupTime == Long.MAX_VALUE) {         // no need to clean up because we didn't set one         return.     }     if (windowAssigner.isEventTime()) {         triggerContext.deleteEventTimeTimer(cleanupTime).     } else {         triggerContext.deleteProcessingTimeTimer(cleanupTime).     } }
true;private;1;8;/**  * Returns the cleanup time for a window, which is  * {@code window.maxTimestamp + allowedLateness}. In  * case this leads to a value greater than {@link Long#MAX_VALUE}  * then a cleanup time of {@link Long#MAX_VALUE} is  * returned.  *  * @param window the window whose cleanup time we are computing.  */ ;/**  * Returns the cleanup time for a window, which is  * {@code window.maxTimestamp + allowedLateness}. In  * case this leads to a value greater than {@link Long#MAX_VALUE}  * then a cleanup time of {@link Long#MAX_VALUE} is  * returned.  *  * @param window the window whose cleanup time we are computing.  */ private long cleanupTime(W window) {     if (windowAssigner.isEventTime()) {         long cleanupTime = window.maxTimestamp() + allowedLateness.         return cleanupTime >= window.maxTimestamp() ? cleanupTime : Long.MAX_VALUE.     } else {         return window.maxTimestamp().     } }
true;protected,final;2;3;/**  * Returns {@code true} if the given time is the cleanup time for the given window.  */ ;/**  * Returns {@code true} if the given time is the cleanup time for the given window.  */ protected final boolean isCleanupTime(W window, long time) {     return time == cleanupTime(window). }
false;public;1;4;;@Override public <T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties) {     throw new UnsupportedOperationException("Per-window state is not allowed when using merging windows."). }
false;public;1;4;;@Override public <T> ListState<T> getListState(ListStateDescriptor<T> stateProperties) {     throw new UnsupportedOperationException("Per-window state is not allowed when using merging windows."). }
false;public;1;4;;@Override public <T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties) {     throw new UnsupportedOperationException("Per-window state is not allowed when using merging windows."). }
false;public;1;4;;@Override public <IN, ACC, OUT> AggregatingState<IN, OUT> getAggregatingState(AggregatingStateDescriptor<IN, ACC, OUT> stateProperties) {     throw new UnsupportedOperationException("Per-window state is not allowed when using merging windows."). }
false;public;1;4;;@Override public <T, A> FoldingState<T, A> getFoldingState(FoldingStateDescriptor<T, A> stateProperties) {     throw new UnsupportedOperationException("Per-window state is not allowed when using merging windows."). }
false;public;1;4;;@Override public <UK, UV> MapState<UK, UV> getMapState(MapStateDescriptor<UK, UV> stateProperties) {     throw new UnsupportedOperationException("Per-window state is not allowed when using merging windows."). }
false;protected;1;7;;@Override protected <S extends State> S getPartitionedState(StateDescriptor<S, ?> stateDescriptor) throws Exception {     return keyedStateBackend.getPartitionedState(window, windowSerializer, stateDescriptor). }
false;public;0;4;;@Override public String toString() {     return "WindowContext{Window = " + window.toString() + "}". }
false;public;0;3;;public void clear() throws Exception {     userFunction.clear(window, this). }
false;public;0;4;;@Override public long currentProcessingTime() {     return internalTimerService.currentProcessingTime(). }
false;public;0;4;;@Override public long currentWatermark() {     return internalTimerService.currentWatermark(). }
false;public;0;5;;@Override public KeyedStateStore windowState() {     this.windowState.window = this.window.     return this.windowState. }
false;public;0;4;;@Override public KeyedStateStore globalState() {     return WindowOperator.this.getKeyedStateStore(). }
false;public;2;7;;@Override public <X> void output(OutputTag<X> outputTag, X value) {     if (outputTag == null) {         throw new IllegalArgumentException("OutputTag must not be null.").     }     output.collect(outputTag, new StreamRecord<>(value, window.maxTimestamp())). }
false;public;0;4;;@Override public MetricGroup getMetricGroup() {     return WindowOperator.this.getMetricGroup(). }
false;public;0;3;;public long getCurrentWatermark() {     return internalTimerService.currentWatermark(). }
false;public;3;18;;@Override public <S extends Serializable> ValueState<S> getKeyValueState(String name, Class<S> stateType, S defaultState) {     checkNotNull(stateType, "The state type class must not be null").     TypeInformation<S> typeInfo.     try {         typeInfo = TypeExtractor.getForClass(stateType).     } catch (Exception e) {         throw new RuntimeException("Cannot analyze type '" + stateType.getName() + "' from the class alone, due to generic type parameters. " + "Please specify the TypeInformation directly.", e).     }     return getKeyValueState(name, typeInfo, defaultState). }
false;public;3;11;;@Override public <S extends Serializable> ValueState<S> getKeyValueState(String name, TypeInformation<S> stateType, S defaultState) {     checkNotNull(name, "The name of the state must not be null").     checkNotNull(stateType, "The state type information must not be null").     ValueStateDescriptor<S> stateDesc = new ValueStateDescriptor<>(name, stateType.createSerializer(getExecutionConfig()), defaultState).     return getPartitionedState(stateDesc). }
false;public;1;8;;@SuppressWarnings("unchecked") public <S extends State> S getPartitionedState(StateDescriptor<S, ?> stateDescriptor) {     try {         return WindowOperator.this.getPartitionedState(window, windowSerializer, stateDescriptor).     } catch (Exception e) {         throw new RuntimeException("Could not retrieve state", e).     } }
false;public;1;21;;@Override public <S extends MergingState<?, ?>> void mergePartitionedState(StateDescriptor<S, ?> stateDescriptor) {     if (mergedWindows != null && mergedWindows.size() > 0) {         try {             S rawState = getKeyedStateBackend().getOrCreateKeyedState(windowSerializer, stateDescriptor).             if (rawState instanceof InternalMergingState) {                 @SuppressWarnings("unchecked")                 InternalMergingState<K, W, ?, ?, ?> mergingState = (InternalMergingState<K, W, ?, ?, ?>) rawState.                 mergingState.mergeNamespaces(window, mergedWindows).             } else {                 throw new IllegalArgumentException("The given state descriptor does not refer to a mergeable state (MergingState)").             }         } catch (Exception e) {             throw new RuntimeException("Error while merging state.", e).         }     } }
false;public;0;4;;@Override public long getCurrentProcessingTime() {     return internalTimerService.currentProcessingTime(). }
false;public;1;4;;@Override public void registerProcessingTimeTimer(long time) {     internalTimerService.registerProcessingTimeTimer(window, time). }
false;public;1;4;;@Override public void registerEventTimeTimer(long time) {     internalTimerService.registerEventTimeTimer(window, time). }
false;public;1;4;;@Override public void deleteProcessingTimeTimer(long time) {     internalTimerService.deleteProcessingTimeTimer(window, time). }
false;public;1;4;;@Override public void deleteEventTimeTimer(long time) {     internalTimerService.deleteEventTimeTimer(window, time). }
false;public;1;3;;public TriggerResult onElement(StreamRecord<IN> element) throws Exception {     return trigger.onElement(element.getValue(), element.getTimestamp(), window, this). }
false;public;1;3;;public TriggerResult onProcessingTime(long time) throws Exception {     return trigger.onProcessingTime(time, window, this). }
false;public;1;3;;public TriggerResult onEventTime(long time) throws Exception {     return trigger.onEventTime(time, window, this). }
false;public;1;4;;public void onMerge(Collection<W> mergedWindows) throws Exception {     this.mergedWindows = mergedWindows.     trigger.onMerge(window, this). }
false;public;0;3;;public void clear() throws Exception {     trigger.clear(window, this). }
false;public;0;7;;@Override public String toString() {     return "Context{" + "key=" + key + ", window=" + window + '}'. }
false;public;1;4;;@Override public int compareTo(Timer<K, W> o) {     return Long.compare(this.timestamp, o.timestamp). }
false;public;1;16;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     Timer<?, ?> timer = (Timer<?, ?>) o.     return timestamp == timer.timestamp && key.equals(timer.key) && window.equals(timer.window). }
false;public;0;7;;@Override public int hashCode() {     int result = (int) (timestamp ^ (timestamp >>> 32)).     result = 31 * result + key.hashCode().     result = 31 * result + window.hashCode().     return result. }
false;public;0;8;;@Override public String toString() {     return "Timer{" + "timestamp=" + timestamp + ", key=" + key + ", window=" + window + '}'. }
false;public;0;4;;// ------------------------------------------------------------------------ // Getters for testing // ------------------------------------------------------------------------ @VisibleForTesting public Trigger<? super IN, ? super W> getTrigger() {     return trigger. }
false;public;0;4;;@VisibleForTesting public KeySelector<IN, K> getKeySelector() {     return keySelector. }
false;public;0;4;;@VisibleForTesting public WindowAssigner<? super IN, W> getWindowAssigner() {     return windowAssigner. }
false;public;0;4;;@VisibleForTesting public StateDescriptor<? extends AppendingState<IN, ACC>, ?> getStateDescriptor() {     return windowStateDescriptor. }
