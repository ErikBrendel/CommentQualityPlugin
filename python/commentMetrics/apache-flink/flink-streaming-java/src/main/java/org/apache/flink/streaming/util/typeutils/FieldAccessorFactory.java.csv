# id;timestamp;commentText;codeText;commentWords;codeWords
FieldAccessorFactory -> @Internal 	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, String field, ExecutionConfig config);1480022575;Creates a {@link FieldAccessor} for the field that is given by a field expression,_which can be used to get and set the specified field on instances of this type.__@param field The field expression_@param config Configuration object_@param <F> The type of the field to access_@return The created FieldAccessor;@Internal_	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, String field, ExecutionConfig config) {__		_		if (typeInfo instanceof BasicArrayTypeInfo || typeInfo instanceof PrimitiveArrayTypeInfo) {_			try {_				return new FieldAccessor.ArrayFieldAccessor<>(Integer.parseInt(field), typeInfo)__			} catch (NumberFormatException ex) {_				throw new CompositeType.InvalidFieldReferenceException_					("A field expression on an array must be an integer index (that might be given as a string).")__			}__		_		} else if (typeInfo instanceof BasicTypeInfo) {_			try {_				int pos = field.equals(Keys.ExpressionKeys.SELECT_ALL_CHAR) ? 0 : Integer.parseInt(field)__				return FieldAccessorFactory.getAccessor(typeInfo, pos, config)__			} catch (NumberFormatException ex) {_				throw new CompositeType.InvalidFieldReferenceException("You tried to select the field \"" + field +_					"\" on a " + typeInfo.toString() + ". A field expression on a basic type can only be \"*\" or \"0\"" +_					" (both of which mean selecting the entire basic type).")__			}__		_		} else if (typeInfo instanceof PojoTypeInfo) {_			FieldExpression decomp = decomposeFieldExpression(field)__			PojoTypeInfo<?> pojoTypeInfo = (PojoTypeInfo) typeInfo___			int fieldIndex = pojoTypeInfo.getFieldIndex(decomp.head)___			if (fieldIndex == -1) {_				throw new CompositeType.InvalidFieldReferenceException(_					"Unable to find field \"" + decomp.head + "\" in type " + typeInfo + ".")__			} else {_				PojoField pojoField = pojoTypeInfo.getPojoFieldAt(fieldIndex)__				TypeInformation<?> fieldType = pojoTypeInfo.getTypeAt(fieldIndex)__				if (decomp.tail == null) {_					@SuppressWarnings("unchecked")_					FieldAccessor<F, F> innerAccessor = new FieldAccessor.SimpleFieldAccessor<>((TypeInformation<F>) fieldType)__					return new FieldAccessor.PojoFieldAccessor<>(pojoField.getField(), innerAccessor)__				} else {_					@SuppressWarnings("unchecked")_					FieldAccessor<Object, F> innerAccessor = FieldAccessorFactory_						.getAccessor((TypeInformation<Object>) fieldType, decomp.tail, config)__					return new FieldAccessor.PojoFieldAccessor<>(pojoField.getField(), innerAccessor)__				}_			}_		_		} else if (typeInfo.isTupleType() && ((TupleTypeInfoBase) typeInfo).isCaseClass()) {_			TupleTypeInfoBase tupleTypeInfo = (TupleTypeInfoBase) typeInfo__			FieldExpression decomp = decomposeFieldExpression(field)__			int fieldPos = tupleTypeInfo.getFieldIndex(decomp.head)__			if (fieldPos < 0) {_				throw new CompositeType.InvalidFieldReferenceException("Invalid field selected: " + field)__			}__			if (decomp.tail == null){_				return new FieldAccessor.SimpleProductFieldAccessor<>(fieldPos, typeInfo, config)__			} else {_				@SuppressWarnings("unchecked")_				FieldAccessor<Object, F> innerAccessor = getAccessor(tupleTypeInfo.getTypeAt(fieldPos), decomp.tail, config)__				return new FieldAccessor.RecursiveProductFieldAccessor<>(fieldPos, typeInfo, innerAccessor, config)__			}__		_		} else if (typeInfo.isTupleType()) {_			TupleTypeInfo tupleTypeInfo = (TupleTypeInfo) typeInfo__			FieldExpression decomp = decomposeFieldExpression(field)__			int fieldPos = tupleTypeInfo.getFieldIndex(decomp.head)__			if (fieldPos == -1) {_				try {_					fieldPos = Integer.parseInt(decomp.head)__				} catch (NumberFormatException ex) {_					throw new CompositeType.InvalidFieldReferenceException("Tried to select field \"" + decomp.head_						+ "\" on " + typeInfo.toString() + " . Only integer values are allowed here.")__				}_			}_			if (decomp.tail == null) {_				@SuppressWarnings("unchecked")_				FieldAccessor<T, F> result = new FieldAccessor.SimpleTupleFieldAccessor(fieldPos, tupleTypeInfo)__				return result__			} else {_				@SuppressWarnings("unchecked")_				FieldAccessor<?, F> innerAccessor = getAccessor(tupleTypeInfo.getTypeAt(fieldPos), decomp.tail, config)__				@SuppressWarnings("unchecked")_				FieldAccessor<T, F> result = new FieldAccessor.RecursiveTupleFieldAccessor(fieldPos, innerAccessor, tupleTypeInfo)__				return result__			}__		_		} else {_			throw new CompositeType.InvalidFieldReferenceException("Cannot reference field by field expression on " + typeInfo.toString()_				+ "Field expressions are only supported on POJO types, tuples, and case classes. "_				+ "(See the Flink documentation on what is considered a POJO.)")__		}_	};creates,a,link,field,accessor,for,the,field,that,is,given,by,a,field,expression,which,can,be,used,to,get,and,set,the,specified,field,on,instances,of,this,type,param,field,the,field,expression,param,config,configuration,object,param,f,the,type,of,the,field,to,access,return,the,created,field,accessor;internal,public,static,t,f,field,accessor,t,f,get,accessor,type,information,t,type,info,string,field,execution,config,config,if,type,info,instanceof,basic,array,type,info,type,info,instanceof,primitive,array,type,info,try,return,new,field,accessor,array,field,accessor,integer,parse,int,field,type,info,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,a,field,expression,on,an,array,must,be,an,integer,index,that,might,be,given,as,a,string,else,if,type,info,instanceof,basic,type,info,try,int,pos,field,equals,keys,expression,keys,0,integer,parse,int,field,return,field,accessor,factory,get,accessor,type,info,pos,config,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,you,tried,to,select,the,field,field,on,a,type,info,to,string,a,field,expression,on,a,basic,type,can,only,be,or,0,both,of,which,mean,selecting,the,entire,basic,type,else,if,type,info,instanceof,pojo,type,info,field,expression,decomp,decompose,field,expression,field,pojo,type,info,pojo,type,info,pojo,type,info,type,info,int,field,index,pojo,type,info,get,field,index,decomp,head,if,field,index,1,throw,new,composite,type,invalid,field,reference,exception,unable,to,find,field,decomp,head,in,type,type,info,else,pojo,field,pojo,field,pojo,type,info,get,pojo,field,at,field,index,type,information,field,type,pojo,type,info,get,type,at,field,index,if,decomp,tail,null,suppress,warnings,unchecked,field,accessor,f,f,inner,accessor,new,field,accessor,simple,field,accessor,type,information,f,field,type,return,new,field,accessor,pojo,field,accessor,pojo,field,get,field,inner,accessor,else,suppress,warnings,unchecked,field,accessor,object,f,inner,accessor,field,accessor,factory,get,accessor,type,information,object,field,type,decomp,tail,config,return,new,field,accessor,pojo,field,accessor,pojo,field,get,field,inner,accessor,else,if,type,info,is,tuple,type,tuple,type,info,base,type,info,is,case,class,tuple,type,info,base,tuple,type,info,tuple,type,info,base,type,info,field,expression,decomp,decompose,field,expression,field,int,field,pos,tuple,type,info,get,field,index,decomp,head,if,field,pos,0,throw,new,composite,type,invalid,field,reference,exception,invalid,field,selected,field,if,decomp,tail,null,return,new,field,accessor,simple,product,field,accessor,field,pos,type,info,config,else,suppress,warnings,unchecked,field,accessor,object,f,inner,accessor,get,accessor,tuple,type,info,get,type,at,field,pos,decomp,tail,config,return,new,field,accessor,recursive,product,field,accessor,field,pos,type,info,inner,accessor,config,else,if,type,info,is,tuple,type,tuple,type,info,tuple,type,info,tuple,type,info,type,info,field,expression,decomp,decompose,field,expression,field,int,field,pos,tuple,type,info,get,field,index,decomp,head,if,field,pos,1,try,field,pos,integer,parse,int,decomp,head,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,tried,to,select,field,decomp,head,on,type,info,to,string,only,integer,values,are,allowed,here,if,decomp,tail,null,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,simple,tuple,field,accessor,field,pos,tuple,type,info,return,result,else,suppress,warnings,unchecked,field,accessor,f,inner,accessor,get,accessor,tuple,type,info,get,type,at,field,pos,decomp,tail,config,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,recursive,tuple,field,accessor,field,pos,inner,accessor,tuple,type,info,return,result,else,throw,new,composite,type,invalid,field,reference,exception,cannot,reference,field,by,field,expression,on,type,info,to,string,field,expressions,are,only,supported,on,pojo,types,tuples,and,case,classes,see,the,flink,documentation,on,what,is,considered,a,pojo
FieldAccessorFactory -> @Internal 	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, String field, ExecutionConfig config);1493195810;Creates a {@link FieldAccessor} for the field that is given by a field expression,_which can be used to get and set the specified field on instances of this type.__@param field The field expression_@param config Configuration object_@param <F> The type of the field to access_@return The created FieldAccessor;@Internal_	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, String field, ExecutionConfig config) {__		_		if (typeInfo instanceof BasicArrayTypeInfo || typeInfo instanceof PrimitiveArrayTypeInfo) {_			try {_				return new FieldAccessor.ArrayFieldAccessor<>(Integer.parseInt(field), typeInfo)__			} catch (NumberFormatException ex) {_				throw new CompositeType.InvalidFieldReferenceException_					("A field expression on an array must be an integer index (that might be given as a string).")__			}__		_		} else if (typeInfo instanceof BasicTypeInfo) {_			try {_				int pos = field.equals(Keys.ExpressionKeys.SELECT_ALL_CHAR) ? 0 : Integer.parseInt(field)__				return FieldAccessorFactory.getAccessor(typeInfo, pos, config)__			} catch (NumberFormatException ex) {_				throw new CompositeType.InvalidFieldReferenceException("You tried to select the field \"" + field +_					"\" on a " + typeInfo.toString() + ". A field expression on a basic type can only be \"*\" or \"0\"" +_					" (both of which mean selecting the entire basic type).")__			}__		_		} else if (typeInfo instanceof PojoTypeInfo) {_			FieldExpression decomp = decomposeFieldExpression(field)__			PojoTypeInfo<?> pojoTypeInfo = (PojoTypeInfo) typeInfo___			int fieldIndex = pojoTypeInfo.getFieldIndex(decomp.head)___			if (fieldIndex == -1) {_				throw new CompositeType.InvalidFieldReferenceException(_					"Unable to find field \"" + decomp.head + "\" in type " + typeInfo + ".")__			} else {_				PojoField pojoField = pojoTypeInfo.getPojoFieldAt(fieldIndex)__				TypeInformation<?> fieldType = pojoTypeInfo.getTypeAt(fieldIndex)__				if (decomp.tail == null) {_					@SuppressWarnings("unchecked")_					FieldAccessor<F, F> innerAccessor = new FieldAccessor.SimpleFieldAccessor<>((TypeInformation<F>) fieldType)__					return new FieldAccessor.PojoFieldAccessor<>(pojoField.getField(), innerAccessor)__				} else {_					@SuppressWarnings("unchecked")_					FieldAccessor<Object, F> innerAccessor = FieldAccessorFactory_						.getAccessor((TypeInformation<Object>) fieldType, decomp.tail, config)__					return new FieldAccessor.PojoFieldAccessor<>(pojoField.getField(), innerAccessor)__				}_			}_		_		} else if (typeInfo.isTupleType() && ((TupleTypeInfoBase) typeInfo).isCaseClass()) {_			TupleTypeInfoBase tupleTypeInfo = (TupleTypeInfoBase) typeInfo__			FieldExpression decomp = decomposeFieldExpression(field)__			int fieldPos = tupleTypeInfo.getFieldIndex(decomp.head)__			if (fieldPos < 0) {_				throw new CompositeType.InvalidFieldReferenceException("Invalid field selected: " + field)__			}__			if (decomp.tail == null){_				return new FieldAccessor.SimpleProductFieldAccessor<>(fieldPos, typeInfo, config)__			} else {_				@SuppressWarnings("unchecked")_				FieldAccessor<Object, F> innerAccessor = getAccessor(tupleTypeInfo.getTypeAt(fieldPos), decomp.tail, config)__				return new FieldAccessor.RecursiveProductFieldAccessor<>(fieldPos, typeInfo, innerAccessor, config)__			}__		_		} else if (typeInfo.isTupleType()) {_			TupleTypeInfo tupleTypeInfo = (TupleTypeInfo) typeInfo__			FieldExpression decomp = decomposeFieldExpression(field)__			int fieldPos = tupleTypeInfo.getFieldIndex(decomp.head)__			if (fieldPos == -1) {_				try {_					fieldPos = Integer.parseInt(decomp.head)__				} catch (NumberFormatException ex) {_					throw new CompositeType.InvalidFieldReferenceException("Tried to select field \"" + decomp.head_						+ "\" on " + typeInfo.toString() + " . Only integer values are allowed here.")__				}_			}_			if (decomp.tail == null) {_				@SuppressWarnings("unchecked")_				FieldAccessor<T, F> result = new FieldAccessor.SimpleTupleFieldAccessor(fieldPos, tupleTypeInfo)__				return result__			} else {_				@SuppressWarnings("unchecked")_				FieldAccessor<?, F> innerAccessor = getAccessor(tupleTypeInfo.getTypeAt(fieldPos), decomp.tail, config)__				@SuppressWarnings("unchecked")_				FieldAccessor<T, F> result = new FieldAccessor.RecursiveTupleFieldAccessor(fieldPos, innerAccessor, tupleTypeInfo)__				return result__			}__		_		} else {_			throw new CompositeType.InvalidFieldReferenceException("Cannot reference field by field expression on " + typeInfo.toString()_				+ "Field expressions are only supported on POJO types, tuples, and case classes. "_				+ "(See the Flink documentation on what is considered a POJO.)")__		}_	};creates,a,link,field,accessor,for,the,field,that,is,given,by,a,field,expression,which,can,be,used,to,get,and,set,the,specified,field,on,instances,of,this,type,param,field,the,field,expression,param,config,configuration,object,param,f,the,type,of,the,field,to,access,return,the,created,field,accessor;internal,public,static,t,f,field,accessor,t,f,get,accessor,type,information,t,type,info,string,field,execution,config,config,if,type,info,instanceof,basic,array,type,info,type,info,instanceof,primitive,array,type,info,try,return,new,field,accessor,array,field,accessor,integer,parse,int,field,type,info,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,a,field,expression,on,an,array,must,be,an,integer,index,that,might,be,given,as,a,string,else,if,type,info,instanceof,basic,type,info,try,int,pos,field,equals,keys,expression,keys,0,integer,parse,int,field,return,field,accessor,factory,get,accessor,type,info,pos,config,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,you,tried,to,select,the,field,field,on,a,type,info,to,string,a,field,expression,on,a,basic,type,can,only,be,or,0,both,of,which,mean,selecting,the,entire,basic,type,else,if,type,info,instanceof,pojo,type,info,field,expression,decomp,decompose,field,expression,field,pojo,type,info,pojo,type,info,pojo,type,info,type,info,int,field,index,pojo,type,info,get,field,index,decomp,head,if,field,index,1,throw,new,composite,type,invalid,field,reference,exception,unable,to,find,field,decomp,head,in,type,type,info,else,pojo,field,pojo,field,pojo,type,info,get,pojo,field,at,field,index,type,information,field,type,pojo,type,info,get,type,at,field,index,if,decomp,tail,null,suppress,warnings,unchecked,field,accessor,f,f,inner,accessor,new,field,accessor,simple,field,accessor,type,information,f,field,type,return,new,field,accessor,pojo,field,accessor,pojo,field,get,field,inner,accessor,else,suppress,warnings,unchecked,field,accessor,object,f,inner,accessor,field,accessor,factory,get,accessor,type,information,object,field,type,decomp,tail,config,return,new,field,accessor,pojo,field,accessor,pojo,field,get,field,inner,accessor,else,if,type,info,is,tuple,type,tuple,type,info,base,type,info,is,case,class,tuple,type,info,base,tuple,type,info,tuple,type,info,base,type,info,field,expression,decomp,decompose,field,expression,field,int,field,pos,tuple,type,info,get,field,index,decomp,head,if,field,pos,0,throw,new,composite,type,invalid,field,reference,exception,invalid,field,selected,field,if,decomp,tail,null,return,new,field,accessor,simple,product,field,accessor,field,pos,type,info,config,else,suppress,warnings,unchecked,field,accessor,object,f,inner,accessor,get,accessor,tuple,type,info,get,type,at,field,pos,decomp,tail,config,return,new,field,accessor,recursive,product,field,accessor,field,pos,type,info,inner,accessor,config,else,if,type,info,is,tuple,type,tuple,type,info,tuple,type,info,tuple,type,info,type,info,field,expression,decomp,decompose,field,expression,field,int,field,pos,tuple,type,info,get,field,index,decomp,head,if,field,pos,1,try,field,pos,integer,parse,int,decomp,head,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,tried,to,select,field,decomp,head,on,type,info,to,string,only,integer,values,are,allowed,here,if,decomp,tail,null,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,simple,tuple,field,accessor,field,pos,tuple,type,info,return,result,else,suppress,warnings,unchecked,field,accessor,f,inner,accessor,get,accessor,tuple,type,info,get,type,at,field,pos,decomp,tail,config,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,recursive,tuple,field,accessor,field,pos,inner,accessor,tuple,type,info,return,result,else,throw,new,composite,type,invalid,field,reference,exception,cannot,reference,field,by,field,expression,on,type,info,to,string,field,expressions,are,only,supported,on,pojo,types,tuples,and,case,classes,see,the,flink,documentation,on,what,is,considered,a,pojo
FieldAccessorFactory -> @Internal 	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, String field, ExecutionConfig config);1493195810;Creates a {@link FieldAccessor} for the field that is given by a field expression,_which can be used to get and set the specified field on instances of this type.__@param field The field expression_@param config Configuration object_@param <F> The type of the field to access_@return The created FieldAccessor;@Internal_	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, String field, ExecutionConfig config) {__		_		if (typeInfo instanceof BasicArrayTypeInfo || typeInfo instanceof PrimitiveArrayTypeInfo) {_			try {_				return new FieldAccessor.ArrayFieldAccessor<>(Integer.parseInt(field), typeInfo)__			} catch (NumberFormatException ex) {_				throw new CompositeType.InvalidFieldReferenceException_					("A field expression on an array must be an integer index (that might be given as a string).")__			}__		_		} else if (typeInfo instanceof BasicTypeInfo) {_			try {_				int pos = field.equals(Keys.ExpressionKeys.SELECT_ALL_CHAR) ? 0 : Integer.parseInt(field)__				return FieldAccessorFactory.getAccessor(typeInfo, pos, config)__			} catch (NumberFormatException ex) {_				throw new CompositeType.InvalidFieldReferenceException("You tried to select the field \"" + field +_					"\" on a " + typeInfo.toString() + ". A field expression on a basic type can only be \"*\" or \"0\"" +_					" (both of which mean selecting the entire basic type).")__			}__		_		} else if (typeInfo instanceof PojoTypeInfo) {_			FieldExpression decomp = decomposeFieldExpression(field)__			PojoTypeInfo<?> pojoTypeInfo = (PojoTypeInfo) typeInfo___			int fieldIndex = pojoTypeInfo.getFieldIndex(decomp.head)___			if (fieldIndex == -1) {_				throw new CompositeType.InvalidFieldReferenceException(_					"Unable to find field \"" + decomp.head + "\" in type " + typeInfo + ".")__			} else {_				PojoField pojoField = pojoTypeInfo.getPojoFieldAt(fieldIndex)__				TypeInformation<?> fieldType = pojoTypeInfo.getTypeAt(fieldIndex)__				if (decomp.tail == null) {_					@SuppressWarnings("unchecked")_					FieldAccessor<F, F> innerAccessor = new FieldAccessor.SimpleFieldAccessor<>((TypeInformation<F>) fieldType)__					return new FieldAccessor.PojoFieldAccessor<>(pojoField.getField(), innerAccessor)__				} else {_					@SuppressWarnings("unchecked")_					FieldAccessor<Object, F> innerAccessor = FieldAccessorFactory_						.getAccessor((TypeInformation<Object>) fieldType, decomp.tail, config)__					return new FieldAccessor.PojoFieldAccessor<>(pojoField.getField(), innerAccessor)__				}_			}_		_		} else if (typeInfo.isTupleType() && ((TupleTypeInfoBase) typeInfo).isCaseClass()) {_			TupleTypeInfoBase tupleTypeInfo = (TupleTypeInfoBase) typeInfo__			FieldExpression decomp = decomposeFieldExpression(field)__			int fieldPos = tupleTypeInfo.getFieldIndex(decomp.head)__			if (fieldPos < 0) {_				throw new CompositeType.InvalidFieldReferenceException("Invalid field selected: " + field)__			}__			if (decomp.tail == null){_				return new FieldAccessor.SimpleProductFieldAccessor<>(fieldPos, typeInfo, config)__			} else {_				@SuppressWarnings("unchecked")_				FieldAccessor<Object, F> innerAccessor = getAccessor(tupleTypeInfo.getTypeAt(fieldPos), decomp.tail, config)__				return new FieldAccessor.RecursiveProductFieldAccessor<>(fieldPos, typeInfo, innerAccessor, config)__			}__		_		} else if (typeInfo.isTupleType()) {_			TupleTypeInfo tupleTypeInfo = (TupleTypeInfo) typeInfo__			FieldExpression decomp = decomposeFieldExpression(field)__			int fieldPos = tupleTypeInfo.getFieldIndex(decomp.head)__			if (fieldPos == -1) {_				try {_					fieldPos = Integer.parseInt(decomp.head)__				} catch (NumberFormatException ex) {_					throw new CompositeType.InvalidFieldReferenceException("Tried to select field \"" + decomp.head_						+ "\" on " + typeInfo.toString() + " . Only integer values are allowed here.")__				}_			}_			if (decomp.tail == null) {_				@SuppressWarnings("unchecked")_				FieldAccessor<T, F> result = new FieldAccessor.SimpleTupleFieldAccessor(fieldPos, tupleTypeInfo)__				return result__			} else {_				@SuppressWarnings("unchecked")_				FieldAccessor<?, F> innerAccessor = getAccessor(tupleTypeInfo.getTypeAt(fieldPos), decomp.tail, config)__				@SuppressWarnings("unchecked")_				FieldAccessor<T, F> result = new FieldAccessor.RecursiveTupleFieldAccessor(fieldPos, innerAccessor, tupleTypeInfo)__				return result__			}__		_		} else {_			throw new CompositeType.InvalidFieldReferenceException("Cannot reference field by field expression on " + typeInfo.toString()_				+ "Field expressions are only supported on POJO types, tuples, and case classes. "_				+ "(See the Flink documentation on what is considered a POJO.)")__		}_	};creates,a,link,field,accessor,for,the,field,that,is,given,by,a,field,expression,which,can,be,used,to,get,and,set,the,specified,field,on,instances,of,this,type,param,field,the,field,expression,param,config,configuration,object,param,f,the,type,of,the,field,to,access,return,the,created,field,accessor;internal,public,static,t,f,field,accessor,t,f,get,accessor,type,information,t,type,info,string,field,execution,config,config,if,type,info,instanceof,basic,array,type,info,type,info,instanceof,primitive,array,type,info,try,return,new,field,accessor,array,field,accessor,integer,parse,int,field,type,info,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,a,field,expression,on,an,array,must,be,an,integer,index,that,might,be,given,as,a,string,else,if,type,info,instanceof,basic,type,info,try,int,pos,field,equals,keys,expression,keys,0,integer,parse,int,field,return,field,accessor,factory,get,accessor,type,info,pos,config,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,you,tried,to,select,the,field,field,on,a,type,info,to,string,a,field,expression,on,a,basic,type,can,only,be,or,0,both,of,which,mean,selecting,the,entire,basic,type,else,if,type,info,instanceof,pojo,type,info,field,expression,decomp,decompose,field,expression,field,pojo,type,info,pojo,type,info,pojo,type,info,type,info,int,field,index,pojo,type,info,get,field,index,decomp,head,if,field,index,1,throw,new,composite,type,invalid,field,reference,exception,unable,to,find,field,decomp,head,in,type,type,info,else,pojo,field,pojo,field,pojo,type,info,get,pojo,field,at,field,index,type,information,field,type,pojo,type,info,get,type,at,field,index,if,decomp,tail,null,suppress,warnings,unchecked,field,accessor,f,f,inner,accessor,new,field,accessor,simple,field,accessor,type,information,f,field,type,return,new,field,accessor,pojo,field,accessor,pojo,field,get,field,inner,accessor,else,suppress,warnings,unchecked,field,accessor,object,f,inner,accessor,field,accessor,factory,get,accessor,type,information,object,field,type,decomp,tail,config,return,new,field,accessor,pojo,field,accessor,pojo,field,get,field,inner,accessor,else,if,type,info,is,tuple,type,tuple,type,info,base,type,info,is,case,class,tuple,type,info,base,tuple,type,info,tuple,type,info,base,type,info,field,expression,decomp,decompose,field,expression,field,int,field,pos,tuple,type,info,get,field,index,decomp,head,if,field,pos,0,throw,new,composite,type,invalid,field,reference,exception,invalid,field,selected,field,if,decomp,tail,null,return,new,field,accessor,simple,product,field,accessor,field,pos,type,info,config,else,suppress,warnings,unchecked,field,accessor,object,f,inner,accessor,get,accessor,tuple,type,info,get,type,at,field,pos,decomp,tail,config,return,new,field,accessor,recursive,product,field,accessor,field,pos,type,info,inner,accessor,config,else,if,type,info,is,tuple,type,tuple,type,info,tuple,type,info,tuple,type,info,type,info,field,expression,decomp,decompose,field,expression,field,int,field,pos,tuple,type,info,get,field,index,decomp,head,if,field,pos,1,try,field,pos,integer,parse,int,decomp,head,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,tried,to,select,field,decomp,head,on,type,info,to,string,only,integer,values,are,allowed,here,if,decomp,tail,null,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,simple,tuple,field,accessor,field,pos,tuple,type,info,return,result,else,suppress,warnings,unchecked,field,accessor,f,inner,accessor,get,accessor,tuple,type,info,get,type,at,field,pos,decomp,tail,config,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,recursive,tuple,field,accessor,field,pos,inner,accessor,tuple,type,info,return,result,else,throw,new,composite,type,invalid,field,reference,exception,cannot,reference,field,by,field,expression,on,type,info,to,string,field,expressions,are,only,supported,on,pojo,types,tuples,and,case,classes,see,the,flink,documentation,on,what,is,considered,a,pojo
FieldAccessorFactory -> @Internal 	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, String field, ExecutionConfig config);1493195810;Creates a {@link FieldAccessor} for the field that is given by a field expression,_which can be used to get and set the specified field on instances of this type.__@param field The field expression_@param config Configuration object_@param <F> The type of the field to access_@return The created FieldAccessor;@Internal_	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, String field, ExecutionConfig config) {__		_		if (typeInfo instanceof BasicArrayTypeInfo || typeInfo instanceof PrimitiveArrayTypeInfo) {_			try {_				return new FieldAccessor.ArrayFieldAccessor<>(Integer.parseInt(field), typeInfo)__			} catch (NumberFormatException ex) {_				throw new CompositeType.InvalidFieldReferenceException_					("A field expression on an array must be an integer index (that might be given as a string).")__			}__		_		} else if (typeInfo instanceof BasicTypeInfo) {_			try {_				int pos = field.equals(Keys.ExpressionKeys.SELECT_ALL_CHAR) ? 0 : Integer.parseInt(field)__				return FieldAccessorFactory.getAccessor(typeInfo, pos, config)__			} catch (NumberFormatException ex) {_				throw new CompositeType.InvalidFieldReferenceException("You tried to select the field \"" + field +_					"\" on a " + typeInfo.toString() + ". A field expression on a basic type can only be \"*\" or \"0\"" +_					" (both of which mean selecting the entire basic type).")__			}__		_		} else if (typeInfo instanceof PojoTypeInfo) {_			FieldExpression decomp = decomposeFieldExpression(field)__			PojoTypeInfo<?> pojoTypeInfo = (PojoTypeInfo) typeInfo___			int fieldIndex = pojoTypeInfo.getFieldIndex(decomp.head)___			if (fieldIndex == -1) {_				throw new CompositeType.InvalidFieldReferenceException(_					"Unable to find field \"" + decomp.head + "\" in type " + typeInfo + ".")__			} else {_				PojoField pojoField = pojoTypeInfo.getPojoFieldAt(fieldIndex)__				TypeInformation<?> fieldType = pojoTypeInfo.getTypeAt(fieldIndex)__				if (decomp.tail == null) {_					@SuppressWarnings("unchecked")_					FieldAccessor<F, F> innerAccessor = new FieldAccessor.SimpleFieldAccessor<>((TypeInformation<F>) fieldType)__					return new FieldAccessor.PojoFieldAccessor<>(pojoField.getField(), innerAccessor)__				} else {_					@SuppressWarnings("unchecked")_					FieldAccessor<Object, F> innerAccessor = FieldAccessorFactory_						.getAccessor((TypeInformation<Object>) fieldType, decomp.tail, config)__					return new FieldAccessor.PojoFieldAccessor<>(pojoField.getField(), innerAccessor)__				}_			}_		_		} else if (typeInfo.isTupleType() && ((TupleTypeInfoBase) typeInfo).isCaseClass()) {_			TupleTypeInfoBase tupleTypeInfo = (TupleTypeInfoBase) typeInfo__			FieldExpression decomp = decomposeFieldExpression(field)__			int fieldPos = tupleTypeInfo.getFieldIndex(decomp.head)__			if (fieldPos < 0) {_				throw new CompositeType.InvalidFieldReferenceException("Invalid field selected: " + field)__			}__			if (decomp.tail == null){_				return new FieldAccessor.SimpleProductFieldAccessor<>(fieldPos, typeInfo, config)__			} else {_				@SuppressWarnings("unchecked")_				FieldAccessor<Object, F> innerAccessor = getAccessor(tupleTypeInfo.getTypeAt(fieldPos), decomp.tail, config)__				return new FieldAccessor.RecursiveProductFieldAccessor<>(fieldPos, typeInfo, innerAccessor, config)__			}__		_		} else if (typeInfo.isTupleType()) {_			TupleTypeInfo tupleTypeInfo = (TupleTypeInfo) typeInfo__			FieldExpression decomp = decomposeFieldExpression(field)__			int fieldPos = tupleTypeInfo.getFieldIndex(decomp.head)__			if (fieldPos == -1) {_				try {_					fieldPos = Integer.parseInt(decomp.head)__				} catch (NumberFormatException ex) {_					throw new CompositeType.InvalidFieldReferenceException("Tried to select field \"" + decomp.head_						+ "\" on " + typeInfo.toString() + " . Only integer values are allowed here.")__				}_			}_			if (decomp.tail == null) {_				@SuppressWarnings("unchecked")_				FieldAccessor<T, F> result = new FieldAccessor.SimpleTupleFieldAccessor(fieldPos, tupleTypeInfo)__				return result__			} else {_				@SuppressWarnings("unchecked")_				FieldAccessor<?, F> innerAccessor = getAccessor(tupleTypeInfo.getTypeAt(fieldPos), decomp.tail, config)__				@SuppressWarnings("unchecked")_				FieldAccessor<T, F> result = new FieldAccessor.RecursiveTupleFieldAccessor(fieldPos, innerAccessor, tupleTypeInfo)__				return result__			}__		_		} else {_			throw new CompositeType.InvalidFieldReferenceException("Cannot reference field by field expression on " + typeInfo.toString()_				+ "Field expressions are only supported on POJO types, tuples, and case classes. "_				+ "(See the Flink documentation on what is considered a POJO.)")__		}_	};creates,a,link,field,accessor,for,the,field,that,is,given,by,a,field,expression,which,can,be,used,to,get,and,set,the,specified,field,on,instances,of,this,type,param,field,the,field,expression,param,config,configuration,object,param,f,the,type,of,the,field,to,access,return,the,created,field,accessor;internal,public,static,t,f,field,accessor,t,f,get,accessor,type,information,t,type,info,string,field,execution,config,config,if,type,info,instanceof,basic,array,type,info,type,info,instanceof,primitive,array,type,info,try,return,new,field,accessor,array,field,accessor,integer,parse,int,field,type,info,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,a,field,expression,on,an,array,must,be,an,integer,index,that,might,be,given,as,a,string,else,if,type,info,instanceof,basic,type,info,try,int,pos,field,equals,keys,expression,keys,0,integer,parse,int,field,return,field,accessor,factory,get,accessor,type,info,pos,config,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,you,tried,to,select,the,field,field,on,a,type,info,to,string,a,field,expression,on,a,basic,type,can,only,be,or,0,both,of,which,mean,selecting,the,entire,basic,type,else,if,type,info,instanceof,pojo,type,info,field,expression,decomp,decompose,field,expression,field,pojo,type,info,pojo,type,info,pojo,type,info,type,info,int,field,index,pojo,type,info,get,field,index,decomp,head,if,field,index,1,throw,new,composite,type,invalid,field,reference,exception,unable,to,find,field,decomp,head,in,type,type,info,else,pojo,field,pojo,field,pojo,type,info,get,pojo,field,at,field,index,type,information,field,type,pojo,type,info,get,type,at,field,index,if,decomp,tail,null,suppress,warnings,unchecked,field,accessor,f,f,inner,accessor,new,field,accessor,simple,field,accessor,type,information,f,field,type,return,new,field,accessor,pojo,field,accessor,pojo,field,get,field,inner,accessor,else,suppress,warnings,unchecked,field,accessor,object,f,inner,accessor,field,accessor,factory,get,accessor,type,information,object,field,type,decomp,tail,config,return,new,field,accessor,pojo,field,accessor,pojo,field,get,field,inner,accessor,else,if,type,info,is,tuple,type,tuple,type,info,base,type,info,is,case,class,tuple,type,info,base,tuple,type,info,tuple,type,info,base,type,info,field,expression,decomp,decompose,field,expression,field,int,field,pos,tuple,type,info,get,field,index,decomp,head,if,field,pos,0,throw,new,composite,type,invalid,field,reference,exception,invalid,field,selected,field,if,decomp,tail,null,return,new,field,accessor,simple,product,field,accessor,field,pos,type,info,config,else,suppress,warnings,unchecked,field,accessor,object,f,inner,accessor,get,accessor,tuple,type,info,get,type,at,field,pos,decomp,tail,config,return,new,field,accessor,recursive,product,field,accessor,field,pos,type,info,inner,accessor,config,else,if,type,info,is,tuple,type,tuple,type,info,tuple,type,info,tuple,type,info,type,info,field,expression,decomp,decompose,field,expression,field,int,field,pos,tuple,type,info,get,field,index,decomp,head,if,field,pos,1,try,field,pos,integer,parse,int,decomp,head,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,tried,to,select,field,decomp,head,on,type,info,to,string,only,integer,values,are,allowed,here,if,decomp,tail,null,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,simple,tuple,field,accessor,field,pos,tuple,type,info,return,result,else,suppress,warnings,unchecked,field,accessor,f,inner,accessor,get,accessor,tuple,type,info,get,type,at,field,pos,decomp,tail,config,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,recursive,tuple,field,accessor,field,pos,inner,accessor,tuple,type,info,return,result,else,throw,new,composite,type,invalid,field,reference,exception,cannot,reference,field,by,field,expression,on,type,info,to,string,field,expressions,are,only,supported,on,pojo,types,tuples,and,case,classes,see,the,flink,documentation,on,what,is,considered,a,pojo
FieldAccessorFactory -> @Internal 	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, String field, ExecutionConfig config);1493195810;Creates a {@link FieldAccessor} for the field that is given by a field expression,_which can be used to get and set the specified field on instances of this type.__@param field The field expression_@param config Configuration object_@param <F> The type of the field to access_@return The created FieldAccessor;@Internal_	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, String field, ExecutionConfig config) {__		_		if (typeInfo instanceof BasicArrayTypeInfo || typeInfo instanceof PrimitiveArrayTypeInfo) {_			try {_				return new FieldAccessor.ArrayFieldAccessor<>(Integer.parseInt(field), typeInfo)__			} catch (NumberFormatException ex) {_				throw new CompositeType.InvalidFieldReferenceException_					("A field expression on an array must be an integer index (that might be given as a string).")__			}__		_		} else if (typeInfo instanceof BasicTypeInfo) {_			try {_				int pos = field.equals(Keys.ExpressionKeys.SELECT_ALL_CHAR) ? 0 : Integer.parseInt(field)__				return FieldAccessorFactory.getAccessor(typeInfo, pos, config)__			} catch (NumberFormatException ex) {_				throw new CompositeType.InvalidFieldReferenceException("You tried to select the field \"" + field +_					"\" on a " + typeInfo.toString() + ". A field expression on a basic type can only be \"*\" or \"0\"" +_					" (both of which mean selecting the entire basic type).")__			}__		_		} else if (typeInfo instanceof PojoTypeInfo) {_			FieldExpression decomp = decomposeFieldExpression(field)__			PojoTypeInfo<?> pojoTypeInfo = (PojoTypeInfo) typeInfo___			int fieldIndex = pojoTypeInfo.getFieldIndex(decomp.head)___			if (fieldIndex == -1) {_				throw new CompositeType.InvalidFieldReferenceException(_					"Unable to find field \"" + decomp.head + "\" in type " + typeInfo + ".")__			} else {_				PojoField pojoField = pojoTypeInfo.getPojoFieldAt(fieldIndex)__				TypeInformation<?> fieldType = pojoTypeInfo.getTypeAt(fieldIndex)__				if (decomp.tail == null) {_					@SuppressWarnings("unchecked")_					FieldAccessor<F, F> innerAccessor = new FieldAccessor.SimpleFieldAccessor<>((TypeInformation<F>) fieldType)__					return new FieldAccessor.PojoFieldAccessor<>(pojoField.getField(), innerAccessor)__				} else {_					@SuppressWarnings("unchecked")_					FieldAccessor<Object, F> innerAccessor = FieldAccessorFactory_						.getAccessor((TypeInformation<Object>) fieldType, decomp.tail, config)__					return new FieldAccessor.PojoFieldAccessor<>(pojoField.getField(), innerAccessor)__				}_			}_		_		} else if (typeInfo.isTupleType() && ((TupleTypeInfoBase) typeInfo).isCaseClass()) {_			TupleTypeInfoBase tupleTypeInfo = (TupleTypeInfoBase) typeInfo__			FieldExpression decomp = decomposeFieldExpression(field)__			int fieldPos = tupleTypeInfo.getFieldIndex(decomp.head)__			if (fieldPos < 0) {_				throw new CompositeType.InvalidFieldReferenceException("Invalid field selected: " + field)__			}__			if (decomp.tail == null){_				return new FieldAccessor.SimpleProductFieldAccessor<>(fieldPos, typeInfo, config)__			} else {_				@SuppressWarnings("unchecked")_				FieldAccessor<Object, F> innerAccessor = getAccessor(tupleTypeInfo.getTypeAt(fieldPos), decomp.tail, config)__				return new FieldAccessor.RecursiveProductFieldAccessor<>(fieldPos, typeInfo, innerAccessor, config)__			}__		_		} else if (typeInfo.isTupleType()) {_			TupleTypeInfo tupleTypeInfo = (TupleTypeInfo) typeInfo__			FieldExpression decomp = decomposeFieldExpression(field)__			int fieldPos = tupleTypeInfo.getFieldIndex(decomp.head)__			if (fieldPos == -1) {_				try {_					fieldPos = Integer.parseInt(decomp.head)__				} catch (NumberFormatException ex) {_					throw new CompositeType.InvalidFieldReferenceException("Tried to select field \"" + decomp.head_						+ "\" on " + typeInfo.toString() + " . Only integer values are allowed here.")__				}_			}_			if (decomp.tail == null) {_				@SuppressWarnings("unchecked")_				FieldAccessor<T, F> result = new FieldAccessor.SimpleTupleFieldAccessor(fieldPos, tupleTypeInfo)__				return result__			} else {_				@SuppressWarnings("unchecked")_				FieldAccessor<?, F> innerAccessor = getAccessor(tupleTypeInfo.getTypeAt(fieldPos), decomp.tail, config)__				@SuppressWarnings("unchecked")_				FieldAccessor<T, F> result = new FieldAccessor.RecursiveTupleFieldAccessor(fieldPos, innerAccessor, tupleTypeInfo)__				return result__			}__		_		} else {_			throw new CompositeType.InvalidFieldReferenceException("Cannot reference field by field expression on " + typeInfo.toString()_				+ "Field expressions are only supported on POJO types, tuples, and case classes. "_				+ "(See the Flink documentation on what is considered a POJO.)")__		}_	};creates,a,link,field,accessor,for,the,field,that,is,given,by,a,field,expression,which,can,be,used,to,get,and,set,the,specified,field,on,instances,of,this,type,param,field,the,field,expression,param,config,configuration,object,param,f,the,type,of,the,field,to,access,return,the,created,field,accessor;internal,public,static,t,f,field,accessor,t,f,get,accessor,type,information,t,type,info,string,field,execution,config,config,if,type,info,instanceof,basic,array,type,info,type,info,instanceof,primitive,array,type,info,try,return,new,field,accessor,array,field,accessor,integer,parse,int,field,type,info,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,a,field,expression,on,an,array,must,be,an,integer,index,that,might,be,given,as,a,string,else,if,type,info,instanceof,basic,type,info,try,int,pos,field,equals,keys,expression,keys,0,integer,parse,int,field,return,field,accessor,factory,get,accessor,type,info,pos,config,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,you,tried,to,select,the,field,field,on,a,type,info,to,string,a,field,expression,on,a,basic,type,can,only,be,or,0,both,of,which,mean,selecting,the,entire,basic,type,else,if,type,info,instanceof,pojo,type,info,field,expression,decomp,decompose,field,expression,field,pojo,type,info,pojo,type,info,pojo,type,info,type,info,int,field,index,pojo,type,info,get,field,index,decomp,head,if,field,index,1,throw,new,composite,type,invalid,field,reference,exception,unable,to,find,field,decomp,head,in,type,type,info,else,pojo,field,pojo,field,pojo,type,info,get,pojo,field,at,field,index,type,information,field,type,pojo,type,info,get,type,at,field,index,if,decomp,tail,null,suppress,warnings,unchecked,field,accessor,f,f,inner,accessor,new,field,accessor,simple,field,accessor,type,information,f,field,type,return,new,field,accessor,pojo,field,accessor,pojo,field,get,field,inner,accessor,else,suppress,warnings,unchecked,field,accessor,object,f,inner,accessor,field,accessor,factory,get,accessor,type,information,object,field,type,decomp,tail,config,return,new,field,accessor,pojo,field,accessor,pojo,field,get,field,inner,accessor,else,if,type,info,is,tuple,type,tuple,type,info,base,type,info,is,case,class,tuple,type,info,base,tuple,type,info,tuple,type,info,base,type,info,field,expression,decomp,decompose,field,expression,field,int,field,pos,tuple,type,info,get,field,index,decomp,head,if,field,pos,0,throw,new,composite,type,invalid,field,reference,exception,invalid,field,selected,field,if,decomp,tail,null,return,new,field,accessor,simple,product,field,accessor,field,pos,type,info,config,else,suppress,warnings,unchecked,field,accessor,object,f,inner,accessor,get,accessor,tuple,type,info,get,type,at,field,pos,decomp,tail,config,return,new,field,accessor,recursive,product,field,accessor,field,pos,type,info,inner,accessor,config,else,if,type,info,is,tuple,type,tuple,type,info,tuple,type,info,tuple,type,info,type,info,field,expression,decomp,decompose,field,expression,field,int,field,pos,tuple,type,info,get,field,index,decomp,head,if,field,pos,1,try,field,pos,integer,parse,int,decomp,head,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,tried,to,select,field,decomp,head,on,type,info,to,string,only,integer,values,are,allowed,here,if,decomp,tail,null,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,simple,tuple,field,accessor,field,pos,tuple,type,info,return,result,else,suppress,warnings,unchecked,field,accessor,f,inner,accessor,get,accessor,tuple,type,info,get,type,at,field,pos,decomp,tail,config,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,recursive,tuple,field,accessor,field,pos,inner,accessor,tuple,type,info,return,result,else,throw,new,composite,type,invalid,field,reference,exception,cannot,reference,field,by,field,expression,on,type,info,to,string,field,expressions,are,only,supported,on,pojo,types,tuples,and,case,classes,see,the,flink,documentation,on,what,is,considered,a,pojo
FieldAccessorFactory -> @Internal 	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, String field, ExecutionConfig config);1495484544;Creates a {@link FieldAccessor} for the field that is given by a field expression,_which can be used to get and set the specified field on instances of this type.__@param field The field expression_@param config Configuration object_@param <F> The type of the field to access_@return The created FieldAccessor;@Internal_	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, String field, ExecutionConfig config) {__		_		if (typeInfo instanceof BasicArrayTypeInfo || typeInfo instanceof PrimitiveArrayTypeInfo) {_			try {_				return new FieldAccessor.ArrayFieldAccessor<>(Integer.parseInt(field), typeInfo)__			} catch (NumberFormatException ex) {_				throw new CompositeType.InvalidFieldReferenceException_					("A field expression on an array must be an integer index (that might be given as a string).")__			}__		_		} else if (typeInfo instanceof BasicTypeInfo) {_			try {_				int pos = field.equals(Keys.ExpressionKeys.SELECT_ALL_CHAR) ? 0 : Integer.parseInt(field)__				return FieldAccessorFactory.getAccessor(typeInfo, pos, config)__			} catch (NumberFormatException ex) {_				throw new CompositeType.InvalidFieldReferenceException("You tried to select the field \"" + field +_					"\" on a " + typeInfo.toString() + ". A field expression on a basic type can only be \"*\" or \"0\"" +_					" (both of which mean selecting the entire basic type).")__			}__		_		} else if (typeInfo instanceof PojoTypeInfo) {_			FieldExpression decomp = decomposeFieldExpression(field)__			PojoTypeInfo<?> pojoTypeInfo = (PojoTypeInfo) typeInfo___			int fieldIndex = pojoTypeInfo.getFieldIndex(decomp.head)___			if (fieldIndex == -1) {_				throw new CompositeType.InvalidFieldReferenceException(_					"Unable to find field \"" + decomp.head + "\" in type " + typeInfo + ".")__			} else {_				PojoField pojoField = pojoTypeInfo.getPojoFieldAt(fieldIndex)__				TypeInformation<?> fieldType = pojoTypeInfo.getTypeAt(fieldIndex)__				if (decomp.tail == null) {_					@SuppressWarnings("unchecked")_					FieldAccessor<F, F> innerAccessor = new FieldAccessor.SimpleFieldAccessor<>((TypeInformation<F>) fieldType)__					return new FieldAccessor.PojoFieldAccessor<>(pojoField.getField(), innerAccessor)__				} else {_					@SuppressWarnings("unchecked")_					FieldAccessor<Object, F> innerAccessor = FieldAccessorFactory_						.getAccessor((TypeInformation<Object>) fieldType, decomp.tail, config)__					return new FieldAccessor.PojoFieldAccessor<>(pojoField.getField(), innerAccessor)__				}_			}_		_		} else if (typeInfo.isTupleType() && ((TupleTypeInfoBase) typeInfo).isCaseClass()) {_			TupleTypeInfoBase tupleTypeInfo = (TupleTypeInfoBase) typeInfo__			FieldExpression decomp = decomposeFieldExpression(field)__			int fieldPos = tupleTypeInfo.getFieldIndex(decomp.head)__			if (fieldPos < 0) {_				throw new CompositeType.InvalidFieldReferenceException("Invalid field selected: " + field)__			}__			if (decomp.tail == null){_				return new FieldAccessor.SimpleProductFieldAccessor<>(fieldPos, typeInfo, config)__			} else {_				@SuppressWarnings("unchecked")_				FieldAccessor<Object, F> innerAccessor = getAccessor(tupleTypeInfo.getTypeAt(fieldPos), decomp.tail, config)__				return new FieldAccessor.RecursiveProductFieldAccessor<>(fieldPos, typeInfo, innerAccessor, config)__			}__		_		} else if (typeInfo.isTupleType()) {_			TupleTypeInfo tupleTypeInfo = (TupleTypeInfo) typeInfo__			FieldExpression decomp = decomposeFieldExpression(field)__			int fieldPos = tupleTypeInfo.getFieldIndex(decomp.head)__			if (fieldPos == -1) {_				try {_					fieldPos = Integer.parseInt(decomp.head)__				} catch (NumberFormatException ex) {_					throw new CompositeType.InvalidFieldReferenceException("Tried to select field \"" + decomp.head_						+ "\" on " + typeInfo.toString() + " . Only integer values are allowed here.")__				}_			}_			if (decomp.tail == null) {_				@SuppressWarnings("unchecked")_				FieldAccessor<T, F> result = new FieldAccessor.SimpleTupleFieldAccessor(fieldPos, tupleTypeInfo)__				return result__			} else {_				@SuppressWarnings("unchecked")_				FieldAccessor<?, F> innerAccessor = getAccessor(tupleTypeInfo.getTypeAt(fieldPos), decomp.tail, config)__				@SuppressWarnings("unchecked")_				FieldAccessor<T, F> result = new FieldAccessor.RecursiveTupleFieldAccessor(fieldPos, innerAccessor, tupleTypeInfo)__				return result__			}__		_		} else {_			throw new CompositeType.InvalidFieldReferenceException("Cannot reference field by field expression on " + typeInfo.toString()_				+ "Field expressions are only supported on POJO types, tuples, and case classes. "_				+ "(See the Flink documentation on what is considered a POJO.)")__		}_	};creates,a,link,field,accessor,for,the,field,that,is,given,by,a,field,expression,which,can,be,used,to,get,and,set,the,specified,field,on,instances,of,this,type,param,field,the,field,expression,param,config,configuration,object,param,f,the,type,of,the,field,to,access,return,the,created,field,accessor;internal,public,static,t,f,field,accessor,t,f,get,accessor,type,information,t,type,info,string,field,execution,config,config,if,type,info,instanceof,basic,array,type,info,type,info,instanceof,primitive,array,type,info,try,return,new,field,accessor,array,field,accessor,integer,parse,int,field,type,info,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,a,field,expression,on,an,array,must,be,an,integer,index,that,might,be,given,as,a,string,else,if,type,info,instanceof,basic,type,info,try,int,pos,field,equals,keys,expression,keys,0,integer,parse,int,field,return,field,accessor,factory,get,accessor,type,info,pos,config,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,you,tried,to,select,the,field,field,on,a,type,info,to,string,a,field,expression,on,a,basic,type,can,only,be,or,0,both,of,which,mean,selecting,the,entire,basic,type,else,if,type,info,instanceof,pojo,type,info,field,expression,decomp,decompose,field,expression,field,pojo,type,info,pojo,type,info,pojo,type,info,type,info,int,field,index,pojo,type,info,get,field,index,decomp,head,if,field,index,1,throw,new,composite,type,invalid,field,reference,exception,unable,to,find,field,decomp,head,in,type,type,info,else,pojo,field,pojo,field,pojo,type,info,get,pojo,field,at,field,index,type,information,field,type,pojo,type,info,get,type,at,field,index,if,decomp,tail,null,suppress,warnings,unchecked,field,accessor,f,f,inner,accessor,new,field,accessor,simple,field,accessor,type,information,f,field,type,return,new,field,accessor,pojo,field,accessor,pojo,field,get,field,inner,accessor,else,suppress,warnings,unchecked,field,accessor,object,f,inner,accessor,field,accessor,factory,get,accessor,type,information,object,field,type,decomp,tail,config,return,new,field,accessor,pojo,field,accessor,pojo,field,get,field,inner,accessor,else,if,type,info,is,tuple,type,tuple,type,info,base,type,info,is,case,class,tuple,type,info,base,tuple,type,info,tuple,type,info,base,type,info,field,expression,decomp,decompose,field,expression,field,int,field,pos,tuple,type,info,get,field,index,decomp,head,if,field,pos,0,throw,new,composite,type,invalid,field,reference,exception,invalid,field,selected,field,if,decomp,tail,null,return,new,field,accessor,simple,product,field,accessor,field,pos,type,info,config,else,suppress,warnings,unchecked,field,accessor,object,f,inner,accessor,get,accessor,tuple,type,info,get,type,at,field,pos,decomp,tail,config,return,new,field,accessor,recursive,product,field,accessor,field,pos,type,info,inner,accessor,config,else,if,type,info,is,tuple,type,tuple,type,info,tuple,type,info,tuple,type,info,type,info,field,expression,decomp,decompose,field,expression,field,int,field,pos,tuple,type,info,get,field,index,decomp,head,if,field,pos,1,try,field,pos,integer,parse,int,decomp,head,catch,number,format,exception,ex,throw,new,composite,type,invalid,field,reference,exception,tried,to,select,field,decomp,head,on,type,info,to,string,only,integer,values,are,allowed,here,if,decomp,tail,null,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,simple,tuple,field,accessor,field,pos,tuple,type,info,return,result,else,suppress,warnings,unchecked,field,accessor,f,inner,accessor,get,accessor,tuple,type,info,get,type,at,field,pos,decomp,tail,config,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,recursive,tuple,field,accessor,field,pos,inner,accessor,tuple,type,info,return,result,else,throw,new,composite,type,invalid,field,reference,exception,cannot,reference,field,by,field,expression,on,type,info,to,string,field,expressions,are,only,supported,on,pojo,types,tuples,and,case,classes,see,the,flink,documentation,on,what,is,considered,a,pojo
FieldAccessorFactory -> @Internal 	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, int pos, ExecutionConfig config);1480022575;Creates a {@link FieldAccessor} for the given field position, which can be used to get and set_the specified field on instances of this type.__@param pos The field position (zero-based)_@param config Configuration object_@param <F> The type of the field to access_@return The created FieldAccessor;@Internal_	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, int pos, ExecutionConfig config){__		_		if (typeInfo instanceof BasicArrayTypeInfo || typeInfo instanceof PrimitiveArrayTypeInfo) {_			return new FieldAccessor.ArrayFieldAccessor<>(pos, typeInfo)___		_		} else if (typeInfo instanceof BasicTypeInfo) {_			if (pos != 0) {_				throw new CompositeType.InvalidFieldReferenceException("The " + ((Integer) pos).toString() + ". field selected on a " +_					"basic type (" + typeInfo.toString() + "). A field expression on a basic type can only select " +_					"the 0th field (which means selecting the entire basic type).")__			}_			@SuppressWarnings("unchecked")_			FieldAccessor<T, F> result = (FieldAccessor<T, F>) new FieldAccessor.SimpleFieldAccessor<>(typeInfo)__			return result___		_		} else if (typeInfo.isTupleType() && ((TupleTypeInfoBase) typeInfo).isCaseClass()) {_			TupleTypeInfoBase tupleTypeInfo = (TupleTypeInfoBase) typeInfo__			@SuppressWarnings("unchecked")_			TypeInformation<F> fieldTypeInfo = (TypeInformation<F>)tupleTypeInfo.getTypeAt(pos)__			return new FieldAccessor.RecursiveProductFieldAccessor<>(_				pos, typeInfo, new FieldAccessor.SimpleFieldAccessor<>(fieldTypeInfo), config)___		_		} else if (typeInfo.isTupleType()) {_			@SuppressWarnings("unchecked")_			FieldAccessor<T, F> result = new FieldAccessor.SimpleTupleFieldAccessor(pos, typeInfo)__			return result___		_		} else {_			throw new CompositeType.InvalidFieldReferenceException("Cannot reference field by position on " + typeInfo.toString()_				+ "Referencing a field by position is supported on tuples, case classes, and arrays. "_				+ "Additionally, you can select the 0th field of a primitive/basic type (e.g. int).")__		}_	};creates,a,link,field,accessor,for,the,given,field,position,which,can,be,used,to,get,and,set,the,specified,field,on,instances,of,this,type,param,pos,the,field,position,zero,based,param,config,configuration,object,param,f,the,type,of,the,field,to,access,return,the,created,field,accessor;internal,public,static,t,f,field,accessor,t,f,get,accessor,type,information,t,type,info,int,pos,execution,config,config,if,type,info,instanceof,basic,array,type,info,type,info,instanceof,primitive,array,type,info,return,new,field,accessor,array,field,accessor,pos,type,info,else,if,type,info,instanceof,basic,type,info,if,pos,0,throw,new,composite,type,invalid,field,reference,exception,the,integer,pos,to,string,field,selected,on,a,basic,type,type,info,to,string,a,field,expression,on,a,basic,type,can,only,select,the,0th,field,which,means,selecting,the,entire,basic,type,suppress,warnings,unchecked,field,accessor,t,f,result,field,accessor,t,f,new,field,accessor,simple,field,accessor,type,info,return,result,else,if,type,info,is,tuple,type,tuple,type,info,base,type,info,is,case,class,tuple,type,info,base,tuple,type,info,tuple,type,info,base,type,info,suppress,warnings,unchecked,type,information,f,field,type,info,type,information,f,tuple,type,info,get,type,at,pos,return,new,field,accessor,recursive,product,field,accessor,pos,type,info,new,field,accessor,simple,field,accessor,field,type,info,config,else,if,type,info,is,tuple,type,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,simple,tuple,field,accessor,pos,type,info,return,result,else,throw,new,composite,type,invalid,field,reference,exception,cannot,reference,field,by,position,on,type,info,to,string,referencing,a,field,by,position,is,supported,on,tuples,case,classes,and,arrays,additionally,you,can,select,the,0th,field,of,a,primitive,basic,type,e,g,int
FieldAccessorFactory -> @Internal 	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, int pos, ExecutionConfig config);1493195810;Creates a {@link FieldAccessor} for the given field position, which can be used to get and set_the specified field on instances of this type.__@param pos The field position (zero-based)_@param config Configuration object_@param <F> The type of the field to access_@return The created FieldAccessor;@Internal_	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, int pos, ExecutionConfig config){__		_		if (typeInfo instanceof BasicArrayTypeInfo || typeInfo instanceof PrimitiveArrayTypeInfo) {_			return new FieldAccessor.ArrayFieldAccessor<>(pos, typeInfo)___		_		} else if (typeInfo instanceof BasicTypeInfo) {_			if (pos != 0) {_				throw new CompositeType.InvalidFieldReferenceException("The " + ((Integer) pos).toString() + ". field selected on a " +_					"basic type (" + typeInfo.toString() + "). A field expression on a basic type can only select " +_					"the 0th field (which means selecting the entire basic type).")__			}_			@SuppressWarnings("unchecked")_			FieldAccessor<T, F> result = (FieldAccessor<T, F>) new FieldAccessor.SimpleFieldAccessor<>(typeInfo)__			return result___		_		} else if (typeInfo.isTupleType() && ((TupleTypeInfoBase) typeInfo).isCaseClass()) {_			TupleTypeInfoBase tupleTypeInfo = (TupleTypeInfoBase) typeInfo__			@SuppressWarnings("unchecked")_			TypeInformation<F> fieldTypeInfo = (TypeInformation<F>)tupleTypeInfo.getTypeAt(pos)__			return new FieldAccessor.RecursiveProductFieldAccessor<>(_				pos, typeInfo, new FieldAccessor.SimpleFieldAccessor<>(fieldTypeInfo), config)___		_		} else if (typeInfo.isTupleType()) {_			@SuppressWarnings("unchecked")_			FieldAccessor<T, F> result = new FieldAccessor.SimpleTupleFieldAccessor(pos, typeInfo)__			return result___		_		} else {_			throw new CompositeType.InvalidFieldReferenceException("Cannot reference field by position on " + typeInfo.toString()_				+ "Referencing a field by position is supported on tuples, case classes, and arrays. "_				+ "Additionally, you can select the 0th field of a primitive/basic type (e.g. int).")__		}_	};creates,a,link,field,accessor,for,the,given,field,position,which,can,be,used,to,get,and,set,the,specified,field,on,instances,of,this,type,param,pos,the,field,position,zero,based,param,config,configuration,object,param,f,the,type,of,the,field,to,access,return,the,created,field,accessor;internal,public,static,t,f,field,accessor,t,f,get,accessor,type,information,t,type,info,int,pos,execution,config,config,if,type,info,instanceof,basic,array,type,info,type,info,instanceof,primitive,array,type,info,return,new,field,accessor,array,field,accessor,pos,type,info,else,if,type,info,instanceof,basic,type,info,if,pos,0,throw,new,composite,type,invalid,field,reference,exception,the,integer,pos,to,string,field,selected,on,a,basic,type,type,info,to,string,a,field,expression,on,a,basic,type,can,only,select,the,0th,field,which,means,selecting,the,entire,basic,type,suppress,warnings,unchecked,field,accessor,t,f,result,field,accessor,t,f,new,field,accessor,simple,field,accessor,type,info,return,result,else,if,type,info,is,tuple,type,tuple,type,info,base,type,info,is,case,class,tuple,type,info,base,tuple,type,info,tuple,type,info,base,type,info,suppress,warnings,unchecked,type,information,f,field,type,info,type,information,f,tuple,type,info,get,type,at,pos,return,new,field,accessor,recursive,product,field,accessor,pos,type,info,new,field,accessor,simple,field,accessor,field,type,info,config,else,if,type,info,is,tuple,type,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,simple,tuple,field,accessor,pos,type,info,return,result,else,throw,new,composite,type,invalid,field,reference,exception,cannot,reference,field,by,position,on,type,info,to,string,referencing,a,field,by,position,is,supported,on,tuples,case,classes,and,arrays,additionally,you,can,select,the,0th,field,of,a,primitive,basic,type,e,g,int
FieldAccessorFactory -> @Internal 	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, int pos, ExecutionConfig config);1493195810;Creates a {@link FieldAccessor} for the given field position, which can be used to get and set_the specified field on instances of this type.__@param pos The field position (zero-based)_@param config Configuration object_@param <F> The type of the field to access_@return The created FieldAccessor;@Internal_	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, int pos, ExecutionConfig config){__		_		if (typeInfo instanceof BasicArrayTypeInfo || typeInfo instanceof PrimitiveArrayTypeInfo) {_			return new FieldAccessor.ArrayFieldAccessor<>(pos, typeInfo)___		_		} else if (typeInfo instanceof BasicTypeInfo) {_			if (pos != 0) {_				throw new CompositeType.InvalidFieldReferenceException("The " + ((Integer) pos).toString() + ". field selected on a " +_					"basic type (" + typeInfo.toString() + "). A field expression on a basic type can only select " +_					"the 0th field (which means selecting the entire basic type).")__			}_			@SuppressWarnings("unchecked")_			FieldAccessor<T, F> result = (FieldAccessor<T, F>) new FieldAccessor.SimpleFieldAccessor<>(typeInfo)__			return result___		_		} else if (typeInfo.isTupleType() && ((TupleTypeInfoBase) typeInfo).isCaseClass()) {_			TupleTypeInfoBase tupleTypeInfo = (TupleTypeInfoBase) typeInfo__			@SuppressWarnings("unchecked")_			TypeInformation<F> fieldTypeInfo = (TypeInformation<F>)tupleTypeInfo.getTypeAt(pos)__			return new FieldAccessor.RecursiveProductFieldAccessor<>(_				pos, typeInfo, new FieldAccessor.SimpleFieldAccessor<>(fieldTypeInfo), config)___		_		} else if (typeInfo.isTupleType()) {_			@SuppressWarnings("unchecked")_			FieldAccessor<T, F> result = new FieldAccessor.SimpleTupleFieldAccessor(pos, typeInfo)__			return result___		_		} else {_			throw new CompositeType.InvalidFieldReferenceException("Cannot reference field by position on " + typeInfo.toString()_				+ "Referencing a field by position is supported on tuples, case classes, and arrays. "_				+ "Additionally, you can select the 0th field of a primitive/basic type (e.g. int).")__		}_	};creates,a,link,field,accessor,for,the,given,field,position,which,can,be,used,to,get,and,set,the,specified,field,on,instances,of,this,type,param,pos,the,field,position,zero,based,param,config,configuration,object,param,f,the,type,of,the,field,to,access,return,the,created,field,accessor;internal,public,static,t,f,field,accessor,t,f,get,accessor,type,information,t,type,info,int,pos,execution,config,config,if,type,info,instanceof,basic,array,type,info,type,info,instanceof,primitive,array,type,info,return,new,field,accessor,array,field,accessor,pos,type,info,else,if,type,info,instanceof,basic,type,info,if,pos,0,throw,new,composite,type,invalid,field,reference,exception,the,integer,pos,to,string,field,selected,on,a,basic,type,type,info,to,string,a,field,expression,on,a,basic,type,can,only,select,the,0th,field,which,means,selecting,the,entire,basic,type,suppress,warnings,unchecked,field,accessor,t,f,result,field,accessor,t,f,new,field,accessor,simple,field,accessor,type,info,return,result,else,if,type,info,is,tuple,type,tuple,type,info,base,type,info,is,case,class,tuple,type,info,base,tuple,type,info,tuple,type,info,base,type,info,suppress,warnings,unchecked,type,information,f,field,type,info,type,information,f,tuple,type,info,get,type,at,pos,return,new,field,accessor,recursive,product,field,accessor,pos,type,info,new,field,accessor,simple,field,accessor,field,type,info,config,else,if,type,info,is,tuple,type,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,simple,tuple,field,accessor,pos,type,info,return,result,else,throw,new,composite,type,invalid,field,reference,exception,cannot,reference,field,by,position,on,type,info,to,string,referencing,a,field,by,position,is,supported,on,tuples,case,classes,and,arrays,additionally,you,can,select,the,0th,field,of,a,primitive,basic,type,e,g,int
FieldAccessorFactory -> @Internal 	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, int pos, ExecutionConfig config);1493195810;Creates a {@link FieldAccessor} for the given field position, which can be used to get and set_the specified field on instances of this type.__@param pos The field position (zero-based)_@param config Configuration object_@param <F> The type of the field to access_@return The created FieldAccessor;@Internal_	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, int pos, ExecutionConfig config){__		_		if (typeInfo instanceof BasicArrayTypeInfo || typeInfo instanceof PrimitiveArrayTypeInfo) {_			return new FieldAccessor.ArrayFieldAccessor<>(pos, typeInfo)___		_		} else if (typeInfo instanceof BasicTypeInfo) {_			if (pos != 0) {_				throw new CompositeType.InvalidFieldReferenceException("The " + ((Integer) pos).toString() + ". field selected on a " +_					"basic type (" + typeInfo.toString() + "). A field expression on a basic type can only select " +_					"the 0th field (which means selecting the entire basic type).")__			}_			@SuppressWarnings("unchecked")_			FieldAccessor<T, F> result = (FieldAccessor<T, F>) new FieldAccessor.SimpleFieldAccessor<>(typeInfo)__			return result___		_		} else if (typeInfo.isTupleType() && ((TupleTypeInfoBase) typeInfo).isCaseClass()) {_			TupleTypeInfoBase tupleTypeInfo = (TupleTypeInfoBase) typeInfo__			@SuppressWarnings("unchecked")_			TypeInformation<F> fieldTypeInfo = (TypeInformation<F>) tupleTypeInfo.getTypeAt(pos)__			return new FieldAccessor.RecursiveProductFieldAccessor<>(_				pos, typeInfo, new FieldAccessor.SimpleFieldAccessor<>(fieldTypeInfo), config)___		_		} else if (typeInfo.isTupleType()) {_			@SuppressWarnings("unchecked")_			FieldAccessor<T, F> result = new FieldAccessor.SimpleTupleFieldAccessor(pos, typeInfo)__			return result___		_		} else {_			throw new CompositeType.InvalidFieldReferenceException("Cannot reference field by position on " + typeInfo.toString()_				+ "Referencing a field by position is supported on tuples, case classes, and arrays. "_				+ "Additionally, you can select the 0th field of a primitive/basic type (e.g. int).")__		}_	};creates,a,link,field,accessor,for,the,given,field,position,which,can,be,used,to,get,and,set,the,specified,field,on,instances,of,this,type,param,pos,the,field,position,zero,based,param,config,configuration,object,param,f,the,type,of,the,field,to,access,return,the,created,field,accessor;internal,public,static,t,f,field,accessor,t,f,get,accessor,type,information,t,type,info,int,pos,execution,config,config,if,type,info,instanceof,basic,array,type,info,type,info,instanceof,primitive,array,type,info,return,new,field,accessor,array,field,accessor,pos,type,info,else,if,type,info,instanceof,basic,type,info,if,pos,0,throw,new,composite,type,invalid,field,reference,exception,the,integer,pos,to,string,field,selected,on,a,basic,type,type,info,to,string,a,field,expression,on,a,basic,type,can,only,select,the,0th,field,which,means,selecting,the,entire,basic,type,suppress,warnings,unchecked,field,accessor,t,f,result,field,accessor,t,f,new,field,accessor,simple,field,accessor,type,info,return,result,else,if,type,info,is,tuple,type,tuple,type,info,base,type,info,is,case,class,tuple,type,info,base,tuple,type,info,tuple,type,info,base,type,info,suppress,warnings,unchecked,type,information,f,field,type,info,type,information,f,tuple,type,info,get,type,at,pos,return,new,field,accessor,recursive,product,field,accessor,pos,type,info,new,field,accessor,simple,field,accessor,field,type,info,config,else,if,type,info,is,tuple,type,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,simple,tuple,field,accessor,pos,type,info,return,result,else,throw,new,composite,type,invalid,field,reference,exception,cannot,reference,field,by,position,on,type,info,to,string,referencing,a,field,by,position,is,supported,on,tuples,case,classes,and,arrays,additionally,you,can,select,the,0th,field,of,a,primitive,basic,type,e,g,int
FieldAccessorFactory -> @Internal 	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, int pos, ExecutionConfig config);1493195810;Creates a {@link FieldAccessor} for the given field position, which can be used to get and set_the specified field on instances of this type.__@param pos The field position (zero-based)_@param config Configuration object_@param <F> The type of the field to access_@return The created FieldAccessor;@Internal_	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, int pos, ExecutionConfig config){__		_		if (typeInfo instanceof BasicArrayTypeInfo || typeInfo instanceof PrimitiveArrayTypeInfo) {_			return new FieldAccessor.ArrayFieldAccessor<>(pos, typeInfo)___		_		} else if (typeInfo instanceof BasicTypeInfo) {_			if (pos != 0) {_				throw new CompositeType.InvalidFieldReferenceException("The " + ((Integer) pos).toString() + ". field selected on a " +_					"basic type (" + typeInfo.toString() + "). A field expression on a basic type can only select " +_					"the 0th field (which means selecting the entire basic type).")__			}_			@SuppressWarnings("unchecked")_			FieldAccessor<T, F> result = (FieldAccessor<T, F>) new FieldAccessor.SimpleFieldAccessor<>(typeInfo)__			return result___		_		} else if (typeInfo.isTupleType() && ((TupleTypeInfoBase) typeInfo).isCaseClass()) {_			TupleTypeInfoBase tupleTypeInfo = (TupleTypeInfoBase) typeInfo__			@SuppressWarnings("unchecked")_			TypeInformation<F> fieldTypeInfo = (TypeInformation<F>) tupleTypeInfo.getTypeAt(pos)__			return new FieldAccessor.RecursiveProductFieldAccessor<>(_				pos, typeInfo, new FieldAccessor.SimpleFieldAccessor<>(fieldTypeInfo), config)___		_		} else if (typeInfo.isTupleType()) {_			@SuppressWarnings("unchecked")_			FieldAccessor<T, F> result = new FieldAccessor.SimpleTupleFieldAccessor(pos, typeInfo)__			return result___		_		} else {_			throw new CompositeType.InvalidFieldReferenceException("Cannot reference field by position on " + typeInfo.toString()_				+ "Referencing a field by position is supported on tuples, case classes, and arrays. "_				+ "Additionally, you can select the 0th field of a primitive/basic type (e.g. int).")__		}_	};creates,a,link,field,accessor,for,the,given,field,position,which,can,be,used,to,get,and,set,the,specified,field,on,instances,of,this,type,param,pos,the,field,position,zero,based,param,config,configuration,object,param,f,the,type,of,the,field,to,access,return,the,created,field,accessor;internal,public,static,t,f,field,accessor,t,f,get,accessor,type,information,t,type,info,int,pos,execution,config,config,if,type,info,instanceof,basic,array,type,info,type,info,instanceof,primitive,array,type,info,return,new,field,accessor,array,field,accessor,pos,type,info,else,if,type,info,instanceof,basic,type,info,if,pos,0,throw,new,composite,type,invalid,field,reference,exception,the,integer,pos,to,string,field,selected,on,a,basic,type,type,info,to,string,a,field,expression,on,a,basic,type,can,only,select,the,0th,field,which,means,selecting,the,entire,basic,type,suppress,warnings,unchecked,field,accessor,t,f,result,field,accessor,t,f,new,field,accessor,simple,field,accessor,type,info,return,result,else,if,type,info,is,tuple,type,tuple,type,info,base,type,info,is,case,class,tuple,type,info,base,tuple,type,info,tuple,type,info,base,type,info,suppress,warnings,unchecked,type,information,f,field,type,info,type,information,f,tuple,type,info,get,type,at,pos,return,new,field,accessor,recursive,product,field,accessor,pos,type,info,new,field,accessor,simple,field,accessor,field,type,info,config,else,if,type,info,is,tuple,type,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,simple,tuple,field,accessor,pos,type,info,return,result,else,throw,new,composite,type,invalid,field,reference,exception,cannot,reference,field,by,position,on,type,info,to,string,referencing,a,field,by,position,is,supported,on,tuples,case,classes,and,arrays,additionally,you,can,select,the,0th,field,of,a,primitive,basic,type,e,g,int
FieldAccessorFactory -> @Internal 	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, int pos, ExecutionConfig config);1495484544;Creates a {@link FieldAccessor} for the given field position, which can be used to get and set_the specified field on instances of this type.__@param pos The field position (zero-based)_@param config Configuration object_@param <F> The type of the field to access_@return The created FieldAccessor;@Internal_	public static <T, F> FieldAccessor<T, F> getAccessor(TypeInformation<T> typeInfo, int pos, ExecutionConfig config){__		_		if (typeInfo instanceof BasicArrayTypeInfo || typeInfo instanceof PrimitiveArrayTypeInfo) {_			return new FieldAccessor.ArrayFieldAccessor<>(pos, typeInfo)___		_		} else if (typeInfo instanceof BasicTypeInfo) {_			if (pos != 0) {_				throw new CompositeType.InvalidFieldReferenceException("The " + ((Integer) pos).toString() + ". field selected on a " +_					"basic type (" + typeInfo.toString() + "). A field expression on a basic type can only select " +_					"the 0th field (which means selecting the entire basic type).")__			}_			@SuppressWarnings("unchecked")_			FieldAccessor<T, F> result = (FieldAccessor<T, F>) new FieldAccessor.SimpleFieldAccessor<>(typeInfo)__			return result___		_		} else if (typeInfo.isTupleType() && ((TupleTypeInfoBase) typeInfo).isCaseClass()) {_			TupleTypeInfoBase tupleTypeInfo = (TupleTypeInfoBase) typeInfo__			@SuppressWarnings("unchecked")_			TypeInformation<F> fieldTypeInfo = (TypeInformation<F>) tupleTypeInfo.getTypeAt(pos)__			return new FieldAccessor.RecursiveProductFieldAccessor<>(_				pos, typeInfo, new FieldAccessor.SimpleFieldAccessor<>(fieldTypeInfo), config)___		_		} else if (typeInfo.isTupleType()) {_			@SuppressWarnings("unchecked")_			FieldAccessor<T, F> result = new FieldAccessor.SimpleTupleFieldAccessor(pos, typeInfo)__			return result___		_		} else {_			throw new CompositeType.InvalidFieldReferenceException("Cannot reference field by position on " + typeInfo.toString()_				+ "Referencing a field by position is supported on tuples, case classes, and arrays. "_				+ "Additionally, you can select the 0th field of a primitive/basic type (e.g. int).")__		}_	};creates,a,link,field,accessor,for,the,given,field,position,which,can,be,used,to,get,and,set,the,specified,field,on,instances,of,this,type,param,pos,the,field,position,zero,based,param,config,configuration,object,param,f,the,type,of,the,field,to,access,return,the,created,field,accessor;internal,public,static,t,f,field,accessor,t,f,get,accessor,type,information,t,type,info,int,pos,execution,config,config,if,type,info,instanceof,basic,array,type,info,type,info,instanceof,primitive,array,type,info,return,new,field,accessor,array,field,accessor,pos,type,info,else,if,type,info,instanceof,basic,type,info,if,pos,0,throw,new,composite,type,invalid,field,reference,exception,the,integer,pos,to,string,field,selected,on,a,basic,type,type,info,to,string,a,field,expression,on,a,basic,type,can,only,select,the,0th,field,which,means,selecting,the,entire,basic,type,suppress,warnings,unchecked,field,accessor,t,f,result,field,accessor,t,f,new,field,accessor,simple,field,accessor,type,info,return,result,else,if,type,info,is,tuple,type,tuple,type,info,base,type,info,is,case,class,tuple,type,info,base,tuple,type,info,tuple,type,info,base,type,info,suppress,warnings,unchecked,type,information,f,field,type,info,type,information,f,tuple,type,info,get,type,at,pos,return,new,field,accessor,recursive,product,field,accessor,pos,type,info,new,field,accessor,simple,field,accessor,field,type,info,config,else,if,type,info,is,tuple,type,suppress,warnings,unchecked,field,accessor,t,f,result,new,field,accessor,simple,tuple,field,accessor,pos,type,info,return,result,else,throw,new,composite,type,invalid,field,reference,exception,cannot,reference,field,by,position,on,type,info,to,string,referencing,a,field,by,position,is,supported,on,tuples,case,classes,and,arrays,additionally,you,can,select,the,0th,field,of,a,primitive,basic,type,e,g,int
