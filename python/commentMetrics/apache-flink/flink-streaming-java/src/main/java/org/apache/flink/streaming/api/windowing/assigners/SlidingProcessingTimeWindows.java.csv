commented;modifiers;parameterAmount;loc;comment;code
false;public;3;12;;@Override public Collection<TimeWindow> assignWindows(Object element, long timestamp, WindowAssignerContext context) {     timestamp = context.getCurrentProcessingTime().     List<TimeWindow> windows = new ArrayList<>((int) (size / slide)).     long lastStart = TimeWindow.getWindowStartWithOffset(timestamp, offset, slide).     for (long start = lastStart. start > timestamp - size. start -= slide) {         windows.add(new TimeWindow(start, start + size)).     }     return windows. }
false;public;0;3;;public long getSize() {     return size. }
false;public;0;3;;public long getSlide() {     return slide. }
false;public;1;4;;@Override public Trigger<Object, TimeWindow> getDefaultTrigger(StreamExecutionEnvironment env) {     return ProcessingTimeTrigger.create(). }
false;public;0;4;;@Override public String toString() {     return "SlidingProcessingTimeWindows(" + size + ", " + slide + ")". }
true;public,static;2;3;/**  * Creates a new {@code SlidingProcessingTimeWindows} {@link WindowAssigner} that assigns  * elements to sliding time windows based on the element timestamp.  *  * @param size The size of the generated windows.  * @param slide The slide interval of the generated windows.  * @return The time policy.  */ ;/**  * Creates a new {@code SlidingProcessingTimeWindows} {@link WindowAssigner} that assigns  * elements to sliding time windows based on the element timestamp.  *  * @param size The size of the generated windows.  * @param slide The slide interval of the generated windows.  * @return The time policy.  */ public static SlidingProcessingTimeWindows of(Time size, Time slide) {     return new SlidingProcessingTimeWindows(size.toMilliseconds(), slide.toMilliseconds(), 0). }
true;public,static;3;3;/**  * Creates a new {@code SlidingProcessingTimeWindows} {@link WindowAssigner} that assigns  * elements to time windows based on the element timestamp and offset.  *  * <p>For example, if you want window a stream by hour,but window begins at the 15th minutes  * of each hour, you can use {@code of(Time.hours(1),Time.minutes(15))},then you will get  * time windows start at 0:15:00,1:15:00,2:15:00,etc.  *  * <p>Rather than that,if you are living in somewhere which is not using UTC±00:00 time,  * such as China which is using UTC+08:00,and you want a time window with size of one day,  * and window begins at every 00:00:00 of local time,you may use {@code of(Time.days(1),Time.hours(-8))}.  * The parameter of offset is {@code Time.hours(-8))} since UTC+08:00 is 8 hours earlier than UTC time.  *  * @param size The size of the generated windows.  * @param slide  The slide interval of the generated windows.  * @param offset The offset which window start would be shifted by.  * @return The time policy.  */ ;/**  * Creates a new {@code SlidingProcessingTimeWindows} {@link WindowAssigner} that assigns  * elements to time windows based on the element timestamp and offset.  *  * <p>For example, if you want window a stream by hour,but window begins at the 15th minutes  * of each hour, you can use {@code of(Time.hours(1),Time.minutes(15))},then you will get  * time windows start at 0:15:00,1:15:00,2:15:00,etc.  *  * <p>Rather than that,if you are living in somewhere which is not using UTC±00:00 time,  * such as China which is using UTC+08:00,and you want a time window with size of one day,  * and window begins at every 00:00:00 of local time,you may use {@code of(Time.days(1),Time.hours(-8))}.  * The parameter of offset is {@code Time.hours(-8))} since UTC+08:00 is 8 hours earlier than UTC time.  *  * @param size The size of the generated windows.  * @param slide  The slide interval of the generated windows.  * @param offset The offset which window start would be shifted by.  * @return The time policy.  */ public static SlidingProcessingTimeWindows of(Time size, Time slide, Time offset) {     return new SlidingProcessingTimeWindows(size.toMilliseconds(), slide.toMilliseconds(), offset.toMilliseconds()). }
false;public;1;4;;@Override public TypeSerializer<TimeWindow> getWindowSerializer(ExecutionConfig executionConfig) {     return new TimeWindow.Serializer(). }
false;public;0;4;;@Override public boolean isEventTime() {     return false. }
