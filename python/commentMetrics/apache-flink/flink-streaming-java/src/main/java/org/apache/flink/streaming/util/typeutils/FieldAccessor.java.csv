commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Gets the TypeInformation for the type of the field.  * Note: For an array of a primitive type, it returns the corresponding basic type (Integer for int[]).  */ ;/**  * Gets the TypeInformation for the type of the field.  * Note: For an array of a primitive type, it returns the corresponding basic type (Integer for int[]).  */ @SuppressWarnings("unchecked") public TypeInformation<F> getFieldType() {     return fieldType. }
true;public,abstract;1;1;/**  * Gets the value of the field (specified in the constructor) of the given record.  * @param record The record on which the field will be accessed  * @return The value of the field.  */ ;/**  * Gets the value of the field (specified in the constructor) of the given record.  * @param record The record on which the field will be accessed  * @return The value of the field.  */ public abstract F get(T record).
true;public,abstract;2;1;/**  * Sets the field (specified in the constructor) of the given record to the given value.  *  * <p>Warning: This might modify the original object, or might return a new object instance.  * (This is necessary, because the record might be immutable.)  *  * @param record The record to modify  * @param fieldValue The new value of the field  * @return A record that has the given field value. (this might be a new instance or the original)  */ ;/**  * Sets the field (specified in the constructor) of the given record to the given value.  *  * <p>Warning: This might modify the original object, or might return a new object instance.  * (This is necessary, because the record might be immutable.)  *  * @param record The record to modify  * @param fieldValue The new value of the field  * @return A record that has the given field value. (this might be a new instance or the original)  */ public abstract T set(T record, F fieldValue).
false;public;1;4;;@Override public T get(T record) {     return record. }
false;public;2;4;;@Override public T set(T record, T fieldValue) {     return fieldValue. }
false;public;1;5;;@SuppressWarnings("unchecked") @Override public F get(T record) {     return (F) Array.get(record, pos). }
false;public;2;5;;@Override public T set(T record, F fieldValue) {     Array.set(record, pos, fieldValue).     return record. }
false;public;1;5;;@SuppressWarnings("unchecked") @Override public F get(T record) {     return (F) record.getField(pos). }
false;public;2;5;;@Override public T set(T record, F fieldValue) {     record.setField(fieldValue, pos).     return record. }
false;public;1;5;;@Override public F get(T record) {     final R inner = record.getField(pos).     return innerAccessor.get(inner). }
false;public;2;6;;@Override public T set(T record, F fieldValue) {     final R inner = record.getField(pos).     record.setField(innerAccessor.set(inner, fieldValue), pos).     return record. }
false;public;1;12;;@Override public F get(T pojo) {     try {         @SuppressWarnings("unchecked")         final R inner = (R) field.get(pojo).         return innerAccessor.get(inner).     } catch (IllegalAccessException iaex) {         // The Field class is transient and when deserializing its value we also make it accessible         throw new RuntimeException("This should not happen since we call setAccesssible(true) in readObject." + " fields: " + field + " obj: " + pojo).     } }
false;public;2;13;;@Override public T set(T pojo, F valueToSet) {     try {         @SuppressWarnings("unchecked")         final R inner = (R) field.get(pojo).         field.set(pojo, innerAccessor.set(inner, valueToSet)).         return pojo.     } catch (IllegalAccessException iaex) {         // The Field class is transient and when deserializing its value we also make it accessible         throw new RuntimeException("This should not happen since we call setAccesssible(true) in readObject." + " fields: " + field + " obj: " + pojo).     } }
false;private;1;5;;private void writeObject(ObjectOutputStream out) throws IOException, ClassNotFoundException {     out.defaultWriteObject().     FieldSerializer.serializeField(field, out). }
false;private;1;5;;private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {     in.defaultReadObject().     field = FieldSerializer.deserializeField(in). }
false;public;1;6;;@SuppressWarnings("unchecked") @Override public F get(T record) {     Product prod = (Product) record.     return (F) prod.productElement(pos). }
false;public;2;9;;@Override public T set(T record, F fieldValue) {     Product prod = (Product) record.     for (int i = 0. i < length. i++) {         fields[i] = prod.productElement(i).     }     fields[pos] = fieldValue.     return serializer.createInstance(fields). }
false;public;1;5;;@SuppressWarnings("unchecked") @Override public F get(T record) {     return innerAccessor.get((R) ((Product) record).productElement(pos)). }
false;public;2;10;;@SuppressWarnings("unchecked") @Override public T set(T record, F fieldValue) {     Product prod = (Product) record.     for (int i = 0. i < length. i++) {         fields[i] = prod.productElement(i).     }     fields[pos] = innerAccessor.set((R) fields[pos], fieldValue).     return serializer.createInstance(fields). }
