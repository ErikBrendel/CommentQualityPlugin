commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the input split provider associated with the operator.  *  * @return The input split provider.  */ ;// ------------------------------------------------------------------------ /**  * Returns the input split provider associated with the operator.  *  * @return The input split provider.  */ public InputSplitProvider getInputSplitProvider() {     return taskEnvironment.getInputSplitProvider(). }
false;public;0;3;;public ProcessingTimeService getProcessingTimeService() {     return operator.getProcessingTimeService(). }
true;public;0;3;/**  * Returns the global aggregate manager for the current job.  * @return The global aggregate manager.  */ ;/**  * Returns the global aggregate manager for the current job.  * @return The global aggregate manager.  */ public GlobalAggregateManager getGlobalAggregateManager() {     return taskEnvironment.getGlobalAggregateManager(). }
true;public;0;3;/**  * Returned value is guaranteed to be unique between operators within the same job and to be  * stable and the same across job submissions.  *  * <p>This operation is currently only supported in Streaming (DataStream) contexts.  *  * @return String representation of the operator's unique id.  */ ;/**  * Returned value is guaranteed to be unique between operators within the same job and to be  * stable and the same across job submissions.  *  * <p>This operation is currently only supported in Streaming (DataStream) contexts.  *  * @return String representation of the operator's unique id.  */ public String getOperatorUniqueID() {     return operatorUniqueID. }
false;public;1;4;;// ------------------------------------------------------------------------ // broadcast variables // ------------------------------------------------------------------------ @Override public boolean hasBroadcastVariable(String name) {     throw new UnsupportedOperationException("Broadcast variables can only be used in DataSet programs"). }
false;public;1;4;;@Override public <RT> List<RT> getBroadcastVariable(String name) {     throw new UnsupportedOperationException("Broadcast variables can only be used in DataSet programs"). }
false;public;2;4;;@Override public <T, C> C getBroadcastVariableWithInitializer(String name, BroadcastVariableInitializer<T, C> initializer) {     throw new UnsupportedOperationException("Broadcast variables can only be used in DataSet programs"). }
false;public;1;6;;// ------------------------------------------------------------------------ // key/value state // ------------------------------------------------------------------------ @Override public <T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties) {     KeyedStateStore keyedStateStore = checkPreconditionsAndGetKeyedStateStore(stateProperties).     stateProperties.initializeSerializerUnlessSet(getExecutionConfig()).     return keyedStateStore.getState(stateProperties). }
false;public;1;6;;@Override public <T> ListState<T> getListState(ListStateDescriptor<T> stateProperties) {     KeyedStateStore keyedStateStore = checkPreconditionsAndGetKeyedStateStore(stateProperties).     stateProperties.initializeSerializerUnlessSet(getExecutionConfig()).     return keyedStateStore.getListState(stateProperties). }
false;public;1;6;;@Override public <T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties) {     KeyedStateStore keyedStateStore = checkPreconditionsAndGetKeyedStateStore(stateProperties).     stateProperties.initializeSerializerUnlessSet(getExecutionConfig()).     return keyedStateStore.getReducingState(stateProperties). }
false;public;1;6;;@Override public <IN, ACC, OUT> AggregatingState<IN, OUT> getAggregatingState(AggregatingStateDescriptor<IN, ACC, OUT> stateProperties) {     KeyedStateStore keyedStateStore = checkPreconditionsAndGetKeyedStateStore(stateProperties).     stateProperties.initializeSerializerUnlessSet(getExecutionConfig()).     return keyedStateStore.getAggregatingState(stateProperties). }
false;public;1;6;;@Override public <T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties) {     KeyedStateStore keyedStateStore = checkPreconditionsAndGetKeyedStateStore(stateProperties).     stateProperties.initializeSerializerUnlessSet(getExecutionConfig()).     return keyedStateStore.getFoldingState(stateProperties). }
false;public;1;6;;@Override public <UK, UV> MapState<UK, UV> getMapState(MapStateDescriptor<UK, UV> stateProperties) {     KeyedStateStore keyedStateStore = checkPreconditionsAndGetKeyedStateStore(stateProperties).     stateProperties.initializeSerializerUnlessSet(getExecutionConfig()).     return keyedStateStore.getMapState(stateProperties). }
false;private;1;6;;private KeyedStateStore checkPreconditionsAndGetKeyedStateStore(StateDescriptor<?, ?> stateDescriptor) {     Preconditions.checkNotNull(stateDescriptor, "The state properties must not be null").     KeyedStateStore keyedStateStore = operator.getKeyedStateStore().     Preconditions.checkNotNull(keyedStateStore, "Keyed state can only be used on a 'keyed stream', i.e., after a 'keyBy()' operation.").     return keyedStateStore. }
true;public;0;3;/**  * Returns true if checkpointing is enabled for the running job.  *  * @return true if checkpointing is enabled.  */ ;// ------------------ expose (read only) relevant information from the stream config -------- // /**  * Returns true if checkpointing is enabled for the running job.  *  * @return true if checkpointing is enabled.  */ public boolean isCheckpointingEnabled() {     return streamConfig.isCheckpointingEnabled(). }
true;public;0;3;/**  * Returns the checkpointing mode.  *  * @return checkpointing mode  */ ;/**  * Returns the checkpointing mode.  *  * @return checkpointing mode  */ public CheckpointingMode getCheckpointMode() {     return streamConfig.getCheckpointMode(). }
true;public;0;3;/**  * Returns the buffer timeout of the job.  *  * @return buffer timeout (in milliseconds)  */ ;/**  * Returns the buffer timeout of the job.  *  * @return buffer timeout (in milliseconds)  */ public long getBufferTimeout() {     return streamConfig.getBufferTimeout(). }
