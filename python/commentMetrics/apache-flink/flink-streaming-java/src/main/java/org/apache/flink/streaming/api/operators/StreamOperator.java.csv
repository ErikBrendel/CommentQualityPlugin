commented;modifiers;parameterAmount;loc;comment;code
true;;3;1;/**  * Initializes the operator. Sets access to the context and the output.  */ ;// ------------------------------------------------------------------------ // life cycle // ------------------------------------------------------------------------ /**  * Initializes the operator. Sets access to the context and the output.  */ void setup(StreamTask<?, ?> containingTask, StreamConfig config, Output<StreamRecord<OUT>> output).
true;;0;1;/**  * This method is called immediately before any elements are processed, it should contain the  * operator's initialization logic.  *  * @throws java.lang.Exception An exception in this method causes the operator to fail.  */ ;/**  * This method is called immediately before any elements are processed, it should contain the  * operator's initialization logic.  *  * @throws java.lang.Exception An exception in this method causes the operator to fail.  */ void open() throws Exception.
true;;0;1;/**  * This method is called after all records have been added to the operators via the methods  * {@link org.apache.flink.streaming.api.operators.OneInputStreamOperator#processElement(StreamRecord)}, or  * {@link org.apache.flink.streaming.api.operators.TwoInputStreamOperator#processElement1(StreamRecord)} and  * {@link org.apache.flink.streaming.api.operators.TwoInputStreamOperator#processElement2(StreamRecord)}.  *  * <p>The method is expected to flush all remaining buffered data. Exceptions during this  * flushing of buffered should be propagated, in order to cause the operation to be recognized  * as failed, because the last data items are not processed properly.  *  * @throws java.lang.Exception An exception in this method causes the operator to fail.  */ ;/**  * This method is called after all records have been added to the operators via the methods  * {@link org.apache.flink.streaming.api.operators.OneInputStreamOperator#processElement(StreamRecord)}, or  * {@link org.apache.flink.streaming.api.operators.TwoInputStreamOperator#processElement1(StreamRecord)} and  * {@link org.apache.flink.streaming.api.operators.TwoInputStreamOperator#processElement2(StreamRecord)}.  *  * <p>The method is expected to flush all remaining buffered data. Exceptions during this  * flushing of buffered should be propagated, in order to cause the operation to be recognized  * as failed, because the last data items are not processed properly.  *  * @throws java.lang.Exception An exception in this method causes the operator to fail.  */ void close() throws Exception.
true;;0;2;/**  * This method is called at the very end of the operator's life, both in the case of a successful  * completion of the operation, and in the case of a failure and canceling.  *  * <p>This method is expected to make a thorough effort to release all resources  * that the operator has acquired.  */ ;/**  * This method is called at the very end of the operator's life, both in the case of a successful  * completion of the operation, and in the case of a failure and canceling.  *  * <p>This method is expected to make a thorough effort to release all resources  * that the operator has acquired.  */ @Override void dispose() throws Exception.
true;;1;1;/**  * This method is called when the operator should do a snapshot, before it emits its  * own checkpoint barrier.  *  * <p>This method is intended not for any actual state persistence, but only for emitting some  * data before emitting the checkpoint barrier. Operators that maintain some small transient state  * that is inefficient to checkpoint (especially when it would need to be checkpointed in a  * re-scalable way) but can simply be sent downstream before the checkpoint. An example are  * opportunistic pre-aggregation operators, which have small the pre-aggregation state that is  * frequently flushed downstream.  *  * <p><b>Important:</b> This method should not be used for any actual state snapshot logic, because  * it will inherently be within the synchronous part of the operator's checkpoint. If heavy work is done  * within this method, it will affect latency and downstream checkpoint alignments.  *  * @param checkpointId The ID of the checkpoint.  * @throws Exception Throwing an exception here causes the operator to fail and go into recovery.  */ ;// ------------------------------------------------------------------------ // state snapshots // ------------------------------------------------------------------------ /**  * This method is called when the operator should do a snapshot, before it emits its  * own checkpoint barrier.  *  * <p>This method is intended not for any actual state persistence, but only for emitting some  * data before emitting the checkpoint barrier. Operators that maintain some small transient state  * that is inefficient to checkpoint (especially when it would need to be checkpointed in a  * re-scalable way) but can simply be sent downstream before the checkpoint. An example are  * opportunistic pre-aggregation operators, which have small the pre-aggregation state that is  * frequently flushed downstream.  *  * <p><b>Important:</b> This method should not be used for any actual state snapshot logic, because  * it will inherently be within the synchronous part of the operator's checkpoint. If heavy work is done  * within this method, it will affect latency and downstream checkpoint alignments.  *  * @param checkpointId The ID of the checkpoint.  * @throws Exception Throwing an exception here causes the operator to fail and go into recovery.  */ void prepareSnapshotPreBarrier(long checkpointId) throws Exception.
true;;4;5;/**  * Called to draw a state snapshot from the operator.  *  * @return a runnable future to the state handle that points to the snapshotted state. For synchronous implementations,  * the runnable might already be finished.  *  * @throws Exception exception that happened during snapshotting.  */ ;/**  * Called to draw a state snapshot from the operator.  *  * @return a runnable future to the state handle that points to the snapshotted state. For synchronous implementations,  * the runnable might already be finished.  *  * @throws Exception exception that happened during snapshotting.  */ OperatorSnapshotFutures snapshotState(long checkpointId, long timestamp, CheckpointOptions checkpointOptions, CheckpointStreamFactory storageLocation) throws Exception.
true;;0;1;/**  * Provides a context to initialize all state in the operator.  */ ;/**  * Provides a context to initialize all state in the operator.  */ void initializeState() throws Exception.
false;;1;1;;// ------------------------------------------------------------------------ // miscellaneous // ------------------------------------------------------------------------ void setKeyContextElement1(StreamRecord<?> record) throws Exception.
false;;1;1;;void setKeyContextElement2(StreamRecord<?> record) throws Exception.
false;;0;1;;ChainingStrategy getChainingStrategy().
false;;1;1;;void setChainingStrategy(ChainingStrategy strategy).
false;;0;1;;MetricGroup getMetricGroup().
false;;0;1;;OperatorID getOperatorID().
