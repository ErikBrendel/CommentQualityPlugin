commented;modifiers;parameterAmount;loc;comment;code
false;public;1;20;;@Override public void triggerCheckpoint(long checkpointId) throws FlinkException {     // TODO - we need to see how to derive those. We should probably not encode this in the     // TODO -   source's trigger message, but do a handshake in this task between the trigger     // TODO -   message from the master, and the source's trigger notification     final CheckpointOptions checkpointOptions = CheckpointOptions.forCheckpointWithDefaultLocation().     final long timestamp = System.currentTimeMillis().     final CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp).     try {         SourceStreamTask.super.triggerCheckpoint(checkpointMetaData, checkpointOptions).     } catch (RuntimeException | FlinkException e) {         throw e.     } catch (Exception e) {         throw new FlinkException(e.getMessage(), e).     } }
false;protected;0;35;;@Override protected void init() {     // we check if the source is actually inducing the checkpoints, rather     // than the trigger     SourceFunction<?> source = headOperator.getUserFunction().     if (source instanceof ExternallyInducedSource) {         externallyInducedCheckpoints = true.         ExternallyInducedSource.CheckpointTrigger triggerHook = new ExternallyInducedSource.CheckpointTrigger() {              @Override             public void triggerCheckpoint(long checkpointId) throws FlinkException {                 // TODO - we need to see how to derive those. We should probably not encode this in the                 // TODO -   source's trigger message, but do a handshake in this task between the trigger                 // TODO -   message from the master, and the source's trigger notification                 final CheckpointOptions checkpointOptions = CheckpointOptions.forCheckpointWithDefaultLocation().                 final long timestamp = System.currentTimeMillis().                 final CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp).                 try {                     SourceStreamTask.super.triggerCheckpoint(checkpointMetaData, checkpointOptions).                 } catch (RuntimeException | FlinkException e) {                     throw e.                 } catch (Exception e) {                     throw new FlinkException(e.getMessage(), e).                 }             }         }.         ((ExternallyInducedSource<?, ?>) source).setCheckpointTrigger(triggerHook).     } }
false;protected;0;4;;@Override protected void cleanup() { // does not hold any resources, so no cleanup needed }
false;protected;0;4;;@Override protected void run() throws Exception {     headOperator.run(getCheckpointLock(), getStreamStatusMaintainer()). }
false;protected;0;6;;@Override protected void cancelTask() throws Exception {     if (headOperator != null) {         headOperator.cancel().     } }
false;public;2;12;;// ------------------------------------------------------------------------ // Checkpointing // ------------------------------------------------------------------------ @Override public boolean triggerCheckpoint(CheckpointMetaData checkpointMetaData, CheckpointOptions checkpointOptions) throws Exception {     if (!externallyInducedCheckpoints) {         return super.triggerCheckpoint(checkpointMetaData, checkpointOptions).     } else {         // we do not trigger checkpoints here, we simply state whether we can trigger them         synchronized (getCheckpointLock()) {             return isRunning().         }     } }
