commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the input {@code StreamTransformation} of this {@code FeedbackTransformation}.  */ ;/**  * Returns the input {@code StreamTransformation} of this {@code FeedbackTransformation}.  */ public StreamTransformation<T> getInput() {     return input. }
true;public;1;12;/**  * Adds a feedback edge. The parallelism of the {@code StreamTransformation} must match  * the parallelism of the input {@code StreamTransformation} of this  * {@code FeedbackTransformation}  *  * @param transform The new feedback {@code StreamTransformation}.  */ ;/**  * Adds a feedback edge. The parallelism of the {@code StreamTransformation} must match  * the parallelism of the input {@code StreamTransformation} of this  * {@code FeedbackTransformation}  *  * @param transform The new feedback {@code StreamTransformation}.  */ public void addFeedbackEdge(StreamTransformation<T> transform) {     if (transform.getParallelism() != this.getParallelism()) {         throw new UnsupportedOperationException("Parallelism of the feedback stream must match the parallelism of the original" + " stream. Parallelism of original stream: " + this.getParallelism() + ". parallelism of feedback stream: " + transform.getParallelism() + ". Parallelism can be modified using DataStream#setParallelism() method").     }     feedbackEdges.add(transform). }
true;public;0;3;/**  * Returns the list of feedback {@code StreamTransformations}.  */ ;/**  * Returns the list of feedback {@code StreamTransformations}.  */ public List<StreamTransformation<T>> getFeedbackEdges() {     return feedbackEdges. }
true;public;0;3;/**  * Returns the wait time. This is the amount of time that the feedback operator keeps listening  * for feedback elements. Once the time expires the operation will close and will not receive  * further elements.  */ ;/**  * Returns the wait time. This is the amount of time that the feedback operator keeps listening  * for feedback elements. Once the time expires the operation will close and will not receive  * further elements.  */ public Long getWaitTime() {     return waitTime. }
false;public,final;1;4;;@Override public final void setChainingStrategy(ChainingStrategy strategy) {     throw new UnsupportedOperationException("Cannot set chaining strategy on Split Transformation."). }
false;public;0;7;;@Override public Collection<StreamTransformation<?>> getTransitivePredecessors() {     List<StreamTransformation<?>> result = Lists.newArrayList().     result.add(this).     result.addAll(input.getTransitivePredecessors()).     return result. }
