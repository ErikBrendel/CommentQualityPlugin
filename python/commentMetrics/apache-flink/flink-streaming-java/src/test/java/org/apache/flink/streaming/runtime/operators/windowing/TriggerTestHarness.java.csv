commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setCurrentKey(Object key) { // ignore }
false;public;0;4;;@Override public Object getCurrentKey() {     return KEY. }
false;public;0;3;;public int numProcessingTimeTimers() {     return internalTimerService.numProcessingTimeTimers(). }
false;public;1;3;;public int numProcessingTimeTimers(W window) {     return internalTimerService.numProcessingTimeTimers(window). }
false;public;0;3;;public int numEventTimeTimers() {     return internalTimerService.numEventTimeTimers(). }
false;public;1;3;;public int numEventTimeTimers(W window) {     return internalTimerService.numEventTimeTimers(window). }
false;public;0;3;;public int numStateEntries() {     return stateBackend.numKeyValueStateEntries(). }
false;public;1;3;;public int numStateEntries(W window) {     return stateBackend.numKeyValueStateEntries(window). }
true;public;2;9;/**  * Injects one element into the trigger for the given window and returns the result of  * {@link Trigger#onElement(Object, long, Window, Trigger.TriggerContext)}.  */ ;/**  * Injects one element into the trigger for the given window and returns the result of  * {@link Trigger#onElement(Object, long, Window, Trigger.TriggerContext)}.  */ public TriggerResult processElement(StreamRecord<T> element, W window) throws Exception {     TestTriggerContext<Integer, W> triggerContext = new TestTriggerContext<>(KEY, window, internalTimerService, stateBackend, windowSerializer).     return trigger.onElement(element.getValue(), element.getTimestamp(), window, triggerContext). }
true;public;2;15;/**  * Advanced processing time and checks whether we have exactly one firing for the given  * window. The result of {@link Trigger#onProcessingTime(long, Window, Trigger.TriggerContext)}  * is returned for that firing.  */ ;/**  * Advanced processing time and checks whether we have exactly one firing for the given  * window. The result of {@link Trigger#onProcessingTime(long, Window, Trigger.TriggerContext)}  * is returned for that firing.  */ public TriggerResult advanceProcessingTime(long time, W window) throws Exception {     Collection<Tuple2<W, TriggerResult>> firings = advanceProcessingTime(time).     if (firings.size() != 1) {         throw new IllegalStateException("Must have exactly one timer firing. Fired timers: " + firings).     }     Tuple2<W, TriggerResult> firing = firings.iterator().next().     if (!firing.f0.equals(window)) {         throw new IllegalStateException("Trigger fired for another window.").     }     return firing.f1. }
true;public;2;15;/**  * Advanced the watermark and checks whether we have exactly one firing for the given  * window. The result of {@link Trigger#onEventTime(long, Window, Trigger.TriggerContext)}  * is returned for that firing.  */ ;/**  * Advanced the watermark and checks whether we have exactly one firing for the given  * window. The result of {@link Trigger#onEventTime(long, Window, Trigger.TriggerContext)}  * is returned for that firing.  */ public TriggerResult advanceWatermark(long time, W window) throws Exception {     Collection<Tuple2<W, TriggerResult>> firings = advanceWatermark(time).     if (firings.size() != 1) {         throw new IllegalStateException("Must have exactly one timer firing. Fired timers: " + firings).     }     Tuple2<W, TriggerResult> firing = firings.iterator().next().     if (!firing.f0.equals(window)) {         throw new IllegalStateException("Trigger fired for another window.").     }     return firing.f1. }
true;public;1;22;/**  * Advanced processing time and processes any timers that fire because of this. The  * window and {@link TriggerResult} for each firing are returned.  */ ;/**  * Advanced processing time and processes any timers that fire because of this. The  * window and {@link TriggerResult} for each firing are returned.  */ public Collection<Tuple2<W, TriggerResult>> advanceProcessingTime(long time) throws Exception {     Collection<TestInternalTimerService.Timer<Integer, W>> firedTimers = internalTimerService.advanceProcessingTime(time).     Collection<Tuple2<W, TriggerResult>> result = new ArrayList<>().     for (TestInternalTimerService.Timer<Integer, W> timer : firedTimers) {         TestTriggerContext<Integer, W> triggerContext = new TestTriggerContext<>(KEY, timer.getNamespace(), internalTimerService, stateBackend, windowSerializer).         TriggerResult triggerResult = trigger.onProcessingTime(timer.getTimestamp(), timer.getNamespace(), triggerContext).         result.add(new Tuple2<>(timer.getNamespace(), triggerResult)).     }     return result. }
true;public;1;13;/**  * Advanced the watermark and processes any timers that fire because of this. The  * window and {@link TriggerResult} for each firing are returned.  */ ;/**  * Advanced the watermark and processes any timers that fire because of this. The  * window and {@link TriggerResult} for each firing are returned.  */ public Collection<Tuple2<W, TriggerResult>> advanceWatermark(long time) throws Exception {     Collection<TestInternalTimerService.Timer<Integer, W>> firedTimers = internalTimerService.advanceWatermark(time).     Collection<Tuple2<W, TriggerResult>> result = new ArrayList<>().     for (TestInternalTimerService.Timer<Integer, W> timer : firedTimers) {         TriggerResult triggerResult = invokeOnEventTime(timer).         result.add(new Tuple2<>(timer.getNamespace(), triggerResult)).     }     return result. }
false;private;1;10;;private TriggerResult invokeOnEventTime(TestInternalTimerService.Timer<Integer, W> timer) throws Exception {     TestTriggerContext<Integer, W> triggerContext = new TestTriggerContext<>(KEY, timer.getNamespace(), internalTimerService, stateBackend, windowSerializer).     return trigger.onEventTime(timer.getTimestamp(), timer.getNamespace(), triggerContext). }
true;public;2;6;/**  * Manually invoke {@link Trigger#onEventTime(long, Window, Trigger.TriggerContext)} with  * the given parameters.  */ ;/**  * Manually invoke {@link Trigger#onEventTime(long, Window, Trigger.TriggerContext)} with  * the given parameters.  */ public TriggerResult invokeOnEventTime(long timestamp, W window) throws Exception {     TestInternalTimerService.Timer<Integer, W> timer = new TestInternalTimerService.Timer<>(timestamp, KEY, window).     return invokeOnEventTime(timer). }
true;public;2;14;/**  * Calls {@link Trigger#onMerge(Window, Trigger.OnMergeContext)} with the given  * parameters. This also calls {@link Trigger#clear(Window, Trigger.TriggerContext)} on the  * merged windows as does {@link WindowOperator}.  */ ;/**  * Calls {@link Trigger#onMerge(Window, Trigger.OnMergeContext)} with the given  * parameters. This also calls {@link Trigger#clear(Window, Trigger.TriggerContext)} on the  * merged windows as does {@link WindowOperator}.  */ public void mergeWindows(W targetWindow, Collection<W> mergedWindows) throws Exception {     TestOnMergeContext<Integer, W> onMergeContext = new TestOnMergeContext<>(KEY, targetWindow, mergedWindows, internalTimerService, stateBackend, windowSerializer).     trigger.onMerge(targetWindow, onMergeContext).     for (W mergedWindow : mergedWindows) {         clearTriggerState(mergedWindow).     } }
true;public;1;9;/**  * Calls {@link Trigger#clear(Window, Trigger.TriggerContext)} for the given window.  */ ;/**  * Calls {@link Trigger#clear(Window, Trigger.TriggerContext)} for the given window.  */ public void clearTriggerState(W window) throws Exception {     TestTriggerContext<Integer, W> triggerContext = new TestTriggerContext<>(KEY, window, internalTimerService, stateBackend, windowSerializer).     trigger.clear(window, triggerContext). }
false;public;0;4;;@Override public long getCurrentProcessingTime() {     return timerService.currentProcessingTime(). }
false;public;0;4;;@Override public MetricGroup getMetricGroup() {     return null. }
false;public;0;4;;@Override public long getCurrentWatermark() {     return timerService.currentWatermark(). }
false;public;1;4;;@Override public void registerProcessingTimeTimer(long time) {     timerService.registerProcessingTimeTimer(window, time). }
false;public;1;4;;@Override public void registerEventTimeTimer(long time) {     timerService.registerEventTimeTimer(window, time). }
false;public;1;4;;@Override public void deleteProcessingTimeTimer(long time) {     timerService.deleteProcessingTimeTimer(window, time). }
false;public;1;4;;@Override public void deleteEventTimeTimer(long time) {     timerService.deleteEventTimeTimer(window, time). }
false;public;1;8;;@Override public <S extends State> S getPartitionedState(StateDescriptor<S, ?> stateDescriptor) {     try {         return stateBackend.getPartitionedState(window, windowSerializer, stateDescriptor).     } catch (Exception e) {         throw new RuntimeException("Error getting state", e).     } }
false;public;3;5;;@Override public <S extends Serializable> ValueState<S> getKeyValueState(String name, Class<S> stateType, S defaultState) {     return getPartitionedState(new ValueStateDescriptor<>(name, stateType, defaultState)). }
false;public;3;5;;@Override public <S extends Serializable> ValueState<S> getKeyValueState(String name, TypeInformation<S> stateType, S defaultState) {     return getPartitionedState(new ValueStateDescriptor<>(name, stateType, defaultState)). }
false;public;1;19;;@Override public <S extends MergingState<?, ?>> void mergePartitionedState(StateDescriptor<S, ?> stateDescriptor) {     try {         S rawState = stateBackend.getOrCreateKeyedState(windowSerializer, stateDescriptor).         if (rawState instanceof InternalMergingState) {             @SuppressWarnings("unchecked")             InternalMergingState<K, W, ?, ?, ?> mergingState = (InternalMergingState<K, W, ?, ?, ?>) rawState.             mergingState.mergeNamespaces(window, mergedWindows).         } else {             throw new IllegalArgumentException("The given state descriptor does not refer to a mergeable state (MergingState)").         }     } catch (Exception e) {         throw new RuntimeException("Error while merging state.", e).     } }
