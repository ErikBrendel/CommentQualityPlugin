commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public ProcessingTimeService getProcessingTimeService() {     return task.getProcessingTimeService(). }
true;protected;0;1;/**  * This must be overwritten for OneInputStreamTask or TwoInputStreamTask test harnesses.  */ ;/**  * This must be overwritten for OneInputStreamTask or TwoInputStreamTask test harnesses.  */ protected void initializeInputs() throws IOException, InterruptedException { }
false;public;0;3;;public TestTaskStateManager getTaskStateManager() {     return taskStateManager. }
false;public;2;5;;public void setTaskStateSnapshot(long checkpointId, TaskStateSnapshot taskStateSnapshot) {     taskStateManager.setReportedCheckpointId(checkpointId).     taskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(Collections.singletonMap(checkpointId, taskStateSnapshot)). }
false;private;0;5;;@SuppressWarnings("unchecked") private void initializeOutput() {     outputList = new LinkedBlockingQueue<Object>().     mockEnv.addOutput(outputList, outputStreamRecordSerializer). }
true;public;0;25;/**  * Users of the test harness can call this utility method to setup the stream config  * if there will only be a single operator to be tested. The method will setup the  * outgoing network connection for the operator.  *  * <p>For more advanced test cases such as testing chains of multiple operators with the harness,  * please manually configure the stream config.  */ ;/**  * Users of the test harness can call this utility method to setup the stream config  * if there will only be a single operator to be tested. The method will setup the  * outgoing network connection for the operator.  *  * <p>For more advanced test cases such as testing chains of multiple operators with the harness,  * please manually configure the stream config.  */ public void setupOutputForSingletonOperatorChain() {     Preconditions.checkState(!setupCalled, "This harness was already setup.").     setupCalled = true.     streamConfig.setChainStart().     streamConfig.setBufferTimeout(0).     streamConfig.setTimeCharacteristic(TimeCharacteristic.EventTime).     streamConfig.setOutputSelectors(Collections.<OutputSelector<?>>emptyList()).     streamConfig.setNumberOfOutputs(1).     streamConfig.setTypeSerializerOut(outputSerializer).     streamConfig.setVertexID(0).     streamConfig.setOperatorID(new OperatorID(4711L, 123L)).     StreamOperator<OUT> dummyOperator = new AbstractStreamOperator<OUT>() {          private static final long serialVersionUID = 1L.     }.     List<StreamEdge> outEdgesInOrder = new LinkedList<StreamEdge>().     StreamNode sourceVertexDummy = new StreamNode(null, 0, "group", null, dummyOperator, "source dummy", new LinkedList<OutputSelector<?>>(), SourceStreamTask.class).     StreamNode targetVertexDummy = new StreamNode(null, 1, "group", null, dummyOperator, "target dummy", new LinkedList<OutputSelector<?>>(), SourceStreamTask.class).     outEdgesInOrder.add(new StreamEdge(sourceVertexDummy, targetVertexDummy, 0, new LinkedList<String>(), new BroadcastPartitioner<Object>(), null)).     streamConfig.setOutEdgesInOrder(outEdgesInOrder).     streamConfig.setNonChainedOutputs(outEdgesInOrder). }
false;public;0;10;;public StreamMockEnvironment createEnvironment() {     return new StreamMockEnvironment(jobConfig, taskConfig, executionConfig, memorySize, new MockInputSplitProvider(), bufferSize, taskStateManager). }
true;public;0;3;/**  * Invoke the Task. This resets the output of any previous invocation. This will start a new  * Thread to execute the Task in. Use {@link #waitForTaskCompletion()} to wait for the  * Task thread to finish running.  */ ;/**  * Invoke the Task. This resets the output of any previous invocation. This will start a new  * Thread to execute the Task in. Use {@link #waitForTaskCompletion()} to wait for the  * Task thread to finish running.  */ public void invoke() throws Exception {     invoke(createEnvironment()). }
true;public;1;11;/**  * Invoke the Task. This resets the output of any previous invocation. This will start a new  * Thread to execute the Task in. Use {@link #waitForTaskCompletion()} to wait for the  * Task thread to finish running.  */ ;/**  * Invoke the Task. This resets the output of any previous invocation. This will start a new  * Thread to execute the Task in. Use {@link #waitForTaskCompletion()} to wait for the  * Task thread to finish running.  */ public void invoke(StreamMockEnvironment mockEnv) throws Exception {     this.mockEnv = checkNotNull(mockEnv).     initializeInputs().     initializeOutput().     this.task = taskFactory.apply(mockEnv).     taskThread = new TaskThread(task).     taskThread.start(). }
true;public;0;3;/**  * Waits for the task completion.  *  * @throws Exception  */ ;/**  * Waits for the task completion.  *  * @throws Exception  */ public void waitForTaskCompletion() throws Exception {     waitForTaskCompletion(Long.MAX_VALUE). }
true;public;1;10;/**  * Waits for the task completion. If this does not happen within the timeout, then a  * TimeoutException is thrown.  *  * @param timeout Timeout for the task completion  * @throws Exception  */ ;/**  * Waits for the task completion. If this does not happen within the timeout, then a  * TimeoutException is thrown.  *  * @param timeout Timeout for the task completion  * @throws Exception  */ public void waitForTaskCompletion(long timeout) throws Exception {     if (taskThread == null) {         throw new IllegalStateException("Task thread was not started.").     }     taskThread.join(timeout).     if (taskThread.getError() != null) {         throw new Exception("error in task", taskThread.getError()).     } }
true;public;0;3;/**  * Waits for the task to be running.  *  * @throws Exception  */ ;/**  * Waits for the task to be running.  *  * @throws Exception  */ public void waitForTaskRunning() throws Exception {     waitForTaskRunning(Long.MAX_VALUE). }
true;public;1;23;/**  * Waits fro the task to be running. If this does not happen within the timeout, then a  * TimeoutException is thrown.  *  * @param timeout Timeout for the task to be running.  * @throws Exception  */ ;/**  * Waits fro the task to be running. If this does not happen within the timeout, then a  * TimeoutException is thrown.  *  * @param timeout Timeout for the task to be running.  * @throws Exception  */ public void waitForTaskRunning(long timeout) throws Exception {     if (taskThread == null) {         throw new IllegalStateException("Task thread was not started.").     } else {         if (taskThread.task instanceof StreamTask) {             StreamTask<?, ?> streamTask = (StreamTask<?, ?>) taskThread.task.             while (!streamTask.isRunning()) {                 Thread.sleep(10).                 if (!taskThread.isAlive()) {                     if (taskThread.getError() != null) {                         throw new Exception("Task Thread failed due to an error.", taskThread.getError()).                     } else {                         throw new Exception("Task Thread unexpectedly shut down.").                     }                 }             }         } else {             throw new IllegalStateException("Not a StreamTask").         }     } }
false;public;0;3;;public StreamTask<OUT, ?> getTask() {     return task. }
true;public;0;3;/**  * Get all the output from the task. This contains StreamRecords and Events interleaved. Use  * {@link org.apache.flink.streaming.util.TestHarnessUtil#getRawElementsFromOutput(java.util.Queue)}}  * to extract only the StreamRecords.  */ ;/**  * Get all the output from the task. This contains StreamRecords and Events interleaved. Use  * {@link org.apache.flink.streaming.util.TestHarnessUtil#getRawElementsFromOutput(java.util.Queue)}}  * to extract only the StreamRecords.  */ public LinkedBlockingQueue<Object> getOutput() {     return outputList. }
false;public;0;3;;public StreamConfig getStreamConfig() {     return streamConfig. }
false;public;0;3;;public ExecutionConfig getExecutionConfig() {     return executionConfig. }
false;private;0;4;;private void shutdownIOManager() throws Exception {     this.mockEnv.getIOManager().shutdown().     Assert.assertTrue("IO Manager has not properly shut down.", this.mockEnv.getIOManager().isProperlyShutDown()). }
false;private;0;9;;private void shutdownMemoryManager() throws Exception {     if (this.memorySize > 0) {         MemoryManager memMan = this.mockEnv.getMemoryManager().         if (memMan != null) {             Assert.assertTrue("Memory Manager managed memory was not completely freed.", memMan.verifyEmpty()).             memMan.shutdown().         }     } }
true;public;1;4;/**  * Sends the element to input gate 0 on channel 0.  */ ;/**  * Sends the element to input gate 0 on channel 0.  */ @SuppressWarnings("unchecked") public void processElement(Object element) {     inputGates[0].sendElement(element, 0). }
true;public;3;4;/**  * Sends the element to the specified channel on the specified input gate.  */ ;/**  * Sends the element to the specified channel on the specified input gate.  */ @SuppressWarnings("unchecked") public void processElement(Object element, int inputGate, int channel) {     inputGates[inputGate].sendElement(element, channel). }
true;public;1;3;/**  * Sends the event to input gate 0 on channel 0.  */ ;/**  * Sends the event to input gate 0 on channel 0.  */ public void processEvent(AbstractEvent event) {     inputGates[0].sendEvent(event, 0). }
true;public;3;3;/**  * Sends the event to the specified channel on the specified input gate.  */ ;/**  * Sends the event to the specified channel on the specified input gate.  */ public void processEvent(AbstractEvent event, int inputGate, int channel) {     inputGates[inputGate].sendEvent(event, channel). }
true;public;0;35;/**  * This only returns after all input queues are empty.  */ ;/**  * This only returns after all input queues are empty.  */ public void waitForInputProcessing() throws Exception {     while (true) {         Throwable error = taskThread.getError().         if (error != null) {             throw new Exception("Exception in the task thread", error).         }         boolean allEmpty = true.         for (int i = 0. i < numInputGates. i++) {             if (!inputGates[i].allQueuesEmpty()) {                 allEmpty = false.             }         }         if (allEmpty) {             break.         }     }     // notifyNonEmpty more input, i.e. all currently available input has been processed.     while (true) {         Thread.State state = taskThread.getState().         if (state == Thread.State.BLOCKED || state == Thread.State.TERMINATED || state == Thread.State.WAITING || state == Thread.State.TIMED_WAITING) {             break.         }         try {             Thread.sleep(1).         } catch (InterruptedException ignored) {         }     } }
true;public;0;5;/**  * Notifies all input channels on all input gates that no more input will arrive. This  * will usually make the Task exit from his internal loop.  */ ;/**  * Notifies all input channels on all input gates that no more input will arrive. This  * will usually make the Task exit from his internal loop.  */ public void endInput() {     for (int i = 0. i < numInputGates. i++) {         inputGates[i].endInput().     } }
false;public;2;5;;public StreamConfigChainer setupOperatorChain(OperatorID headOperatorId, OneInputStreamOperator<?, ?> headOperator) {     Preconditions.checkState(!setupCalled, "This harness was already setup.").     setupCalled = true.     return new StreamConfigChainer(headOperatorId, headOperator, getStreamConfig()). }
false;public;2;5;;public StreamConfigChainer setupOperatorChain(OperatorID headOperatorId, TwoInputStreamOperator<?, ?, ?> headOperator) {     Preconditions.checkState(!setupCalled, "This harness was already setup.").     setupCalled = true.     return new StreamConfigChainer(headOperatorId, headOperator, getStreamConfig()). }
false;public;0;11;;@Override public void run() {     try {         task.invoke().         shutdownIOManager().         shutdownMemoryManager().     } catch (Throwable t) {         this.error = t.     } }
false;public;0;3;;public Throwable getError() {     return error. }
