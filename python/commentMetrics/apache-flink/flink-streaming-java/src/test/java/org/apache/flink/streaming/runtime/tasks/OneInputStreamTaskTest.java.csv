# id;timestamp;commentText;codeText;commentWords;codeWords
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1472663401;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		streamTask.triggerCheckpoint(checkpointId, checkpointTimestamp)___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		assertEquals(checkpointId, env.getCheckpointId())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(env.getState(), env.getKeyGroupStates())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,stream,task,trigger,checkpoint,checkpoint,id,checkpoint,timestamp,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,0,testing,stream,operator,number,restore,calls,assert,equals,checkpoint,id,env,get,checkpoint,id,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,env,get,state,env,get,key,group,states,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1472663401;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		streamTask.triggerCheckpoint(checkpointId, checkpointTimestamp)___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(env.getState(), env.getKeyGroupStates())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,stream,task,trigger,checkpoint,checkpoint,id,checkpoint,timestamp,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,env,get,state,env,get,key,group,states,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1474981121;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		streamTask.triggerCheckpoint(checkpointId, checkpointTimestamp)___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(env.getState(), env.getKeyGroupStates())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,stream,task,trigger,checkpoint,checkpoint,id,checkpoint,timestamp,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,env,get,state,env,get,key,group,states,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1475231926;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		while(!streamTask.triggerCheckpoint(checkpointId, checkpointTimestamp))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(env.getState(), env.getKeyGroupStates(), env.getPartitionableOperatorState())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,while,stream,task,trigger,checkpoint,checkpoint,id,checkpoint,timestamp,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,env,get,state,env,get,key,group,states,env,get,partitionable,operator,state,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1475688972;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		while(!streamTask.triggerCheckpoint(checkpointId, checkpointTimestamp))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(env.getState(), env.getKeyGroupStates(), env.getPartitionableOperatorState())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,while,stream,task,trigger,checkpoint,checkpoint,id,checkpoint,timestamp,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,env,get,state,env,get,key,group,states,env,get,partitionable,operator,state,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1475688973;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		while(!streamTask.triggerCheckpoint(checkpointId, checkpointTimestamp))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(env.getState(), env.getKeyGroupStates(), env.getPartitionableOperatorState())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,while,stream,task,trigger,checkpoint,checkpoint,id,checkpoint,timestamp,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,env,get,state,env,get,key,group,states,env,get,partitionable,operator,state,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1475766252;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while(!streamTask.triggerCheckpoint(checkpointMetaData))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(env.getState(), env.getKeyGroupStates(), env.getPartitionableOperatorState())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,env,get,state,env,get,key,group,states,env,get,partitionable,operator,state,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1476972861;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while(!streamTask.triggerCheckpoint(checkpointMetaData))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(new TaskStateHandles(env.getCheckpointStateHandles()))___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,new,task,state,handles,env,get,checkpoint,state,handles,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1477069385;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while(!streamTask.triggerCheckpoint(checkpointMetaData))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(new TaskStateHandles(env.getCheckpointStateHandles()))___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,new,task,state,handles,env,get,checkpoint,state,handles,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1477517188;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while(!streamTask.triggerCheckpoint(checkpointMetaData))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(new TaskStateHandles(env.getCheckpointStateHandles()))___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,new,task,state,handles,env,get,checkpoint,state,handles,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1478257462;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while(!streamTask.triggerCheckpoint(checkpointMetaData))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(new TaskStateHandles(env.getCheckpointStateHandles()))___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,new,task,state,handles,env,get,checkpoint,state,handles,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1478636134;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while(!streamTask.triggerCheckpoint(checkpointMetaData))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(new TaskStateHandles(env.getCheckpointStateHandles()))___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,new,task,state,handles,env,get,checkpoint,state,handles,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1486732842;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while(!streamTask.triggerCheckpoint(checkpointMetaData))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(new TaskStateHandles(env.getCheckpointStateHandles()))___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,new,task,state,handles,env,get,checkpoint,state,handles,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1487762095;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while(!streamTask.triggerCheckpoint(checkpointMetaData))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(new TaskStateHandles(env.getCheckpointStateHandles()))___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,new,task,state,handles,env,get,checkpoint,state,handles,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1487871589;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while(!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint()))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(new TaskStateHandles(env.getCheckpointStateHandles()))___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,new,task,state,handles,env,get,checkpoint,state,handles,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1489819457;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while(!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint()))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(new TaskStateHandles(env.getCheckpointStateHandles()))___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,new,task,state,handles,env,get,checkpoint,state,handles,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1492569128;Tests that the stream operator can snapshot and restore the operator state of chained_operators;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while(!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint()))___		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(new TaskStateHandles(env.getCheckpointStateHandles()))___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,new,task,state,handles,env,get,checkpoint,state,handles,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1495484544;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(new TaskStateHandles(env.getCheckpointStateHandles()))___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,new,task,state,handles,env,get,checkpoint,state,handles,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1495650059;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()__		restoredTask.setInitialState(new TaskStateHandles(env.getCheckpointStateHandles()))___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness = new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,restored,task,set,initial,state,new,task,state,handles,env,get,checkpoint,state,handles,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1502801814;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		long recoveryTimestamp = 3L__		long seed = 2L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks, seed, recoveryTimestamp)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_			new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks, seed, recoveryTimestamp)___		TaskStateSnapshot stateHandles = env.getCheckpointStateHandles()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		restoredTask.setInitialState(stateHandles)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,long,recovery,timestamp,3l,long,seed,2l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,seed,recovery,timestamp,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,seed,recovery,timestamp,task,state,snapshot,state,handles,env,get,checkpoint,state,handles,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,restored,task,set,initial,state,state,handles,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1503598628;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_			new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = env.getCheckpointStateHandles()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		restoredTask.setInitialState(stateHandles)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,env,get,checkpoint,state,handles,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,restored,task,set,initial,state,state,handles,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1508850403;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_			new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = env.getCheckpointStateHandles()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		restoredTask.setInitialState(stateHandles)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,env,get,checkpoint,state,handles,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,restored,task,set,initial,state,state,handles,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1508850407;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_			new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = env.getCheckpointStateHandles()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		restoredTask.setInitialState(stateHandles)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,env,get,checkpoint,state,handles,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,restored,task,set,initial,state,state,handles,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1508969168;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forFullCheckpoint())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_			new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = env.getCheckpointStateHandles()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		restoredTask.setInitialState(stateHandles)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,full,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,env,get,checkpoint,state,handles,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,restored,task,set,initial,state,state,handles,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1509118643;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		final OneInputStreamTask<String, String> streamTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(streamTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> restoredTask = new OneInputStreamTask<String, String>()___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_			new OneInputStreamTaskTestHarness<String, String>(restoredTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = env.getCheckpointStateHandles()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		restoredTask.setInitialState(stateHandles)___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,string,string,stream,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,stream,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,string,string,restored,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,string,string,restored,task,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,env,get,checkpoint,state,handles,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,restored,task,set,initial,state,state,handles,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1515519059;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()___		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)___		AcknowledgeStreamMockEnvironment env = new AcknowledgeStreamMockEnvironment(_			testHarness.jobConfig,_			testHarness.taskConfig,_			testHarness.executionConfig,_			testHarness.memorySize,_			new MockInputSplitProvider(),_			testHarness.bufferSize)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke(env)__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> streamTask = testHarness.getTask()___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		env.getCheckpointLatch().await()___		assertEquals(checkpointId, env.getCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_				new OneInputStreamTaskTestHarness<>(_						OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = env.getCheckpointStateHandles()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		TestingStreamOperator.numberRestoreCalls = 0___		restoredTaskHarness.invoke(stateHandles)__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,acknowledge,stream,mock,environment,env,new,acknowledge,stream,mock,environment,test,harness,job,config,test,harness,task,config,test,harness,execution,config,test,harness,memory,size,new,mock,input,split,provider,test,harness,buffer,size,testing,stream,operator,number,restore,calls,0,test,harness,invoke,env,test,harness,wait,for,task,running,deadline,time,left,to,millis,final,one,input,stream,task,string,string,stream,task,test,harness,get,task,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,env,get,checkpoint,latch,await,assert,equals,checkpoint,id,env,get,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,env,get,checkpoint,state,handles,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,testing,stream,operator,number,restore,calls,0,restored,task,harness,invoke,state,handles,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1516626397;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()___		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)__		TestTaskStateManager taskStateManager = testHarness.taskStateManager__		OneShotLatch waitForAcknowledgeLatch = new OneShotLatch()___		taskStateManager.setWaitForReportLatch(waitForAcknowledgeLatch)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke()__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> streamTask = testHarness.getTask()___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpoint())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		waitForAcknowledgeLatch.await()___		assertEquals(checkpointId, taskStateManager.getReportedCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_				new OneInputStreamTaskTestHarness<>(_						OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.setTaskStateSnapshot(checkpointId, taskStateManager.getLastTaskStateSnapshot())___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = taskStateManager.getLastTaskStateSnapshot()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		TestingStreamOperator.numberRestoreCalls = 0___		_		restoredTaskHarness.taskStateManager.restoreLatestCheckpointState(_			taskStateManager.getTaskStateSnapshotsByCheckpointId())__		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,test,task,state,manager,task,state,manager,test,harness,task,state,manager,one,shot,latch,wait,for,acknowledge,latch,new,one,shot,latch,task,state,manager,set,wait,for,report,latch,wait,for,acknowledge,latch,testing,stream,operator,number,restore,calls,0,test,harness,invoke,test,harness,wait,for,task,running,deadline,time,left,to,millis,final,one,input,stream,task,string,string,stream,task,test,harness,get,task,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,assert,equals,0,testing,stream,operator,number,restore,calls,wait,for,acknowledge,latch,await,assert,equals,checkpoint,id,task,state,manager,get,reported,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,restored,task,harness,set,task,state,snapshot,checkpoint,id,task,state,manager,get,last,task,state,snapshot,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,task,state,manager,get,last,task,state,snapshot,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,testing,stream,operator,number,restore,calls,0,restored,task,harness,task,state,manager,restore,latest,checkpoint,state,task,state,manager,get,task,state,snapshots,by,checkpoint,id,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1517489695;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()___		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)__		TestTaskStateManager taskStateManager = testHarness.taskStateManager__		OneShotLatch waitForAcknowledgeLatch = new OneShotLatch()___		taskStateManager.setWaitForReportLatch(waitForAcknowledgeLatch)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke()__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> streamTask = testHarness.getTask()___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		waitForAcknowledgeLatch.await()___		assertEquals(checkpointId, taskStateManager.getReportedCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_				new OneInputStreamTaskTestHarness<>(_						OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.setTaskStateSnapshot(checkpointId, taskStateManager.getLastTaskStateSnapshot())___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = taskStateManager.getLastTaskStateSnapshot()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		TestingStreamOperator.numberRestoreCalls = 0___		_		restoredTaskHarness.taskStateManager.restoreLatestCheckpointState(_			taskStateManager.getTaskStateSnapshotsByCheckpointId())__		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,test,task,state,manager,task,state,manager,test,harness,task,state,manager,one,shot,latch,wait,for,acknowledge,latch,new,one,shot,latch,task,state,manager,set,wait,for,report,latch,wait,for,acknowledge,latch,testing,stream,operator,number,restore,calls,0,test,harness,invoke,test,harness,wait,for,task,running,deadline,time,left,to,millis,final,one,input,stream,task,string,string,stream,task,test,harness,get,task,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,assert,equals,0,testing,stream,operator,number,restore,calls,wait,for,acknowledge,latch,await,assert,equals,checkpoint,id,task,state,manager,get,reported,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,restored,task,harness,set,task,state,snapshot,checkpoint,id,task,state,manager,get,last,task,state,snapshot,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,task,state,manager,get,last,task,state,snapshot,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,testing,stream,operator,number,restore,calls,0,restored,task,harness,task,state,manager,restore,latest,checkpoint,state,task,state,manager,get,task,state,snapshots,by,checkpoint,id,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1517584327;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()___		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)__		TestTaskStateManager taskStateManager = testHarness.taskStateManager__		OneShotLatch waitForAcknowledgeLatch = new OneShotLatch()___		taskStateManager.setWaitForReportLatch(waitForAcknowledgeLatch)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke()__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> streamTask = testHarness.getTask()___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		waitForAcknowledgeLatch.await()___		assertEquals(checkpointId, taskStateManager.getReportedCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_				new OneInputStreamTaskTestHarness<>(_						OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.setTaskStateSnapshot(checkpointId, taskStateManager.getLastTaskStateSnapshot())___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = taskStateManager.getLastTaskStateSnapshot()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		TestingStreamOperator.numberRestoreCalls = 0___		_		restoredTaskHarness.taskStateManager.restoreLatestCheckpointState(_			taskStateManager.getTaskStateSnapshotsByCheckpointId())__		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,test,task,state,manager,task,state,manager,test,harness,task,state,manager,one,shot,latch,wait,for,acknowledge,latch,new,one,shot,latch,task,state,manager,set,wait,for,report,latch,wait,for,acknowledge,latch,testing,stream,operator,number,restore,calls,0,test,harness,invoke,test,harness,wait,for,task,running,deadline,time,left,to,millis,final,one,input,stream,task,string,string,stream,task,test,harness,get,task,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,assert,equals,0,testing,stream,operator,number,restore,calls,wait,for,acknowledge,latch,await,assert,equals,checkpoint,id,task,state,manager,get,reported,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,restored,task,harness,set,task,state,snapshot,checkpoint,id,task,state,manager,get,last,task,state,snapshot,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,task,state,manager,get,last,task,state,snapshot,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,testing,stream,operator,number,restore,calls,0,restored,task,harness,task,state,manager,restore,latest,checkpoint,state,task,state,manager,get,task,state,snapshots,by,checkpoint,id,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1519568061;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()___		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)__		TestTaskStateManager taskStateManager = testHarness.taskStateManager__		OneShotLatch waitForAcknowledgeLatch = new OneShotLatch()___		taskStateManager.setWaitForReportLatch(waitForAcknowledgeLatch)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke()__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> streamTask = testHarness.getTask()___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		waitForAcknowledgeLatch.await()___		assertEquals(checkpointId, taskStateManager.getReportedCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_				new OneInputStreamTaskTestHarness<>(_						OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.setTaskStateSnapshot(checkpointId, taskStateManager.getLastJobManagerTaskStateSnapshot())___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = taskStateManager.getLastJobManagerTaskStateSnapshot()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		TestingStreamOperator.numberRestoreCalls = 0___		_		restoredTaskHarness.taskStateManager.restoreLatestCheckpointState(_			taskStateManager.getJobManagerTaskStateSnapshotsByCheckpointId())__		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,test,task,state,manager,task,state,manager,test,harness,task,state,manager,one,shot,latch,wait,for,acknowledge,latch,new,one,shot,latch,task,state,manager,set,wait,for,report,latch,wait,for,acknowledge,latch,testing,stream,operator,number,restore,calls,0,test,harness,invoke,test,harness,wait,for,task,running,deadline,time,left,to,millis,final,one,input,stream,task,string,string,stream,task,test,harness,get,task,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,assert,equals,0,testing,stream,operator,number,restore,calls,wait,for,acknowledge,latch,await,assert,equals,checkpoint,id,task,state,manager,get,reported,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,restored,task,harness,set,task,state,snapshot,checkpoint,id,task,state,manager,get,last,job,manager,task,state,snapshot,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,task,state,manager,get,last,job,manager,task,state,snapshot,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,testing,stream,operator,number,restore,calls,0,restored,task,harness,task,state,manager,restore,latest,checkpoint,state,task,state,manager,get,job,manager,task,state,snapshots,by,checkpoint,id,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1528997616;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()___		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)__		TestTaskStateManager taskStateManager = testHarness.taskStateManager__		OneShotLatch waitForAcknowledgeLatch = new OneShotLatch()___		taskStateManager.setWaitForReportLatch(waitForAcknowledgeLatch)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke()__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> streamTask = testHarness.getTask()___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		waitForAcknowledgeLatch.await()___		assertEquals(checkpointId, taskStateManager.getReportedCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_				new OneInputStreamTaskTestHarness<>(_						OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.setTaskStateSnapshot(checkpointId, taskStateManager.getLastJobManagerTaskStateSnapshot())___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = taskStateManager.getLastJobManagerTaskStateSnapshot()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		TestingStreamOperator.numberRestoreCalls = 0___		_		restoredTaskHarness.taskStateManager.restoreLatestCheckpointState(_			taskStateManager.getJobManagerTaskStateSnapshotsByCheckpointId())__		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,test,task,state,manager,task,state,manager,test,harness,task,state,manager,one,shot,latch,wait,for,acknowledge,latch,new,one,shot,latch,task,state,manager,set,wait,for,report,latch,wait,for,acknowledge,latch,testing,stream,operator,number,restore,calls,0,test,harness,invoke,test,harness,wait,for,task,running,deadline,time,left,to,millis,final,one,input,stream,task,string,string,stream,task,test,harness,get,task,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,assert,equals,0,testing,stream,operator,number,restore,calls,wait,for,acknowledge,latch,await,assert,equals,checkpoint,id,task,state,manager,get,reported,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,restored,task,harness,set,task,state,snapshot,checkpoint,id,task,state,manager,get,last,job,manager,task,state,snapshot,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,task,state,manager,get,last,job,manager,task,state,snapshot,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,testing,stream,operator,number,restore,calls,0,restored,task,harness,task,state,manager,restore,latest,checkpoint,state,task,state,manager,get,job,manager,task,state,snapshots,by,checkpoint,id,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1531303507;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()___		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)__		TestTaskStateManager taskStateManager = testHarness.taskStateManager__		OneShotLatch waitForAcknowledgeLatch = new OneShotLatch()___		taskStateManager.setWaitForReportLatch(waitForAcknowledgeLatch)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke()__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> streamTask = testHarness.getTask()___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		waitForAcknowledgeLatch.await()___		assertEquals(checkpointId, taskStateManager.getReportedCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_				new OneInputStreamTaskTestHarness<>(_						OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.setTaskStateSnapshot(checkpointId, taskStateManager.getLastJobManagerTaskStateSnapshot())___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = taskStateManager.getLastJobManagerTaskStateSnapshot()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		TestingStreamOperator.numberRestoreCalls = 0___		_		restoredTaskHarness.taskStateManager.restoreLatestCheckpointState(_			taskStateManager.getJobManagerTaskStateSnapshotsByCheckpointId())__		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,test,task,state,manager,task,state,manager,test,harness,task,state,manager,one,shot,latch,wait,for,acknowledge,latch,new,one,shot,latch,task,state,manager,set,wait,for,report,latch,wait,for,acknowledge,latch,testing,stream,operator,number,restore,calls,0,test,harness,invoke,test,harness,wait,for,task,running,deadline,time,left,to,millis,final,one,input,stream,task,string,string,stream,task,test,harness,get,task,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,assert,equals,0,testing,stream,operator,number,restore,calls,wait,for,acknowledge,latch,await,assert,equals,checkpoint,id,task,state,manager,get,reported,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,restored,task,harness,set,task,state,snapshot,checkpoint,id,task,state,manager,get,last,job,manager,task,state,snapshot,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,task,state,manager,get,last,job,manager,task,state,snapshot,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,testing,stream,operator,number,restore,calls,0,restored,task,harness,task,state,manager,restore,latest,checkpoint,state,task,state,manager,get,job,manager,task,state,snapshots,by,checkpoint,id,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1531381123;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()___		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)__		TestTaskStateManager taskStateManager = testHarness.taskStateManager__		OneShotLatch waitForAcknowledgeLatch = new OneShotLatch()___		taskStateManager.setWaitForReportLatch(waitForAcknowledgeLatch)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke()__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> streamTask = testHarness.getTask()___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		waitForAcknowledgeLatch.await()___		assertEquals(checkpointId, taskStateManager.getReportedCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_				new OneInputStreamTaskTestHarness<>(_						OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.setTaskStateSnapshot(checkpointId, taskStateManager.getLastJobManagerTaskStateSnapshot())___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = taskStateManager.getLastJobManagerTaskStateSnapshot()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		TestingStreamOperator.numberRestoreCalls = 0___		_		restoredTaskHarness.taskStateManager.restoreLatestCheckpointState(_			taskStateManager.getJobManagerTaskStateSnapshotsByCheckpointId())__		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,test,task,state,manager,task,state,manager,test,harness,task,state,manager,one,shot,latch,wait,for,acknowledge,latch,new,one,shot,latch,task,state,manager,set,wait,for,report,latch,wait,for,acknowledge,latch,testing,stream,operator,number,restore,calls,0,test,harness,invoke,test,harness,wait,for,task,running,deadline,time,left,to,millis,final,one,input,stream,task,string,string,stream,task,test,harness,get,task,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,assert,equals,0,testing,stream,operator,number,restore,calls,wait,for,acknowledge,latch,await,assert,equals,checkpoint,id,task,state,manager,get,reported,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,restored,task,harness,set,task,state,snapshot,checkpoint,id,task,state,manager,get,last,job,manager,task,state,snapshot,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,task,state,manager,get,last,job,manager,task,state,snapshot,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,testing,stream,operator,number,restore,calls,0,restored,task,harness,task,state,manager,restore,latest,checkpoint,state,task,state,manager,get,job,manager,task,state,snapshots,by,checkpoint,id,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1535979810;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()___		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)__		TestTaskStateManager taskStateManager = testHarness.taskStateManager__		OneShotLatch waitForAcknowledgeLatch = new OneShotLatch()___		taskStateManager.setWaitForReportLatch(waitForAcknowledgeLatch)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke()__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> streamTask = testHarness.getTask()___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		waitForAcknowledgeLatch.await()___		assertEquals(checkpointId, taskStateManager.getReportedCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_				new OneInputStreamTaskTestHarness<>(_						OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.setTaskStateSnapshot(checkpointId, taskStateManager.getLastJobManagerTaskStateSnapshot())___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = taskStateManager.getLastJobManagerTaskStateSnapshot()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		TestingStreamOperator.numberRestoreCalls = 0___		_		restoredTaskHarness.taskStateManager.restoreLatestCheckpointState(_			taskStateManager.getJobManagerTaskStateSnapshotsByCheckpointId())__		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,test,task,state,manager,task,state,manager,test,harness,task,state,manager,one,shot,latch,wait,for,acknowledge,latch,new,one,shot,latch,task,state,manager,set,wait,for,report,latch,wait,for,acknowledge,latch,testing,stream,operator,number,restore,calls,0,test,harness,invoke,test,harness,wait,for,task,running,deadline,time,left,to,millis,final,one,input,stream,task,string,string,stream,task,test,harness,get,task,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,assert,equals,0,testing,stream,operator,number,restore,calls,wait,for,acknowledge,latch,await,assert,equals,checkpoint,id,task,state,manager,get,reported,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,restored,task,harness,set,task,state,snapshot,checkpoint,id,task,state,manager,get,last,job,manager,task,state,snapshot,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,task,state,manager,get,last,job,manager,task,state,snapshot,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,testing,stream,operator,number,restore,calls,0,restored,task,harness,task,state,manager,restore,latest,checkpoint,state,task,state,manager,get,job,manager,task,state,snapshots,by,checkpoint,id,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0
OneInputStreamTaskTest -> @Test 	public void testSnapshottingAndRestoring() throws Exception;1550833397;Tests that the stream operator can snapshot and restore the operator state of chained_operators.;@Test_	public void testSnapshottingAndRestoring() throws Exception {_		final Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()___		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		IdentityKeySelector<String> keySelector = new IdentityKeySelector<>()__		testHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		long checkpointId = 1L__		long checkpointTimestamp = 1L__		int numberChainedTasks = 11___		StreamConfig streamConfig = testHarness.getStreamConfig()___		configureChainedTestingStreamOperator(streamConfig, numberChainedTasks)__		TestTaskStateManager taskStateManager = testHarness.taskStateManager__		OneShotLatch waitForAcknowledgeLatch = new OneShotLatch()___		taskStateManager.setWaitForReportLatch(waitForAcknowledgeLatch)___		_		TestingStreamOperator.numberRestoreCalls = 0___		testHarness.invoke()__		testHarness.waitForTaskRunning(deadline.timeLeft().toMillis())___		final OneInputStreamTask<String, String> streamTask = testHarness.getTask()___		CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp)___		while (!streamTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation())) {}__		_		assertEquals(0, TestingStreamOperator.numberRestoreCalls)___		waitForAcknowledgeLatch.await()___		assertEquals(checkpointId, taskStateManager.getReportedCheckpointId())___		testHarness.endInput()__		testHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		final OneInputStreamTaskTestHarness<String, String> restoredTaskHarness =_				new OneInputStreamTaskTestHarness<>(_						OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.configureForKeyedStream(keySelector, BasicTypeInfo.STRING_TYPE_INFO)___		restoredTaskHarness.setTaskStateSnapshot(checkpointId, taskStateManager.getLastJobManagerTaskStateSnapshot())___		StreamConfig restoredTaskStreamConfig = restoredTaskHarness.getStreamConfig()___		configureChainedTestingStreamOperator(restoredTaskStreamConfig, numberChainedTasks)___		TaskStateSnapshot stateHandles = taskStateManager.getLastJobManagerTaskStateSnapshot()__		Assert.assertEquals(numberChainedTasks, stateHandles.getSubtaskStateMappings().size())___		TestingStreamOperator.numberRestoreCalls = 0___		_		restoredTaskHarness.taskStateManager.restoreLatestCheckpointState(_			taskStateManager.getJobManagerTaskStateSnapshotsByCheckpointId())__		restoredTaskHarness.invoke()__		restoredTaskHarness.endInput()__		restoredTaskHarness.waitForTaskCompletion(deadline.timeLeft().toMillis())___		_		assertEquals(numberChainedTasks, TestingStreamOperator.numberRestoreCalls)___		TestingStreamOperator.numberRestoreCalls = 0__		TestingStreamOperator.numberSnapshotCalls = 0__	};tests,that,the,stream,operator,can,snapshot,and,restore,the,operator,state,of,chained,operators;test,public,void,test,snapshotting,and,restoring,throws,exception,final,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,identity,key,selector,string,key,selector,new,identity,key,selector,test,harness,configure,for,keyed,stream,key,selector,basic,type,info,long,checkpoint,id,1l,long,checkpoint,timestamp,1l,int,number,chained,tasks,11,stream,config,stream,config,test,harness,get,stream,config,configure,chained,testing,stream,operator,stream,config,number,chained,tasks,test,task,state,manager,task,state,manager,test,harness,task,state,manager,one,shot,latch,wait,for,acknowledge,latch,new,one,shot,latch,task,state,manager,set,wait,for,report,latch,wait,for,acknowledge,latch,testing,stream,operator,number,restore,calls,0,test,harness,invoke,test,harness,wait,for,task,running,deadline,time,left,to,millis,final,one,input,stream,task,string,string,stream,task,test,harness,get,task,checkpoint,meta,data,checkpoint,meta,data,new,checkpoint,meta,data,checkpoint,id,checkpoint,timestamp,while,stream,task,trigger,checkpoint,checkpoint,meta,data,checkpoint,options,for,checkpoint,with,default,location,assert,equals,0,testing,stream,operator,number,restore,calls,wait,for,acknowledge,latch,await,assert,equals,checkpoint,id,task,state,manager,get,reported,checkpoint,id,test,harness,end,input,test,harness,wait,for,task,completion,deadline,time,left,to,millis,final,one,input,stream,task,test,harness,string,string,restored,task,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,restored,task,harness,configure,for,keyed,stream,key,selector,basic,type,info,restored,task,harness,set,task,state,snapshot,checkpoint,id,task,state,manager,get,last,job,manager,task,state,snapshot,stream,config,restored,task,stream,config,restored,task,harness,get,stream,config,configure,chained,testing,stream,operator,restored,task,stream,config,number,chained,tasks,task,state,snapshot,state,handles,task,state,manager,get,last,job,manager,task,state,snapshot,assert,assert,equals,number,chained,tasks,state,handles,get,subtask,state,mappings,size,testing,stream,operator,number,restore,calls,0,restored,task,harness,task,state,manager,restore,latest,checkpoint,state,task,state,manager,get,job,manager,task,state,snapshots,by,checkpoint,id,restored,task,harness,invoke,restored,task,harness,end,input,restored,task,harness,wait,for,task,completion,deadline,time,left,to,millis,assert,equals,number,chained,tasks,testing,stream,operator,number,restore,calls,testing,stream,operator,number,restore,calls,0,testing,stream,operator,number,snapshot,calls,0
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1445418103;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1453902315;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1467026067;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1472663401;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1472663401;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1474981121;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1475231926;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1475688972;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1475688973;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1475766252;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1476972861;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1477069385;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1477517188;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1478257462;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1478636134;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1486732842;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1487762095;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1487871589;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1489819457;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1492569128;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1495484544;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1495650059;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1502801814;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1503598628;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1508850403;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1508850407;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1508969168;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1509118643;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1515519059;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1516626397;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1517489695;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1517584327;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1519568061;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1528997616;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1531303507;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1531381123;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1535979810;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOvertakingCheckpointBarriers() throws Exception;1550833397;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	public void testOvertakingCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1445418103;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1453902315;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1467026067;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1472663401;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1472663401;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1474981121;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1475231926;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1475688972;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1475688973;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1475766252;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1476972861;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1477069385;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1477517188;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1478257462;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1478636134;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1486732842;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1487762095;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1487871589;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1489819457;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1492569128;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1495484544;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1495650059;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1502801814;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1503598628;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1508850403;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1508850407;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1508969168;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1509118643;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1515519059;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1516626397;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1517489695;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1517584327;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1519568061;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1528997616;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1531303507;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1531381123;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1535979810;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testOpenCloseAndTimestamps() throws Exception;1550833397;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link StreamMap} assigns the input_timestamp to emitted elements.;@Test_	public void testOpenCloseAndTimestamps() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime + 2))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime + 2))___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,public,void,test,open,close,and,timestamps,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,test,open,close,map,function,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,test,harness,process,element,new,stream,record,string,ciao,initial,time,2,expected,output,add,new,stream,record,string,hello,initial,time,1,expected,output,add,new,stream,record,string,ciao,initial,time,2,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1445418103;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1453902315;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1467026067;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1472663401;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1472663401;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1474981121;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1475231926;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1475688972;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1475688973;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1475766252;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1476972861;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1477069385;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1477517188;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1478257462;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1478636134;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1445418103;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1453902315;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1467026067;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1472663401;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1472663401;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1474981121;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1475231926;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1475688972;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1475688973;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1475766252;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1476972861;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1477069385;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1477517188;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1478257462;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1478636134;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1486732842;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1487762095;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1487871589;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1489819457;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1492569128;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1495484544;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1495650059;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1502801814;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1503598628;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1508850403;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1508850407;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1508969168;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1509118643;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<String, String>(mapTask, 2, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1515519059;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1516626397;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1517489695;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1517584327;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1519568061;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1528997616;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1531303507;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1531381123;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1535979810;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	public void testCheckpointBarriers() throws Exception;1550833397;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	public void testCheckpointBarriers() throws Exception {_		final OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<String>("Hello-1-1", initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<String>("Ciao-1-1", initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello-1-1", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-1-1", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,public,void,test,checkpoint,barriers,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,hello,1,1,initial,time,1,1,test,harness,process,element,new,stream,record,string,ciao,1,1,initial,time,1,1,expected,output,add,new,stream,record,string,hello,1,1,initial,time,expected,output,add,new,stream,record,string,ciao,1,1,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1486732842;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1487762095;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1487871589;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1489819457;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1492569128;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1495484544;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1495650059;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1502801814;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1503598628;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1508850403;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1508850407;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1508969168;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1509118643;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final OneInputStreamTask<String, String> mapTask = new OneInputStreamTask<String, String>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				mapTask, 2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,string,string,map,task,new,one,input,stream,task,string,string,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,map,task,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1515519059;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1516626397;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1517489695;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1517584327;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1519568061;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1528997616;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1531303507;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1531381123;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1535979810;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1550833397;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				2, 2,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamMap<String, String> mapOperator = new StreamMap<String, String>(new IdentityMap())__		streamConfig.setStreamOperator(mapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)__		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime))__		testHarness.processElement(new StreamRecord<String>("Ciao", initialTime))__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao", initialTime))___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 2))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		expectedOutput.add(new Watermark(initialTime + 6))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,2,2,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,map,string,string,map,operator,new,stream,map,string,string,new,identity,map,stream,config,set,stream,operator,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,test,harness,process,element,new,stream,record,string,ciao,initial,time,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,ciao,initial,time,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,2,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,expected,output,add,new,watermark,initial,time,6,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,2,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1486732842;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		__		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig headOperatorConfig = testHarness.getStreamConfig()___		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		StreamConfig watermarkOperatorConfig = new StreamConfig(new Configuration())___		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig tailOperatorConfig = new StreamConfig(new Configuration())___		headOperatorConfig.setStreamOperator(headOperator)__		headOperatorConfig.setChainStart()__		headOperatorConfig.setChainIndex(0)__		headOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 0, null, null, null, null, null),_			new StreamNode(null, 1, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null_		)))___		watermarkOperatorConfig.setStreamOperator(watermarkOperator)__		watermarkOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		watermarkOperatorConfig.setChainIndex(1)__		watermarkOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 1, null, null, null, null, null),_			new StreamNode(null, 2, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null_		)))___		List<StreamEdge> outEdgesInOrder = new LinkedList<StreamEdge>()__		outEdgesInOrder.add(new StreamEdge(_			new StreamNode(null, 2, null, null, null, null, null),_			new StreamNode(null, 3, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			new BroadcastPartitioner<Object>()))___		tailOperatorConfig.setStreamOperator(tailOperator)__		tailOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		tailOperatorConfig.setBufferTimeout(0)__		tailOperatorConfig.setChainIndex(2)__		tailOperatorConfig.setChainEnd()__		tailOperatorConfig.setOutputSelectors(Collections.<OutputSelector<?>>emptyList())__		tailOperatorConfig.setNumberOfOutputs(1)__		tailOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)__		tailOperatorConfig.setNonChainedOutputs(outEdgesInOrder)__		tailOperatorConfig.setTypeSerializerOut(StringSerializer.INSTANCE)___		Map<Integer, StreamConfig> chainedConfigs = new HashMap<>(2)__		chainedConfigs.put(1, watermarkOperatorConfig)__		chainedConfigs.put(2, tailOperatorConfig)__		headOperatorConfig.setTransitiveChainedTaskConfigs(chainedConfigs)__		headOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)___		__		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,head,operator,config,test,harness,get,stream,config,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,stream,config,watermark,operator,config,new,stream,config,new,configuration,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,tail,operator,config,new,stream,config,new,configuration,head,operator,config,set,stream,operator,head,operator,head,operator,config,set,chain,start,head,operator,config,set,chain,index,0,head,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,0,null,null,null,null,null,new,stream,node,null,1,null,null,null,null,null,0,collections,string,empty,list,null,watermark,operator,config,set,stream,operator,watermark,operator,watermark,operator,config,set,type,serializer,in1,string,serializer,instance,watermark,operator,config,set,chain,index,1,watermark,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,1,null,null,null,null,null,new,stream,node,null,2,null,null,null,null,null,0,collections,string,empty,list,null,list,stream,edge,out,edges,in,order,new,linked,list,stream,edge,out,edges,in,order,add,new,stream,edge,new,stream,node,null,2,null,null,null,null,null,new,stream,node,null,3,null,null,null,null,null,0,collections,string,empty,list,new,broadcast,partitioner,object,tail,operator,config,set,stream,operator,tail,operator,tail,operator,config,set,type,serializer,in1,string,serializer,instance,tail,operator,config,set,buffer,timeout,0,tail,operator,config,set,chain,index,2,tail,operator,config,set,chain,end,tail,operator,config,set,output,selectors,collections,output,selector,empty,list,tail,operator,config,set,number,of,outputs,1,tail,operator,config,set,out,edges,in,order,out,edges,in,order,tail,operator,config,set,non,chained,outputs,out,edges,in,order,tail,operator,config,set,type,serializer,out,string,serializer,instance,map,integer,stream,config,chained,configs,new,hash,map,2,chained,configs,put,1,watermark,operator,config,chained,configs,put,2,tail,operator,config,head,operator,config,set,transitive,chained,task,configs,chained,configs,head,operator,config,set,out,edges,in,order,out,edges,in,order,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1487762095;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		__		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig headOperatorConfig = testHarness.getStreamConfig()___		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		StreamConfig watermarkOperatorConfig = new StreamConfig(new Configuration())___		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig tailOperatorConfig = new StreamConfig(new Configuration())___		headOperatorConfig.setStreamOperator(headOperator)__		headOperatorConfig.setChainStart()__		headOperatorConfig.setChainIndex(0)__		headOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 0, null, null, null, null, null),_			new StreamNode(null, 1, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null_		)))___		watermarkOperatorConfig.setStreamOperator(watermarkOperator)__		watermarkOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		watermarkOperatorConfig.setChainIndex(1)__		watermarkOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 1, null, null, null, null, null),_			new StreamNode(null, 2, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null_		)))___		List<StreamEdge> outEdgesInOrder = new LinkedList<StreamEdge>()__		outEdgesInOrder.add(new StreamEdge(_			new StreamNode(null, 2, null, null, null, null, null),_			new StreamNode(null, 3, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			new BroadcastPartitioner<Object>()))___		tailOperatorConfig.setStreamOperator(tailOperator)__		tailOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		tailOperatorConfig.setBufferTimeout(0)__		tailOperatorConfig.setChainIndex(2)__		tailOperatorConfig.setChainEnd()__		tailOperatorConfig.setOutputSelectors(Collections.<OutputSelector<?>>emptyList())__		tailOperatorConfig.setNumberOfOutputs(1)__		tailOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)__		tailOperatorConfig.setNonChainedOutputs(outEdgesInOrder)__		tailOperatorConfig.setTypeSerializerOut(StringSerializer.INSTANCE)___		Map<Integer, StreamConfig> chainedConfigs = new HashMap<>(2)__		chainedConfigs.put(1, watermarkOperatorConfig)__		chainedConfigs.put(2, tailOperatorConfig)__		headOperatorConfig.setTransitiveChainedTaskConfigs(chainedConfigs)__		headOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)___		__		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,head,operator,config,test,harness,get,stream,config,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,stream,config,watermark,operator,config,new,stream,config,new,configuration,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,tail,operator,config,new,stream,config,new,configuration,head,operator,config,set,stream,operator,head,operator,head,operator,config,set,chain,start,head,operator,config,set,chain,index,0,head,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,0,null,null,null,null,null,new,stream,node,null,1,null,null,null,null,null,0,collections,string,empty,list,null,watermark,operator,config,set,stream,operator,watermark,operator,watermark,operator,config,set,type,serializer,in1,string,serializer,instance,watermark,operator,config,set,chain,index,1,watermark,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,1,null,null,null,null,null,new,stream,node,null,2,null,null,null,null,null,0,collections,string,empty,list,null,list,stream,edge,out,edges,in,order,new,linked,list,stream,edge,out,edges,in,order,add,new,stream,edge,new,stream,node,null,2,null,null,null,null,null,new,stream,node,null,3,null,null,null,null,null,0,collections,string,empty,list,new,broadcast,partitioner,object,tail,operator,config,set,stream,operator,tail,operator,tail,operator,config,set,type,serializer,in1,string,serializer,instance,tail,operator,config,set,buffer,timeout,0,tail,operator,config,set,chain,index,2,tail,operator,config,set,chain,end,tail,operator,config,set,output,selectors,collections,output,selector,empty,list,tail,operator,config,set,number,of,outputs,1,tail,operator,config,set,out,edges,in,order,out,edges,in,order,tail,operator,config,set,non,chained,outputs,out,edges,in,order,tail,operator,config,set,type,serializer,out,string,serializer,instance,map,integer,stream,config,chained,configs,new,hash,map,2,chained,configs,put,1,watermark,operator,config,chained,configs,put,2,tail,operator,config,head,operator,config,set,transitive,chained,task,configs,chained,configs,head,operator,config,set,out,edges,in,order,out,edges,in,order,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1487871589;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		__		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig headOperatorConfig = testHarness.getStreamConfig()___		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		StreamConfig watermarkOperatorConfig = new StreamConfig(new Configuration())___		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig tailOperatorConfig = new StreamConfig(new Configuration())___		headOperatorConfig.setStreamOperator(headOperator)__		headOperatorConfig.setChainStart()__		headOperatorConfig.setChainIndex(0)__		headOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 0, null, null, null, null, null),_			new StreamNode(null, 1, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null_		)))___		watermarkOperatorConfig.setStreamOperator(watermarkOperator)__		watermarkOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		watermarkOperatorConfig.setChainIndex(1)__		watermarkOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 1, null, null, null, null, null),_			new StreamNode(null, 2, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null_		)))___		List<StreamEdge> outEdgesInOrder = new LinkedList<StreamEdge>()__		outEdgesInOrder.add(new StreamEdge(_			new StreamNode(null, 2, null, null, null, null, null),_			new StreamNode(null, 3, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			new BroadcastPartitioner<Object>()))___		tailOperatorConfig.setStreamOperator(tailOperator)__		tailOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		tailOperatorConfig.setBufferTimeout(0)__		tailOperatorConfig.setChainIndex(2)__		tailOperatorConfig.setChainEnd()__		tailOperatorConfig.setOutputSelectors(Collections.<OutputSelector<?>>emptyList())__		tailOperatorConfig.setNumberOfOutputs(1)__		tailOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)__		tailOperatorConfig.setNonChainedOutputs(outEdgesInOrder)__		tailOperatorConfig.setTypeSerializerOut(StringSerializer.INSTANCE)___		Map<Integer, StreamConfig> chainedConfigs = new HashMap<>(2)__		chainedConfigs.put(1, watermarkOperatorConfig)__		chainedConfigs.put(2, tailOperatorConfig)__		headOperatorConfig.setTransitiveChainedTaskConfigs(chainedConfigs)__		headOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)___		__		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,head,operator,config,test,harness,get,stream,config,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,stream,config,watermark,operator,config,new,stream,config,new,configuration,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,tail,operator,config,new,stream,config,new,configuration,head,operator,config,set,stream,operator,head,operator,head,operator,config,set,chain,start,head,operator,config,set,chain,index,0,head,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,0,null,null,null,null,null,new,stream,node,null,1,null,null,null,null,null,0,collections,string,empty,list,null,watermark,operator,config,set,stream,operator,watermark,operator,watermark,operator,config,set,type,serializer,in1,string,serializer,instance,watermark,operator,config,set,chain,index,1,watermark,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,1,null,null,null,null,null,new,stream,node,null,2,null,null,null,null,null,0,collections,string,empty,list,null,list,stream,edge,out,edges,in,order,new,linked,list,stream,edge,out,edges,in,order,add,new,stream,edge,new,stream,node,null,2,null,null,null,null,null,new,stream,node,null,3,null,null,null,null,null,0,collections,string,empty,list,new,broadcast,partitioner,object,tail,operator,config,set,stream,operator,tail,operator,tail,operator,config,set,type,serializer,in1,string,serializer,instance,tail,operator,config,set,buffer,timeout,0,tail,operator,config,set,chain,index,2,tail,operator,config,set,chain,end,tail,operator,config,set,output,selectors,collections,output,selector,empty,list,tail,operator,config,set,number,of,outputs,1,tail,operator,config,set,out,edges,in,order,out,edges,in,order,tail,operator,config,set,non,chained,outputs,out,edges,in,order,tail,operator,config,set,type,serializer,out,string,serializer,instance,map,integer,stream,config,chained,configs,new,hash,map,2,chained,configs,put,1,watermark,operator,config,chained,configs,put,2,tail,operator,config,head,operator,config,set,transitive,chained,task,configs,chained,configs,head,operator,config,set,out,edges,in,order,out,edges,in,order,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1489819457;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		__		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig headOperatorConfig = testHarness.getStreamConfig()___		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		StreamConfig watermarkOperatorConfig = new StreamConfig(new Configuration())___		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig tailOperatorConfig = new StreamConfig(new Configuration())___		headOperatorConfig.setStreamOperator(headOperator)__		headOperatorConfig.setChainStart()__		headOperatorConfig.setChainIndex(0)__		headOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 0, null, null, null, null, null),_			new StreamNode(null, 1, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null,_			null_		)))___		watermarkOperatorConfig.setStreamOperator(watermarkOperator)__		watermarkOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		watermarkOperatorConfig.setChainIndex(1)__		watermarkOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 1, null, null, null, null, null),_			new StreamNode(null, 2, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null,_			null_		)))___		List<StreamEdge> outEdgesInOrder = new LinkedList<StreamEdge>()__		outEdgesInOrder.add(new StreamEdge(_			new StreamNode(null, 2, null, null, null, null, null),_			new StreamNode(null, 3, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			new BroadcastPartitioner<Object>(),_			null))___		tailOperatorConfig.setStreamOperator(tailOperator)__		tailOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		tailOperatorConfig.setBufferTimeout(0)__		tailOperatorConfig.setChainIndex(2)__		tailOperatorConfig.setChainEnd()__		tailOperatorConfig.setOutputSelectors(Collections.<OutputSelector<?>>emptyList())__		tailOperatorConfig.setNumberOfOutputs(1)__		tailOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)__		tailOperatorConfig.setNonChainedOutputs(outEdgesInOrder)__		tailOperatorConfig.setTypeSerializerOut(StringSerializer.INSTANCE)___		Map<Integer, StreamConfig> chainedConfigs = new HashMap<>(2)__		chainedConfigs.put(1, watermarkOperatorConfig)__		chainedConfigs.put(2, tailOperatorConfig)__		headOperatorConfig.setTransitiveChainedTaskConfigs(chainedConfigs)__		headOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)___		__		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,head,operator,config,test,harness,get,stream,config,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,stream,config,watermark,operator,config,new,stream,config,new,configuration,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,tail,operator,config,new,stream,config,new,configuration,head,operator,config,set,stream,operator,head,operator,head,operator,config,set,chain,start,head,operator,config,set,chain,index,0,head,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,0,null,null,null,null,null,new,stream,node,null,1,null,null,null,null,null,0,collections,string,empty,list,null,null,watermark,operator,config,set,stream,operator,watermark,operator,watermark,operator,config,set,type,serializer,in1,string,serializer,instance,watermark,operator,config,set,chain,index,1,watermark,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,1,null,null,null,null,null,new,stream,node,null,2,null,null,null,null,null,0,collections,string,empty,list,null,null,list,stream,edge,out,edges,in,order,new,linked,list,stream,edge,out,edges,in,order,add,new,stream,edge,new,stream,node,null,2,null,null,null,null,null,new,stream,node,null,3,null,null,null,null,null,0,collections,string,empty,list,new,broadcast,partitioner,object,null,tail,operator,config,set,stream,operator,tail,operator,tail,operator,config,set,type,serializer,in1,string,serializer,instance,tail,operator,config,set,buffer,timeout,0,tail,operator,config,set,chain,index,2,tail,operator,config,set,chain,end,tail,operator,config,set,output,selectors,collections,output,selector,empty,list,tail,operator,config,set,number,of,outputs,1,tail,operator,config,set,out,edges,in,order,out,edges,in,order,tail,operator,config,set,non,chained,outputs,out,edges,in,order,tail,operator,config,set,type,serializer,out,string,serializer,instance,map,integer,stream,config,chained,configs,new,hash,map,2,chained,configs,put,1,watermark,operator,config,chained,configs,put,2,tail,operator,config,head,operator,config,set,transitive,chained,task,configs,chained,configs,head,operator,config,set,out,edges,in,order,out,edges,in,order,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1492569128;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		__		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig headOperatorConfig = testHarness.getStreamConfig()___		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		StreamConfig watermarkOperatorConfig = new StreamConfig(new Configuration())___		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig tailOperatorConfig = new StreamConfig(new Configuration())___		headOperatorConfig.setStreamOperator(headOperator)__		headOperatorConfig.setChainStart()__		headOperatorConfig.setChainIndex(0)__		headOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 0, null, null, null, null, null),_			new StreamNode(null, 1, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null,_			null_		)))___		watermarkOperatorConfig.setStreamOperator(watermarkOperator)__		watermarkOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		watermarkOperatorConfig.setChainIndex(1)__		watermarkOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 1, null, null, null, null, null),_			new StreamNode(null, 2, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null,_			null_		)))___		List<StreamEdge> outEdgesInOrder = new LinkedList<StreamEdge>()__		outEdgesInOrder.add(new StreamEdge(_			new StreamNode(null, 2, null, null, null, null, null),_			new StreamNode(null, 3, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			new BroadcastPartitioner<Object>(),_			null))___		tailOperatorConfig.setStreamOperator(tailOperator)__		tailOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		tailOperatorConfig.setBufferTimeout(0)__		tailOperatorConfig.setChainIndex(2)__		tailOperatorConfig.setChainEnd()__		tailOperatorConfig.setOutputSelectors(Collections.<OutputSelector<?>>emptyList())__		tailOperatorConfig.setNumberOfOutputs(1)__		tailOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)__		tailOperatorConfig.setNonChainedOutputs(outEdgesInOrder)__		tailOperatorConfig.setTypeSerializerOut(StringSerializer.INSTANCE)___		Map<Integer, StreamConfig> chainedConfigs = new HashMap<>(2)__		chainedConfigs.put(1, watermarkOperatorConfig)__		chainedConfigs.put(2, tailOperatorConfig)__		headOperatorConfig.setTransitiveChainedTaskConfigs(chainedConfigs)__		headOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)___		__		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,head,operator,config,test,harness,get,stream,config,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,stream,config,watermark,operator,config,new,stream,config,new,configuration,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,tail,operator,config,new,stream,config,new,configuration,head,operator,config,set,stream,operator,head,operator,head,operator,config,set,chain,start,head,operator,config,set,chain,index,0,head,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,0,null,null,null,null,null,new,stream,node,null,1,null,null,null,null,null,0,collections,string,empty,list,null,null,watermark,operator,config,set,stream,operator,watermark,operator,watermark,operator,config,set,type,serializer,in1,string,serializer,instance,watermark,operator,config,set,chain,index,1,watermark,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,1,null,null,null,null,null,new,stream,node,null,2,null,null,null,null,null,0,collections,string,empty,list,null,null,list,stream,edge,out,edges,in,order,new,linked,list,stream,edge,out,edges,in,order,add,new,stream,edge,new,stream,node,null,2,null,null,null,null,null,new,stream,node,null,3,null,null,null,null,null,0,collections,string,empty,list,new,broadcast,partitioner,object,null,tail,operator,config,set,stream,operator,tail,operator,tail,operator,config,set,type,serializer,in1,string,serializer,instance,tail,operator,config,set,buffer,timeout,0,tail,operator,config,set,chain,index,2,tail,operator,config,set,chain,end,tail,operator,config,set,output,selectors,collections,output,selector,empty,list,tail,operator,config,set,number,of,outputs,1,tail,operator,config,set,out,edges,in,order,out,edges,in,order,tail,operator,config,set,non,chained,outputs,out,edges,in,order,tail,operator,config,set,type,serializer,out,string,serializer,instance,map,integer,stream,config,chained,configs,new,hash,map,2,chained,configs,put,1,watermark,operator,config,chained,configs,put,2,tail,operator,config,head,operator,config,set,transitive,chained,task,configs,chained,configs,head,operator,config,set,out,edges,in,order,out,edges,in,order,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1495484544;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		__		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig headOperatorConfig = testHarness.getStreamConfig()___		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		StreamConfig watermarkOperatorConfig = new StreamConfig(new Configuration())___		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig tailOperatorConfig = new StreamConfig(new Configuration())___		headOperatorConfig.setStreamOperator(headOperator)__		headOperatorConfig.setChainStart()__		headOperatorConfig.setChainIndex(0)__		headOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 0, null, null, null, null, null),_			new StreamNode(null, 1, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null,_			null_		)))___		watermarkOperatorConfig.setStreamOperator(watermarkOperator)__		watermarkOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		watermarkOperatorConfig.setChainIndex(1)__		watermarkOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 1, null, null, null, null, null),_			new StreamNode(null, 2, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null,_			null_		)))___		List<StreamEdge> outEdgesInOrder = new LinkedList<StreamEdge>()__		outEdgesInOrder.add(new StreamEdge(_			new StreamNode(null, 2, null, null, null, null, null),_			new StreamNode(null, 3, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			new BroadcastPartitioner<Object>(),_			null))___		tailOperatorConfig.setStreamOperator(tailOperator)__		tailOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		tailOperatorConfig.setBufferTimeout(0)__		tailOperatorConfig.setChainIndex(2)__		tailOperatorConfig.setChainEnd()__		tailOperatorConfig.setOutputSelectors(Collections.<OutputSelector<?>>emptyList())__		tailOperatorConfig.setNumberOfOutputs(1)__		tailOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)__		tailOperatorConfig.setNonChainedOutputs(outEdgesInOrder)__		tailOperatorConfig.setTypeSerializerOut(StringSerializer.INSTANCE)___		Map<Integer, StreamConfig> chainedConfigs = new HashMap<>(2)__		chainedConfigs.put(1, watermarkOperatorConfig)__		chainedConfigs.put(2, tailOperatorConfig)__		headOperatorConfig.setTransitiveChainedTaskConfigs(chainedConfigs)__		headOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)___		__		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,head,operator,config,test,harness,get,stream,config,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,stream,config,watermark,operator,config,new,stream,config,new,configuration,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,tail,operator,config,new,stream,config,new,configuration,head,operator,config,set,stream,operator,head,operator,head,operator,config,set,chain,start,head,operator,config,set,chain,index,0,head,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,0,null,null,null,null,null,new,stream,node,null,1,null,null,null,null,null,0,collections,string,empty,list,null,null,watermark,operator,config,set,stream,operator,watermark,operator,watermark,operator,config,set,type,serializer,in1,string,serializer,instance,watermark,operator,config,set,chain,index,1,watermark,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,1,null,null,null,null,null,new,stream,node,null,2,null,null,null,null,null,0,collections,string,empty,list,null,null,list,stream,edge,out,edges,in,order,new,linked,list,stream,edge,out,edges,in,order,add,new,stream,edge,new,stream,node,null,2,null,null,null,null,null,new,stream,node,null,3,null,null,null,null,null,0,collections,string,empty,list,new,broadcast,partitioner,object,null,tail,operator,config,set,stream,operator,tail,operator,tail,operator,config,set,type,serializer,in1,string,serializer,instance,tail,operator,config,set,buffer,timeout,0,tail,operator,config,set,chain,index,2,tail,operator,config,set,chain,end,tail,operator,config,set,output,selectors,collections,output,selector,empty,list,tail,operator,config,set,number,of,outputs,1,tail,operator,config,set,out,edges,in,order,out,edges,in,order,tail,operator,config,set,non,chained,outputs,out,edges,in,order,tail,operator,config,set,type,serializer,out,string,serializer,instance,map,integer,stream,config,chained,configs,new,hash,map,2,chained,configs,put,1,watermark,operator,config,chained,configs,put,2,tail,operator,config,head,operator,config,set,transitive,chained,task,configs,chained,configs,head,operator,config,set,out,edges,in,order,out,edges,in,order,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1495650059;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		__		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig headOperatorConfig = testHarness.getStreamConfig()___		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		StreamConfig watermarkOperatorConfig = new StreamConfig(new Configuration())___		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig tailOperatorConfig = new StreamConfig(new Configuration())___		headOperatorConfig.setStreamOperator(headOperator)__		headOperatorConfig.setChainStart()__		headOperatorConfig.setChainIndex(0)__		headOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 0, null, null, null, null, null),_			new StreamNode(null, 1, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null,_			null_		)))___		watermarkOperatorConfig.setStreamOperator(watermarkOperator)__		watermarkOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		watermarkOperatorConfig.setChainIndex(1)__		watermarkOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 1, null, null, null, null, null),_			new StreamNode(null, 2, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null,_			null_		)))___		List<StreamEdge> outEdgesInOrder = new LinkedList<StreamEdge>()__		outEdgesInOrder.add(new StreamEdge(_			new StreamNode(null, 2, null, null, null, null, null),_			new StreamNode(null, 3, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			new BroadcastPartitioner<Object>(),_			null))___		tailOperatorConfig.setStreamOperator(tailOperator)__		tailOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		tailOperatorConfig.setBufferTimeout(0)__		tailOperatorConfig.setChainIndex(2)__		tailOperatorConfig.setChainEnd()__		tailOperatorConfig.setOutputSelectors(Collections.<OutputSelector<?>>emptyList())__		tailOperatorConfig.setNumberOfOutputs(1)__		tailOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)__		tailOperatorConfig.setNonChainedOutputs(outEdgesInOrder)__		tailOperatorConfig.setTypeSerializerOut(StringSerializer.INSTANCE)___		Map<Integer, StreamConfig> chainedConfigs = new HashMap<>(2)__		chainedConfigs.put(1, watermarkOperatorConfig)__		chainedConfigs.put(2, tailOperatorConfig)__		headOperatorConfig.setTransitiveChainedTaskConfigs(chainedConfigs)__		headOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)___		__		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,head,operator,config,test,harness,get,stream,config,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,stream,config,watermark,operator,config,new,stream,config,new,configuration,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,tail,operator,config,new,stream,config,new,configuration,head,operator,config,set,stream,operator,head,operator,head,operator,config,set,chain,start,head,operator,config,set,chain,index,0,head,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,0,null,null,null,null,null,new,stream,node,null,1,null,null,null,null,null,0,collections,string,empty,list,null,null,watermark,operator,config,set,stream,operator,watermark,operator,watermark,operator,config,set,type,serializer,in1,string,serializer,instance,watermark,operator,config,set,chain,index,1,watermark,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,1,null,null,null,null,null,new,stream,node,null,2,null,null,null,null,null,0,collections,string,empty,list,null,null,list,stream,edge,out,edges,in,order,new,linked,list,stream,edge,out,edges,in,order,add,new,stream,edge,new,stream,node,null,2,null,null,null,null,null,new,stream,node,null,3,null,null,null,null,null,0,collections,string,empty,list,new,broadcast,partitioner,object,null,tail,operator,config,set,stream,operator,tail,operator,tail,operator,config,set,type,serializer,in1,string,serializer,instance,tail,operator,config,set,buffer,timeout,0,tail,operator,config,set,chain,index,2,tail,operator,config,set,chain,end,tail,operator,config,set,output,selectors,collections,output,selector,empty,list,tail,operator,config,set,number,of,outputs,1,tail,operator,config,set,out,edges,in,order,out,edges,in,order,tail,operator,config,set,non,chained,outputs,out,edges,in,order,tail,operator,config,set,type,serializer,out,string,serializer,instance,map,integer,stream,config,chained,configs,new,hash,map,2,chained,configs,put,1,watermark,operator,config,chained,configs,put,2,tail,operator,config,head,operator,config,set,transitive,chained,task,configs,chained,configs,head,operator,config,set,out,edges,in,order,out,edges,in,order,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1502801814;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		__		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		OperatorID headOperatorId = new OperatorID()___		StreamConfig headOperatorConfig = testHarness.getStreamConfig()___		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		OperatorID watermarkOperatorId = new OperatorID()___		StreamConfig watermarkOperatorConfig = new StreamConfig(new Configuration())___		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()__		OperatorID tailOperatorId = new OperatorID()__		StreamConfig tailOperatorConfig = new StreamConfig(new Configuration())___		headOperatorConfig.setStreamOperator(headOperator)__		headOperatorConfig.setOperatorID(headOperatorId)__		headOperatorConfig.setChainStart()__		headOperatorConfig.setChainIndex(0)__		headOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 0, null, null, null, null, null),_			new StreamNode(null, 1, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null,_			null_		)))___		watermarkOperatorConfig.setStreamOperator(watermarkOperator)__		watermarkOperatorConfig.setOperatorID(watermarkOperatorId)__		watermarkOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		watermarkOperatorConfig.setChainIndex(1)__		watermarkOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 1, null, null, null, null, null),_			new StreamNode(null, 2, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null,_			null_		)))___		List<StreamEdge> outEdgesInOrder = new LinkedList<StreamEdge>()__		outEdgesInOrder.add(new StreamEdge(_			new StreamNode(null, 2, null, null, null, null, null),_			new StreamNode(null, 3, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			new BroadcastPartitioner<Object>(),_			null))___		tailOperatorConfig.setStreamOperator(tailOperator)__		tailOperatorConfig.setOperatorID(tailOperatorId)__		tailOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		tailOperatorConfig.setBufferTimeout(0)__		tailOperatorConfig.setChainIndex(2)__		tailOperatorConfig.setChainEnd()__		tailOperatorConfig.setOutputSelectors(Collections.<OutputSelector<?>>emptyList())__		tailOperatorConfig.setNumberOfOutputs(1)__		tailOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)__		tailOperatorConfig.setNonChainedOutputs(outEdgesInOrder)__		tailOperatorConfig.setTypeSerializerOut(StringSerializer.INSTANCE)___		Map<Integer, StreamConfig> chainedConfigs = new HashMap<>(2)__		chainedConfigs.put(1, watermarkOperatorConfig)__		chainedConfigs.put(2, tailOperatorConfig)__		headOperatorConfig.setTransitiveChainedTaskConfigs(chainedConfigs)__		headOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)___		__		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,operator,id,head,operator,id,new,operator,id,stream,config,head,operator,config,test,harness,get,stream,config,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,operator,id,watermark,operator,id,new,operator,id,stream,config,watermark,operator,config,new,stream,config,new,configuration,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,operator,id,tail,operator,id,new,operator,id,stream,config,tail,operator,config,new,stream,config,new,configuration,head,operator,config,set,stream,operator,head,operator,head,operator,config,set,operator,id,head,operator,id,head,operator,config,set,chain,start,head,operator,config,set,chain,index,0,head,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,0,null,null,null,null,null,new,stream,node,null,1,null,null,null,null,null,0,collections,string,empty,list,null,null,watermark,operator,config,set,stream,operator,watermark,operator,watermark,operator,config,set,operator,id,watermark,operator,id,watermark,operator,config,set,type,serializer,in1,string,serializer,instance,watermark,operator,config,set,chain,index,1,watermark,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,1,null,null,null,null,null,new,stream,node,null,2,null,null,null,null,null,0,collections,string,empty,list,null,null,list,stream,edge,out,edges,in,order,new,linked,list,stream,edge,out,edges,in,order,add,new,stream,edge,new,stream,node,null,2,null,null,null,null,null,new,stream,node,null,3,null,null,null,null,null,0,collections,string,empty,list,new,broadcast,partitioner,object,null,tail,operator,config,set,stream,operator,tail,operator,tail,operator,config,set,operator,id,tail,operator,id,tail,operator,config,set,type,serializer,in1,string,serializer,instance,tail,operator,config,set,buffer,timeout,0,tail,operator,config,set,chain,index,2,tail,operator,config,set,chain,end,tail,operator,config,set,output,selectors,collections,output,selector,empty,list,tail,operator,config,set,number,of,outputs,1,tail,operator,config,set,out,edges,in,order,out,edges,in,order,tail,operator,config,set,non,chained,outputs,out,edges,in,order,tail,operator,config,set,type,serializer,out,string,serializer,instance,map,integer,stream,config,chained,configs,new,hash,map,2,chained,configs,put,1,watermark,operator,config,chained,configs,put,2,tail,operator,config,head,operator,config,set,transitive,chained,task,configs,chained,configs,head,operator,config,set,out,edges,in,order,out,edges,in,order,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1503598628;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		__		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig headOperatorConfig = testHarness.getStreamConfig()___		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		StreamConfig watermarkOperatorConfig = new StreamConfig(new Configuration())___		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()__		StreamConfig tailOperatorConfig = new StreamConfig(new Configuration())___		headOperatorConfig.setStreamOperator(headOperator)__		headOperatorConfig.setOperatorID(new OperatorID(42L, 42L))__		headOperatorConfig.setChainStart()__		headOperatorConfig.setChainIndex(0)__		headOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 0, null, null, null, null, null),_			new StreamNode(null, 1, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null,_			null_		)))___		watermarkOperatorConfig.setStreamOperator(watermarkOperator)__		watermarkOperatorConfig.setOperatorID(new OperatorID(4711L, 42L))__		watermarkOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		watermarkOperatorConfig.setChainIndex(1)__		watermarkOperatorConfig.setChainedOutputs(Collections.singletonList(new StreamEdge(_			new StreamNode(null, 1, null, null, null, null, null),_			new StreamNode(null, 2, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			null,_			null_		)))___		List<StreamEdge> outEdgesInOrder = new LinkedList<StreamEdge>()__		outEdgesInOrder.add(new StreamEdge(_			new StreamNode(null, 2, null, null, null, null, null),_			new StreamNode(null, 3, null, null, null, null, null),_			0,_			Collections.<String>emptyList(),_			new BroadcastPartitioner<Object>(),_			null))___		tailOperatorConfig.setStreamOperator(tailOperator)__		tailOperatorConfig.setOperatorID(new OperatorID(123L, 123L))__		tailOperatorConfig.setTypeSerializerIn1(StringSerializer.INSTANCE)__		tailOperatorConfig.setBufferTimeout(0)__		tailOperatorConfig.setChainIndex(2)__		tailOperatorConfig.setChainEnd()__		tailOperatorConfig.setOutputSelectors(Collections.<OutputSelector<?>>emptyList())__		tailOperatorConfig.setNumberOfOutputs(1)__		tailOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)__		tailOperatorConfig.setNonChainedOutputs(outEdgesInOrder)__		tailOperatorConfig.setTypeSerializerOut(StringSerializer.INSTANCE)___		Map<Integer, StreamConfig> chainedConfigs = new HashMap<>(2)__		chainedConfigs.put(1, watermarkOperatorConfig)__		chainedConfigs.put(2, tailOperatorConfig)__		headOperatorConfig.setTransitiveChainedTaskConfigs(chainedConfigs)__		headOperatorConfig.setOutEdgesInOrder(outEdgesInOrder)___		__		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,head,operator,config,test,harness,get,stream,config,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,stream,config,watermark,operator,config,new,stream,config,new,configuration,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,stream,config,tail,operator,config,new,stream,config,new,configuration,head,operator,config,set,stream,operator,head,operator,head,operator,config,set,operator,id,new,operator,id,42l,42l,head,operator,config,set,chain,start,head,operator,config,set,chain,index,0,head,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,0,null,null,null,null,null,new,stream,node,null,1,null,null,null,null,null,0,collections,string,empty,list,null,null,watermark,operator,config,set,stream,operator,watermark,operator,watermark,operator,config,set,operator,id,new,operator,id,4711l,42l,watermark,operator,config,set,type,serializer,in1,string,serializer,instance,watermark,operator,config,set,chain,index,1,watermark,operator,config,set,chained,outputs,collections,singleton,list,new,stream,edge,new,stream,node,null,1,null,null,null,null,null,new,stream,node,null,2,null,null,null,null,null,0,collections,string,empty,list,null,null,list,stream,edge,out,edges,in,order,new,linked,list,stream,edge,out,edges,in,order,add,new,stream,edge,new,stream,node,null,2,null,null,null,null,null,new,stream,node,null,3,null,null,null,null,null,0,collections,string,empty,list,new,broadcast,partitioner,object,null,tail,operator,config,set,stream,operator,tail,operator,tail,operator,config,set,operator,id,new,operator,id,123l,123l,tail,operator,config,set,type,serializer,in1,string,serializer,instance,tail,operator,config,set,buffer,timeout,0,tail,operator,config,set,chain,index,2,tail,operator,config,set,chain,end,tail,operator,config,set,output,selectors,collections,output,selector,empty,list,tail,operator,config,set,number,of,outputs,1,tail,operator,config,set,out,edges,in,order,out,edges,in,order,tail,operator,config,set,non,chained,outputs,out,edges,in,order,tail,operator,config,set,type,serializer,out,string,serializer,instance,map,integer,stream,config,chained,configs,new,hash,map,2,chained,configs,put,1,watermark,operator,config,chained,configs,put,2,tail,operator,config,head,operator,config,set,transitive,chained,task,configs,chained,configs,head,operator,config,set,out,edges,in,order,out,edges,in,order,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1508850403;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1508850407;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1508969168;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1509118643;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {_		final OneInputStreamTask<String, String> testTask = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<String, String>(_				testTask, 1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,string,string,test,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,string,string,test,task,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1515519059;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1516626397;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1517489695;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1517584327;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1519568061;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1528997616;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1531303507;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1531381123;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1535979810;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
OneInputStreamTaskTest -> @Test 	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception;1550833397;This test verifies that watermarks are not forwarded when the task is idle._It also verifies that when task is idle, watermarks generated in the middle of chains are also blocked and_never forwarded.__<p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) --> (normal operator)._The operators will throw an exception and fail the test if either of them were forwarded watermarks when_the task is idle.;@Test_	public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {__		final OneInputStreamTaskTestHarness<String, String> testHarness =_			new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)___		TriggerableFailOnWatermarkTestOperator headOperator = new TriggerableFailOnWatermarkTestOperator()__		WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator()__		TriggerableFailOnWatermarkTestOperator tailOperator = new TriggerableFailOnWatermarkTestOperator()___		testHarness.setupOperatorChain(new OperatorID(42L, 42L), headOperator)_			.chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)_			.chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)_			.finish()___		__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("10"), 0, 0)___		_		_		testHarness.processElement(new Watermark(15))___		testHarness.processElement(new StreamRecord<>("20"), 0, 0)__		testHarness.processElement(new StreamRecord<>("30"), 0, 0)___		testHarness.waitForInputProcessing()___		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("10"))__		expectedOutput.add(new Watermark(10))__		expectedOutput.add(new StreamRecord<>("20"))__		expectedOutput.add(new Watermark(20))__		expectedOutput.add(new StreamRecord<>("30"))__		expectedOutput.add(new Watermark(30))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE)___		_		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))___		_		_		testHarness.processElement(new StreamRecord<>("40"), 0, 0)__		testHarness.processElement(new StreamRecord<>("50"), 0, 0)__		testHarness.processElement(new StreamRecord<>("60"), 0, 0)__		testHarness.processElement(new Watermark(65))_ _		testHarness.waitForInputProcessing()___		_		expectedOutput.add(StreamStatus.IDLE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("40"))__		expectedOutput.add(new StreamRecord<>("50"))__		expectedOutput.add(new StreamRecord<>("60"))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE)__		testHarness.processElement(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))___		testHarness.processElement(new StreamRecord<>("70"), 0, 0)__		testHarness.processElement(new StreamRecord<>("80"), 0, 0)__		testHarness.processElement(new StreamRecord<>("90"), 0, 0)__		testHarness.waitForInputProcessing()___		expectedOutput.add(StreamStatus.ACTIVE)__		expectedOutput.add(new StreamRecord<>(TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER))__		expectedOutput.add(new StreamRecord<>("70"))__		expectedOutput.add(new Watermark(70))__		expectedOutput.add(new StreamRecord<>("80"))__		expectedOutput.add(new Watermark(80))__		expectedOutput.add(new StreamRecord<>("90"))__		expectedOutput.add(new Watermark(90))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		assertEquals(12, resultElements.size())__	};this,test,verifies,that,watermarks,are,not,forwarded,when,the,task,is,idle,it,also,verifies,that,when,task,is,idle,watermarks,generated,in,the,middle,of,chains,are,also,blocked,and,never,forwarded,p,the,tested,chain,will,be,head,normal,operator,watermark,generating,operator,normal,operator,the,operators,will,throw,an,exception,and,fail,the,test,if,either,of,them,were,forwarded,watermarks,when,the,task,is,idle;test,public,void,test,watermarks,not,forwarded,within,chain,when,idle,throws,exception,final,one,input,stream,task,test,harness,string,string,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,triggerable,fail,on,watermark,test,operator,head,operator,new,triggerable,fail,on,watermark,test,operator,watermark,generating,test,operator,watermark,operator,new,watermark,generating,test,operator,triggerable,fail,on,watermark,test,operator,tail,operator,new,triggerable,fail,on,watermark,test,operator,test,harness,setup,operator,chain,new,operator,id,42l,42l,head,operator,chain,new,operator,id,4711l,42l,watermark,operator,string,serializer,instance,chain,new,operator,id,123l,123l,tail,operator,string,serializer,instance,finish,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,10,0,0,test,harness,process,element,new,watermark,15,test,harness,process,element,new,stream,record,20,0,0,test,harness,process,element,new,stream,record,30,0,0,test,harness,wait,for,input,processing,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,10,expected,output,add,new,watermark,10,expected,output,add,new,stream,record,20,expected,output,add,new,watermark,20,expected,output,add,new,stream,record,30,expected,output,add,new,watermark,30,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,40,0,0,test,harness,process,element,new,stream,record,50,0,0,test,harness,process,element,new,stream,record,60,0,0,test,harness,process,element,new,watermark,65,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,40,expected,output,add,new,stream,record,50,expected,output,add,new,stream,record,60,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,test,harness,process,element,new,stream,record,triggerable,fail,on,watermark,test,operator,test,harness,process,element,new,stream,record,70,0,0,test,harness,process,element,new,stream,record,80,0,0,test,harness,process,element,new,stream,record,90,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,expected,output,add,new,stream,record,triggerable,fail,on,watermark,test,operator,expected,output,add,new,stream,record,70,expected,output,add,new,watermark,70,expected,output,add,new,stream,record,80,expected,output,add,new,watermark,80,expected,output,add,new,stream,record,90,expected,output,add,new,watermark,90,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,equals,12,result,elements,size
