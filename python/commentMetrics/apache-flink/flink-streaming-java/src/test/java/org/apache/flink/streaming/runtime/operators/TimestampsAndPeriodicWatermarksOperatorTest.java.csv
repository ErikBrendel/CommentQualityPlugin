commented;modifiers;parameterAmount;loc;comment;code
false;public;0;82;;@Test public void testTimestampsAndPeriodicWatermarksOperator() throws Exception {     final TimestampsAndPeriodicWatermarksOperator<Long> operator = new TimestampsAndPeriodicWatermarksOperator<Long>(new LongExtractor()).     OneInputStreamOperatorTestHarness<Long, Long> testHarness = new OneInputStreamOperatorTestHarness<>(operator).     testHarness.getExecutionConfig().setAutoWatermarkInterval(50).     long currentTime = 0.     testHarness.open().     testHarness.processElement(new StreamRecord<>(1L, 1)).     testHarness.processElement(new StreamRecord<>(2L, 1)).     // this watermark should be ignored     testHarness.processWatermark(new Watermark(2)).     testHarness.processElement(new StreamRecord<>(3L, 3)).     testHarness.processElement(new StreamRecord<>(4L, 3)).     // validate first part of the sequence. we poll elements until our     // watermark updates to "3", which must be the result of the "4" element.     {         ConcurrentLinkedQueue<Object> output = testHarness.getOutput().         long nextElementValue = 1L.         long lastWatermark = -1L.         while (lastWatermark < 3) {             if (output.size() > 0) {                 Object next = output.poll().                 assertNotNull(next).                 Tuple2<Long, Long> update = validateElement(next, nextElementValue, lastWatermark).                 nextElementValue = update.f0.                 lastWatermark = update.f1.                 // check the invariant                 assertTrue(lastWatermark < nextElementValue).             } else {                 currentTime = currentTime + 10.                 testHarness.setProcessingTime(currentTime).             }         }         output.clear().     }     testHarness.processElement(new StreamRecord<>(4L, 4)).     testHarness.processElement(new StreamRecord<>(5L, 4)).     testHarness.processElement(new StreamRecord<>(6L, 4)).     testHarness.processElement(new StreamRecord<>(7L, 4)).     testHarness.processElement(new StreamRecord<>(8L, 4)).     // validate the next part of the sequence. we poll elements until our     // watermark updates to "7", which must be the result of the "8" element.     {         ConcurrentLinkedQueue<Object> output = testHarness.getOutput().         long nextElementValue = 4L.         long lastWatermark = 2L.         while (lastWatermark < 7) {             if (output.size() > 0) {                 Object next = output.poll().                 assertNotNull(next).                 Tuple2<Long, Long> update = validateElement(next, nextElementValue, lastWatermark).                 nextElementValue = update.f0.                 lastWatermark = update.f1.                 // check the invariant                 assertTrue(lastWatermark < nextElementValue).             } else {                 currentTime = currentTime + 10.                 testHarness.setProcessingTime(currentTime).             }         }         output.clear().     }     testHarness.processWatermark(new Watermark(Long.MAX_VALUE)).     assertEquals(Long.MAX_VALUE, ((Watermark) testHarness.getOutput().poll()).getTimestamp()). }
false;public;0;27;;@Test public void testNegativeTimestamps() throws Exception {     final AssignerWithPeriodicWatermarks<Long> assigner = new NeverWatermarkExtractor().     final TimestampsAndPeriodicWatermarksOperator<Long> operator = new TimestampsAndPeriodicWatermarksOperator<Long>(assigner).     OneInputStreamOperatorTestHarness<Long, Long> testHarness = new OneInputStreamOperatorTestHarness<Long, Long>(operator).     testHarness.getExecutionConfig().setAutoWatermarkInterval(50).     testHarness.open().     long[] values = { Long.MIN_VALUE, -1L, 0L, 1L, 2L, 3L, Long.MAX_VALUE }.     for (long value : values) {         testHarness.processElement(new StreamRecord<>(value)).     }     ConcurrentLinkedQueue<Object> output = testHarness.getOutput().     for (long value : values) {         assertEquals(value, ((StreamRecord<?>) output.poll()).getTimestamp()).     } }
false;private;3;17;;// ------------------------------------------------------------------------ private Tuple2<Long, Long> validateElement(Object element, long nextElementValue, long currentWatermark) {     if (element instanceof StreamRecord) {         @SuppressWarnings("unchecked")         StreamRecord<Long> record = (StreamRecord<Long>) element.         assertEquals(nextElementValue, record.getValue().longValue()).         assertEquals(nextElementValue, record.getTimestamp()).         return new Tuple2<>(nextElementValue + 1, currentWatermark).     } else if (element instanceof Watermark) {         long wt = ((Watermark) element).getTimestamp().         assertTrue(wt > currentWatermark).         return new Tuple2<>(nextElementValue, wt).     } else {         throw new IllegalArgumentException("unrecognized element: " + element).     } }
false;public;2;5;;@Override public long extractTimestamp(Long element, long previousElementTimestamp) {     currentTimestamp = element.     return element. }
false;public;0;4;;@Override public Watermark getCurrentWatermark() {     return new Watermark(currentTimestamp == Long.MIN_VALUE ? Long.MIN_VALUE : currentTimestamp - 1). }
false;public;2;4;;@Override public long extractTimestamp(Long element, long previousElementTimestamp) {     return element. }
false;public;0;4;;@Override public Watermark getCurrentWatermark() {     return null. }
