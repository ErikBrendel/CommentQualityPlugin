commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Test public void fromElementsWithBaseTypeTest1() {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.fromElements(ParentClass.class, new SubClass(1, "Java"), new ParentClass(1, "hello")). }
false;public;0;5;;@Test(expected = IllegalArgumentException.class) public void fromElementsWithBaseTypeTest2() {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.fromElements(SubClass.class, new SubClass(1, "Java"), new ParentClass(1, "hello")). }
false;public;0;36;;@Test @SuppressWarnings("unchecked") public void testFromCollectionParallelism() {     try {         TypeInformation<Integer> typeInfo = BasicTypeInfo.INT_TYPE_INFO.         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         DataStreamSource<Integer> dataStream1 = env.fromCollection(new DummySplittableIterator<Integer>(), typeInfo).         try {             dataStream1.setParallelism(4).             fail("should throw an exception").         } catch (IllegalArgumentException e) {         // expected         }         dataStream1.addSink(new DiscardingSink<Integer>()).         DataStreamSource<Integer> dataStream2 = env.fromParallelCollection(new DummySplittableIterator<Integer>(), typeInfo).setParallelism(4).         dataStream2.addSink(new DiscardingSink<Integer>()).         env.getExecutionPlan().         assertEquals("Parallelism of collection source must be 1.", 1, env.getStreamGraph().getStreamNode(dataStream1.getId()).getParallelism()).         assertEquals("Parallelism of parallel collection source must be 4.", 4, env.getStreamGraph().getStreamNode(dataStream2.getId()).getParallelism()).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;1;3;;@Override public void run(SourceContext<Integer> ctx) throws Exception { }
false;public;0;3;;@Override public void cancel() { }
false;public;0;30;;@Test public void testSources() {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     SourceFunction<Integer> srcFun = new SourceFunction<Integer>() {          private static final long serialVersionUID = 1L.          @Override         public void run(SourceContext<Integer> ctx) throws Exception {         }          @Override         public void cancel() {         }     }.     DataStreamSource<Integer> src1 = env.addSource(srcFun).     src1.addSink(new DiscardingSink<Integer>()).     assertEquals(srcFun, getFunctionFromDataSource(src1)).     List<Long> list = Arrays.asList(0L, 1L, 2L).     DataStreamSource<Long> src2 = env.generateSequence(0, 2).     assertTrue(getFunctionFromDataSource(src2) instanceof StatefulSequenceSource).     DataStreamSource<Long> src3 = env.fromElements(0L, 1L, 2L).     assertTrue(getFunctionFromDataSource(src3) instanceof FromElementsFunction).     DataStreamSource<Long> src4 = env.fromCollection(list).     assertTrue(getFunctionFromDataSource(src4) instanceof FromElementsFunction). }
false;public;1;3;;@Override public void run(SourceContext<Integer> ctx) throws Exception { }
false;public;0;3;;@Override public void cancel() { }
false;public;2;4;;@Override public void flatMap(Integer value, Collector<Object> out) throws Exception { }
false;public;0;94;;@Test public void testParallelismBounds() {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     SourceFunction<Integer> srcFun = new SourceFunction<Integer>() {          private static final long serialVersionUID = 1L.          @Override         public void run(SourceContext<Integer> ctx) throws Exception {         }          @Override         public void cancel() {         }     }.     SingleOutputStreamOperator<Object> operator = env.addSource(srcFun).flatMap(new FlatMapFunction<Integer, Object>() {          private static final long serialVersionUID = 1L.          @Override         public void flatMap(Integer value, Collector<Object> out) throws Exception {         }     }).     // default value for max parallelism     Assert.assertEquals(-1, operator.getTransformation().getMaxParallelism()).     // bounds for parallelism 1     try {         operator.setParallelism(0).         Assert.fail().     } catch (IllegalArgumentException expected) {     }     // bounds for parallelism 2     operator.setParallelism(1).     Assert.assertEquals(1, operator.getParallelism()).     // bounds for parallelism 3     operator.setParallelism(1 << 15).     Assert.assertEquals(1 << 15, operator.getParallelism()).     // default value after generating     env.getStreamGraph().getJobGraph().     Assert.assertEquals(-1, operator.getTransformation().getMaxParallelism()).     // configured value after generating     env.setMaxParallelism(42).     env.getStreamGraph().getJobGraph().     Assert.assertEquals(42, operator.getTransformation().getMaxParallelism()).     // bounds configured parallelism 1     try {         env.setMaxParallelism(0).         Assert.fail().     } catch (IllegalArgumentException expected) {     }     // bounds configured parallelism 2     try {         env.setMaxParallelism(1 + (1 << 15)).         Assert.fail().     } catch (IllegalArgumentException expected) {     }     // bounds for max parallelism 1     try {         operator.setMaxParallelism(0).         Assert.fail().     } catch (IllegalArgumentException expected) {     }     // bounds for max parallelism 2     try {         operator.setMaxParallelism(1 + (1 << 15)).         Assert.fail().     } catch (IllegalArgumentException expected) {     }     // bounds for max parallelism 3     operator.setMaxParallelism(1).     Assert.assertEquals(1, operator.getTransformation().getMaxParallelism()).     // bounds for max parallelism 4     operator.setMaxParallelism(1 << 15).     Assert.assertEquals(1 << 15, operator.getTransformation().getMaxParallelism()).     // override config     env.getStreamGraph().getJobGraph().     Assert.assertEquals(1 << 15, operator.getTransformation().getMaxParallelism()). }
false;private,static;1;5;;// /////////////////////////////////////////////////////////// // Utilities // /////////////////////////////////////////////////////////// private static StreamOperator<?> getOperatorFromDataStream(DataStream<?> dataStream) {     StreamExecutionEnvironment env = dataStream.getExecutionEnvironment().     StreamGraph streamGraph = env.getStreamGraph().     return streamGraph.getStreamNode(dataStream.getId()).getOperator(). }
false;private,static;1;7;;@SuppressWarnings("unchecked") private static <T> SourceFunction<T> getFunctionFromDataSource(DataStreamSource<T> dataStreamSource) {     dataStreamSource.addSink(new DiscardingSink<T>()).     AbstractUdfStreamOperator<?, ?> operator = (AbstractUdfStreamOperator<?, ?>) getOperatorFromDataStream(dataStreamSource).     return (SourceFunction<T>) operator.getUserFunction(). }
false;public;1;5;;@SuppressWarnings("unchecked") @Override public Iterator<T>[] split(int numPartitions) {     return (Iterator<T>[]) new Iterator<?>[0]. }
false;public;0;4;;@Override public int getMaximumNumberOfSplits() {     return 0. }
false;public;0;4;;@Override public boolean hasNext() {     return false. }
false;public;0;4;;@Override public T next() {     throw new NoSuchElementException(). }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
