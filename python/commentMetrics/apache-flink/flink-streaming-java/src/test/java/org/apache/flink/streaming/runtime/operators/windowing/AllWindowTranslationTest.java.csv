commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;@Override public Tuple2<String, Integer> reduce(Tuple2<String, Integer> value1, Tuple2<String, Integer> value2) throws Exception {     return null. }
true;public;0;21;/**  * .reduce() does not support RichReduceFunction, since the reduce function is used internally  * in a {@code ReducingState}.  */ ;// ------------------------------------------------------------------------ // rich function tests // ------------------------------------------------------------------------ /**  * .reduce() does not support RichReduceFunction, since the reduce function is used internally  * in a {@code ReducingState}.  */ @Test(expected = UnsupportedOperationException.class) public void testReduceWithRichReducerFails() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).reduce(new RichReduceFunction<Tuple2<String, Integer>>() {          private static final long serialVersionUID = -6448847205314995812L.          @Override         public Tuple2<String, Integer> reduce(Tuple2<String, Integer> value1, Tuple2<String, Integer> value2) throws Exception {             return null.         }     }).     fail("exception was not thrown"). }
true;public;0;13;/**  * .aggregate() does not support RichAggregateFunction, since the AggregateFunction is used internally  * in an {@code AggregatingState}.  */ ;/**  * .aggregate() does not support RichAggregateFunction, since the AggregateFunction is used internally  * in an {@code AggregatingState}.  */ @Test(expected = UnsupportedOperationException.class) public void testAggregateWithRichFunctionFails() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).aggregate(new DummyRichAggregationFunction<Tuple2<String, Integer>>()).     fail("exception was not thrown"). }
false;public;2;5;;@Override public Tuple2<String, Integer> fold(Tuple2<String, Integer> value1, Tuple2<String, Integer> value2) throws Exception {     return null. }
true;public;0;21;/**  * .fold() does not support RichFoldFunction, since the fold function is used internally  * in a {@code FoldingState}.  */ ;/**  * .fold() does not support RichFoldFunction, since the fold function is used internally  * in a {@code FoldingState}.  */ @Test(expected = UnsupportedOperationException.class) public void testFoldWithRichFolderFails() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).fold(new Tuple2<>("", 0), new RichFoldFunction<Tuple2<String, Integer>, Tuple2<String, Integer>>() {          private static final long serialVersionUID = -6448847205314995812L.          @Override         public Tuple2<String, Integer> fold(Tuple2<String, Integer> value1, Tuple2<String, Integer> value2) throws Exception {             return null.         }     }).     fail("exception was not thrown"). }
false;public;2;4;;@Override public String fold(String accumulator, String value) throws Exception {     return accumulator. }
false;public;0;26;;// ------------------------------------------------------------------------ // Merging Windows Support // ------------------------------------------------------------------------ @Test public void testSessionWithFoldFails() throws Exception {     // verify that fold does not work with merging windows     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     AllWindowedStream<String, TimeWindow> windowedStream = env.fromElements("Hello", "Ciao").windowAll(EventTimeSessionWindows.withGap(Time.seconds(5))).     try {         windowedStream.fold("", new FoldFunction<String, String>() {              private static final long serialVersionUID = -4567902917104921706L.              @Override             public String fold(String accumulator, String value) throws Exception {                 return accumulator.             }         }).     } catch (UnsupportedOperationException e) {         // use a catch to ensure that the exception is thrown by the fold         return.     }     fail("The fold call should fail."). }
false;public;4;7;;@Override public TriggerResult onElement(String element, long timestamp, TimeWindow window, TriggerContext ctx) throws Exception {     return null. }
false;public;3;6;;@Override public TriggerResult onProcessingTime(long time, TimeWindow window, TriggerContext ctx) throws Exception {     return null. }
false;public;3;6;;@Override public TriggerResult onEventTime(long time, TimeWindow window, TriggerContext ctx) throws Exception {     return null. }
false;public;0;4;;@Override public boolean canMerge() {     return false. }
false;public;2;2;;@Override public void clear(TimeWindow window, TriggerContext ctx) throws Exception { }
false;public;0;51;;@Test public void testMergingAssignerWithNonMergingTriggerFails() throws Exception {     // verify that we check for trigger compatibility     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     AllWindowedStream<String, TimeWindow> windowedStream = env.fromElements("Hello", "Ciao").windowAll(EventTimeSessionWindows.withGap(Time.seconds(5))).     try {         windowedStream.trigger(new Trigger<String, TimeWindow>() {              private static final long serialVersionUID = 6558046711583024443L.              @Override             public TriggerResult onElement(String element, long timestamp, TimeWindow window, TriggerContext ctx) throws Exception {                 return null.             }              @Override             public TriggerResult onProcessingTime(long time, TimeWindow window, TriggerContext ctx) throws Exception {                 return null.             }              @Override             public TriggerResult onEventTime(long time, TimeWindow window, TriggerContext ctx) throws Exception {                 return null.             }              @Override             public boolean canMerge() {                 return false.             }              @Override             public void clear(TimeWindow window, TriggerContext ctx) throws Exception {             }         }).     } catch (UnsupportedOperationException e) {         // use a catch to ensure that the exception is thrown by the fold         return.     }     fail("The trigger call should fail."). }
false;public;0;23;;@Test @SuppressWarnings("rawtypes") public void testMergingWindowsWithEvictor() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple3<String, String, Integer>> window1 = source.windowAll(EventTimeSessionWindows.withGap(Time.seconds(5))).evictor(CountEvictor.of(5)).process(new TestProcessAllWindowFunction()).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof EventTimeSessionWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;22;;// ------------------------------------------------------------------------ // reduce() translation tests // ------------------------------------------------------------------------ @Test @SuppressWarnings("rawtypes") public void testReduceEventTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).reduce(new DummyReducer()).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ReducingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;22;;@Test @SuppressWarnings("rawtypes") public void testReduceProcessingTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(SlidingProcessingTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).reduce(new DummyReducer()).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof ProcessingTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingProcessingTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ReducingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(new Tuple3<>(in.f0, in.f0, in.f1)).     } }
false;public;0;37;;@Test @SuppressWarnings("rawtypes") public void testReduceWithWindowFunctionEventTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DummyReducer reducer = new DummyReducer().     DataStream<Tuple3<String, String, Integer>> window = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).reduce(reducer, new AllWindowFunction<Tuple2<String, Integer>, Tuple3<String, String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(new Tuple3<>(in.f0, in.f0, in.f1)).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ReducingStateDescriptor).     processElementAndEnsureOutput(operator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(new Tuple3<>(in.f0, in.f0, in.f1)).     } }
false;public;0;35;;@Test @SuppressWarnings("rawtypes") public void testReduceWithWindowFunctionProcessingTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple3<String, String, Integer>> window = source.windowAll(TumblingProcessingTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).reduce(new DummyReducer(), new AllWindowFunction<Tuple2<String, Integer>, Tuple3<String, String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(new Tuple3<>(in.f0, in.f0, in.f1)).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof ProcessingTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingProcessingTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ReducingStateDescriptor).     processElementAndEnsureOutput(operator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(new Tuple3<>(in.f0, in.f0, in.f1)).     } }
false;public;0;37;;@Test @SuppressWarnings("rawtypes") public void testReduceWithProcessWindowFunctionEventTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DummyReducer reducer = new DummyReducer().     DataStream<Tuple3<String, String, Integer>> window = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).reduce(reducer, new ProcessAllWindowFunction<Tuple2<String, Integer>, Tuple3<String, String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(new Tuple3<>(in.f0, in.f0, in.f1)).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ReducingStateDescriptor).     processElementAndEnsureOutput(operator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(new Tuple3<>(in.f0, in.f0, in.f1)).     } }
false;public;0;35;;@Test @SuppressWarnings("rawtypes") public void testReduceWithProcessWindowFunctionProcessingTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple3<String, String, Integer>> window = source.windowAll(TumblingProcessingTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).reduce(new DummyReducer(), new ProcessAllWindowFunction<Tuple2<String, Integer>, Tuple3<String, String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(new Tuple3<>(in.f0, in.f0, in.f1)).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof ProcessingTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingProcessingTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ReducingStateDescriptor).     processElementAndEnsureOutput(operator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void process(Context context, Iterable<Tuple2<String, Integer>> elements, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : elements) {         out.collect(in).     } }
false;public;0;38;;@Test @SuppressWarnings("rawtypes") public void testReduceWithEvictorAndProcessFunction() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DummyReducer reducer = new DummyReducer().     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).evictor(CountEvictor.of(100)).reduce(reducer, new ProcessAllWindowFunction<Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          @Override         public void process(Context context, Iterable<Tuple2<String, Integer>> elements, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : elements) {                 out.collect(in).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof EvictingWindowOperator).     EvictingWindowOperator<String, Tuple2<String, Integer>, ?, ?> winOperator = (EvictingWindowOperator<String, Tuple2<String, Integer>, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getEvictor() instanceof CountEvictor).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(new Tuple3<>(in.f0, in.f0, in.f1)).     } }
true;public;0;37;/**  * Test for the deprecated .apply(Reducer, WindowFunction).  */ ;/**  * Test for the deprecated .apply(Reducer, WindowFunction).  */ @Test @SuppressWarnings("rawtypes") public void testApplyWithPreReducerEventTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DummyReducer reducer = new DummyReducer().     DataStream<Tuple3<String, String, Integer>> window = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).apply(reducer, new AllWindowFunction<Tuple2<String, Integer>, Tuple3<String, String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(new Tuple3<>(in.f0, in.f0, in.f1)).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ReducingStateDescriptor).     processElementAndEnsureOutput(operator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;27;;// ------------------------------------------------------------------------ // aggregate() translation tests // ------------------------------------------------------------------------ @Test public void testAggregateEventTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).aggregate(new DummyAggregationFunction()).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof AggregatingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;27;;@Test public void testAggregateProcessingTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(SlidingProcessingTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).aggregate(new DummyAggregationFunction()).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof ProcessingTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingProcessingTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof AggregatingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;27;;@Test public void testAggregateWithWindowFunctionEventTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple3<String, String, Integer>> window = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).aggregate(new DummyAggregationFunction(), new TestAllWindowFunction()).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof AggregatingStateDescriptor).     processElementAndEnsureOutput(operator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;27;;@Test public void testAggregateWithWindowFunctionProcessingTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple3<String, String, Integer>> window = source.windowAll(TumblingProcessingTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).aggregate(new DummyAggregationFunction(), new TestAllWindowFunction()).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof ProcessingTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingProcessingTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof AggregatingStateDescriptor).     processElementAndEnsureOutput(operator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;28;;@Test public void testAggregateWithEvictor() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).evictor(CountEvictor.of(100)).aggregate(new DummyAggregationFunction()).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void process(Context context, Iterable<Tuple2<String, Integer>> elements, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : elements) {         out.collect(in).     } }
false;public;0;40;;@Test public void testAggregateWithEvictorAndProcessFunction() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).evictor(CountEvictor.of(100)).aggregate(new DummyAggregationFunction(), new ProcessAllWindowFunction<Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          @Override         public void process(Context context, Iterable<Tuple2<String, Integer>> elements, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : elements) {                 out.collect(in).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(in).     } }
false;public;0;34;;// ------------------------------------------------------------------------ // process() translation tests // ------------------------------------------------------------------------ @Test @SuppressWarnings("rawtypes") public void testProcessEventTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).process(new ProcessAllWindowFunction<Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(in).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(in).     } }
false;public;0;35;;@Test @SuppressWarnings("rawtypes") public void testProcessProcessingTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(TumblingProcessingTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).process(new ProcessAllWindowFunction<Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(in).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof ProcessingTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingProcessingTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(in).     } }
false;public;0;37;;@Test @SuppressWarnings("rawtypes") public void testProcessWithEvictor() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).trigger(CountTrigger.of(1)).evictor(TimeEvictor.of(Time.of(100, TimeUnit.MILLISECONDS))).process(new ProcessAllWindowFunction<Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(in).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof EvictingWindowOperator).     EvictingWindowOperator<String, Tuple2<String, Integer>, ?, ?> winOperator = (EvictingWindowOperator<String, Tuple2<String, Integer>, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof CountTrigger).     Assert.assertTrue(winOperator.getEvictor() instanceof TimeEvictor).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(in).     } }
false;public;0;35;;@Test @SuppressWarnings("rawtypes") public void testProcessWithCustomTrigger() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).trigger(CountTrigger.of(1)).process(new ProcessAllWindowFunction<Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(in).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof CountTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;23;;// ------------------------------------------------------------------------ // fold() translation tests // ------------------------------------------------------------------------ @Test @SuppressWarnings("rawtypes") public void testFoldEventTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple3<String, String, Integer>> window1 = source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).fold(new Tuple3<>("", "", 1), new DummyFolder()).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof FoldingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;23;;@Test @SuppressWarnings("rawtypes") public void testFoldProcessingTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple3<String, String, Integer>> window = source.windowAll(SlidingProcessingTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).fold(new Tuple3<>("", "", 0), new DummyFolder()).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof ProcessingTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingProcessingTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof FoldingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void apply(TimeWindow window, Iterable<Tuple3<String, String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple3<String, String, Integer> in : values) {         out.collect(new Tuple2<>(in.f0, in.f2)).     } }
false;public;0;35;;@Test @SuppressWarnings("rawtypes") public void testFoldWithWindowFunctionEventTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).fold(new Tuple3<>("", "", 0), new DummyFolder(), new AllWindowFunction<Tuple3<String, String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void apply(TimeWindow window, Iterable<Tuple3<String, String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple3<String, String, Integer> in : values) {                 out.collect(new Tuple2<>(in.f0, in.f2)).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof FoldingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void apply(TimeWindow window, Iterable<Tuple3<String, String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple3<String, String, Integer> in : values) {         out.collect(new Tuple2<>(in.f0, in.f2)).     } }
false;public;0;35;;@Test @SuppressWarnings("rawtypes") public void testFoldWithWindowFunctionProcessingTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window = source.windowAll(TumblingProcessingTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).fold(new Tuple3<>("", "empty", 0), new DummyFolder(), new AllWindowFunction<Tuple3<String, String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void apply(TimeWindow window, Iterable<Tuple3<String, String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple3<String, String, Integer> in : values) {                 out.collect(new Tuple2<>(in.f0, in.f2)).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof ProcessingTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingProcessingTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof FoldingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void process(Context ctx, Iterable<Tuple3<String, String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple3<String, String, Integer> in : values) {         out.collect(new Tuple2<>(in.f0, in.f2)).     } }
false;public;0;34;;@Test @SuppressWarnings("rawtypes") public void testFoldWithProcessAllWindowFunctionEventTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).fold(new Tuple3<>("", "", 0), new DummyFolder(), new ProcessAllWindowFunction<Tuple3<String, String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void process(Context ctx, Iterable<Tuple3<String, String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple3<String, String, Integer> in : values) {                 out.collect(new Tuple2<>(in.f0, in.f2)).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof FoldingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void process(Context ctx, Iterable<Tuple3<String, String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple3<String, String, Integer> in : values) {         out.collect(new Tuple2<>(in.f0, in.f2)).     } }
false;public;0;35;;@Test @SuppressWarnings("rawtypes") public void testFoldWithProcessAllWindowFunctionProcessingTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window = source.windowAll(TumblingProcessingTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).fold(new Tuple3<>("", "empty", 0), new DummyFolder(), new ProcessAllWindowFunction<Tuple3<String, String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void process(Context ctx, Iterable<Tuple3<String, String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple3<String, String, Integer> in : values) {                 out.collect(new Tuple2<>(in.f0, in.f2)).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof ProcessingTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingProcessingTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof FoldingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void process(Context context, Iterable<Tuple3<String, String, Integer>> elements, Collector<Tuple3<String, String, Integer>> out) throws Exception {     for (Tuple3<String, String, Integer> in : elements) {         out.collect(in).     } }
false;public;0;39;;@Test @SuppressWarnings({ "rawtypes", "unchecked" }) public void testFoldWithEvictorAndProcessFunction() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple3<String, String, Integer>> window1 = source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).evictor(CountEvictor.of(100)).fold(new Tuple3<>("", "", 1), new DummyFolder(), new ProcessAllWindowFunction<Tuple3<String, String, Integer>, Tuple3<String, String, Integer>, TimeWindow>() {          @Override         public void process(Context context, Iterable<Tuple3<String, String, Integer>> elements, Collector<Tuple3<String, String, Integer>> out) throws Exception {             for (Tuple3<String, String, Integer> in : elements) {                 out.collect(in).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof EvictingWindowOperator).     EvictingWindowOperator<String, Tuple2<String, Integer>, ?, ?> winOperator = (EvictingWindowOperator<String, Tuple2<String, Integer>, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getEvictor() instanceof CountEvictor).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     winOperator.setOutputType((TypeInformation) window1.getType(), new ExecutionConfig()).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void apply(TimeWindow window, Iterable<Tuple3<String, String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {     for (Tuple3<String, String, Integer> in : values) {         out.collect(new Tuple3<>(in.f0, in.f1, in.f2)).     } }
false;public;0;35;;@Test @SuppressWarnings("rawtypes") public void testApplyWithPreFolderEventTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple3<String, String, Integer>> window = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).apply(new Tuple3<>("", "", 0), new DummyFolder(), new AllWindowFunction<Tuple3<String, String, Integer>, Tuple3<String, String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void apply(TimeWindow window, Iterable<Tuple3<String, String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {             for (Tuple3<String, String, Integer> in : values) {                 out.collect(new Tuple3<>(in.f0, in.f1, in.f2)).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof FoldingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(in).     } }
false;public;0;34;;// ------------------------------------------------------------------------ // apply() translation tests // ------------------------------------------------------------------------ @Test @SuppressWarnings("rawtypes") public void testApplyEventTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).apply(new AllWindowFunction<Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(in).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(in).     } }
false;public;0;35;;@Test @SuppressWarnings("rawtypes") public void testApplyProcessingTimeTime() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(TumblingProcessingTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).apply(new AllWindowFunction<Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(in).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof ProcessingTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingProcessingTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;25;;@Test @SuppressWarnings("rawtypes") public void testReduceWithCustomTrigger() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DummyReducer reducer = new DummyReducer().     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).trigger(CountTrigger.of(1)).reduce(reducer).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof CountTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ReducingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;24;;@Test @SuppressWarnings("rawtypes") public void testFoldWithCustomTrigger() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple3<String, String, Integer>> window1 = source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).trigger(CountTrigger.of(1)).fold(new Tuple3<>("", "", 1), new DummyFolder()).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof CountTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof FoldingStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(in).     } }
false;public;0;35;;@Test @SuppressWarnings("rawtypes") public void testApplyWithCustomTrigger() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).trigger(CountTrigger.of(1)).apply(new AllWindowFunction<Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(in).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof WindowOperator).     WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?> winOperator = (WindowOperator<String, Tuple2<String, Integer>, ?, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof CountTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;26;;@Test @SuppressWarnings("rawtypes") public void testReduceWithEvictor() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DummyReducer reducer = new DummyReducer().     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).evictor(CountEvictor.of(100)).reduce(reducer).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof EvictingWindowOperator).     EvictingWindowOperator<String, Tuple2<String, Integer>, ?, ?> winOperator = (EvictingWindowOperator<String, Tuple2<String, Integer>, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingEventTimeWindows).     Assert.assertTrue(winOperator.getEvictor() instanceof CountEvictor).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;0;26;;@Test @SuppressWarnings({ "rawtypes", "unchecked" }) public void testFoldWithEvictor() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple3<String, String, Integer>> window1 = source.windowAll(SlidingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS), Time.of(100, TimeUnit.MILLISECONDS))).evictor(CountEvictor.of(100)).fold(new Tuple3<>("", "", 1), new DummyFolder()).     OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple3<String, String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple3<String, String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof EvictingWindowOperator).     EvictingWindowOperator<String, Tuple2<String, Integer>, ?, ?> winOperator = (EvictingWindowOperator<String, Tuple2<String, Integer>, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof EventTimeTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof SlidingEventTimeWindows).     Assert.assertTrue(winOperator.getEvictor() instanceof CountEvictor).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     winOperator.setOutputType((TypeInformation) window1.getType(), new ExecutionConfig()).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
false;public;3;9;;@Override public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(in).     } }
false;public;0;37;;@Test @SuppressWarnings("rawtypes") public void testApplyWithEvictor() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     DataStream<Tuple2<String, Integer>> source = env.fromElements(Tuple2.of("hello", 1), Tuple2.of("hello", 2)).     DataStream<Tuple2<String, Integer>> window1 = source.windowAll(TumblingEventTimeWindows.of(Time.of(1, TimeUnit.SECONDS))).trigger(CountTrigger.of(1)).evictor(TimeEvictor.of(Time.of(100, TimeUnit.MILLISECONDS))).apply(new AllWindowFunction<Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) throws Exception {             for (Tuple2<String, Integer> in : values) {                 out.collect(in).             }         }     }).     OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>> transform = (OneInputTransformation<Tuple2<String, Integer>, Tuple2<String, Integer>>) window1.getTransformation().     OneInputStreamOperator<Tuple2<String, Integer>, Tuple2<String, Integer>> operator = transform.getOperator().     Assert.assertTrue(operator instanceof EvictingWindowOperator).     EvictingWindowOperator<String, Tuple2<String, Integer>, ?, ?> winOperator = (EvictingWindowOperator<String, Tuple2<String, Integer>, ?, ?>) operator.     Assert.assertTrue(winOperator.getTrigger() instanceof CountTrigger).     Assert.assertTrue(winOperator.getWindowAssigner() instanceof TumblingEventTimeWindows).     Assert.assertTrue(winOperator.getEvictor() instanceof TimeEvictor).     Assert.assertTrue(winOperator.getStateDescriptor() instanceof ListStateDescriptor).     processElementAndEnsureOutput(winOperator, winOperator.getKeySelector(), BasicTypeInfo.STRING_TYPE_INFO, new Tuple2<>("hello", 1)). }
true;private,static;4;28;/**  * Ensure that we get some output from the given operator when pushing in an element and  * setting watermark and processing time to {@code Long.MAX_VALUE}.  */ ;/**  * Ensure that we get some output from the given operator when pushing in an element and  * setting watermark and processing time to {@code Long.MAX_VALUE}.  */ private static <K, IN, OUT> void processElementAndEnsureOutput(OneInputStreamOperator<IN, OUT> operator, KeySelector<IN, K> keySelector, TypeInformation<K> keyType, IN element) throws Exception {     KeyedOneInputStreamOperatorTestHarness<K, IN, OUT> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, keySelector, keyType).     testHarness.open().     testHarness.setProcessingTime(0).     testHarness.processWatermark(Long.MIN_VALUE).     testHarness.processElement(new StreamRecord<>(element, 0)).     // provoke any processing-time/event-time triggers     testHarness.setProcessingTime(Long.MAX_VALUE).     testHarness.processWatermark(Long.MAX_VALUE).     // we at least get the two watermarks and should also see an output element     assertTrue(testHarness.getOutput().size() >= 3).     testHarness.close(). }
false;public;2;4;;@Override public Tuple2<String, Integer> reduce(Tuple2<String, Integer> value1, Tuple2<String, Integer> value2) throws Exception {     return value1. }
false;public;2;6;;@Override public Tuple3<String, String, Integer> fold(Tuple3<String, String, Integer> accumulator, Tuple2<String, Integer> value) throws Exception {     return accumulator. }
false;public;0;4;;@Override public Tuple2<String, Integer> createAccumulator() {     return new Tuple2<>("", 0). }
false;public;2;6;;@Override public Tuple2<String, Integer> add(Tuple2<String, Integer> value, Tuple2<String, Integer> accumulator) {     accumulator.f0 = value.f0.     accumulator.f1 = value.f1.     return accumulator. }
false;public;1;4;;@Override public Tuple2<String, Integer> getResult(Tuple2<String, Integer> accumulator) {     return accumulator. }
false;public;2;4;;@Override public Tuple2<String, Integer> merge(Tuple2<String, Integer> a, Tuple2<String, Integer> b) {     return a. }
false;public;0;4;;@Override public T createAccumulator() {     return null. }
false;public;2;4;;@Override public T add(T value, T accumulator) {     return accumulator. }
false;public;1;4;;@Override public T getResult(T accumulator) {     return accumulator. }
false;public;2;4;;@Override public T merge(T a, T b) {     return a. }
false;public;3;10;;@Override public void apply(TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(new Tuple3<>(in.f0, in.f0, in.f1)).     } }
false;public;3;9;;@Override public void process(Context ctx, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, String, Integer>> out) throws Exception {     for (Tuple2<String, Integer> in : values) {         out.collect(new Tuple3<>(in.f0, in.f0, in.f1)).     } }
