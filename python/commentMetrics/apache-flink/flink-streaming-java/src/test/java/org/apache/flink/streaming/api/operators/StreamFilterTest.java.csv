commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public boolean filter(Integer value) throws Exception {     return value % 2 == 0. }
false;public;0;28;;@Test @SuppressWarnings("unchecked") public void testFilter() throws Exception {     StreamFilter<Integer> operator = new StreamFilter<Integer>(new MyFilter()).     OneInputStreamOperatorTestHarness<Integer, Integer> testHarness = new OneInputStreamOperatorTestHarness<Integer, Integer>(operator).     long initialTime = 0L.     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>().     testHarness.open().     testHarness.processElement(new StreamRecord<Integer>(1, initialTime + 1)).     testHarness.processElement(new StreamRecord<Integer>(2, initialTime + 2)).     testHarness.processWatermark(new Watermark(initialTime + 2)).     testHarness.processElement(new StreamRecord<Integer>(3, initialTime + 3)).     testHarness.processElement(new StreamRecord<Integer>(4, initialTime + 4)).     testHarness.processElement(new StreamRecord<Integer>(5, initialTime + 5)).     testHarness.processElement(new StreamRecord<Integer>(6, initialTime + 6)).     testHarness.processElement(new StreamRecord<Integer>(7, initialTime + 7)).     expectedOutput.add(new StreamRecord<Integer>(2, initialTime + 2)).     expectedOutput.add(new Watermark(initialTime + 2)).     expectedOutput.add(new StreamRecord<Integer>(4, initialTime + 4)).     expectedOutput.add(new StreamRecord<Integer>(6, initialTime + 6)).     TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput()). }
false;public;0;18;;@Test public void testOpenClose() throws Exception {     StreamFilter<String> operator = new StreamFilter<String>(new TestOpenCloseFilterFunction()).     OneInputStreamOperatorTestHarness<String, String> testHarness = new OneInputStreamOperatorTestHarness<String, String>(operator).     long initialTime = 0L.     testHarness.open().     testHarness.processElement(new StreamRecord<String>("fooHello", initialTime)).     testHarness.processElement(new StreamRecord<String>("bar", initialTime)).     testHarness.close().     Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseFilterFunction.closeCalled).     Assert.assertTrue("Output contains no elements.", testHarness.getOutput().size() > 0). }
false;public;1;8;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     if (closeCalled) {         Assert.fail("Close called before open.").     }     openCalled = true. }
false;public;0;8;;@Override public void close() throws Exception {     super.close().     if (!openCalled) {         Assert.fail("Open was not called before close.").     }     closeCalled = true. }
false;public;1;7;;@Override public boolean filter(String value) throws Exception {     if (!openCalled) {         Assert.fail("Open was not called before run.").     }     return value.startsWith("foo"). }
