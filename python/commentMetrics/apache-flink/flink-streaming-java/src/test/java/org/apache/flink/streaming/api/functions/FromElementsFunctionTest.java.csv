commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Test public void testStrings() {     try {         String[] data = { "Oh", "boy", "what", "a", "show", "!" }.         FromElementsFunction<String> source = new FromElementsFunction<String>(BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), data).         List<String> result = new ArrayList<String>().         source.run(new ListSourceContext<String>(result)).         assertEquals(Arrays.asList(data), result).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;18;;@Test public void testNonJavaSerializableType() {     try {         MyPojo[] data = { new MyPojo(1, 2), new MyPojo(3, 4), new MyPojo(5, 6) }.         FromElementsFunction<MyPojo> source = new FromElementsFunction<MyPojo>(TypeExtractor.getForClass(MyPojo.class).createSerializer(new ExecutionConfig()), data).         List<MyPojo> result = new ArrayList<MyPojo>().         source.run(new ListSourceContext<MyPojo>(result)).         assertEquals(Arrays.asList(data), result).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;21;;@Test public void testSerializationError() {     try {         TypeInformation<SerializationErrorType> info = new ValueTypeInfo<SerializationErrorType>(SerializationErrorType.class).         try {             new FromElementsFunction<SerializationErrorType>(info.createSerializer(new ExecutionConfig()), new SerializationErrorType()).             fail("should fail with an exception").         } catch (IOException e) {             assertTrue(ExceptionUtils.stringifyException(e).contains("test exception")).         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;22;;@Test public void testDeSerializationError() {     try {         TypeInformation<DeserializeTooMuchType> info = new ValueTypeInfo<DeserializeTooMuchType>(DeserializeTooMuchType.class).         FromElementsFunction<DeserializeTooMuchType> source = new FromElementsFunction<DeserializeTooMuchType>(info.createSerializer(new ExecutionConfig()), new DeserializeTooMuchType()).         try {             source.run(new ListSourceContext<DeserializeTooMuchType>(new ArrayList<DeserializeTooMuchType>())).             fail("should fail with an exception").         } catch (IOException e) {             assertTrue(ExceptionUtils.stringifyException(e).contains("user-defined serialization")).         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;9;;@Override public void run() {     try {         source.run(ctx).     } catch (Throwable t) {         error[0] = t.     } }
false;public;0;78;;@Test public void testCheckpointAndRestore() {     try {         final int numElements = 10000.         List<Integer> data = new ArrayList<Integer>(numElements).         List<Integer> result = new ArrayList<Integer>(numElements).         for (int i = 0. i < numElements. i++) {             data.add(i).         }         final FromElementsFunction<Integer> source = new FromElementsFunction<>(IntSerializer.INSTANCE, data).         StreamSource<Integer, FromElementsFunction<Integer>> src = new StreamSource<>(source).         AbstractStreamOperatorTestHarness<Integer> testHarness = new AbstractStreamOperatorTestHarness<>(src, 1, 1, 0).         testHarness.open().         final SourceFunction.SourceContext<Integer> ctx = new ListSourceContext<Integer>(result, 2L).         final Throwable[] error = new Throwable[1].         // run the source asynchronously         Thread runner = new Thread() {              @Override             public void run() {                 try {                     source.run(ctx).                 } catch (Throwable t) {                     error[0] = t.                 }             }         }.         runner.start().         // wait for a bit         Thread.sleep(1000).         // make a checkpoint         List<Integer> checkpointData = new ArrayList<>(numElements).         OperatorSubtaskState handles = null.         synchronized (ctx.getCheckpointLock()) {             handles = testHarness.snapshot(566, System.currentTimeMillis()).             checkpointData.addAll(result).         }         // cancel the source         source.cancel().         runner.join().         // check for errors         if (error[0] != null) {             System.err.println("Error in asynchronous source runner").             error[0].printStackTrace().             fail("Error in asynchronous source runner").         }         final FromElementsFunction<Integer> sourceCopy = new FromElementsFunction<>(IntSerializer.INSTANCE, data).         StreamSource<Integer, FromElementsFunction<Integer>> srcCopy = new StreamSource<>(sourceCopy).         AbstractStreamOperatorTestHarness<Integer> testHarnessCopy = new AbstractStreamOperatorTestHarness<>(srcCopy, 1, 1, 0).         testHarnessCopy.setup().         testHarnessCopy.initializeState(handles).         testHarnessCopy.open().         // recovery run         SourceFunction.SourceContext<Integer> newCtx = new ListSourceContext<>(checkpointData).         sourceCopy.run(newCtx).         assertEquals(data, checkpointData).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;4;;@Override public int hashCode() {     return this.val2. }
false;public;1;10;;@Override public boolean equals(Object obj) {     if (obj instanceof MyPojo) {         MyPojo that = (MyPojo) obj.         return this.val1 == that.val1 && this.val2 == that.val2.     } else {         return false.     } }
false;public;1;4;;@Override public void write(DataOutputView out) throws IOException {     throw new IOException("test exception"). }
false;public;1;4;;@Override public void read(DataInputView in) throws IOException {     throw new IOException("test exception"). }
false;public;1;4;;@Override public void write(DataOutputView out) throws IOException {     out.writeInt(42). }
false;public;1;4;;@Override public void read(DataInputView in) throws IOException {     in.readLong(). }
