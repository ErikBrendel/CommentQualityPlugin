commented;modifiers;parameterAmount;loc;comment;code
true;public;0;13;/**  * Tests that watermarks correctly advance with increasing watermarks for a single input valve.  */ ;/**  * Tests that watermarks correctly advance with increasing watermarks for a single input valve.  */ @Test public void testSingleInputIncreasingWatermarks() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(1, valveOutput).     valve.inputWatermark(new Watermark(0), 0).     assertEquals(new Watermark(0), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputWatermark(new Watermark(25), 0).     assertEquals(new Watermark(25), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()). }
true;public;0;15;/**  * Tests that watermarks do not advance with decreasing watermark inputs for a single input valve.  */ ;/**  * Tests that watermarks do not advance with decreasing watermark inputs for a single input valve.  */ @Test public void testSingleInputDecreasingWatermarksYieldsNoOutput() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(1, valveOutput).     valve.inputWatermark(new Watermark(25), 0).     assertEquals(new Watermark(25), valveOutput.popLastSeenOutput()).     valve.inputWatermark(new Watermark(18), 0).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputWatermark(new Watermark(42), 0).     assertEquals(new Watermark(42), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()). }
true;public;0;19;/**  * Tests that stream status toggling works correctly, as well as that non-toggling status  * inputs do not yield output for a single input valve.  */ ;/**  * Tests that stream status toggling works correctly, as well as that non-toggling status  * inputs do not yield output for a single input valve.  */ @Test public void testSingleInputStreamStatusToggling() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(1, valveOutput).     valve.inputStreamStatus(StreamStatus.ACTIVE, 0).     // this also implicitly verifies that input channels start as ACTIVE     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputStreamStatus(StreamStatus.IDLE, 0).     assertEquals(StreamStatus.IDLE, valveOutput.popLastSeenOutput()).     valve.inputStreamStatus(StreamStatus.IDLE, 0).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputStreamStatus(StreamStatus.ACTIVE, 0).     assertEquals(StreamStatus.ACTIVE, valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()). }
true;public;0;24;/**  * Tests that the watermark of an input channel remains intact while in the IDLE status.  */ ;/**  * Tests that the watermark of an input channel remains intact while in the IDLE status.  */ @Test public void testSingleInputWatermarksIntactDuringIdleness() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(1, valveOutput).     valve.inputWatermark(new Watermark(25), 0).     assertEquals(new Watermark(25), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputStreamStatus(StreamStatus.IDLE, 0).     assertEquals(StreamStatus.IDLE, valveOutput.popLastSeenOutput()).     valve.inputWatermark(new Watermark(50), 0).     assertEquals(null, valveOutput.popLastSeenOutput()).     assertEquals(25, valve.getInputChannelStatus(0).watermark).     valve.inputStreamStatus(StreamStatus.ACTIVE, 0).     assertEquals(StreamStatus.ACTIVE, valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputWatermark(new Watermark(50), 0).     assertEquals(new Watermark(50), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()). }
true;public;0;14;/**  * Tests that the valve yields a watermark only when all inputs have received a watermark.  */ ;/**  * Tests that the valve yields a watermark only when all inputs have received a watermark.  */ @Test public void testMultipleInputYieldsWatermarkOnlyWhenAllChannelsReceivesWatermarks() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(3, valveOutput).     valve.inputWatermark(new Watermark(0), 0).     valve.inputWatermark(new Watermark(0), 1).     assertEquals(null, valveOutput.popLastSeenOutput()).     // now, all channels have watermarks     valve.inputWatermark(new Watermark(0), 2).     assertEquals(new Watermark(0), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()). }
true;public;0;30;/**  * Tests that new min watermark is emitted from the valve as soon as the overall  * new min watermark across inputs advances.  */ ;/**  * Tests that new min watermark is emitted from the valve as soon as the overall  * new min watermark across inputs advances.  */ @Test public void testMultipleInputIncreasingWatermarks() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(3, valveOutput).     valve.inputWatermark(new Watermark(0), 0).     valve.inputWatermark(new Watermark(0), 1).     valve.inputWatermark(new Watermark(0), 2).     assertEquals(new Watermark(0), valveOutput.popLastSeenOutput()).     valve.inputWatermark(new Watermark(12), 0).     valve.inputWatermark(new Watermark(8), 2).     valve.inputWatermark(new Watermark(10), 2).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputWatermark(new Watermark(15), 1).     // lowest watermark across all channels is now channel 2, with watermark @ 10     assertEquals(new Watermark(10), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputWatermark(new Watermark(17), 2).     // lowest watermark across all channels is now channel 0, with watermark @ 12     assertEquals(new Watermark(12), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputWatermark(new Watermark(20), 0).     // lowest watermark across all channels is now channel 1, with watermark @ 15     assertEquals(new Watermark(15), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()). }
true;public;0;15;/**  * Tests that for a multiple input valve, decreasing watermarks will yield no output.  */ ;/**  * Tests that for a multiple input valve, decreasing watermarks will yield no output.  */ @Test public void testMultipleInputDecreasingWatermarksYieldsNoOutput() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(3, valveOutput).     valve.inputWatermark(new Watermark(25), 0).     valve.inputWatermark(new Watermark(10), 1).     valve.inputWatermark(new Watermark(17), 2).     assertEquals(new Watermark(10), valveOutput.popLastSeenOutput()).     valve.inputWatermark(new Watermark(12), 0).     valve.inputWatermark(new Watermark(8), 1).     valve.inputWatermark(new Watermark(15), 2).     assertEquals(null, valveOutput.popLastSeenOutput()). }
true;public;0;29;/**  * Tests that stream status toggling works correctly, as well as that non-toggling status  * inputs do not yield output for a multiple input valve.  */ ;/**  * Tests that stream status toggling works correctly, as well as that non-toggling status  * inputs do not yield output for a multiple input valve.  */ @Test public void testMultipleInputStreamStatusToggling() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(2, valveOutput).     // this also implicitly verifies that all input channels start as active     valve.inputStreamStatus(StreamStatus.ACTIVE, 0).     valve.inputStreamStatus(StreamStatus.ACTIVE, 1).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputStreamStatus(StreamStatus.IDLE, 1).     assertEquals(null, valveOutput.popLastSeenOutput()).     // now, all channels are IDLE     valve.inputStreamStatus(StreamStatus.IDLE, 0).     assertEquals(StreamStatus.IDLE, valveOutput.popLastSeenOutput()).     valve.inputStreamStatus(StreamStatus.IDLE, 0).     valve.inputStreamStatus(StreamStatus.IDLE, 1).     assertEquals(null, valveOutput.popLastSeenOutput()).     // as soon as at least one input becomes active again, the ACTIVE marker should be forwarded     valve.inputStreamStatus(StreamStatus.ACTIVE, 1).     assertEquals(StreamStatus.ACTIVE, valveOutput.popLastSeenOutput()).     valve.inputStreamStatus(StreamStatus.ACTIVE, 0).     // already back to ACTIVE, should yield no output     assertEquals(null, valveOutput.popLastSeenOutput()). }
true;public;0;24;/**  * Tests that for multiple inputs, when some inputs are idle, the min watermark  * is correctly computed and advanced from the remaining active inputs.  */ ;/**  * Tests that for multiple inputs, when some inputs are idle, the min watermark  * is correctly computed and advanced from the remaining active inputs.  */ @Test public void testMultipleInputWatermarkAdvancingWithPartiallyIdleChannels() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(3, valveOutput).     valve.inputWatermark(new Watermark(15), 0).     valve.inputWatermark(new Watermark(10), 1).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputStreamStatus(StreamStatus.IDLE, 2).     // min watermark should be computed from remaining ACTIVE channels     assertEquals(new Watermark(10), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputWatermark(new Watermark(18), 1).     // now, min watermark should be 15 from channel #0     assertEquals(new Watermark(15), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputWatermark(new Watermark(20), 0).     // now, min watermark should be 18 from channel #1     assertEquals(new Watermark(18), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()). }
true;public;0;19;/**  * Tests that as input channels individually and gradually become idle, watermarks  * are output as soon remaining active channels can yield a new min watermark.  */ ;/**  * Tests that as input channels individually and gradually become idle, watermarks  * are output as soon remaining active channels can yield a new min watermark.  */ @Test public void testMultipleInputWatermarkAdvancingAsChannelsIndividuallyBecomeIdle() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(3, valveOutput).     valve.inputWatermark(new Watermark(25), 0).     valve.inputWatermark(new Watermark(10), 1).     valve.inputWatermark(new Watermark(17), 2).     assertEquals(new Watermark(10), valveOutput.popLastSeenOutput()).     valve.inputStreamStatus(StreamStatus.IDLE, 1).     // only channel 0 & 2 is ACTIVE. 17 is the overall min watermark now     assertEquals(new Watermark(17), valveOutput.popLastSeenOutput()).     valve.inputStreamStatus(StreamStatus.IDLE, 2).     // only channel 0 is ACTIVE. 25 is the overall min watermark now     assertEquals(new Watermark(25), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()). }
true;public;0;33;/**  * Tests that when all inputs become idle, the max watermark across all channels  * is correctly "flushed" from the valve, as well as the stream status IDLE marker.  *  * <p>This test along with {@link #testMultipleInputWatermarkAdvancingAsChannelsIndividuallyBecomeIdle}  * should completely verify that the eventual watermark advancement result when all inputs become idle  * is independent of the order that the inputs become idle.  */ ;/**  * Tests that when all inputs become idle, the max watermark across all channels  * is correctly "flushed" from the valve, as well as the stream status IDLE marker.  *  * <p>This test along with {@link #testMultipleInputWatermarkAdvancingAsChannelsIndividuallyBecomeIdle}  * should completely verify that the eventual watermark advancement result when all inputs become idle  * is independent of the order that the inputs become idle.  */ @Test public void testMultipleInputFlushMaxWatermarkAndStreamStatusOnceAllInputsBecomeIdle() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(3, valveOutput).     // -------------------------------------------------------------------------------------------     // Setup valve for test case:     // channel #1: Watermark 10, ACTIVE     // channel #2: Watermark 5, ACTIVE     // channel #3: Watermark 3, ACTIVE     // Min Watermark across channels = 3 (from channel #3)     // -------------------------------------------------------------------------------------------     valve.inputWatermark(new Watermark(10), 0).     valve.inputWatermark(new Watermark(5), 1).     valve.inputWatermark(new Watermark(3), 2).     assertEquals(new Watermark(3), valveOutput.popLastSeenOutput()).     // -------------------------------------------------------------------------------------------     // Order of becoming IDLE:     // channel #1 ----------------> channel #2 ----------------> channel #3     // |-> (nothing emitted)        |-> (nothing emitted)        |-> Emit Watermark(10) & IDLE     // -------------------------------------------------------------------------------------------     valve.inputStreamStatus(StreamStatus.IDLE, 0).     valve.inputStreamStatus(StreamStatus.IDLE, 1).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputStreamStatus(StreamStatus.IDLE, 2).     assertEquals(new Watermark(10), valveOutput.popLastSeenOutput()).     assertEquals(StreamStatus.IDLE, valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()). }
true;public;0;35;/**  * Tests that when idle channels become active again, they need to "catch up" with  * the latest watermark before they are considered for min watermark computation again.  */ ;/**  * Tests that when idle channels become active again, they need to "catch up" with  * the latest watermark before they are considered for min watermark computation again.  */ @Test public void testMultipleInputWatermarkRealignmentAfterResumeActive() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(3, valveOutput).     valve.inputWatermark(new Watermark(10), 0).     valve.inputWatermark(new Watermark(7), 1).     valve.inputWatermark(new Watermark(3), 2).     assertEquals(new Watermark(3), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()).     valve.inputStreamStatus(StreamStatus.IDLE, 2).     assertEquals(new Watermark(7), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()).     // let channel 2 become active again. since the min watermark has now advanced to 7,     // channel 2 should have been marked as non-aligned.     valve.inputStreamStatus(StreamStatus.ACTIVE, 2).     assertFalse(valve.getInputChannelStatus(2).isWatermarkAligned).     // during the realignment process, watermarks should still be accepted by channel 2 (but shouldn't yield new watermarks)     valve.inputWatermark(new Watermark(5), 2).     assertEquals(5, valve.getInputChannelStatus(2).watermark).     assertEquals(null, valveOutput.popLastSeenOutput()).     // let channel 2 catch up with the min watermark. now should be realigned     valve.inputWatermark(new Watermark(9), 2).     assertTrue(valve.getInputChannelStatus(2).isWatermarkAligned).     assertEquals(null, valveOutput.popLastSeenOutput()).     // check that realigned inputs is now taken into account for watermark advancement     valve.inputWatermark(new Watermark(12), 1).     assertEquals(new Watermark(9), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()). }
true;public;0;24;/**  * Verify that we don't see any state changes/watermarks when all ACTIVE channels are unaligned.  * Earlier versions of the valve had a bug that would cause it to emit a {@code Long.MAX_VALUE}  * watermark in that case.  */ ;/**  * Verify that we don't see any state changes/watermarks when all ACTIVE channels are unaligned.  * Earlier versions of the valve had a bug that would cause it to emit a {@code Long.MAX_VALUE}  * watermark in that case.  */ @Test public void testNoOutputWhenAllActiveChannelsAreUnaligned() {     BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler().     StatusWatermarkValve valve = new StatusWatermarkValve(3, valveOutput).     valve.inputWatermark(new Watermark(10), 0).     valve.inputWatermark(new Watermark(7), 1).     // make channel 2 ACTIVE, it is now in "catch up" mode (unaligned watermark)     valve.inputStreamStatus(StreamStatus.IDLE, 2).     assertEquals(new Watermark(7), valveOutput.popLastSeenOutput()).     assertEquals(null, valveOutput.popLastSeenOutput()).     // make channel 2 ACTIVE again, it is still unaligned     valve.inputStreamStatus(StreamStatus.ACTIVE, 2).     assertEquals(null, valveOutput.popLastSeenOutput()).     // make channel 0 and 1 IDLE, now channel 2 is the only ACTIVE channel but it's unaligned     valve.inputStreamStatus(StreamStatus.IDLE, 0).     valve.inputStreamStatus(StreamStatus.IDLE, 1).     // we should not see any output     assertEquals(null, valveOutput.popLastSeenOutput()). }
false;public;1;4;;@Override public void handleWatermark(Watermark watermark) {     allOutputs.add(watermark). }
false;public;1;4;;@Override public void handleStreamStatus(StreamStatus streamStatus) {     allOutputs.add(streamStatus). }
false;public;0;3;;public StreamElement popLastSeenOutput() {     return allOutputs.poll(). }
