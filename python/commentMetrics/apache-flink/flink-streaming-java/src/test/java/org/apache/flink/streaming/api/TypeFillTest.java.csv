commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public String map(Long value) throws Exception {     return null. }
false;public;0;98;;@Test public void test() {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).     try {         env.addSource(new TestSource<Integer>()).print().         fail().     } catch (Exception ignored) {     }     DataStream<Long> source = env.generateSequence(1, 10).     try {         source.map(new TestMap<Long, Long>()).print().         fail().     } catch (Exception ignored) {     }     try {         source.flatMap(new TestFlatMap<Long, Long>()).print().         fail().     } catch (Exception ignored) {     }     try {         source.connect(source).map(new TestCoMap<Long, Long, Integer>()).print().         fail().     } catch (Exception ignored) {     }     try {         source.connect(source).flatMap(new TestCoFlatMap<Long, Long, Integer>()).print().         fail().     } catch (Exception ignored) {     }     try {         source.keyBy(new TestKeySelector<Long, String>()).print().         fail().     } catch (Exception ignored) {     }     try {         source.connect(source).keyBy(new TestKeySelector<Long, String>(), new TestKeySelector<>()).         fail().     } catch (Exception ignored) {     }     try {         source.coGroup(source).where(new TestKeySelector<>()).equalTo(new TestKeySelector<>()).         fail().     } catch (Exception ignored) {     }     try {         source.join(source).where(new TestKeySelector<>()).equalTo(new TestKeySelector<>()).         fail().     } catch (Exception ignored) {     }     try {         source.keyBy((in) -> in).intervalJoin(source.keyBy((in) -> in)).between(Time.milliseconds(10L), Time.milliseconds(10L)).process(new TestProcessJoinFunction<>()).print().         fail().     } catch (Exception ignored) {     }     env.addSource(new TestSource<Integer>()).returns(Integer.class).     source.map(new TestMap<Long, Long>()).returns(Long.class).print().     source.flatMap(new TestFlatMap<Long, Long>()).returns(new TypeHint<Long>() {     }).print().     source.connect(source).map(new TestCoMap<Long, Long, Integer>()).returns(BasicTypeInfo.INT_TYPE_INFO).print().     source.connect(source).flatMap(new TestCoFlatMap<Long, Long, Integer>()).returns(BasicTypeInfo.INT_TYPE_INFO).print().     source.connect(source).keyBy(new TestKeySelector<>(), new TestKeySelector<>(), Types.STRING).     source.coGroup(source).where(new TestKeySelector<>(), Types.STRING).equalTo(new TestKeySelector<>(), Types.STRING).     source.join(source).where(new TestKeySelector<>(), Types.STRING).equalTo(new TestKeySelector<>(), Types.STRING).     source.keyBy((in) -> in).intervalJoin(source.keyBy((in) -> in)).between(Time.milliseconds(10L), Time.milliseconds(10L)).process(new TestProcessJoinFunction<Long, Long, String>()).returns(Types.STRING).     source.keyBy((in) -> in).intervalJoin(source.keyBy((in) -> in)).between(Time.milliseconds(10L), Time.milliseconds(10L)).process(new TestProcessJoinFunction<>(), Types.STRING).     assertEquals(BasicTypeInfo.LONG_TYPE_INFO, source.map(new TestMap<Long, Long>()).returns(Long.class).getType()).     SingleOutputStreamOperator<String> map = source.map(new MapFunction<Long, String>() {          @Override         public String map(Long value) throws Exception {             return null.         }     }).     map.print().     try {         map.returns(String.class).         fail().     } catch (Exception ignored) {     } }
false;public;1;2;;@Override public void run(SourceContext<T> ctx) throws Exception { }
false;public;0;2;;@Override public void cancel() { }
false;public;1;4;;@Override public O map(T value) throws Exception {     return null. }
false;public;2;2;;@Override public void flatMap(T value, Collector<O> out) throws Exception { }
false;public;1;4;;@Override public OUT map1(IN1 value) {     return null. }
false;public;1;4;;@Override public OUT map2(IN2 value) {     return null. }
false;public;2;2;;@Override public void flatMap1(IN1 value, Collector<OUT> out) throws Exception { }
false;public;2;2;;@Override public void flatMap2(IN2 value, Collector<OUT> out) throws Exception { }
false;public;1;4;;@Override public KEY getKey(IN value) throws Exception {     return null. }
false;public;4;4;;@Override public void processElement(IN1 left, IN2 right, Context ctx, Collector<OUT> out) throws Exception { // nothing to do }
