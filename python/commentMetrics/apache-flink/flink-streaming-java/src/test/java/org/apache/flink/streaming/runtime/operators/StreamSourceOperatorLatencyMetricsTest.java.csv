commented;modifiers;parameterAmount;loc;comment;code
true;public;0;6;/**  * Verifies that by default no latency metrics are emitted.  */ ;/**  * Verifies that by default no latency metrics are emitted.  */ @Test public void testLatencyMarkEmissionDisabled() throws Exception {     testLatencyMarkEmission(0, (operator, timeProvider) -> {         setupSourceOperator(operator, new ExecutionConfig(), MockEnvironment.builder().build(), timeProvider).     }). }
true;public;0;9;/**  * Verifies that latency metrics can be enabled via the {@link ExecutionConfig}.  */ ;/**  * Verifies that latency metrics can be enabled via the {@link ExecutionConfig}.  */ @Test public void testLatencyMarkEmissionEnabledViaExecutionConfig() throws Exception {     testLatencyMarkEmission((int) (maxProcessingTime / latencyMarkInterval) + 1, (operator, timeProvider) -> {         ExecutionConfig executionConfig = new ExecutionConfig().         executionConfig.setLatencyTrackingInterval(latencyMarkInterval).         setupSourceOperator(operator, executionConfig, MockEnvironment.builder().build(), timeProvider).     }). }
true;public;0;13;/**  * Verifies that latency metrics can be enabled via the configuration.  */ ;/**  * Verifies that latency metrics can be enabled via the configuration.  */ @Test public void testLatencyMarkEmissionEnabledViaFlinkConfig() throws Exception {     testLatencyMarkEmission((int) (maxProcessingTime / latencyMarkInterval) + 1, (operator, timeProvider) -> {         Configuration tmConfig = new Configuration().         tmConfig.setLong(MetricOptions.LATENCY_INTERVAL, latencyMarkInterval).         Environment env = MockEnvironment.builder().setTaskManagerRuntimeInfo(new TestingTaskManagerRuntimeInfo(tmConfig)).build().         setupSourceOperator(operator, new ExecutionConfig(), env, timeProvider).     }). }
true;public;0;16;/**  * Verifies that latency metrics can be enabled via the {@link ExecutionConfig} even if they are disabled via  * the configuration.  */ ;/**  * Verifies that latency metrics can be enabled via the {@link ExecutionConfig} even if they are disabled via  * the configuration.  */ @Test public void testLatencyMarkEmissionEnabledOverrideViaExecutionConfig() throws Exception {     testLatencyMarkEmission((int) (maxProcessingTime / latencyMarkInterval) + 1, (operator, timeProvider) -> {         ExecutionConfig executionConfig = new ExecutionConfig().         executionConfig.setLatencyTrackingInterval(latencyMarkInterval).         Configuration tmConfig = new Configuration().         tmConfig.setLong(MetricOptions.LATENCY_INTERVAL, 0L).         Environment env = MockEnvironment.builder().setTaskManagerRuntimeInfo(new TestingTaskManagerRuntimeInfo(tmConfig)).build().         setupSourceOperator(operator, executionConfig, env, timeProvider).     }). }
true;public;0;16;/**  * Verifies that latency metrics can be disabled via the {@link ExecutionConfig} even if they are enabled via  * the configuration.  */ ;/**  * Verifies that latency metrics can be disabled via the {@link ExecutionConfig} even if they are enabled via  * the configuration.  */ @Test public void testLatencyMarkEmissionDisabledOverrideViaExecutionConfig() throws Exception {     testLatencyMarkEmission(0, (operator, timeProvider) -> {         Configuration tmConfig = new Configuration().         tmConfig.setLong(MetricOptions.LATENCY_INTERVAL, latencyMarkInterval).         Environment env = MockEnvironment.builder().setTaskManagerRuntimeInfo(new TestingTaskManagerRuntimeInfo(tmConfig)).build().         ExecutionConfig executionConfig = new ExecutionConfig().         executionConfig.setLatencyTrackingInterval(0).         setupSourceOperator(operator, executionConfig, env, timeProvider).     }). }
false;;2;4;;void setupSourceOperator(StreamSource<Long, ?> operator, TestProcessingTimeService testProcessingTimeService).
false;private;2;36;;private void testLatencyMarkEmission(int numberLatencyMarkers, OperatorSetupOperation operatorSetup) throws Exception {     final List<StreamElement> output = new ArrayList<>().     final TestProcessingTimeService testProcessingTimeService = new TestProcessingTimeService().     testProcessingTimeService.setCurrentTime(0L).     final List<Long> processingTimes = Arrays.asList(1L, 10L, 11L, 21L, maxProcessingTime).     // regular stream source operator     final StreamSource<Long, ProcessingTimeServiceSource> operator = new StreamSource<>(new ProcessingTimeServiceSource(testProcessingTimeService, processingTimes)).     operatorSetup.setupSourceOperator(operator, testProcessingTimeService).     // run and wait to be stopped     operator.run(new Object(), mock(StreamStatusMaintainer.class), new CollectorOutput<Long>(output)).     assertEquals(// + 1 is the final watermark element     numberLatencyMarkers + 1, output.size()).     long timestamp = 0L.     int i = 0.     // verify that its only latency markers + a final watermark     for (. i < numberLatencyMarkers. i++) {         StreamElement se = output.get(i).         Assert.assertTrue(se.isLatencyMarker()).         Assert.assertEquals(operator.getOperatorID(), se.asLatencyMarker().getOperatorId()).         Assert.assertEquals(0, se.asLatencyMarker().getSubtaskIndex()).         Assert.assertTrue(se.asLatencyMarker().getMarkedTime() == timestamp).         timestamp += latencyMarkInterval.     }     Assert.assertTrue(output.get(i).isWatermark()). }
false;private,static;4;25;;// ------------------------------------------------------------------------ private static <T> void setupSourceOperator(StreamSource<T, ?> operator, ExecutionConfig executionConfig, Environment env, ProcessingTimeService timeProvider) {     StreamConfig cfg = new StreamConfig(new Configuration()).     cfg.setStateBackend(new MemoryStateBackend()).     cfg.setTimeCharacteristic(TimeCharacteristic.EventTime).     cfg.setOperatorID(new OperatorID()).     try {         MockStreamTask mockTask = new MockStreamTaskBuilder(env).setConfig(cfg).setExecutionConfig(executionConfig).setProcessingTimeService(timeProvider).build().         operator.setup(mockTask, cfg, (Output<StreamRecord<T>>) mock(Output.class)).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;1;10;;@Override public void run(SourceContext<Long> ctx) throws Exception {     for (Long processingTime : processingTimes) {         if (cancelled) {             break.         }         processingTimeService.setCurrentTime(processingTime).     } }
false;public;0;4;;@Override public void cancel() {     cancelled = true. }
