commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;10;;@Parameterized.Parameters(name = "Migration Savepoint: {0}") public static Collection<MigrationVersion> parameters() {     return Arrays.asList(MigrationVersion.v1_2, MigrationVersion.v1_3, MigrationVersion.v1_4, MigrationVersion.v1_5, MigrationVersion.v1_6, MigrationVersion.v1_7). }
true;public;0;43;/**  * Manually run this to write binary snapshot data.  */ ;/**  * Manually run this to write binary snapshot data.  */ @Ignore @Test public void writeSessionWindowsWithCountTriggerSnapshot() throws Exception {     final int sessionSize = 3.     ListStateDescriptor<Tuple2<String, Integer>> stateDesc = new ListStateDescriptor<>("window-contents", STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     WindowOperator<String, Tuple2<String, Integer>, Iterable<Tuple2<String, Integer>>, Tuple3<String, Long, Long>, TimeWindow> operator = new WindowOperator<>(EventTimeSessionWindows.withGap(Time.seconds(sessionSize)), new TimeWindow.Serializer(), new TupleKeySelector<String>(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new SessionWindowFunction()), PurgingTrigger.of(CountTrigger.of(4)), 0, null).     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setup().     testHarness.open().     // add elements out-of-order     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), 0)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 2), 1000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 3), 2500)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 4), 3500)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), 10)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 2), 1000)).     // do snapshot and save to file     OperatorSubtaskState snapshot = testHarness.snapshot(0L, 0L).     OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/win-op-migration-test-session-with-stateful-trigger-flink" + flinkGenerateSavepointVersion + "-snapshot").     testHarness.close(). }
false;public;0;49;;@Test public void testRestoreSessionWindowsWithCountTrigger() throws Exception {     final int sessionSize = 3.     ListStateDescriptor<Tuple2<String, Integer>> stateDesc = new ListStateDescriptor<>("window-contents", STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     WindowOperator<String, Tuple2<String, Integer>, Iterable<Tuple2<String, Integer>>, Tuple3<String, Long, Long>, TimeWindow> operator = new WindowOperator<>(EventTimeSessionWindows.withGap(Time.seconds(sessionSize)), new TimeWindow.Serializer(), new TupleKeySelector<String>(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new SessionWindowFunction()), PurgingTrigger.of(CountTrigger.of(4)), 0, null).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setup().     testHarness.initializeState(OperatorSnapshotUtil.getResourceFilename("win-op-migration-test-session-with-stateful-trigger-flink" + testMigrateVersion + "-snapshot")).     testHarness.open().     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 3), 2500)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), 6000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 2), 6500)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 3), 7000)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple3ResultSortComparator()).     // add an element that merges the two "key1" sessions, they should now have count 6, and therefore fire     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 10), 4500)).     expectedOutput.add(new StreamRecord<>(new Tuple3<>("key1-22", 10L, 10000L), 9999L)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple3ResultSortComparator()).     testHarness.close(). }
true;public;0;34;/**  * Manually run this to write binary snapshot data.  */ ;/**  * Manually run this to write binary snapshot data.  */ @Ignore @Test public void writeSessionWindowsWithCountTriggerInMintConditionSnapshot() throws Exception {     final int sessionSize = 3.     ListStateDescriptor<Tuple2<String, Integer>> stateDesc = new ListStateDescriptor<>("window-contents", STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     WindowOperator<String, Tuple2<String, Integer>, Iterable<Tuple2<String, Integer>>, Tuple3<String, Long, Long>, TimeWindow> operator = new WindowOperator<>(EventTimeSessionWindows.withGap(Time.seconds(sessionSize)), new TimeWindow.Serializer(), new TupleKeySelector<String>(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new SessionWindowFunction()), PurgingTrigger.of(CountTrigger.of(4)), 0, null).     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setup().     testHarness.open().     // do snapshot and save to file     OperatorSubtaskState snapshot = testHarness.snapshot(0, 0).     OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/win-op-migration-test-session-with-stateful-trigger-mint-flink" + flinkGenerateSavepointVersion + "-snapshot").     testHarness.close(). }
true;public;0;60;/**  * This checks that we can restore from a virgin {@code WindowOperator} that has never seen  * any elements.  */ ;/**  * This checks that we can restore from a virgin {@code WindowOperator} that has never seen  * any elements.  */ @Test public void testRestoreSessionWindowsWithCountTriggerInMintCondition() throws Exception {     final int sessionSize = 3.     ListStateDescriptor<Tuple2<String, Integer>> stateDesc = new ListStateDescriptor<>("window-contents", STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     WindowOperator<String, Tuple2<String, Integer>, Iterable<Tuple2<String, Integer>>, Tuple3<String, Long, Long>, TimeWindow> operator = new WindowOperator<>(EventTimeSessionWindows.withGap(Time.seconds(sessionSize)), new TimeWindow.Serializer(), new TupleKeySelector<String>(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new SessionWindowFunction()), PurgingTrigger.of(CountTrigger.of(4)), 0, null).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple3<String, Long, Long>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setup().     testHarness.initializeState(OperatorSnapshotUtil.getResourceFilename("win-op-migration-test-session-with-stateful-trigger-mint-flink" + testMigrateVersion + "-snapshot")).     testHarness.open().     // add elements out-of-order     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), 0)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 2), 1000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 3), 2500)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 4), 3500)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), 10)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 2), 1000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 3), 2500)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), 6000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 2), 6500)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 3), 7000)).     expectedOutput.add(new StreamRecord<>(new Tuple3<>("key2-10", 0L, 6500L), 6499)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple3ResultSortComparator()).     // add an element that merges the two "key1" sessions, they should now have count 6, and therefore fire     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 10), 4500)).     expectedOutput.add(new StreamRecord<>(new Tuple3<>("key1-22", 10L, 10000L), 9999L)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple3ResultSortComparator()).     testHarness.close(). }
true;public;0;56;/**  * Manually run this to write binary snapshot data.  */ ;/**  * Manually run this to write binary snapshot data.  */ @Ignore @Test public void writeReducingEventTimeWindowsSnapshot() throws Exception {     final int windowSize = 3.     ReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>("window-contents", new SumReducer<>(), STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     WindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(TumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)), new TimeWindow.Serializer(), new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()), EventTimeTrigger.create(), 0, null).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setup().     testHarness.open().     // add elements out-of-order     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), 3999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), 3000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), 20)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), 0)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), 999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), 1998)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), 1999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), 1000)).     testHarness.processWatermark(new Watermark(999)).     expectedOutput.add(new Watermark(999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     testHarness.processWatermark(new Watermark(1999)).     expectedOutput.add(new Watermark(1999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     // do snapshot and save to file     OperatorSubtaskState snapshot = testHarness.snapshot(0, 0).     OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/win-op-migration-test-reduce-event-time-flink" + flinkGenerateSavepointVersion + "-snapshot").     testHarness.close(). }
false;public;0;50;;@Test public void testRestoreReducingEventTimeWindows() throws Exception {     final int windowSize = 3.     ReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>("window-contents", new SumReducer<>(), STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     WindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(TumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)), new TimeWindow.Serializer(), new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()), EventTimeTrigger.create(), 0, null).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setup().     testHarness.initializeState(OperatorSnapshotUtil.getResourceFilename("win-op-migration-test-reduce-event-time-flink" + testMigrateVersion + "-snapshot")).     testHarness.open().     testHarness.processWatermark(new Watermark(2999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 3), 2999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 3), 2999)).     expectedOutput.add(new Watermark(2999)).     testHarness.processWatermark(new Watermark(3999)).     expectedOutput.add(new Watermark(3999)).     testHarness.processWatermark(new Watermark(4999)).     expectedOutput.add(new Watermark(4999)).     testHarness.processWatermark(new Watermark(5999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 2), 5999)).     expectedOutput.add(new Watermark(5999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     testHarness.close(). }
true;public;0;55;/**  * Manually run this to write binary snapshot data.  */ ;/**  * Manually run this to write binary snapshot data.  */ @Ignore @Test public void writeApplyEventTimeWindowsSnapshot() throws Exception {     final int windowSize = 3.     ListStateDescriptor<Tuple2<String, Integer>> stateDesc = new ListStateDescriptor<>("window-contents", STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     WindowOperator<String, Tuple2<String, Integer>, Iterable<Tuple2<String, Integer>>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(TumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)), new TimeWindow.Serializer(), new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new RichSumReducer<TimeWindow>()), EventTimeTrigger.create(), 0, null).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setup().     testHarness.open().     // add elements out-of-order     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), 3999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), 3000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), 20)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), 0)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), 999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), 1998)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), 1999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), 1000)).     testHarness.processWatermark(new Watermark(999)).     expectedOutput.add(new Watermark(999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     testHarness.processWatermark(new Watermark(1999)).     expectedOutput.add(new Watermark(1999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     // do snapshot and save to file     OperatorSubtaskState snapshot = testHarness.snapshot(0, 0).     OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/win-op-migration-test-apply-event-time-flink" + flinkGenerateSavepointVersion + "-snapshot").     testHarness.close(). }
false;public;0;49;;@Test public void testRestoreApplyEventTimeWindows() throws Exception {     final int windowSize = 3.     ListStateDescriptor<Tuple2<String, Integer>> stateDesc = new ListStateDescriptor<>("window-contents", STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     WindowOperator<String, Tuple2<String, Integer>, Iterable<Tuple2<String, Integer>>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(TumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)), new TimeWindow.Serializer(), new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new RichSumReducer<TimeWindow>()), EventTimeTrigger.create(), 0, null).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setup().     testHarness.initializeState(OperatorSnapshotUtil.getResourceFilename("win-op-migration-test-apply-event-time-flink" + testMigrateVersion + "-snapshot")).     testHarness.open().     testHarness.processWatermark(new Watermark(2999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 3), 2999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 3), 2999)).     expectedOutput.add(new Watermark(2999)).     testHarness.processWatermark(new Watermark(3999)).     expectedOutput.add(new Watermark(3999)).     testHarness.processWatermark(new Watermark(4999)).     expectedOutput.add(new Watermark(4999)).     testHarness.processWatermark(new Watermark(5999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 2), 5999)).     expectedOutput.add(new Watermark(5999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     testHarness.close(). }
true;public;0;50;/**  * Manually run this to write binary snapshot data.  */ ;/**  * Manually run this to write binary snapshot data.  */ @Ignore @Test public void writeReducingProcessingTimeWindowsSnapshot() throws Exception {     final int windowSize = 3.     ReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>("window-contents", new SumReducer<>(), STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     WindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(TumblingProcessingTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)), new TimeWindow.Serializer(), new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()), ProcessingTimeTrigger.create(), 0, null).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setup().     testHarness.open().     testHarness.setProcessingTime(10).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1))).     testHarness.setProcessingTime(3010).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key3", 1))).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 1), 2999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 1), 2999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     // do snapshot and save to file     OperatorSubtaskState snapshot = testHarness.snapshot(0, 0).     OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/win-op-migration-test-reduce-processing-time-flink" + flinkGenerateSavepointVersion + "-snapshot").     testHarness.close(). }
false;public;0;45;;@Test public void testRestoreReducingProcessingTimeWindows() throws Exception {     final int windowSize = 3.     ReducingStateDescriptor<Tuple2<String, Integer>> stateDesc = new ReducingStateDescriptor<>("window-contents", new SumReducer<>(), STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     WindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(TumblingProcessingTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)), new TimeWindow.Serializer(), new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<String, TimeWindow, Tuple2<String, Integer>>()), ProcessingTimeTrigger.create(), 0, null).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setup().     testHarness.initializeState(OperatorSnapshotUtil.getResourceFilename("win-op-migration-test-reduce-processing-time-flink" + testMigrateVersion + "-snapshot")).     testHarness.open().     testHarness.setProcessingTime(3020).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 3))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 3))).     testHarness.setProcessingTime(6000).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 3), 5999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 4), 5999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key3", 1), 5999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     testHarness.close(). }
true;public;0;48;/**  * Manually run this to write binary snapshot data.  */ ;/**  * Manually run this to write binary snapshot data.  */ @Ignore @Test public void writeApplyProcessingTimeWindowsSnapshot() throws Exception {     final int windowSize = 3.     ListStateDescriptor<Tuple2<String, Integer>> stateDesc = new ListStateDescriptor<>("window-contents", STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     WindowOperator<String, Tuple2<String, Integer>, Iterable<Tuple2<String, Integer>>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(TumblingProcessingTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)), new TimeWindow.Serializer(), new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new RichSumReducer<TimeWindow>()), ProcessingTimeTrigger.create(), 0, null).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setup().     testHarness.open().     testHarness.setProcessingTime(10).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1))).     testHarness.setProcessingTime(3010).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key3", 1))).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 1), 2999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 1), 2999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     // do snapshot and save to file     OperatorSubtaskState snapshot = testHarness.snapshot(0, 0).     OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/win-op-migration-test-apply-processing-time-flink" + flinkGenerateSavepointVersion + "-snapshot").     testHarness.close(). }
false;public;0;44;;@Test public void testRestoreApplyProcessingTimeWindows() throws Exception {     final int windowSize = 3.     ListStateDescriptor<Tuple2<String, Integer>> stateDesc = new ListStateDescriptor<>("window-contents", STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     WindowOperator<String, Tuple2<String, Integer>, Iterable<Tuple2<String, Integer>>, Tuple2<String, Integer>, TimeWindow> operator = new WindowOperator<>(TumblingProcessingTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)), new TimeWindow.Serializer(), new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new RichSumReducer<TimeWindow>()), ProcessingTimeTrigger.create(), 0, null).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setup().     testHarness.initializeState(OperatorSnapshotUtil.getResourceFilename("win-op-migration-test-apply-processing-time-flink" + testMigrateVersion + "-snapshot")).     testHarness.open().     testHarness.setProcessingTime(3020).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 3))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 3))).     testHarness.setProcessingTime(6000).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 3), 5999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 4), 5999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key3", 1), 5999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     testHarness.close(). }
true;public;0;61;/**  * Manually run this to write binary snapshot data.  */ ;/**  * Manually run this to write binary snapshot data.  */ @Ignore @Test public void writeWindowsWithKryoSerializedKeysSnapshot() throws Exception {     final int windowSize = 3.     TypeInformation<Tuple2<NonPojoType, Integer>> inputType = new TypeHint<Tuple2<NonPojoType, Integer>>() {     }.getTypeInfo().     ReducingStateDescriptor<Tuple2<NonPojoType, Integer>> stateDesc = new ReducingStateDescriptor<>("window-contents", new SumReducer<>(), inputType.createSerializer(new ExecutionConfig())).     TypeSerializer<NonPojoType> keySerializer = TypeInformation.of(NonPojoType.class).createSerializer(new ExecutionConfig()).     assertTrue(keySerializer instanceof KryoSerializer).     WindowOperator<NonPojoType, Tuple2<NonPojoType, Integer>, Tuple2<NonPojoType, Integer>, Tuple2<NonPojoType, Integer>, TimeWindow> operator = new WindowOperator<>(TumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)), new TimeWindow.Serializer(), new TupleKeySelector<>(), keySerializer, stateDesc, new InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<>()), EventTimeTrigger.create(), 0, null).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     OneInputStreamOperatorTestHarness<Tuple2<NonPojoType, Integer>, Tuple2<NonPojoType, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), TypeInformation.of(NonPojoType.class)).     testHarness.setup().     testHarness.open().     // add elements out-of-order     testHarness.processElement(new StreamRecord<>(new Tuple2<>(new NonPojoType("key2"), 1), 3999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>(new NonPojoType("key2"), 1), 3000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>(new NonPojoType("key1"), 1), 20)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>(new NonPojoType("key1"), 1), 0)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>(new NonPojoType("key1"), 1), 999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>(new NonPojoType("key2"), 1), 1998)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>(new NonPojoType("key2"), 1), 1999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>(new NonPojoType("key2"), 1), 1000)).     testHarness.processWatermark(new Watermark(999)).     expectedOutput.add(new Watermark(999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     testHarness.processWatermark(new Watermark(1999)).     expectedOutput.add(new Watermark(1999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     // do snapshot and save to file     OperatorSubtaskState snapshot = testHarness.snapshot(0, 0).     OperatorSnapshotUtil.writeStateHandle(snapshot, "src/test/resources/win-op-migration-test-kryo-serialized-key-flink" + flinkGenerateSavepointVersion + "-snapshot").     testHarness.close(). }
false;public;0;55;;@Test public void testRestoreKryoSerializedKeysWindows() throws Exception {     final int windowSize = 3.     TypeInformation<Tuple2<NonPojoType, Integer>> inputType = new TypeHint<Tuple2<NonPojoType, Integer>>() {     }.getTypeInfo().     ReducingStateDescriptor<Tuple2<NonPojoType, Integer>> stateDesc = new ReducingStateDescriptor<>("window-contents", new SumReducer<>(), inputType.createSerializer(new ExecutionConfig())).     TypeSerializer<NonPojoType> keySerializer = TypeInformation.of(NonPojoType.class).createSerializer(new ExecutionConfig()).     assertTrue(keySerializer instanceof KryoSerializer).     WindowOperator<NonPojoType, Tuple2<NonPojoType, Integer>, Tuple2<NonPojoType, Integer>, Tuple2<NonPojoType, Integer>, TimeWindow> operator = new WindowOperator<>(TumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)), new TimeWindow.Serializer(), new TupleKeySelector<>(), keySerializer, stateDesc, new InternalSingleValueWindowFunction<>(new PassThroughWindowFunction<>()), EventTimeTrigger.create(), 0, null).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     OneInputStreamOperatorTestHarness<Tuple2<NonPojoType, Integer>, Tuple2<NonPojoType, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector<>(), TypeInformation.of(NonPojoType.class)).     testHarness.setup().     testHarness.initializeState(OperatorSnapshotUtil.getResourceFilename("win-op-migration-test-kryo-serialized-key-flink" + testMigrateVersion + "-snapshot")).     testHarness.open().     testHarness.processWatermark(new Watermark(2999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>(new NonPojoType("key1"), 3), 2999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>(new NonPojoType("key2"), 3), 2999)).     expectedOutput.add(new Watermark(2999)).     testHarness.processWatermark(new Watermark(3999)).     expectedOutput.add(new Watermark(3999)).     testHarness.processWatermark(new Watermark(4999)).     expectedOutput.add(new Watermark(4999)).     testHarness.processWatermark(new Watermark(5999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>(new NonPojoType("key2"), 2), 5999)).     expectedOutput.add(new Watermark(5999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new Tuple2ResultSortComparator<>()).     testHarness.close(). }
false;public;1;4;;@Override public K getKey(Tuple2<K, Integer> value) throws Exception {     return value.f0. }
false;public;2;18;;@Override public int compare(Object o1, Object o2) {     if (o1 instanceof Watermark || o2 instanceof Watermark) {         return 0.     } else {         StreamRecord<Tuple2<K, Integer>> sr0 = (StreamRecord<Tuple2<K, Integer>>) o1.         StreamRecord<Tuple2<K, Integer>> sr1 = (StreamRecord<Tuple2<K, Integer>>) o2.         if (sr0.getTimestamp() != sr1.getTimestamp()) {             return (int) (sr0.getTimestamp() - sr1.getTimestamp()).         }         int comparison = sr0.getValue().f0.compareTo(sr1.getValue().f0).         if (comparison != 0) {             return comparison.         } else {             return sr0.getValue().f1 - sr1.getValue().f1.         }     } }
false;public;2;22;;@Override public int compare(Object o1, Object o2) {     if (o1 instanceof Watermark || o2 instanceof Watermark) {         return 0.     } else {         StreamRecord<Tuple3<String, Long, Long>> sr0 = (StreamRecord<Tuple3<String, Long, Long>>) o1.         StreamRecord<Tuple3<String, Long, Long>> sr1 = (StreamRecord<Tuple3<String, Long, Long>>) o2.         if (sr0.getTimestamp() != sr1.getTimestamp()) {             return (int) (sr0.getTimestamp() - sr1.getTimestamp()).         }         int comparison = sr0.getValue().f0.compareTo(sr1.getValue().f0).         if (comparison != 0) {             return comparison.         } else {             comparison = (int) (sr0.getValue().f1 - sr1.getValue().f1).             if (comparison != 0) {                 return comparison.             }             return (int) (sr0.getValue().f1 - sr1.getValue().f1).         }     } }
false;public;2;5;;@Override public Tuple2<K, Integer> reduce(Tuple2<K, Integer> value1, Tuple2<K, Integer> value2) throws Exception {     return new Tuple2<>(value2.f0, value1.f1 + value2.f1). }
false;public;1;5;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     openCalled = true. }
false;public;0;4;;@Override public void close() throws Exception {     super.close(). }
false;public;4;17;;@Override public void apply(String key, W window, Iterable<Tuple2<String, Integer>> input, Collector<Tuple2<String, Integer>> out) throws Exception {     if (!openCalled) {         fail("Open was not called").     }     int sum = 0.     for (Tuple2<String, Integer> t : input) {         sum += t.f1.     }     out.collect(new Tuple2<>(key, sum)). }
false;public;4;12;;@Override public void apply(String key, TimeWindow window, Iterable<Tuple2<String, Integer>> values, Collector<Tuple3<String, Long, Long>> out) throws Exception {     int sum = 0.     for (Tuple2<String, Integer> i : values) {         sum += i.f1.     }     String resultString = key + "-" + sum.     out.collect(new Tuple3<>(resultString, window.getStart(), window.getEnd())). }
