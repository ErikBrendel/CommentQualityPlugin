commented;modifiers;parameterAmount;loc;comment;code
true;public;0;44;/**  * This test creates a program with 4 sources (2 with master hooks, 2 without).  * The resulting job graph must have 2 configured master hooks.  */ ;/**  * This test creates a program with 4 sources (2 with master hooks, 2 without).  * The resulting job graph must have 2 configured master hooks.  */ @Test public void testHookConfiguration() throws Exception {     // create some sources some of which configure master hooks     final TestSource source1 = new TestSource().     final TestSourceWithHook source2 = new TestSourceWithHook("foo").     final TestSource source3 = new TestSource().     final TestSourceWithHook source4 = new TestSourceWithHook("bar").     final MapFunction<String, String> identity = new Identity<>().     final IdentityWithHook<String> identityWithHook1 = new IdentityWithHook<>("apple").     final IdentityWithHook<String> identityWithHook2 = new IdentityWithHook<>("orange").     final Set<MasterTriggerRestoreHook<?>> hooks = new HashSet<MasterTriggerRestoreHook<?>>(asList(source2.createMasterTriggerRestoreHook(), source4.createMasterTriggerRestoreHook(), identityWithHook1.createMasterTriggerRestoreHook(), identityWithHook2.createMasterTriggerRestoreHook())).     // we can instantiate a local environment here, because we never actually execute something     final StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment().     env.enableCheckpointing(500).     env.addSource(source1).map(identity).union(env.addSource(source2).map(identity)).union(env.addSource(source3).map(identityWithHook1)).union(env.addSource(source4).map(identityWithHook2)).addSink(new DiscardingSink<String>()).     final JobGraph jg = env.getStreamGraph().getJobGraph().     SerializedValue<Factory[]> serializedConfiguredHooks = jg.getCheckpointingSettings().getMasterHooks().     assertNotNull(serializedConfiguredHooks).     Factory[] configuredHooks = serializedConfiguredHooks.deserializeValue(getClass().getClassLoader()).     assertEquals(hooks.size(), configuredHooks.length).     // check that all hooks are contained and exist exactly once     for (Factory f : configuredHooks) {         MasterTriggerRestoreHook<?> hook = f.create().         assertTrue(hooks.remove(hook)).     }     assertTrue(hooks.isEmpty()). }
false;public;0;4;;@Override public String getIdentifier() {     return id. }
false;public;0;4;;@Override public void reset() throws Exception {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public void close() throws Exception {     throw new UnsupportedOperationException(). }
false;public;3;4;;@Override public CompletableFuture<String> triggerCheckpoint(long checkpointId, long timestamp, Executor executor) {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public void restoreCheckpoint(long checkpointId, @Nullable String checkpointData) throws Exception {     throw new UnsupportedOperationException(). }
false;public;0;5;;@Nullable @Override public SimpleVersionedSerializer<String> createCheckpointDataSerializer() {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public boolean equals(Object obj) {     return obj == this || (obj != null && obj.getClass() == getClass() && ((TestHook) obj).id.equals(id)). }
false;public;0;4;;@Override public int hashCode() {     return id.hashCode(). }
false;public;1;4;;@Override public void run(SourceContext<String> ctx) {     throw new UnsupportedOperationException(). }
false;public;0;2;;@Override public void cancel() { }
false;public;0;4;;@Override public TestHook createMasterTriggerRestoreHook() {     return new TestHook(id). }
false;public;1;4;;@Override public T map(T value) {     return value. }
false;public;0;4;;@Override public TestHook createMasterTriggerRestoreHook() {     return new TestHook(id). }
