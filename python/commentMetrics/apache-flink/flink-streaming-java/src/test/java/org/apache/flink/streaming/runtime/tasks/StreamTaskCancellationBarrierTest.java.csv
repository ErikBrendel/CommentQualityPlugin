commented;modifiers;parameterAmount;loc;comment;code
true;public;0;22;/**  * This test checks that tasks emit a proper cancel checkpoint barrier, if a "trigger checkpoint" message  * comes before they are ready.  */ ;/**  * This test checks that tasks emit a proper cancel checkpoint barrier, if a "trigger checkpoint" message  * comes before they are ready.  */ @Test public void testEmitCancellationBarrierWhenNotReady() throws Exception {     StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(InitBlockingTask::new, BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setupOutputForSingletonOperatorChain().     // start the test - this cannot succeed across the 'init()' method     testHarness.invoke().     StreamTask<String, ?> task = testHarness.getTask().     // tell the task to commence a checkpoint     boolean result = task.triggerCheckpoint(new CheckpointMetaData(41L, System.currentTimeMillis()), CheckpointOptions.forCheckpointWithDefaultLocation()).     assertFalse("task triggered checkpoint though not ready", result).     // a cancellation barrier should be downstream     Object emitted = testHarness.getOutput().poll().     assertNotNull("nothing emitted", emitted).     assertTrue("wrong type emitted", emitted instanceof CancelCheckpointMarker).     assertEquals("wrong checkpoint id", 41L, ((CancelCheckpointMarker) emitted).getCheckpointId()). }
true;public;0;38;/**  * This test verifies (for onw input tasks) that the Stream tasks react the following way to  * receiving a checkpoint cancellation barrier:  *   - send a "decline checkpoint" notification out (to the JobManager)  *   - emit a cancellation barrier downstream.  */ ;/**  * This test verifies (for onw input tasks) that the Stream tasks react the following way to  * receiving a checkpoint cancellation barrier:  *   - send a "decline checkpoint" notification out (to the JobManager)  *   - emit a cancellation barrier downstream.  */ @Test public void testDeclineCallOnCancelBarrierOneInput() throws Exception {     OneInputStreamTaskTestHarness<String, String> testHarness = new OneInputStreamTaskTestHarness<>(OneInputStreamTask::new, 1, 2, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setupOutputForSingletonOperatorChain().     StreamConfig streamConfig = testHarness.getStreamConfig().     StreamMap<String, String> mapOperator = new StreamMap<>(new IdentityMap()).     streamConfig.setStreamOperator(mapOperator).     streamConfig.setOperatorID(new OperatorID()).     StreamMockEnvironment environment = spy(testHarness.createEnvironment()).     // start the task     testHarness.invoke(environment).     testHarness.waitForTaskRunning().     // emit cancellation barriers     testHarness.processEvent(new CancelCheckpointMarker(2L), 0, 1).     testHarness.processEvent(new CancelCheckpointMarker(2L), 0, 0).     testHarness.waitForInputProcessing().     // the decline call should go to the coordinator     verify(environment, times(1)).declineCheckpoint(eq(2L), any(CheckpointDeclineOnCancellationBarrierException.class)).     // a cancellation barrier should be downstream     Object result = testHarness.getOutput().poll().     assertNotNull("nothing emitted", result).     assertTrue("wrong type emitted", result instanceof CancelCheckpointMarker).     assertEquals("wrong checkpoint id", 2L, ((CancelCheckpointMarker) result).getCheckpointId()).     // cancel and shutdown     testHarness.endInput().     testHarness.waitForTaskCompletion(). }
true;public;0;37;/**  * This test verifies (for two input tasks) that the Stream tasks react the following way to  * receiving a checkpoint cancellation barrier:  *   - send a "decline checkpoint" notification out (to the JobManager)  *   - emit a cancellation barrier downstream.  */ ;/**  * This test verifies (for two input tasks) that the Stream tasks react the following way to  * receiving a checkpoint cancellation barrier:  *   - send a "decline checkpoint" notification out (to the JobManager)  *   - emit a cancellation barrier downstream.  */ @Test public void testDeclineCallOnCancelBarrierTwoInputs() throws Exception {     TwoInputStreamTaskTestHarness<String, String, String> testHarness = new TwoInputStreamTaskTestHarness<>(TwoInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setupOutputForSingletonOperatorChain().     StreamConfig streamConfig = testHarness.getStreamConfig().     CoStreamMap<String, String, String> op = new CoStreamMap<>(new UnionCoMap()).     streamConfig.setStreamOperator(op).     streamConfig.setOperatorID(new OperatorID()).     StreamMockEnvironment environment = spy(testHarness.createEnvironment()).     // start the task     testHarness.invoke(environment).     testHarness.waitForTaskRunning().     // emit cancellation barriers     testHarness.processEvent(new CancelCheckpointMarker(2L), 0, 0).     testHarness.processEvent(new CancelCheckpointMarker(2L), 1, 0).     testHarness.waitForInputProcessing().     // the decline call should go to the coordinator     verify(environment, times(1)).declineCheckpoint(eq(2L), any(CheckpointDeclineOnCancellationBarrierException.class)).     // a cancellation barrier should be downstream     Object result = testHarness.getOutput().poll().     assertNotNull("nothing emitted", result).     assertTrue("wrong type emitted", result instanceof CancelCheckpointMarker).     assertEquals("wrong checkpoint id", 2L, ((CancelCheckpointMarker) result).getCheckpointId()).     // cancel and shutdown     testHarness.endInput().     testHarness.waitForTaskCompletion(). }
false;protected;0;8;;@Override protected void init() throws Exception {     synchronized (lock) {         while (running) {             lock.wait().         }     } }
false;protected;0;2;;@Override protected void run() throws Exception { }
false;protected;0;2;;@Override protected void cleanup() throws Exception { }
false;protected;0;7;;@Override protected void cancelTask() throws Exception {     running = false.     synchronized (lock) {         lock.notifyAll().     } }
false;public;1;4;;@Override public String map(String value) throws Exception {     return value. }
false;public;1;4;;@Override public String map1(String value) throws Exception {     return value. }
false;public;1;4;;@Override public String map2(String value) throws Exception {     return value. }
