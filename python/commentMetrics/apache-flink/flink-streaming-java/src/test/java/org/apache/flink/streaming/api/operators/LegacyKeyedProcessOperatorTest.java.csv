commented;modifiers;parameterAmount;loc;comment;code
false;public;0;29;;@Test public void testTimestampAndWatermarkQuerying() throws Exception {     LegacyKeyedProcessOperator<Integer, Integer, String> operator = new LegacyKeyedProcessOperator<>(new QueryingFlatMapFunction(TimeDomain.EVENT_TIME)).     OneInputStreamOperatorTestHarness<Integer, String> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO).     testHarness.setup().     testHarness.open().     testHarness.processWatermark(new Watermark(17)).     testHarness.processElement(new StreamRecord<>(5, 12L)).     testHarness.processWatermark(new Watermark(42)).     testHarness.processElement(new StreamRecord<>(6, 13L)).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     expectedOutput.add(new Watermark(17L)).     expectedOutput.add(new StreamRecord<>("5TIME:17 TS:12", 12L)).     expectedOutput.add(new Watermark(42L)).     expectedOutput.add(new StreamRecord<>("6TIME:42 TS:13", 13L)).     TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput()).     testHarness.close(). }
false;public;0;27;;@Test public void testTimestampAndProcessingTimeQuerying() throws Exception {     LegacyKeyedProcessOperator<Integer, Integer, String> operator = new LegacyKeyedProcessOperator<>(new QueryingFlatMapFunction(TimeDomain.PROCESSING_TIME)).     OneInputStreamOperatorTestHarness<Integer, String> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO).     testHarness.setup().     testHarness.open().     testHarness.setProcessingTime(17).     testHarness.processElement(new StreamRecord<>(5)).     testHarness.setProcessingTime(42).     testHarness.processElement(new StreamRecord<>(6)).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     expectedOutput.add(new StreamRecord<>("5TIME:17 TS:null")).     expectedOutput.add(new StreamRecord<>("6TIME:42 TS:null")).     TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput()).     testHarness.close(). }
false;public;0;29;;@Test public void testEventTimeTimers() throws Exception {     LegacyKeyedProcessOperator<Integer, Integer, Integer> operator = new LegacyKeyedProcessOperator<>(new TriggeringFlatMapFunction(TimeDomain.EVENT_TIME)).     OneInputStreamOperatorTestHarness<Integer, Integer> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO).     testHarness.setup().     testHarness.open().     testHarness.processWatermark(new Watermark(0)).     testHarness.processElement(new StreamRecord<>(17, 42L)).     testHarness.processWatermark(new Watermark(5)).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     expectedOutput.add(new Watermark(0L)).     expectedOutput.add(new StreamRecord<>(17, 42L)).     expectedOutput.add(new StreamRecord<>(1777, 5L)).     expectedOutput.add(new Watermark(5L)).     TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput()).     testHarness.close(). }
false;public;0;25;;@Test public void testProcessingTimeTimers() throws Exception {     LegacyKeyedProcessOperator<Integer, Integer, Integer> operator = new LegacyKeyedProcessOperator<>(new TriggeringFlatMapFunction(TimeDomain.PROCESSING_TIME)).     OneInputStreamOperatorTestHarness<Integer, Integer> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO).     testHarness.setup().     testHarness.open().     testHarness.processElement(new StreamRecord<>(17)).     testHarness.setProcessingTime(5).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     expectedOutput.add(new StreamRecord<>(17)).     expectedOutput.add(new StreamRecord<>(1777)).     TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput()).     testHarness.close(). }
true;public;0;36;/**  * Verifies that we don't have leakage between different keys.  */ ;/**  * Verifies that we don't have leakage between different keys.  */ @Test public void testEventTimeTimerWithState() throws Exception {     LegacyKeyedProcessOperator<Integer, Integer, String> operator = new LegacyKeyedProcessOperator<>(new TriggeringStatefulFlatMapFunction(TimeDomain.EVENT_TIME)).     OneInputStreamOperatorTestHarness<Integer, String> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO).     testHarness.setup().     testHarness.open().     testHarness.processWatermark(new Watermark(1)).     // should set timer for 6     testHarness.processElement(new StreamRecord<>(17, 0L)).     testHarness.processWatermark(new Watermark(2)).     // should set timer for 7     testHarness.processElement(new StreamRecord<>(42, 1L)).     testHarness.processWatermark(new Watermark(6)).     testHarness.processWatermark(new Watermark(7)).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     expectedOutput.add(new Watermark(1L)).     expectedOutput.add(new StreamRecord<>("INPUT:17", 0L)).     expectedOutput.add(new Watermark(2L)).     expectedOutput.add(new StreamRecord<>("INPUT:42", 1L)).     expectedOutput.add(new StreamRecord<>("STATE:17", 6L)).     expectedOutput.add(new Watermark(6L)).     expectedOutput.add(new StreamRecord<>("STATE:42", 7L)).     expectedOutput.add(new Watermark(7L)).     TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput()).     testHarness.close(). }
true;public;0;32;/**  * Verifies that we don't have leakage between different keys.  */ ;/**  * Verifies that we don't have leakage between different keys.  */ @Test public void testProcessingTimeTimerWithState() throws Exception {     LegacyKeyedProcessOperator<Integer, Integer, String> operator = new LegacyKeyedProcessOperator<>(new TriggeringStatefulFlatMapFunction(TimeDomain.PROCESSING_TIME)).     OneInputStreamOperatorTestHarness<Integer, String> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO).     testHarness.setup().     testHarness.open().     testHarness.setProcessingTime(1).     // should set timer for 6     testHarness.processElement(new StreamRecord<>(17)).     testHarness.setProcessingTime(2).     // should set timer for 7     testHarness.processElement(new StreamRecord<>(42)).     testHarness.setProcessingTime(6).     testHarness.setProcessingTime(7).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     expectedOutput.add(new StreamRecord<>("INPUT:17")).     expectedOutput.add(new StreamRecord<>("INPUT:42")).     expectedOutput.add(new StreamRecord<>("STATE:17")).     expectedOutput.add(new StreamRecord<>("STATE:42")).     TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput()).     testHarness.close(). }
false;public;0;40;;@Test public void testSnapshotAndRestore() throws Exception {     LegacyKeyedProcessOperator<Integer, Integer, String> operator = new LegacyKeyedProcessOperator<>(new BothTriggeringFlatMapFunction()).     OneInputStreamOperatorTestHarness<Integer, String> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO).     testHarness.setup().     testHarness.open().     testHarness.processElement(new StreamRecord<>(5, 12L)).     // snapshot and restore from scratch     OperatorSubtaskState snapshot = testHarness.snapshot(0, 0).     testHarness.close().     operator = new LegacyKeyedProcessOperator<>(new BothTriggeringFlatMapFunction()).     testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO).     testHarness.setup().     testHarness.initializeState(snapshot).     testHarness.open().     testHarness.setProcessingTime(5).     testHarness.processWatermark(new Watermark(6)).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     expectedOutput.add(new StreamRecord<>("PROC:1777")).     expectedOutput.add(new StreamRecord<>("EVENT:1777", 6L)).     expectedOutput.add(new Watermark(6)).     TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput()).     testHarness.close(). }
false;public;0;20;;@Test public void testNullOutputTagRefusal() throws Exception {     LegacyKeyedProcessOperator<Integer, Integer, String> operator = new LegacyKeyedProcessOperator<>(new NullOutputTagEmittingProcessFunction()).     OneInputStreamOperatorTestHarness<Integer, String> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<>(), BasicTypeInfo.INT_TYPE_INFO).     testHarness.setup().     testHarness.open().     testHarness.setProcessingTime(17).     try {         expectedException.expect(IllegalArgumentException.class).         testHarness.processElement(new StreamRecord<>(5)).     } finally {         testHarness.close().     } }
true;public;0;40;/**  * This also verifies that the timestamps ouf side-emitted records is correct.  */ ;/**  * This also verifies that the timestamps ouf side-emitted records is correct.  */ @Test public void testSideOutput() throws Exception {     LegacyKeyedProcessOperator<Integer, Integer, String> operator = new LegacyKeyedProcessOperator<>(new SideOutputProcessFunction()).     OneInputStreamOperatorTestHarness<Integer, String> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<>(), BasicTypeInfo.INT_TYPE_INFO).     testHarness.setup().     testHarness.open().     testHarness.processElement(new StreamRecord<>(42, 17L)).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     expectedOutput.add(new StreamRecord<>("IN:42", 17L)).     TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput()).     ConcurrentLinkedQueue<StreamRecord<Integer>> expectedIntSideOutput = new ConcurrentLinkedQueue<>().     expectedIntSideOutput.add(new StreamRecord<>(42, 17L)).     ConcurrentLinkedQueue<StreamRecord<Integer>> intSideOutput = testHarness.getSideOutput(SideOutputProcessFunction.INTEGER_OUTPUT_TAG).     TestHarnessUtil.assertOutputEquals("Side output was not correct.", expectedIntSideOutput, intSideOutput).     ConcurrentLinkedQueue<StreamRecord<Long>> expectedLongSideOutput = new ConcurrentLinkedQueue<>().     expectedLongSideOutput.add(new StreamRecord<>(42L, 17L)).     ConcurrentLinkedQueue<StreamRecord<Long>> longSideOutput = testHarness.getSideOutput(SideOutputProcessFunction.LONG_OUTPUT_TAG).     TestHarnessUtil.assertOutputEquals("Side output was not correct.", expectedLongSideOutput, longSideOutput).     testHarness.close(). }
false;public;3;4;;@Override public void processElement(Integer value, Context ctx, Collector<String> out) throws Exception {     ctx.output(null, value). }
false;public;3;7;;@Override public void processElement(Integer value, Context ctx, Collector<String> out) throws Exception {     out.collect("IN:" + value).     ctx.output(INTEGER_OUTPUT_TAG, value).     ctx.output(LONG_OUTPUT_TAG, value.longValue()). }
false;public;1;4;;@Override public T getKey(T value) throws Exception {     return value. }
false;public;3;8;;@Override public void processElement(Integer value, Context ctx, Collector<String> out) throws Exception {     if (timeDomain.equals(TimeDomain.EVENT_TIME)) {         out.collect(value + "TIME:" + ctx.timerService().currentWatermark() + " TS:" + ctx.timestamp()).     } else {         out.collect(value + "TIME:" + ctx.timerService().currentProcessingTime() + " TS:" + ctx.timestamp()).     } }
false;public;3;4;;@Override public void onTimer(long timestamp, OnTimerContext ctx, Collector<String> out) throws Exception { // Do nothing }
false;public;3;9;;@Override public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {     out.collect(value).     if (timeDomain.equals(TimeDomain.EVENT_TIME)) {         ctx.timerService().registerEventTimeTimer(ctx.timerService().currentWatermark() + 5).     } else {         ctx.timerService().registerProcessingTimeTimer(ctx.timerService().currentProcessingTime() + 5).     } }
false;public;3;5;;@Override public void onTimer(long timestamp, OnTimerContext ctx, Collector<Integer> out) throws Exception {     assertEquals(this.timeDomain, ctx.timeDomain()).     out.collect(1777). }
false;public;3;10;;@Override public void processElement(Integer value, Context ctx, Collector<String> out) throws Exception {     out.collect("INPUT:" + value).     getRuntimeContext().getState(state).update(value).     if (timeDomain.equals(TimeDomain.EVENT_TIME)) {         ctx.timerService().registerEventTimeTimer(ctx.timerService().currentWatermark() + 5).     } else {         ctx.timerService().registerProcessingTimeTimer(ctx.timerService().currentProcessingTime() + 5).     } }
false;public;3;5;;@Override public void onTimer(long timestamp, OnTimerContext ctx, Collector<String> out) throws Exception {     assertEquals(this.timeDomain, ctx.timeDomain()).     out.collect("STATE:" + getRuntimeContext().getState(state).value()). }
false;public;3;5;;@Override public void processElement(Integer value, Context ctx, Collector<String> out) throws Exception {     ctx.timerService().registerProcessingTimeTimer(5).     ctx.timerService().registerEventTimeTimer(6). }
false;public;3;8;;@Override public void onTimer(long timestamp, OnTimerContext ctx, Collector<String> out) throws Exception {     if (TimeDomain.EVENT_TIME.equals(ctx.timeDomain())) {         out.collect("EVENT:1777").     } else {         out.collect("PROC:1777").     } }
