# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1477517189;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1478251480;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1478532357;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1483982056;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1484303457;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1485189169;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1487167701;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1487871589;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1488305067;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1489422543;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1490724328;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1493195810;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1493821466;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1494598316;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1495484544;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1509118643;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1509723634;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1516626397;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1517489695;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1517489695;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1519567828;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1519567828;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1519568061;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1526313052;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1538998760;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception;1550863152;Verify that timers for the different time domains don't clash.;@Test_	public void testProcessingTimeAndEventTimeDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)__		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))__	};verify,that,timers,for,the,different,time,domains,don,t,clash;test,public,void,test,processing,time,and,event,time,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,element,new,tuple2,0,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1477517189;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1478251480;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1478532357;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1483982056;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1484303457;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1485189169;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1487167701;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1487871589;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1488305067;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1489422543;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1490724328;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1493195810;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1493821466;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1494598316;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1495484544;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1509118643;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1509723634;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1516626397;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1517489695;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1517489695;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1519567828;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1519567828;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1519568061;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1526313052;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1538998760;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testProcessingTimeTimersDontInterfere() throws Exception;1550863152;Verify that firing processing-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testProcessingTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		testHarness.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:HELLO"))___		testHarness.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,firing,processing,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,processing,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,set,processing,time,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,set,processing,time,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1477517189;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1478251480;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1478532357;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1483982056;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1484303457;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1485189169;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1487167701;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1487871589;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1488305067;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1489422543;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1490724328;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1493195810;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1493821466;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1494598316;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1495484544;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1509118643;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1509723634;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1516626397;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1517489695;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1517489695;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1519567828;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1519567828;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1519568061;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1526313052;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1538998760;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEventTimeTimersDontInterfere() throws Exception;1550863152;Verify that firing event-time timers see the state of the key that was active_when the timer was set.;@Test_	public void testEventTimeTimersDontInterfere() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.processWatermark(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_EVENT_TIME_TIMER:10"), 0)___		testHarness.processWatermark(10L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:HELLO"))___		testHarness.processWatermark(20L)___		assertThat(_				extractResult(testHarness),_				contains("ON_EVENT_TIME:CIAO"))__	};verify,that,firing,event,time,timers,see,the,state,of,the,key,that,was,active,when,the,timer,was,set;test,public,void,test,event,time,timers,dont,interfere,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,process,watermark,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,test,harness,process,watermark,10l,assert,that,extract,result,test,harness,contains,hello,test,harness,process,watermark,20l,assert,that,extract,result,test,harness,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1485189169;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StaetSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, streamFactory)__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,staet,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,stream,factory,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1487167701;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StaetSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong())).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp)__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,staet,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1487871589;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StaetSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,staet,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1488305067;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StaetSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,staet,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1489422543;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StaetSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,staet,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1490724328;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StaetSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,staet,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1493195810;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StaetSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,staet,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1493821466;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StaetSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,staet,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1494598316;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1495484544;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1509118643;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1509723634;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1516626397;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1517489695;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forCheckpointWithDefaultLocation())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1517489695;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1519567828;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1519567828;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1519568061;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1526313052;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1538998760;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingSnapshotMethod() throws Exception;1550863152;Tests that the created StateSnapshotContextSynchronousImpl is closed in case of a failing_Operator#snapshotState(StateSnapshotContextSynchronousImpl) call.;@Test_	public void testFailingSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		_		doThrow(failingException).when(operator).snapshotState(eq(context))___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		verify(context).close()__	};tests,that,the,created,state,snapshot,context,synchronous,impl,is,closed,in,case,of,a,failing,operator,snapshot,state,state,snapshot,context,synchronous,impl,call;test,public,void,test,failing,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,do,throw,failing,exception,when,operator,snapshot,state,eq,context,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1485189169;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyGroupsStateHandle> futureKeyGroupStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyGroupStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory))).thenThrow(failingException)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)___		try {_			operator.snapshotState(checkpointId, timestamp, streamFactory)__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyGroupStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyGroupStateHandle).cancel(anyBoolean())__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,key,groups,state,handle,future,key,group,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,key,group,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,then,throw,failing,exception,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,try,operator,snapshot,state,checkpoint,id,timestamp,stream,factory,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,key,group,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,key,group,state,handle,cancel,any,boolean
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1487167701;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyGroupsStateHandle> futureKeyGroupStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyGroupStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong())).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory))).thenThrow(failingException)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp)__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyGroupStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyGroupStateHandle).cancel(anyBoolean())__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,key,groups,state,handle,future,key,group,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,key,group,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,then,throw,failing,exception,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,key,group,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,key,group,state,handle,cancel,any,boolean
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1487871589;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyGroupsStateHandle> futureKeyGroupStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyGroupStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()___		_		_		_		when(operator.getCheckpointStreamFactory(any(CheckpointOptions.class))).thenReturn(streamFactory)___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), eq(CheckpointOptions.forFullCheckpoint()))).thenThrow(failingException)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyGroupStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyGroupStateHandle).cancel(anyBoolean())__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,key,groups,state,handle,future,key,group,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,key,group,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,when,operator,get,checkpoint,stream,factory,any,checkpoint,options,class,then,return,stream,factory,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,eq,checkpoint,options,for,full,checkpoint,then,throw,failing,exception,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,key,group,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,key,group,state,handle,cancel,any,boolean
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1488305067;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyGroupsStateHandle> futureKeyGroupStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyGroupStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()___		_		_		_		when(operator.getCheckpointStreamFactory(any(CheckpointOptions.class))).thenReturn(streamFactory)___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), eq(CheckpointOptions.forFullCheckpoint()))).thenThrow(failingException)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyGroupStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyGroupStateHandle).cancel(anyBoolean())__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,key,groups,state,handle,future,key,group,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,key,group,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,when,operator,get,checkpoint,stream,factory,any,checkpoint,options,class,then,return,stream,factory,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,eq,checkpoint,options,for,full,checkpoint,then,throw,failing,exception,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,key,group,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,key,group,state,handle,cancel,any,boolean
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1489422543;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyGroupsStateHandle> futureKeyGroupStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyGroupStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()___		_		_		_		when(operator.getCheckpointStreamFactory(any(CheckpointOptions.class))).thenReturn(streamFactory)___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), eq(CheckpointOptions.forFullCheckpoint()))).thenThrow(failingException)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyGroupStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyGroupStateHandle).cancel(anyBoolean())__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,key,groups,state,handle,future,key,group,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,key,group,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,when,operator,get,checkpoint,stream,factory,any,checkpoint,options,class,then,return,stream,factory,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,eq,checkpoint,options,for,full,checkpoint,then,throw,failing,exception,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,key,group,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,key,group,state,handle,cancel,any,boolean
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1490724328;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyedStateHandle> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()___		_		_		_		when(operator.getCheckpointStreamFactory(any(CheckpointOptions.class))).thenReturn(streamFactory)___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), eq(CheckpointOptions.forFullCheckpoint()))).thenThrow(failingException)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,when,operator,get,checkpoint,stream,factory,any,checkpoint,options,class,then,return,stream,factory,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,eq,checkpoint,options,for,full,checkpoint,then,throw,failing,exception,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1493195810;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyedStateHandle> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()___		_		_		_		when(operator.getCheckpointStreamFactory(any(CheckpointOptions.class))).thenReturn(streamFactory)___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), eq(CheckpointOptions.forFullCheckpoint()))).thenThrow(failingException)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,when,operator,get,checkpoint,stream,factory,any,checkpoint,options,class,then,return,stream,factory,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,eq,checkpoint,options,for,full,checkpoint,then,throw,failing,exception,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1493821466;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyedStateHandle> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()___		_		_		_		when(operator.getCheckpointStreamFactory(any(CheckpointOptions.class))).thenReturn(streamFactory)___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), eq(CheckpointOptions.forFullCheckpoint()))).thenThrow(failingException)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,when,operator,get,checkpoint,stream,factory,any,checkpoint,options,class,then,return,stream,factory,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,eq,checkpoint,options,for,full,checkpoint,then,throw,failing,exception,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1494598316;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyedStateHandle> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()___		_		_		_		when(operator.getCheckpointStreamFactory(any(CheckpointOptions.class))).thenReturn(streamFactory)___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), eq(CheckpointOptions.forFullCheckpoint()))).thenThrow(failingException)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,when,operator,get,checkpoint,stream,factory,any,checkpoint,options,class,then,return,stream,factory,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,eq,checkpoint,options,for,full,checkpoint,then,throw,failing,exception,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1495484544;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyedStateHandle> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()___		_		_		_		when(operator.getCheckpointStreamFactory(any(CheckpointOptions.class))).thenReturn(streamFactory)___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), eq(CheckpointOptions.forFullCheckpoint()))).thenThrow(failingException)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,when,operator,get,checkpoint,stream,factory,any,checkpoint,options,class,then,return,stream,factory,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,eq,checkpoint,options,for,full,checkpoint,then,throw,failing,exception,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1509118643;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyedStateHandle> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()___		_		_		_		when(operator.getCheckpointStreamFactory(any(CheckpointOptions.class))).thenReturn(streamFactory)___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), eq(CheckpointOptions.forCheckpoint()))).thenThrow(failingException)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,when,operator,get,checkpoint,stream,factory,any,checkpoint,options,class,then,return,stream,factory,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,eq,checkpoint,options,for,checkpoint,then,throw,failing,exception,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1509723634;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyedStateHandle> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()___		_		_		_		when(operator.getCheckpointStreamFactory(any(CheckpointOptions.class))).thenReturn(streamFactory)___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(eq(checkpointId), eq(timestamp), eq(streamFactory), eq(CheckpointOptions.forCheckpoint()))).thenThrow(failingException)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,when,operator,get,checkpoint,stream,factory,any,checkpoint,options,class,then,return,stream,factory,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,eq,checkpoint,options,for,checkpoint,then,throw,failing,exception,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1516626397;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyedStateHandle> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()___		doCallRealMethod().when(operator).close()__		doCallRealMethod().when(operator).dispose()___		_		_		_		when(operator.getCheckpointStreamFactory(any(CheckpointOptions.class))).thenReturn(streamFactory)___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			eq(streamFactory),_			any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			eq(streamFactory),_			eq(CheckpointOptions.forCheckpoint()))).thenThrow(failingException)___		closeableRegistry.registerCloseable(operatorStateBackend)__		closeableRegistry.registerCloseable(keyedStateBackend)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forCheckpoint())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())___		operator.close()___		operator.dispose()___		verify(operatorStateBackend).close()__		verify(keyedStateBackend).close()__		verify(operatorStateBackend).dispose()__		verify(keyedStateBackend).dispose()__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,call,real,method,when,operator,close,do,call,real,method,when,operator,dispose,when,operator,get,checkpoint,stream,factory,any,checkpoint,options,class,then,return,stream,factory,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,eq,checkpoint,options,for,checkpoint,then,throw,failing,exception,closeable,registry,register,closeable,operator,state,backend,closeable,registry,register,closeable,keyed,state,backend,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean,operator,close,operator,dispose,verify,operator,state,backend,close,verify,keyed,state,backend,close,verify,operator,state,backend,dispose,verify,keyed,state,backend,dispose
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1517489695;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyedStateHandle> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()___		doCallRealMethod().when(operator).close()__		doCallRealMethod().when(operator).dispose()___		_		_		_		when(operator.getCheckpointStreamFactory(any(CheckpointOptions.class))).thenReturn(streamFactory)___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			eq(streamFactory),_			any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			eq(streamFactory),_			eq(CheckpointOptions.forCheckpointWithDefaultLocation()))).thenThrow(failingException)___		closeableRegistry.registerCloseable(operatorStateBackend)__		closeableRegistry.registerCloseable(keyedStateBackend)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)__		Whitebox.setInternalState(operator, "checkpointStreamFactory", streamFactory)___		try {_			operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forCheckpointWithDefaultLocation())__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())___		operator.close()___		operator.dispose()___		verify(operatorStateBackend).close()__		verify(keyedStateBackend).close()__		verify(operatorStateBackend).dispose()__		verify(keyedStateBackend).dispose()__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,call,real,method,when,operator,close,do,call,real,method,when,operator,dispose,when,operator,get,checkpoint,stream,factory,any,checkpoint,options,class,then,return,stream,factory,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,eq,checkpoint,options,for,checkpoint,with,default,location,then,throw,failing,exception,closeable,registry,register,closeable,operator,state,backend,closeable,registry,register,closeable,keyed,state,backend,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,whitebox,set,internal,state,operator,checkpoint,stream,factory,stream,factory,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean,operator,close,operator,dispose,verify,operator,state,backend,close,verify,keyed,state,backend,close,verify,operator,state,backend,dispose,verify,keyed,state,backend,dispose
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1517489695;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyedStateHandle> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()___		doCallRealMethod().when(operator).close()__		doCallRealMethod().when(operator).dispose()___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			eq(streamFactory),_			any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			any(CheckpointStreamFactory.class),_			eq(CheckpointOptions.forCheckpointWithDefaultLocation()))).thenThrow(failingException)___		closeableRegistry.registerCloseable(operatorStateBackend)__		closeableRegistry.registerCloseable(keyedStateBackend)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())___		operator.close()___		operator.dispose()___		verify(operatorStateBackend).close()__		verify(keyedStateBackend).close()__		verify(operatorStateBackend).dispose()__		verify(keyedStateBackend).dispose()__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,call,real,method,when,operator,close,do,call,real,method,when,operator,dispose,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,any,checkpoint,stream,factory,class,eq,checkpoint,options,for,checkpoint,with,default,location,then,throw,failing,exception,closeable,registry,register,closeable,operator,state,backend,closeable,registry,register,closeable,keyed,state,backend,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean,operator,close,operator,dispose,verify,operator,state,backend,close,verify,keyed,state,backend,close,verify,operator,state,backend,dispose,verify,keyed,state,backend,dispose
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1519567828;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyedStateHandle> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotResult operatorSnapshotResult = spy(new OperatorSnapshotResult())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotResult.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()___		doCallRealMethod().when(operator).close()__		doCallRealMethod().when(operator).dispose()___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			eq(streamFactory),_			any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			any(CheckpointStreamFactory.class),_			eq(CheckpointOptions.forCheckpointWithDefaultLocation()))).thenThrow(failingException)___		closeableRegistry.registerCloseable(operatorStateBackend)__		closeableRegistry.registerCloseable(keyedStateBackend)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())___		operator.close()___		operator.dispose()___		verify(operatorStateBackend).close()__		verify(keyedStateBackend).close()__		verify(operatorStateBackend).dispose()__		verify(keyedStateBackend).dispose()__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,result,operator,snapshot,result,spy,new,operator,snapshot,result,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,result,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,call,real,method,when,operator,close,do,call,real,method,when,operator,dispose,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,any,checkpoint,stream,factory,class,eq,checkpoint,options,for,checkpoint,with,default,location,then,throw,failing,exception,closeable,registry,register,closeable,operator,state,backend,closeable,registry,register,closeable,keyed,state,backend,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean,operator,close,operator,dispose,verify,operator,state,backend,close,verify,keyed,state,backend,close,verify,operator,state,backend,dispose,verify,keyed,state,backend,dispose
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1519567828;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<KeyedStateHandle> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<OperatorStateHandle> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotFutures operatorSnapshotResult = spy(new OperatorSnapshotFutures())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotFutures.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()___		doCallRealMethod().when(operator).close()__		doCallRealMethod().when(operator).dispose()___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<OperatorStateHandle> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			eq(streamFactory),_			any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			any(CheckpointStreamFactory.class),_			eq(CheckpointOptions.forCheckpointWithDefaultLocation()))).thenThrow(failingException)___		closeableRegistry.registerCloseable(operatorStateBackend)__		closeableRegistry.registerCloseable(keyedStateBackend)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())___		operator.close()___		operator.dispose()___		verify(operatorStateBackend).close()__		verify(keyedStateBackend).close()__		verify(operatorStateBackend).dispose()__		verify(keyedStateBackend).dispose()__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,futures,operator,snapshot,result,spy,new,operator,snapshot,futures,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,futures,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,call,real,method,when,operator,close,do,call,real,method,when,operator,dispose,do,return,containing,task,when,operator,get,containing,task,runnable,future,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,any,checkpoint,stream,factory,class,eq,checkpoint,options,for,checkpoint,with,default,location,then,throw,failing,exception,closeable,registry,register,closeable,operator,state,backend,closeable,registry,register,closeable,keyed,state,backend,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean,operator,close,operator,dispose,verify,operator,state,backend,close,verify,keyed,state,backend,close,verify,operator,state,backend,dispose,verify,keyed,state,backend,dispose
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1519568061;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<SnapshotResult<KeyedStateHandle>> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<SnapshotResult<OperatorStateHandle>> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotFutures operatorSnapshotResult = spy(new OperatorSnapshotFutures())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotFutures.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()___		doCallRealMethod().when(operator).close()__		doCallRealMethod().when(operator).dispose()___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<SnapshotResult<OperatorStateHandle>> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			eq(streamFactory),_			any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			any(CheckpointStreamFactory.class),_			eq(CheckpointOptions.forCheckpointWithDefaultLocation()))).thenThrow(failingException)___		closeableRegistry.registerCloseable(operatorStateBackend)__		closeableRegistry.registerCloseable(keyedStateBackend)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())___		operator.close()___		operator.dispose()___		verify(operatorStateBackend).close()__		verify(keyedStateBackend).close()__		verify(operatorStateBackend).dispose()__		verify(keyedStateBackend).dispose()__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,snapshot,result,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,snapshot,result,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,futures,operator,snapshot,result,spy,new,operator,snapshot,futures,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,futures,class,with,any,arguments,then,return,operator,snapshot,result,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,call,real,method,when,operator,close,do,call,real,method,when,operator,dispose,do,return,containing,task,when,operator,get,containing,task,runnable,future,snapshot,result,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,eq,stream,factory,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,any,checkpoint,stream,factory,class,eq,checkpoint,options,for,checkpoint,with,default,location,then,throw,failing,exception,closeable,registry,register,closeable,operator,state,backend,closeable,registry,register,closeable,keyed,state,backend,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean,operator,close,operator,dispose,verify,operator,state,backend,close,verify,keyed,state,backend,close,verify,operator,state,backend,dispose,verify,keyed,state,backend,dispose
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1526313052;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<SnapshotResult<KeyedStateHandle>> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<SnapshotResult<OperatorStateHandle>> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = spy(new StateSnapshotContextSynchronousImpl(checkpointId, timestamp))__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotFutures operatorSnapshotResult = spy(new OperatorSnapshotFutures())___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		whenNew(OperatorSnapshotFutures.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()___		doCallRealMethod().when(operator).close()__		doCallRealMethod().when(operator).dispose()___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<SnapshotResult<OperatorStateHandle>> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			any(CheckpointStreamFactory.class),_			any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			any(CheckpointStreamFactory.class),_			eq(CheckpointOptions.forCheckpointWithDefaultLocation()))).thenThrow(failingException)___		closeableRegistry.registerCloseable(operatorStateBackend)__		closeableRegistry.registerCloseable(keyedStateBackend)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())___		operator.close()___		operator.dispose()___		verify(operatorStateBackend).close()__		verify(keyedStateBackend).close()__		verify(operatorStateBackend).dispose()__		verify(keyedStateBackend).dispose()__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,snapshot,result,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,snapshot,result,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,spy,new,state,snapshot,context,synchronous,impl,checkpoint,id,timestamp,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,futures,operator,snapshot,result,spy,new,operator,snapshot,futures,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,when,new,operator,snapshot,futures,class,with,any,arguments,then,return,operator,snapshot,result,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,call,real,method,when,operator,close,do,call,real,method,when,operator,dispose,do,return,containing,task,when,operator,get,containing,task,runnable,future,snapshot,result,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,any,checkpoint,stream,factory,class,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,any,checkpoint,stream,factory,class,eq,checkpoint,options,for,checkpoint,with,default,location,then,throw,failing,exception,closeable,registry,register,closeable,operator,state,backend,closeable,registry,register,closeable,keyed,state,backend,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean,operator,close,operator,dispose,verify,operator,state,backend,close,verify,keyed,state,backend,close,verify,operator,state,backend,dispose,verify,keyed,state,backend,dispose
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1538998760;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<SnapshotResult<KeyedStateHandle>> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<SnapshotResult<OperatorStateHandle>> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = spy(new StateSnapshotContextSynchronousImpl(checkpointId, timestamp))__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotFutures operatorSnapshotResult = spy(new OperatorSnapshotFutures())___		whenNew(StateSnapshotContextSynchronousImpl.class)_			.withArguments(_				anyLong(),_				anyLong(),_				any(CheckpointStreamFactory.class),_				nullable(KeyGroupRange.class),_				any(CloseableRegistry.class))_			.thenReturn(context)__		whenNew(OperatorSnapshotFutures.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()___		doCallRealMethod().when(operator).close()__		doCallRealMethod().when(operator).dispose()___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<SnapshotResult<OperatorStateHandle>> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			any(CheckpointStreamFactory.class),_			any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			any(CheckpointStreamFactory.class),_			eq(CheckpointOptions.forCheckpointWithDefaultLocation()))).thenThrow(failingException)___		closeableRegistry.registerCloseable(operatorStateBackend)__		closeableRegistry.registerCloseable(keyedStateBackend)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())___		operator.close()___		operator.dispose()___		verify(operatorStateBackend).close()__		verify(keyedStateBackend).close()__		verify(operatorStateBackend).dispose()__		verify(keyedStateBackend).dispose()__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,snapshot,result,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,snapshot,result,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,spy,new,state,snapshot,context,synchronous,impl,checkpoint,id,timestamp,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,futures,operator,snapshot,result,spy,new,operator,snapshot,futures,when,new,state,snapshot,context,synchronous,impl,class,with,arguments,any,long,any,long,any,checkpoint,stream,factory,class,nullable,key,group,range,class,any,closeable,registry,class,then,return,context,when,new,operator,snapshot,futures,class,with,any,arguments,then,return,operator,snapshot,result,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,call,real,method,when,operator,close,do,call,real,method,when,operator,dispose,do,return,containing,task,when,operator,get,containing,task,runnable,future,snapshot,result,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,any,checkpoint,stream,factory,class,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,any,checkpoint,stream,factory,class,eq,checkpoint,options,for,checkpoint,with,default,location,then,throw,failing,exception,closeable,registry,register,closeable,operator,state,backend,closeable,registry,register,closeable,keyed,state,backend,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean,operator,close,operator,dispose,verify,operator,state,backend,close,verify,keyed,state,backend,close,verify,operator,state,backend,dispose,verify,keyed,state,backend,dispose
AbstractStreamOperatorTest -> @Test 	public void testFailingBackendSnapshotMethod() throws Exception;1550863152;Tests that a failing snapshot method call to the keyed state backend will trigger the closing_of the StateSnapshotContextSynchronousImpl and the cancellation of the_OperatorSnapshotResult. The latter is supposed to also cancel all assigned futures.;@Test_	public void testFailingBackendSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final Exception failingException = new Exception("Test exception")___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		RunnableFuture<SnapshotResult<KeyedStateHandle>> futureKeyedStateHandle = mock(RunnableFuture.class)__		RunnableFuture<SnapshotResult<OperatorStateHandle>> futureOperatorStateHandle = mock(RunnableFuture.class)___		StateSnapshotContextSynchronousImpl context = spy(new StateSnapshotContextSynchronousImpl(checkpointId, timestamp))__		when(context.getKeyedStateStreamFuture()).thenReturn(futureKeyedStateHandle)__		when(context.getOperatorStateStreamFuture()).thenReturn(futureOperatorStateHandle)___		OperatorSnapshotFutures operatorSnapshotResult = spy(new OperatorSnapshotFutures())___		whenNew(StateSnapshotContextSynchronousImpl.class)_			.withArguments(_				anyLong(),_				anyLong(),_				any(CheckpointStreamFactory.class),_				nullable(KeyGroupRange.class),_				any(CloseableRegistry.class))_			.thenReturn(context)__		whenNew(OperatorSnapshotFutures.class).withAnyArguments().thenReturn(operatorSnapshotResult)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()___		doCallRealMethod().when(operator).close()__		doCallRealMethod().when(operator).dispose()___		doReturn(containingTask).when(operator).getContainingTask()___		RunnableFuture<SnapshotResult<OperatorStateHandle>> futureManagedOperatorStateHandle = mock(RunnableFuture.class)___		OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class)__		when(operatorStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			any(CheckpointStreamFactory.class),_			any(CheckpointOptions.class))).thenReturn(futureManagedOperatorStateHandle)___		AbstractKeyedStateBackend<?> keyedStateBackend = mock(AbstractKeyedStateBackend.class)__		when(keyedStateBackend.snapshot(_			eq(checkpointId),_			eq(timestamp),_			any(CheckpointStreamFactory.class),_			eq(CheckpointOptions.forCheckpointWithDefaultLocation()))).thenThrow(failingException)___		closeableRegistry.registerCloseable(operatorStateBackend)__		closeableRegistry.registerCloseable(keyedStateBackend)___		Whitebox.setInternalState(operator, "operatorStateBackend", operatorStateBackend)__		Whitebox.setInternalState(operator, "keyedStateBackend", keyedStateBackend)___		try {_			operator.snapshotState(_					checkpointId,_					timestamp,_					CheckpointOptions.forCheckpointWithDefaultLocation(),_					new MemCheckpointStreamFactory(Integer.MAX_VALUE))__			fail("Exception expected.")__		} catch (Exception e) {_			assertEquals(failingException, e.getCause())__		}__		_		_		verify(context).close()__		verify(operatorSnapshotResult).cancel()___		verify(futureKeyedStateHandle).cancel(anyBoolean())__		verify(futureOperatorStateHandle).cancel(anyBoolean())__		verify(futureKeyedStateHandle).cancel(anyBoolean())___		operator.close()___		operator.dispose()___		verify(operatorStateBackend).close()__		verify(keyedStateBackend).close()__		verify(operatorStateBackend).dispose()__		verify(keyedStateBackend).dispose()__	};tests,that,a,failing,snapshot,method,call,to,the,keyed,state,backend,will,trigger,the,closing,of,the,state,snapshot,context,synchronous,impl,and,the,cancellation,of,the,operator,snapshot,result,the,latter,is,supposed,to,also,cancel,all,assigned,futures;test,public,void,test,failing,backend,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,exception,failing,exception,new,exception,test,exception,final,closeable,registry,closeable,registry,new,closeable,registry,runnable,future,snapshot,result,keyed,state,handle,future,keyed,state,handle,mock,runnable,future,class,runnable,future,snapshot,result,operator,state,handle,future,operator,state,handle,mock,runnable,future,class,state,snapshot,context,synchronous,impl,context,spy,new,state,snapshot,context,synchronous,impl,checkpoint,id,timestamp,when,context,get,keyed,state,stream,future,then,return,future,keyed,state,handle,when,context,get,operator,state,stream,future,then,return,future,operator,state,handle,operator,snapshot,futures,operator,snapshot,result,spy,new,operator,snapshot,futures,when,new,state,snapshot,context,synchronous,impl,class,with,arguments,any,long,any,long,any,checkpoint,stream,factory,class,nullable,key,group,range,class,any,closeable,registry,class,then,return,context,when,new,operator,snapshot,futures,class,with,any,arguments,then,return,operator,snapshot,result,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,call,real,method,when,operator,close,do,call,real,method,when,operator,dispose,do,return,containing,task,when,operator,get,containing,task,runnable,future,snapshot,result,operator,state,handle,future,managed,operator,state,handle,mock,runnable,future,class,operator,state,backend,operator,state,backend,mock,operator,state,backend,class,when,operator,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,any,checkpoint,stream,factory,class,any,checkpoint,options,class,then,return,future,managed,operator,state,handle,abstract,keyed,state,backend,keyed,state,backend,mock,abstract,keyed,state,backend,class,when,keyed,state,backend,snapshot,eq,checkpoint,id,eq,timestamp,any,checkpoint,stream,factory,class,eq,checkpoint,options,for,checkpoint,with,default,location,then,throw,failing,exception,closeable,registry,register,closeable,operator,state,backend,closeable,registry,register,closeable,keyed,state,backend,whitebox,set,internal,state,operator,operator,state,backend,operator,state,backend,whitebox,set,internal,state,operator,keyed,state,backend,keyed,state,backend,try,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,fail,exception,expected,catch,exception,e,assert,equals,failing,exception,e,get,cause,verify,context,close,verify,operator,snapshot,result,cancel,verify,future,keyed,state,handle,cancel,any,boolean,verify,future,operator,state,handle,cancel,any,boolean,verify,future,keyed,state,handle,cancel,any,boolean,operator,close,operator,dispose,verify,operator,state,backend,close,verify,keyed,state,backend,close,verify,operator,state,backend,dispose,verify,keyed,state,backend,dispose
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1477517189;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1478251480;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1478532357;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1483982056;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1484303457;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1485189169;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1487167701;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1487871589;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1488305067;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1489422543;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1490724328;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1493195810;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1493821466;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1494598316;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1495484544;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1509118643;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1509723634;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1516626397;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1517489695;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1517489695;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1519567828;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1519567828;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1519568061;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1526313052;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1538998760;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness);1550863152;Extracts the result values form the test harness and clear the output queue.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {_		List<StreamRecord<? extends T>> streamRecords = testHarness.extractOutputStreamRecords()__		List<T> result = new ArrayList<>()__		for (Object in : streamRecords) {_			if (in instanceof StreamRecord) {_				result.add((T) ((StreamRecord) in).getValue())__			}_		}_		testHarness.getOutput().clear()__		return result__	};extracts,the,result,values,form,the,test,harness,and,clear,the,output,queue;suppress,warnings,unchecked,rawtypes,private,t,list,t,extract,result,one,input,stream,operator,test,harness,t,test,harness,list,stream,record,extends,t,stream,records,test,harness,extract,output,stream,records,list,t,result,new,array,list,for,object,in,stream,records,if,in,instanceof,stream,record,result,add,t,stream,record,in,get,value,test,harness,get,output,clear,return,result
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1485189169;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		CheckpointStreamFactory streamFactory = mock(CheckpointStreamFactory.class)__		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, streamFactory)___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,checkpoint,stream,factory,stream,factory,mock,checkpoint,stream,factory,class,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,stream,factory,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1487167701;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		_		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong())).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp)___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1487871589;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		_		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1488305067;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		_		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1489422543;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		_		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1490724328;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)__		_		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1493195810;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1493821466;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1494598316;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1495484544;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forFullCheckpoint())___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,full,checkpoint,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1509118643;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forCheckpoint())___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1509723634;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forCheckpoint())___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1516626397;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forCheckpoint())___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1517489695;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(checkpointId, timestamp, CheckpointOptions.forCheckpointWithDefaultLocation())___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1517489695;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(_				checkpointId,_				timestamp,_				CheckpointOptions.forCheckpointWithDefaultLocation(),_				new MemCheckpointStreamFactory(Integer.MAX_VALUE))___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1519567828;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(_				checkpointId,_				timestamp,_				CheckpointOptions.forCheckpointWithDefaultLocation(),_				new MemCheckpointStreamFactory(Integer.MAX_VALUE))___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1519567828;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(_				checkpointId,_				timestamp,_				CheckpointOptions.forCheckpointWithDefaultLocation(),_				new MemCheckpointStreamFactory(Integer.MAX_VALUE))___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1519568061;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = mock(StateSnapshotContextSynchronousImpl.class)___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(_				checkpointId,_				timestamp,_				CheckpointOptions.forCheckpointWithDefaultLocation(),_				new MemCheckpointStreamFactory(Integer.MAX_VALUE))___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,mock,state,snapshot,context,synchronous,impl,class,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1526313052;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = spy(new StateSnapshotContextSynchronousImpl(0L, 0L))___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(_				checkpointId,_				timestamp,_				CheckpointOptions.forCheckpointWithDefaultLocation(),_				new MemCheckpointStreamFactory(Integer.MAX_VALUE))___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,spy,new,state,snapshot,context,synchronous,impl,0l,0l,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1538998760;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = spy(new StateSnapshotContextSynchronousImpl(0L, 0L))___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(_				checkpointId,_				timestamp,_				CheckpointOptions.forCheckpointWithDefaultLocation(),_				new MemCheckpointStreamFactory(Integer.MAX_VALUE))___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,spy,new,state,snapshot,context,synchronous,impl,0l,0l,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testSnapshotMethod() throws Exception;1550863152;Checks that the state snapshot context is closed after a successful snapshot operation.;@Test_	public void testSnapshotMethod() throws Exception {_		final long checkpointId = 42L__		final long timestamp = 1L___		final CloseableRegistry closeableRegistry = new CloseableRegistry()___		StateSnapshotContextSynchronousImpl context = spy(new StateSnapshotContextSynchronousImpl(0L, 0L))___		whenNew(StateSnapshotContextSynchronousImpl.class).withAnyArguments().thenReturn(context)___		StreamTask<Void, AbstractStreamOperator<Void>> containingTask = mock(StreamTask.class)__		when(containingTask.getCancelables()).thenReturn(closeableRegistry)___		AbstractStreamOperator<Void> operator = mock(AbstractStreamOperator.class)__		when(operator.snapshotState(anyLong(), anyLong(), any(CheckpointOptions.class), any(CheckpointStreamFactory.class))).thenCallRealMethod()__		doReturn(containingTask).when(operator).getContainingTask()___		operator.snapshotState(_				checkpointId,_				timestamp,_				CheckpointOptions.forCheckpointWithDefaultLocation(),_				new MemCheckpointStreamFactory(Integer.MAX_VALUE))___		verify(context).close()__	};checks,that,the,state,snapshot,context,is,closed,after,a,successful,snapshot,operation;test,public,void,test,snapshot,method,throws,exception,final,long,checkpoint,id,42l,final,long,timestamp,1l,final,closeable,registry,closeable,registry,new,closeable,registry,state,snapshot,context,synchronous,impl,context,spy,new,state,snapshot,context,synchronous,impl,0l,0l,when,new,state,snapshot,context,synchronous,impl,class,with,any,arguments,then,return,context,stream,task,void,abstract,stream,operator,void,containing,task,mock,stream,task,class,when,containing,task,get,cancelables,then,return,closeable,registry,abstract,stream,operator,void,operator,mock,abstract,stream,operator,class,when,operator,snapshot,state,any,long,any,long,any,checkpoint,options,class,any,checkpoint,stream,factory,class,then,call,real,method,do,return,containing,task,when,operator,get,containing,task,operator,snapshot,state,checkpoint,id,timestamp,checkpoint,options,for,checkpoint,with,default,location,new,mem,checkpoint,stream,factory,integer,verify,context,close
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1478251480;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1478532357;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1483982056;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1484303457;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1485189169;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1487167701;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1487871589;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1488305067;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1489422543;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1490724328;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1493195810;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1493821466;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1494598316;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int MAX_PARALLELISM = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (MAX_PARALLELISM / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, MAX_PARALLELISM - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, MAX_PARALLELISM)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, MAX_PARALLELISM)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						MAX_PARALLELISM,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,10,key,group,range,sub,key,group,range1,new,key,group,range,0,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,int,key2,get,key,in,key,group,range,sub,key,group,range2,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1495484544;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int maxParallelism = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (maxParallelism / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, maxParallelism - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, maxParallelism)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, maxParallelism)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,max,parallelism,10,key,group,range,sub,key,group,range1,new,key,group,range,0,max,parallelism,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,max,parallelism,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,max,parallelism,int,key2,get,key,in,key,group,range,sub,key,group,range2,max,parallelism,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,max,parallelism,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,max,parallelism,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,max,parallelism,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1509118643;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int maxParallelism = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (maxParallelism / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, maxParallelism - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, maxParallelism)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, maxParallelism)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,max,parallelism,10,key,group,range,sub,key,group,range1,new,key,group,range,0,max,parallelism,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,max,parallelism,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,max,parallelism,int,key2,get,key,in,key,group,range,sub,key,group,range2,max,parallelism,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,max,parallelism,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,max,parallelism,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,max,parallelism,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1509723634;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int maxParallelism = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (maxParallelism / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, maxParallelism - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, maxParallelism)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, maxParallelism)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,max,parallelism,10,key,group,range,sub,key,group,range1,new,key,group,range,0,max,parallelism,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,max,parallelism,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,max,parallelism,int,key2,get,key,in,key,group,range,sub,key,group,range2,max,parallelism,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,max,parallelism,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,max,parallelism,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,max,parallelism,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1516626397;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int maxParallelism = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (maxParallelism / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, maxParallelism - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, maxParallelism)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, maxParallelism)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,max,parallelism,10,key,group,range,sub,key,group,range1,new,key,group,range,0,max,parallelism,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,max,parallelism,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,max,parallelism,int,key2,get,key,in,key,group,range,sub,key,group,range2,max,parallelism,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,max,parallelism,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,max,parallelism,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,max,parallelism,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1517489695;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int maxParallelism = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (maxParallelism / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, maxParallelism - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, maxParallelism)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, maxParallelism)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,max,parallelism,10,key,group,range,sub,key,group,range1,new,key,group,range,0,max,parallelism,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,max,parallelism,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,max,parallelism,int,key2,get,key,in,key,group,range,sub,key,group,range2,max,parallelism,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,max,parallelism,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,max,parallelism,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,max,parallelism,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1517489695;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int maxParallelism = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (maxParallelism / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, maxParallelism - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, maxParallelism)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, maxParallelism)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,max,parallelism,10,key,group,range,sub,key,group,range1,new,key,group,range,0,max,parallelism,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,max,parallelism,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,max,parallelism,int,key2,get,key,in,key,group,range,sub,key,group,range2,max,parallelism,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,max,parallelism,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,max,parallelism,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,max,parallelism,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1519567828;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int maxParallelism = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (maxParallelism / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, maxParallelism - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, maxParallelism)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, maxParallelism)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorSubtaskState snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,max,parallelism,10,key,group,range,sub,key,group,range1,new,key,group,range,0,max,parallelism,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,max,parallelism,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,max,parallelism,int,key2,get,key,in,key,group,range,sub,key,group,range2,max,parallelism,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,max,parallelism,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,subtask,state,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,max,parallelism,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,max,parallelism,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1519567828;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int maxParallelism = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (maxParallelism / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, maxParallelism - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, maxParallelism)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, maxParallelism)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorSubtaskState snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,max,parallelism,10,key,group,range,sub,key,group,range1,new,key,group,range,0,max,parallelism,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,max,parallelism,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,max,parallelism,int,key2,get,key,in,key,group,range,sub,key,group,range2,max,parallelism,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,max,parallelism,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,subtask,state,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,max,parallelism,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,max,parallelism,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1519568061;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int maxParallelism = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (maxParallelism / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, maxParallelism - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, maxParallelism)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, maxParallelism)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorSubtaskState snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,max,parallelism,10,key,group,range,sub,key,group,range1,new,key,group,range,0,max,parallelism,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,max,parallelism,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,max,parallelism,int,key2,get,key,in,key,group,range,sub,key,group,range2,max,parallelism,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,max,parallelism,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,subtask,state,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,max,parallelism,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,max,parallelism,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1526313052;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int maxParallelism = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (maxParallelism / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, maxParallelism - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, maxParallelism)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, maxParallelism)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorSubtaskState snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,max,parallelism,10,key,group,range,sub,key,group,range1,new,key,group,range,0,max,parallelism,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,max,parallelism,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,max,parallelism,int,key2,get,key,in,key,group,range,sub,key,group,range2,max,parallelism,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,max,parallelism,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,subtask,state,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,max,parallelism,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,max,parallelism,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1538998760;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int maxParallelism = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (maxParallelism / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, maxParallelism - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, maxParallelism)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, maxParallelism)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorSubtaskState snapshot = testHarness.snapshot(0, 0)___		__		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(snapshot)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,max,parallelism,10,key,group,range,sub,key,group,range1,new,key,group,range,0,max,parallelism,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,max,parallelism,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,max,parallelism,int,key2,get,key,in,key,group,range,sub,key,group,range2,max,parallelism,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,max,parallelism,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,subtask,state,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,max,parallelism,2,0,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,max,parallelism,2,1,test,harness2,setup,test,harness2,initialize,state,snapshot,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testStateAndTimerStateShufflingScalingUp() throws Exception;1550863152;Verify that state and timers are checkpointed per key group and that they are correctly_assigned to operator subtasks when restoring.;@Test_	public void testStateAndTimerStateShufflingScalingUp() throws Exception {_		final int maxParallelism = 10___		_		__		_		KeyGroupRange subKeyGroupRange1 = new KeyGroupRange(0, (maxParallelism / 2) - 1)__		KeyGroupRange subKeyGroupRange2 = new KeyGroupRange(subKeyGroupRange1.getEndKeyGroup() + 1, maxParallelism - 1)___		_		int key1 = getKeyInKeyGroupRange(subKeyGroupRange1, maxParallelism)__		int key2 = getKeyInKeyGroupRange(subKeyGroupRange2, maxParallelism)___		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						1, _						0 )___		testHarness.open()___		testHarness.processWatermark(0L)__		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(key1, "SET_EVENT_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_EVENT_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_PROC_TIME_TIMER:10"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(key1, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(key2, "SET_STATE:CIAO"), 0)___		assertTrue(extractResult(testHarness).isEmpty())___		OperatorSubtaskState snapshot = testHarness.snapshot(0, 0)___		_		OperatorSubtaskState initState1 = AbstractStreamOperatorTestHarness.repartitionOperatorState(_			snapshot, maxParallelism, 1, 2, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						0 )___		testHarness1.setup()__		testHarness1.initializeState(initState1)__		testHarness1.open()___		testHarness1.processWatermark(10L)___		assertThat(extractResult(testHarness1), contains("ON_EVENT_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.processWatermark(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		testHarness1.setProcessingTime(10L)___		assertThat(extractResult(testHarness1), contains("ON_PROC_TIME:HELLO"))___		assertTrue(extractResult(testHarness1).isEmpty())___		_		_		testHarness1.setProcessingTime(20L)___		assertTrue(extractResult(testHarness1).isEmpty())___		_		OperatorSubtaskState initState2 = AbstractStreamOperatorTestHarness.repartitionOperatorState(_			snapshot, maxParallelism, 1, 2, 1)___		TestOperator testOperator2 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness2 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator2,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO,_						maxParallelism,_						2, _						1 )___		testHarness2.setup()__		testHarness2.initializeState(initState2)__		testHarness2.open()___		testHarness2.processWatermark(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.processWatermark(20L)___		assertThat(extractResult(testHarness2), contains("ON_EVENT_TIME:CIAO"))___		testHarness2.setProcessingTime(10L)___		_		assertTrue(extractResult(testHarness2).isEmpty())___		testHarness2.setProcessingTime(20L)___		assertThat(extractResult(testHarness2), contains("ON_PROC_TIME:CIAO"))___		assertTrue(extractResult(testHarness2).isEmpty())__	};verify,that,state,and,timers,are,checkpointed,per,key,group,and,that,they,are,correctly,assigned,to,operator,subtasks,when,restoring;test,public,void,test,state,and,timer,state,shuffling,scaling,up,throws,exception,final,int,max,parallelism,10,key,group,range,sub,key,group,range1,new,key,group,range,0,max,parallelism,2,1,key,group,range,sub,key,group,range2,new,key,group,range,sub,key,group,range1,get,end,key,group,1,max,parallelism,1,int,key1,get,key,in,key,group,range,sub,key,group,range1,max,parallelism,int,key2,get,key,in,key,group,range,sub,key,group,range2,max,parallelism,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,max,parallelism,1,0,test,harness,open,test,harness,process,watermark,0l,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,10,0,test,harness,process,element,new,tuple2,key2,20,0,test,harness,process,element,new,tuple2,key1,hello,0,test,harness,process,element,new,tuple2,key2,ciao,0,assert,true,extract,result,test,harness,is,empty,operator,subtask,state,snapshot,test,harness,snapshot,0,0,operator,subtask,state,init,state1,abstract,stream,operator,test,harness,repartition,operator,state,snapshot,max,parallelism,1,2,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,max,parallelism,2,0,test,harness1,setup,test,harness1,initialize,state,init,state1,test,harness1,open,test,harness1,process,watermark,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,process,watermark,20l,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,assert,true,extract,result,test,harness1,is,empty,test,harness1,set,processing,time,20l,assert,true,extract,result,test,harness1,is,empty,operator,subtask,state,init,state2,abstract,stream,operator,test,harness,repartition,operator,state,snapshot,max,parallelism,1,2,1,test,operator,test,operator2,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness2,new,keyed,one,input,stream,operator,test,harness,test,operator2,new,test,key,selector,basic,type,info,max,parallelism,2,1,test,harness2,setup,test,harness2,initialize,state,init,state2,test,harness2,open,test,harness2,process,watermark,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,process,watermark,20l,assert,that,extract,result,test,harness2,contains,ciao,test,harness2,set,processing,time,10l,assert,true,extract,result,test,harness2,is,empty,test,harness2,set,processing,time,20l,assert,that,extract,result,test,harness2,contains,ciao,assert,true,extract,result,test,harness2,is,empty
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1483982056;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1484303457;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1485189169;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1487167701;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1487871589;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1488305067;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1489422543;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1490724328;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1493195810;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1493821466;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1494598316;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1495484544;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1509118643;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1509723634;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1516626397;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1517489695;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1517489695;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorStateHandles snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,state,handles,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1519567828;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorSubtaskState snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,subtask,state,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1519567828;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorSubtaskState snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,subtask,state,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1519568061;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorSubtaskState snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,subtask,state,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1526313052;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorSubtaskState snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,subtask,state,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1538998760;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorSubtaskState snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,subtask,state,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
AbstractStreamOperatorTest -> @Test 	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception;1550863152;Verify that a low-level timer is set for processing-time timers in case of restore.;@Test_	public void testEnsureProcessingTimeTimerRegisteredOnRestore() throws Exception {_		TestOperator testOperator = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(testOperator, new TestKeySelector(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.open()___		testHarness.setProcessingTime(0L)___		testHarness.processElement(new Tuple2<>(1, "SET_PROC_TIME_TIMER:20"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_STATE:HELLO"), 0)__		testHarness.processElement(new Tuple2<>(1, "SET_STATE:CIAO"), 0)___		testHarness.processElement(new Tuple2<>(0, "SET_PROC_TIME_TIMER:10"), 0)___		OperatorSubtaskState snapshot = testHarness.snapshot(0, 0)___		TestOperator testOperator1 = new TestOperator()___		KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> testHarness1 =_				new KeyedOneInputStreamOperatorTestHarness<>(_						testOperator1,_						new TestKeySelector(),_						BasicTypeInfo.INT_TYPE_INFO)___		testHarness1.setProcessingTime(0L)___		testHarness1.setup()__		testHarness1.initializeState(snapshot)__		testHarness1.open()___		testHarness1.setProcessingTime(10L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:HELLO"))___		testHarness1.setProcessingTime(20L)___		assertThat(_				extractResult(testHarness1),_				contains("ON_PROC_TIME:CIAO"))__	};verify,that,a,low,level,timer,is,set,for,processing,time,timers,in,case,of,restore;test,public,void,test,ensure,processing,time,timer,registered,on,restore,throws,exception,test,operator,test,operator,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness,new,keyed,one,input,stream,operator,test,harness,test,operator,new,test,key,selector,basic,type,info,test,harness,open,test,harness,set,processing,time,0l,test,harness,process,element,new,tuple2,1,20,0,test,harness,process,element,new,tuple2,0,hello,0,test,harness,process,element,new,tuple2,1,ciao,0,test,harness,process,element,new,tuple2,0,10,0,operator,subtask,state,snapshot,test,harness,snapshot,0,0,test,operator,test,operator1,new,test,operator,keyed,one,input,stream,operator,test,harness,integer,tuple2,integer,string,string,test,harness1,new,keyed,one,input,stream,operator,test,harness,test,operator1,new,test,key,selector,basic,type,info,test,harness1,set,processing,time,0l,test,harness1,setup,test,harness1,initialize,state,snapshot,test,harness1,open,test,harness1,set,processing,time,10l,assert,that,extract,result,test,harness1,contains,hello,test,harness1,set,processing,time,20l,assert,that,extract,result,test,harness1,contains,ciao
