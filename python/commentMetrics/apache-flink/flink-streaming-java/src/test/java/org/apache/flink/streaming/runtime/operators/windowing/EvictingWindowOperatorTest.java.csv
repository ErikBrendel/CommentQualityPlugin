commented;modifiers;parameterAmount;loc;comment;code
true;public;0;69;/**  * Tests CountEvictor evictAfter behavior.  */ ;/**  * Tests CountEvictor evictAfter behavior.  */ @Test public void testCountEvictorEvictAfter() throws Exception {     AtomicInteger closeCalled = new AtomicInteger(0).     final int windowSize = 4.     final int triggerCount = 2.     final boolean evictAfter = true.     @SuppressWarnings({ "unchecked", "rawtypes" })     TypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer = (TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     ListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>("window-contents", streamRecordSerializer).     EvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(GlobalWindows.create(), new GlobalWindow.Serializer(), new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)), CountTrigger.of(triggerCount), CountEvictor.of(windowSize, evictAfter), 0, null).     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO).     long initialTime = 0L.     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     testHarness.open().     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 3000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 3999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 20)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1998)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1000)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 2), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 4), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 2), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 10999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1000)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 4), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 6), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1000)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 6), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.close().     Assert.assertEquals("Close was not called.", 1, closeCalled.get()). }
true;public;0;63;/**  * Tests TimeEvictor evictAfter behavior.  */ ;/**  * Tests TimeEvictor evictAfter behavior.  */ @Test public void testTimeEvictorEvictAfter() throws Exception {     AtomicInteger closeCalled = new AtomicInteger(0).     final int triggerCount = 2.     final boolean evictAfter = true.     @SuppressWarnings({ "unchecked", "rawtypes" })     TypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer = (TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     ListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>("window-contents", streamRecordSerializer).     EvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(GlobalWindows.create(), new GlobalWindow.Serializer(), new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)), CountTrigger.of(triggerCount), TimeEvictor.of(Time.seconds(2), evictAfter), 0, null).     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO).     long initialTime = 0L.     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     testHarness.open().     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 4000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 20)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 3500)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 2001)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1001)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 2), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 2), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 3), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 10999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1002)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 4), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 5), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.close().     Assert.assertEquals("Close was not called.", 1, closeCalled.get()). }
true;public;0;63;/**  * Tests TimeEvictor evictBefore behavior.  */ ;/**  * Tests TimeEvictor evictBefore behavior.  */ @Test public void testTimeEvictorEvictBefore() throws Exception {     AtomicInteger closeCalled = new AtomicInteger(0).     final int triggerCount = 2.     final int windowSize = 4.     @SuppressWarnings({ "unchecked", "rawtypes" })     TypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer = (TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     ListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>("window-contents", streamRecordSerializer).     EvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new EvictingWindowOperator<>(TumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)), new TimeWindow.Serializer(), new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new RichSumReducer<TimeWindow>(closeCalled)), CountTrigger.of(triggerCount), TimeEvictor.of(Time.seconds(2)), 0, null).     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO).     long initialTime = 0L.     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     testHarness.open().     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 3999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 20)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 5999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 3500)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 2001)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1001)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 1), 3999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 2), 3999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 3), 3999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 6500)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1002)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 2), 7999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 3), 3999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.close().     Assert.assertEquals("Close was not called.", 1, closeCalled.get()). }
true;public;0;61;/**  * Tests time evictor, if no timestamp information in the StreamRecord.  * No element will be evicted from the window.  */ ;/**  * Tests time evictor, if no timestamp information in the StreamRecord.  * No element will be evicted from the window.  */ @Test public void testTimeEvictorNoTimestamp() throws Exception {     AtomicInteger closeCalled = new AtomicInteger(0).     final int triggerCount = 2.     final boolean evictAfter = true.     @SuppressWarnings({ "unchecked", "rawtypes" })     TypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer = (TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     ListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>("window-contents", streamRecordSerializer).     EvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(GlobalWindows.create(), new GlobalWindow.Serializer(), new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)), CountTrigger.of(triggerCount), TimeEvictor.of(Time.seconds(2), evictAfter), 0, null).     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     testHarness.open().     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1))).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 2), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 2), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 4), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1))).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1))).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 4), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 6), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.close().     Assert.assertEquals("Close was not called.", 1, closeCalled.get()). }
false;public;2;4;;@Override public double getDelta(Tuple2<String, Integer> oldDataPoint, Tuple2<String, Integer> newDataPoint) {     return newDataPoint.f1 - oldDataPoint.f1. }
true;public;0;68;/**  * Tests DeltaEvictor, evictBefore behavior.  */ ;/**  * Tests DeltaEvictor, evictBefore behavior.  */ @Test public void testDeltaEvictorEvictBefore() throws Exception {     AtomicInteger closeCalled = new AtomicInteger(0).     final int triggerCount = 2.     final boolean evictAfter = false.     final int threshold = 2.     @SuppressWarnings({ "unchecked", "rawtypes" })     TypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer = (TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     ListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>("window-contents", streamRecordSerializer).     EvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(GlobalWindows.create(), new GlobalWindow.Serializer(), new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)), CountTrigger.of(triggerCount), DeltaEvictor.of(threshold, new DeltaFunction<Tuple2<String, Integer>>() {          @Override         public double getDelta(Tuple2<String, Integer> oldDataPoint, Tuple2<String, Integer> newDataPoint) {             return newDataPoint.f1 - oldDataPoint.f1.         }     }, evictAfter), 0, null).     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO).     long initialTime = 0L.     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     testHarness.open().     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 3000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 4), initialTime + 3999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 20)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 5), initialTime + 999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 5), initialTime + 1998)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 6), initialTime + 1999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1000)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 4), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 11), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 2), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 3), initialTime + 10999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 10), initialTime + 1000)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 8), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 10), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.close().     Assert.assertEquals("Close was not called.", 1, closeCalled.get()). }
false;public;2;4;;@Override public double getDelta(Tuple2<String, Integer> oldDataPoint, Tuple2<String, Integer> newDataPoint) {     return newDataPoint.f1 - oldDataPoint.f1. }
true;public;0;68;/**  * Tests DeltaEvictor, evictAfter behavior.  */ ;/**  * Tests DeltaEvictor, evictAfter behavior.  */ @Test public void testDeltaEvictorEvictAfter() throws Exception {     AtomicInteger closeCalled = new AtomicInteger(0).     final int triggerCount = 2.     final boolean evictAfter = true.     final int threshold = 2.     @SuppressWarnings({ "unchecked", "rawtypes" })     TypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer = (TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     ListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>("window-contents", streamRecordSerializer).     EvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(GlobalWindows.create(), new GlobalWindow.Serializer(), new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)), CountTrigger.of(triggerCount), DeltaEvictor.of(threshold, new DeltaFunction<Tuple2<String, Integer>>() {          @Override         public double getDelta(Tuple2<String, Integer> oldDataPoint, Tuple2<String, Integer> newDataPoint) {             return newDataPoint.f1 - oldDataPoint.f1.         }     }, evictAfter), 0, null).     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO).     long initialTime = 0L.     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     testHarness.open().     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 3000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 4), initialTime + 3999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 20)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 5), initialTime + 999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 5), initialTime + 1998)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 6), initialTime + 1999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1000)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 5), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 15), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 2), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 9), initialTime + 10999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 10), initialTime + 1000)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 16), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 22), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.close().     Assert.assertEquals("Close was not called.", 1, closeCalled.get()). }
false;public;0;68;;@Test @SuppressWarnings("unchecked") public void testCountTrigger() throws Exception {     final int windowSize = 4.     final int windowSlide = 2.     @SuppressWarnings({ "unchecked", "rawtypes" })     TypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer = (TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     ListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>("window-contents", streamRecordSerializer).     EvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(GlobalWindows.create(), new GlobalWindow.Serializer(), new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new ReduceApplyWindowFunction<>(new SumReducer(), // on some versions of Java we seem to need the explicit type     new PassThroughWindowFunction<String, GlobalWindow, Tuple2<String, Integer>>())), CountTrigger.of(windowSlide), CountEvictor.of(windowSize), 0, null).     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO).     long initialTime = 0L.     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     testHarness.open().     // The global window actually ignores these timestamps...     // add elements out-of-order     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 3000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 3999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 20)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1998)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1000)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 2), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 4), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 2), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 10999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1000)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 4), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 4), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.close(). }
false;public;0;67;;@Test @SuppressWarnings("unchecked") public void testCountTriggerWithApply() throws Exception {     AtomicInteger closeCalled = new AtomicInteger(0).     final int windowSize = 4.     final int windowSlide = 2.     @SuppressWarnings({ "unchecked", "rawtypes" })     TypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer = (TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     ListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>("window-contents", streamRecordSerializer).     EvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, GlobalWindow> operator = new EvictingWindowOperator<>(GlobalWindows.create(), new GlobalWindow.Serializer(), new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new RichSumReducer<GlobalWindow>(closeCalled)), CountTrigger.of(windowSlide), CountEvictor.of(windowSize), 0, null).     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO).     long initialTime = 0L.     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     testHarness.open().     // The global window actually ignores these timestamps...     // add elements out-of-order     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 3000)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 3999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 20)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1998)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1000)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 2), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 4), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 2), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 10999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 1000)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 4), Long.MAX_VALUE)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 4), Long.MAX_VALUE)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new ResultSortComparator()).     testHarness.close().     Assert.assertEquals("Close was not called.", 1, closeCalled.get()). }
false;public;0;59;;@Test @SuppressWarnings("unchecked") public void testTumblingWindowWithApply() throws Exception {     AtomicInteger closeCalled = new AtomicInteger(0).     final int windowSize = 4.     @SuppressWarnings({ "unchecked", "rawtypes" })     TypeSerializer<StreamRecord<Tuple2<String, Integer>>> streamRecordSerializer = (TypeSerializer<StreamRecord<Tuple2<String, Integer>>>) new StreamElementSerializer(STRING_INT_TUPLE.createSerializer(new ExecutionConfig())).     ListStateDescriptor<StreamRecord<Tuple2<String, Integer>>> stateDesc = new ListStateDescriptor<>("window-contents", streamRecordSerializer).     EvictingWindowOperator<String, Tuple2<String, Integer>, Tuple2<String, Integer>, TimeWindow> operator = new EvictingWindowOperator<>(TumblingEventTimeWindows.of(Time.of(windowSize, TimeUnit.SECONDS)), new TimeWindow.Serializer(), new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()), stateDesc, new InternalIterableWindowFunction<>(new RichSumReducer<TimeWindow>(closeCalled)), EventTimeTrigger.create(), CountEvictor.of(windowSize), 0, null).     OneInputStreamOperatorTestHarness<Tuple2<String, Integer>, Tuple2<String, Integer>> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, new TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO).     long initialTime = 0L.     testHarness.open().     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 10)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 100)).     testHarness.processWatermark(new Watermark(1999)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 1997)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 1998)).     // not late but more than 4     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 2310)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key1", 1), initialTime + 2310)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 2310)).     testHarness.processElement(new StreamRecord<>(new Tuple2<>("key2", 1), initialTime + 2310)).     // now is the evictor     testHarness.processWatermark(new Watermark(3999)).     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     expectedOutput.add(new Watermark(1999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key1", 4), 3999)).     expectedOutput.add(new StreamRecord<>(new Tuple2<>("key2", 2), 3999)).     expectedOutput.add(new Watermark(3999)).     TestHarnessUtil.assertOutputEqualsSorted("Output was not correct.", expectedOutput, testHarness.getOutput(), new EvictingWindowOperatorTest.ResultSortComparator()).     testHarness.close(). }
false;public;2;5;;@Override public Tuple2<String, Integer> reduce(Tuple2<String, Integer> value1, Tuple2<String, Integer> value2) throws Exception {     return new Tuple2<>(value2.f0, value1.f1 + value2.f1). }
false;public;1;5;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     openCalled = true. }
false;public;0;5;;@Override public void close() throws Exception {     super.close().     closeCalled.incrementAndGet(). }
false;public;4;18;;@Override public void apply(String key, W window, Iterable<Tuple2<String, Integer>> input, Collector<Tuple2<String, Integer>> out) throws Exception {     if (!openCalled) {         Assert.fail("Open was not called").     }     int sum = 0.     for (Tuple2<String, Integer> t : input) {         sum += t.f1.     }     out.collect(new Tuple2<>(key, sum)). }
false;public;2;18;;@Override public int compare(Object o1, Object o2) {     if (o1 instanceof Watermark || o2 instanceof Watermark) {         return 0.     } else {         StreamRecord<Tuple2<String, Integer>> sr0 = (StreamRecord<Tuple2<String, Integer>>) o1.         StreamRecord<Tuple2<String, Integer>> sr1 = (StreamRecord<Tuple2<String, Integer>>) o2.         if (sr0.getTimestamp() != sr1.getTimestamp()) {             return (int) (sr0.getTimestamp() - sr1.getTimestamp()).         }         int comparison = sr0.getValue().f0.compareTo(sr1.getValue().f0).         if (comparison != 0) {             return comparison.         } else {             return sr0.getValue().f1 - sr1.getValue().f1.         }     } }
false;public;1;4;;@Override public String getKey(Tuple2<String, Integer> value) throws Exception {     return value.f0. }
