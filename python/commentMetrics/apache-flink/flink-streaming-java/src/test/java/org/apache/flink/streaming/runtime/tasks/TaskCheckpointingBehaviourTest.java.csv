commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test public void testDeclineOnCheckpointErrorInSyncPart() throws Exception {     runTestDeclineOnCheckpointError(new SyncFailureInducingStateBackend()). }
false;public;0;4;;@Test public void testDeclineOnCheckpointErrorInAsyncPart() throws Exception {     runTestDeclineOnCheckpointError(new AsyncFailureInducingStateBackend()). }
false;public;0;8;;@Test public void testTaskFailingOnCheckpointErrorInSyncPart() throws Exception {     Throwable failureCause = runTestTaskFailingOnCheckpointError(new SyncFailureInducingStateBackend()).     assertNotNull(failureCause).     String expectedMessageStart = "Could not perform checkpoint".     assertEquals(expectedMessageStart, failureCause.getMessage().substring(0, expectedMessageStart.length())). }
false;public;0;5;;@Test public void testTaskFailingOnCheckpointErrorInAsyncPart() throws Exception {     Throwable failureCause = runTestTaskFailingOnCheckpointError(new AsyncFailureInducingStateBackend()).     assertEquals(AsynchronousException.class, failureCause.getClass()). }
false;public;0;20;;@Test public void testBlockingNonInterruptibleCheckpoint() throws Exception {     StateBackend lockingStateBackend = new BackendForTestStream(LockingOutputStream::new).     Task task = createTask(new TestOperator(), lockingStateBackend, mock(CheckpointResponder.class), true).     // start the task and wait until it is in "restore"     task.startTaskThread().     IN_CHECKPOINT_LATCH.await().     // cancel the task and wait. unless cancellation properly closes     // the streams, this will never terminate     task.cancelExecution().     task.getExecutingThread().join().     assertEquals(ExecutionState.CANCELED, task.getExecutionState()).     assertNull(task.getFailureCause()). }
false;private;1;17;;private void runTestDeclineOnCheckpointError(AbstractStateBackend backend) throws Exception {     TestDeclinedCheckpointResponder checkpointResponder = new TestDeclinedCheckpointResponder().     Task task = createTask(new FilterOperator(), backend, checkpointResponder, false).     // start the task and wait until it is in "restore"     task.startTaskThread().     checkpointResponder.declinedLatch.await().     Assert.assertEquals(ExecutionState.RUNNING, task.getExecutionState()).     task.cancelExecution().     task.getExecutingThread().join(). }
false;private;1;13;;private Throwable runTestTaskFailingOnCheckpointError(AbstractStateBackend backend) throws Exception {     Task task = createTask(new FilterOperator(), backend, mock(CheckpointResponder.class), true).     // start the task and wait until it is in "restore"     task.startTaskThread().     task.getExecutingThread().join().     assertEquals(ExecutionState.FAILED, task.getExecutionState()).     return task.getFailureCause(). }
false;private,static;4;72;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ private static Task createTask(StreamOperator<?> op, StateBackend backend, CheckpointResponder checkpointResponder, boolean failOnCheckpointErrors) throws IOException {     Configuration taskConfig = new Configuration().     StreamConfig cfg = new StreamConfig(taskConfig).     cfg.setStreamOperator(op).     cfg.setOperatorID(new OperatorID()).     cfg.setStateBackend(backend).     ExecutionConfig executionConfig = new ExecutionConfig().     executionConfig.setFailTaskOnCheckpointError(failOnCheckpointErrors).     JobInformation jobInformation = new JobInformation(new JobID(), "test job name", new SerializedValue<>(executionConfig), new Configuration(), Collections.emptyList(), Collections.emptyList()).     TaskInformation taskInformation = new TaskInformation(new JobVertexID(), "test task name", 1, 11, TestStreamTask.class.getName(), taskConfig).     TaskKvStateRegistry mockKvRegistry = mock(TaskKvStateRegistry.class).     TaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher().     NetworkEnvironment network = mock(NetworkEnvironment.class).     when(network.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mockKvRegistry).     when(network.getTaskEventDispatcher()).thenReturn(taskEventDispatcher).     BlobCacheService blobService = new BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class)).     return new Task(jobInformation, taskInformation, new ExecutionAttemptID(), new AllocationID(), 0, 0, Collections.<ResultPartitionDeploymentDescriptor>emptyList(), Collections.<InputGateDeploymentDescriptor>emptyList(), 0, mock(MemoryManager.class), mock(IOManager.class), network, mock(BroadcastVariableManager.class), new TestTaskStateManager(), mock(TaskManagerActions.class), mock(InputSplitProvider.class), checkpointResponder, new TestGlobalAggregateManager(), blobService, new BlobLibraryCacheManager(blobService.getPermanentBlobService(), FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0]), new FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }, blobService.getPermanentBlobService()), new TestingTaskManagerRuntimeInfo(), UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(), new NoOpResultPartitionConsumableNotifier(), mock(PartitionProducerStateChecker.class), Executors.directExecutor()). }
false;public;5;10;;@Override public void acknowledgeCheckpoint(JobID jobID, ExecutionAttemptID executionAttemptID, long checkpointId, CheckpointMetrics checkpointMetrics, TaskStateSnapshot subtaskState) {     throw new RuntimeException("Unexpected call."). }
false;public;4;9;;@Override public void declineCheckpoint(JobID jobID, ExecutionAttemptID executionAttemptID, long checkpointId, Throwable cause) {     declinedLatch.trigger(). }
false;public;0;3;;public OneShotLatch getDeclinedLatch() {     return declinedLatch. }
false;public;4;10;;@Nonnull @Override public RunnableFuture<SnapshotResult<OperatorStateHandle>> snapshot(long checkpointId, long timestamp, @Nonnull CheckpointStreamFactory streamFactory, @Nonnull CheckpointOptions checkpointOptions) throws Exception {     throw new Exception("Sync part snapshot exception."). }
false;public;2;18;;@Override public OperatorStateBackend createOperatorStateBackend(Environment env, String operatorIdentifier) throws Exception {     return new DefaultOperatorStateBackend(env.getUserClassLoader(), env.getExecutionConfig(), true) {          @Nonnull         @Override         public RunnableFuture<SnapshotResult<OperatorStateHandle>> snapshot(long checkpointId, long timestamp, @Nonnull CheckpointStreamFactory streamFactory, @Nonnull CheckpointOptions checkpointOptions) throws Exception {             throw new Exception("Sync part snapshot exception.").         }     }. }
false;public;2;5;;@Override public SyncFailureInducingStateBackend configure(Configuration config, ClassLoader classLoader) {     // retain this instance, no re-configuration!     return this. }
false;public;4;12;;@Nonnull @Override public RunnableFuture<SnapshotResult<OperatorStateHandle>> snapshot(long checkpointId, long timestamp, @Nonnull CheckpointStreamFactory streamFactory, @Nonnull CheckpointOptions checkpointOptions) throws Exception {     return new FutureTask<>(() -> {         throw new Exception("Async part snapshot exception.").     }). }
false;public;2;20;;@Override public OperatorStateBackend createOperatorStateBackend(Environment env, String operatorIdentifier) throws Exception {     return new DefaultOperatorStateBackend(env.getUserClassLoader(), env.getExecutionConfig(), true) {          @Nonnull         @Override         public RunnableFuture<SnapshotResult<OperatorStateHandle>> snapshot(long checkpointId, long timestamp, @Nonnull CheckpointStreamFactory streamFactory, @Nonnull CheckpointOptions checkpointOptions) throws Exception {             return new FutureTask<>(() -> {                 throw new Exception("Async part snapshot exception.").             }).         }     }. }
false;public;2;5;;@Override public AsyncFailureInducingStateBackend configure(Configuration config, ClassLoader classLoader) {     // retain this instance, no re-configuration!     return this. }
false;public;0;5;;@Nullable @Override public StreamStateHandle closeAndGetHandle() throws IOException {     throw new UnsupportedOperationException(). }
false;public;1;12;;@Override public void write(int b) throws IOException {     // this needs to not react to interrupts until the handle is closed     synchronized (lock) {         while (!closed) {             try {                 lock.wait().             } catch (InterruptedException ignored) {             }         }     } }
false;public;0;7;;@Override public void close() throws IOException {     synchronized (lock) {         closed = true.         lock.notifyAll().     } }
false;public;0;4;;@Override public long getPos() {     return 0. }
false;public;0;2;;@Override public void flush() { }
false;public;0;2;;@Override public void sync() { }
false;public;1;4;;@Override public boolean filter(Object value) {     return false. }
false;public;1;4;;@Override public boolean filter(Object value) {     return false. }
false;public;1;9;;@Override public void snapshotState(StateSnapshotContext context) throws Exception {     OperatorStateCheckpointOutputStream outStream = context.getRawOperatorStateOutput().     IN_CHECKPOINT_LATCH.trigger().     // this should lock     outStream.write(1). }
false;public;0;2;;@Override public void init() { }
false;protected;0;14;;@Override protected void run() throws Exception {     triggerCheckpointOnBarrier(new CheckpointMetaData(11L, System.currentTimeMillis()), CheckpointOptions.forCheckpointWithDefaultLocation(), new CheckpointMetrics()).     while (isRunning()) {         Thread.sleep(1L).     } }
false;protected;0;2;;@Override protected void cleanup() { }
false;protected;0;2;;@Override protected void cancelTask() { }
