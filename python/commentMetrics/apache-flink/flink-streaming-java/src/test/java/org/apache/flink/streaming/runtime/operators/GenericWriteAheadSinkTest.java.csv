commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected ListSink createSink() throws Exception {     return new ListSink(). }
false;protected;0;4;;@Override protected TupleTypeInfo<Tuple1<Integer>> createTypeInfo() {     return TupleTypeInfo.getBasicTupleTypeInfo(Integer.class). }
false;protected;2;4;;@Override protected Tuple1<Integer> generateValue(int counter, int checkpointID) {     return new Tuple1<>(counter). }
false;protected;1;14;;@Override protected void verifyResultsIdealCircumstances(ListSink sink) {     ArrayList<Integer> list = new ArrayList<>().     for (int x = 1. x <= 60. x++) {         list.add(x).     }     for (Integer i : sink.values) {         list.remove(i).     }     Assert.assertTrue("The following ID's where not found in the result list: " + list.toString(), list.isEmpty()).     Assert.assertTrue("The sink emitted to many values: " + (sink.values.size() - 60), sink.values.size() == 60). }
false;protected;1;14;;@Override protected void verifyResultsDataPersistenceUponMissedNotify(ListSink sink) {     ArrayList<Integer> list = new ArrayList<>().     for (int x = 1. x <= 60. x++) {         list.add(x).     }     for (Integer i : sink.values) {         list.remove(i).     }     Assert.assertTrue("The following ID's where not found in the result list: " + list.toString(), list.isEmpty()).     Assert.assertTrue("The sink emitted to many values: " + (sink.values.size() - 60), sink.values.size() == 60). }
false;protected;1;17;;@Override protected void verifyResultsDataDiscardingUponRestore(ListSink sink) {     ArrayList<Integer> list = new ArrayList<>().     for (int x = 1. x <= 20. x++) {         list.add(x).     }     for (int x = 41. x <= 60. x++) {         list.add(x).     }     for (Integer i : sink.values) {         list.remove(i).     }     Assert.assertTrue("The following ID's where not found in the result list: " + list.toString(), list.isEmpty()).     Assert.assertTrue("The sink emitted to many values: " + (sink.values.size() - 40), sink.values.size() == 40). }
false;protected;3;11;;@Override protected void verifyResultsWhenReScaling(ListSink sink, int startElementCounter, int endElementCounter) throws Exception {     ArrayList<Integer> list = new ArrayList<>().     for (int i = startElementCounter. i <= endElementCounter. i++) {         list.add(i).     }     Collections.sort(sink.values).     Assert.assertArrayEquals(list.toArray(), sink.values.toArray()). }
false;public;0;49;;@Test public /**  * Verifies that exceptions thrown by a committer do not fail a job and lead to an abort of notify()  * and later retry of the affected checkpoints.  */ void testCommitterException() throws Exception {     ListSink2 sink = new ListSink2().     OneInputStreamOperatorTestHarness<Tuple1<Integer>, Tuple1<Integer>> testHarness = new OneInputStreamOperatorTestHarness<>(sink).     testHarness.open().     int elementCounter = 1.     for (int x = 0. x < 10. x++) {         testHarness.processElement(new StreamRecord<>(generateValue(elementCounter, 0))).         elementCounter++.     }     testHarness.snapshot(0, 0).     testHarness.notifyOfCompletedCheckpoint(0).     // isCommitted should have failed, thus sendValues() should never have been called     Assert.assertEquals(0, sink.values.size()).     for (int x = 0. x < 11. x++) {         testHarness.processElement(new StreamRecord<>(generateValue(elementCounter, 1))).         elementCounter++.     }     testHarness.snapshot(1, 0).     testHarness.notifyOfCompletedCheckpoint(1).     // previous CP should be retried, but will fail the CP commit. Second CP should be skipped.     Assert.assertEquals(10, sink.values.size()).     for (int x = 0. x < 12. x++) {         testHarness.processElement(new StreamRecord<>(generateValue(elementCounter, 2))).         elementCounter++.     }     testHarness.snapshot(2, 0).     testHarness.notifyOfCompletedCheckpoint(2).     // all CP's should be retried and succeed. since one CP was written twice we have 2 * 10 + 11 + 12 = 43 values     Assert.assertEquals(43, sink.values.size()). }
false;protected;3;7;;@Override protected boolean sendValues(Iterable<Tuple1<Integer>> values, long checkpointId, long timestamp) throws Exception {     for (Tuple1<Integer> value : values) {         this.values.add(value.f0).     }     return true. }
false;public;0;3;;@Override public void open() throws Exception { }
false;public;0;3;;@Override public void close() throws Exception { }
false;public;0;4;;@Override public void createResource() throws Exception {     checkpoints = new ArrayList<>(). }
false;public;2;4;;@Override public void commitCheckpoint(int subtaskIdx, long checkpointID) {     checkpoints.add(new Tuple2<>(checkpointID, subtaskIdx)). }
false;public;2;4;;@Override public boolean isCheckpointCommitted(int subtaskIdx, long checkpointID) {     return checkpoints.contains(new Tuple2<>(checkpointID, subtaskIdx)). }
false;protected;3;7;;@Override protected boolean sendValues(Iterable<Tuple1<Integer>> values, long checkpointId, long timestamp) throws Exception {     for (Tuple1<Integer> value : values) {         this.values.add(value.f0).     }     return true. }
false;public;0;3;;@Override public void open() throws Exception { }
false;public;0;3;;@Override public void close() throws Exception { }
false;public;0;4;;@Override public void createResource() throws Exception {     checkpoints = new ArrayList<>(). }
false;public;2;9;;@Override public void commitCheckpoint(int subtaskIdx, long checkpointID) {     if (failCommit) {         failCommit = false.         throw new RuntimeException("Expected exception").     } else {         checkpoints.add(new Tuple2<>(checkpointID, subtaskIdx)).     } }
false;public;2;9;;@Override public boolean isCheckpointCommitted(int subtaskIdx, long checkpointID) {     if (failIsCommitted) {         failIsCommitted = false.         throw new RuntimeException("Expected exception").     } else {         return false.     } }
