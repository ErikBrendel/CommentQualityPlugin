commented;modifiers;parameterAmount;loc;comment;code
false;abstract;0;1;;abstract BufferBlocker createBufferBlocker().
false;public;0;7;;@Test public void testRollOverEmptySequences() throws IOException {     BufferBlocker bufferBlocker = createBufferBlocker().     assertNull(bufferBlocker.rollOverReusingResources()).     assertNull(bufferBlocker.rollOverReusingResources()).     assertNull(bufferBlocker.rollOverReusingResources()). }
false;public;0;64;;@Test public void testSpillAndRollOverSimple() throws IOException {     final Random rnd = new Random().     final Random bufferRnd = new Random().     final int maxNumEventsAndBuffers = 3000.     final int maxNumChannels = 1656.     BufferBlocker bufferBlocker = createBufferBlocker().     // do multiple spilling / rolling over rounds     for (int round = 0. round < 5. round++) {         final long bufferSeed = rnd.nextLong().         bufferRnd.setSeed(bufferSeed).         final int numEventsAndBuffers = rnd.nextInt(maxNumEventsAndBuffers) + 1.         final int numberOfChannels = rnd.nextInt(maxNumChannels) + 1.         final ArrayList<BufferOrEvent> events = new ArrayList<BufferOrEvent>(128).         // generate sequence         for (int i = 0. i < numEventsAndBuffers. i++) {             boolean isEvent = rnd.nextDouble() < 0.05d.             BufferOrEvent evt.             if (isEvent) {                 evt = generateRandomEvent(rnd, numberOfChannels).                 events.add(evt).             } else {                 evt = generateRandomBuffer(bufferRnd.nextInt(PAGE_SIZE) + 1, bufferRnd.nextInt(numberOfChannels)).             }             bufferBlocker.add(evt).         }         // reset and create reader         bufferRnd.setSeed(bufferSeed).         BufferOrEventSequence seq = bufferBlocker.rollOverReusingResources().         seq.open().         // read and validate the sequence         int numEvent = 0.         for (int i = 0. i < numEventsAndBuffers. i++) {             BufferOrEvent next = seq.getNext().             assertNotNull(next).             if (next.isEvent()) {                 BufferOrEvent expected = events.get(numEvent++).                 assertEquals(expected.getEvent(), next.getEvent()).                 assertEquals(expected.getChannelIndex(), next.getChannelIndex()).             } else {                 validateBuffer(next, bufferRnd.nextInt(PAGE_SIZE) + 1, bufferRnd.nextInt(numberOfChannels)).             }         }         // no further data         assertNull(seq.getNext()).         // all events need to be consumed         assertEquals(events.size(), numEvent).         seq.cleanup().     } }
false;public;0;134;;@Test public void testSpillWhileReading() throws IOException {     final int sequences = 10.     final Random rnd = new Random().     final int maxNumEventsAndBuffers = 30000.     final int maxNumChannels = 1656.     int sequencesConsumed = 0.     ArrayDeque<SequenceToConsume> pendingSequences = new ArrayDeque<SequenceToConsume>().     SequenceToConsume currentSequence = null.     int currentNumEvents = 0.     int currentNumRecordAndEvents = 0.     BufferBlocker bufferBlocker = createBufferBlocker().     // do multiple spilling / rolling over rounds     for (int round = 0. round < 2 * sequences. round++) {         if (round % 2 == 1) {             // make this an empty sequence             assertNull(bufferBlocker.rollOverReusingResources()).         } else {             // proper spilled sequence             final long bufferSeed = rnd.nextLong().             final Random bufferRnd = new Random(bufferSeed).             final int numEventsAndBuffers = rnd.nextInt(maxNumEventsAndBuffers) + 1.             final int numberOfChannels = rnd.nextInt(maxNumChannels) + 1.             final ArrayList<BufferOrEvent> events = new ArrayList<BufferOrEvent>(128).             int generated = 0.             while (generated < numEventsAndBuffers) {                 if (currentSequence == null || rnd.nextDouble() < 0.5) {                     // add a new record                     boolean isEvent = rnd.nextDouble() < 0.05.                     BufferOrEvent evt.                     if (isEvent) {                         evt = generateRandomEvent(rnd, numberOfChannels).                         events.add(evt).                     } else {                         evt = generateRandomBuffer(bufferRnd.nextInt(PAGE_SIZE) + 1, bufferRnd.nextInt(numberOfChannels)).                     }                     bufferBlocker.add(evt).                     generated++.                 } else {                     // consume a record                     BufferOrEvent next = currentSequence.sequence.getNext().                     assertNotNull(next).                     if (next.isEvent()) {                         BufferOrEvent expected = currentSequence.events.get(currentNumEvents++).                         assertEquals(expected.getEvent(), next.getEvent()).                         assertEquals(expected.getChannelIndex(), next.getChannelIndex()).                     } else {                         Random validationRnd = currentSequence.bufferRnd.                         validateBuffer(next, validationRnd.nextInt(PAGE_SIZE) + 1, validationRnd.nextInt(currentSequence.numberOfChannels)).                     }                     currentNumRecordAndEvents++.                     if (currentNumRecordAndEvents == currentSequence.numBuffersAndEvents) {                         // done with the sequence                         currentSequence.sequence.cleanup().                         sequencesConsumed++.                         // validate we had all events                         assertEquals(currentSequence.events.size(), currentNumEvents).                         // reset                         currentSequence = pendingSequences.pollFirst().                         if (currentSequence != null) {                             currentSequence.sequence.open().                         }                         currentNumRecordAndEvents = 0.                         currentNumEvents = 0.                     }                 }             }             // done generating a sequence. queue it for consumption             bufferRnd.setSeed(bufferSeed).             BufferOrEventSequence seq = bufferBlocker.rollOverReusingResources().             SequenceToConsume stc = new SequenceToConsume(bufferRnd, events, seq, numEventsAndBuffers, numberOfChannels).             if (currentSequence == null) {                 currentSequence = stc.                 stc.sequence.open().             } else {                 pendingSequences.addLast(stc).             }         }     }     // consume all the remainder     while (currentSequence != null) {         // consume a record         BufferOrEvent next = currentSequence.sequence.getNext().         assertNotNull(next).         if (next.isEvent()) {             BufferOrEvent expected = currentSequence.events.get(currentNumEvents++).             assertEquals(expected.getEvent(), next.getEvent()).             assertEquals(expected.getChannelIndex(), next.getChannelIndex()).         } else {             Random validationRnd = currentSequence.bufferRnd.             validateBuffer(next, validationRnd.nextInt(PAGE_SIZE) + 1, validationRnd.nextInt(currentSequence.numberOfChannels)).         }         currentNumRecordAndEvents++.         if (currentNumRecordAndEvents == currentSequence.numBuffersAndEvents) {             // done with the sequence             currentSequence.sequence.cleanup().             sequencesConsumed++.             // validate we had all events             assertEquals(currentSequence.events.size(), currentNumEvents).             // reset             currentSequence = pendingSequences.pollFirst().             if (currentSequence != null) {                 currentSequence.sequence.open().             }             currentNumRecordAndEvents = 0.             currentNumEvents = 0.         }     }     assertEquals(sequences, sequencesConsumed). }
false;private,static;2;10;;// ------------------------------------------------------------------------ // Utils // ------------------------------------------------------------------------ private static BufferOrEvent generateRandomEvent(Random rnd, int numberOfChannels) {     long magicNumber = rnd.nextLong().     byte[] data = new byte[rnd.nextInt(1000)].     rnd.nextBytes(data).     TestEvent evt = new TestEvent(magicNumber, data).     int channelIndex = rnd.nextInt(numberOfChannels).     return new BufferOrEvent(evt, channelIndex). }
false;public,static;2;10;;public static BufferOrEvent generateRandomBuffer(int size, int channelIndex) {     MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(PAGE_SIZE).     for (int i = 0. i < size. i++) {         seg.put(i, (byte) i).     }     Buffer buf = new NetworkBuffer(seg, FreeingBufferRecycler.INSTANCE).     buf.setSize(size).     return new BufferOrEvent(buf, channelIndex). }
false;private,static;3;16;;private static void validateBuffer(BufferOrEvent boe, int expectedSize, int expectedChannelIndex) {     assertEquals("wrong channel index", expectedChannelIndex, boe.getChannelIndex()).     assertTrue("is not buffer", boe.isBuffer()).     Buffer buf = boe.getBuffer().     assertEquals("wrong buffer size", expectedSize, buf.getSize()).     MemorySegment seg = buf.getMemorySegment().     for (int i = 0. i < expectedSize. i++) {         byte expected = (byte) i.         if (expected != seg.get(i)) {             fail(String.format("wrong buffer contents at position %s : expected=%d , found=%d", i, expected, seg.get(i))).         }     } }
