commented;modifiers;parameterAmount;loc;comment;code
false;public;5;15;;public void setUp(int writers, int channels, boolean localMode, int senderBufferPoolSize, int receiverBufferPoolSize) throws Exception {     setUp(writers, channels, false, localMode, senderBufferPoolSize, receiverBufferPoolSize, new Configuration()). }
true;public;7;33;/**  * Sets up the environment including buffer pools and netty threads.  *  * @param writers  * 		number of writers  * @param channels  * 		outgoing channels per writer  * @param localMode  * 		only local channels?  * @param senderBufferPoolSize  * 		buffer pool size for the sender (set to <tt>-1</tt> for default)  * @param receiverBufferPoolSize  * 		buffer pool size for the receiver (set to <tt>-1</tt> for default)  */ ;/**  * Sets up the environment including buffer pools and netty threads.  *  * @param writers  * 		number of writers  * @param channels  * 		outgoing channels per writer  * @param localMode  * 		only local channels?  * @param senderBufferPoolSize  * 		buffer pool size for the sender (set to <tt>-1</tt> for default)  * @param receiverBufferPoolSize  * 		buffer pool size for the receiver (set to <tt>-1</tt> for default)  */ public void setUp(int writers, int channels, boolean broadcastMode, boolean localMode, int senderBufferPoolSize, int receiverBufferPoolSize, Configuration config) throws Exception {     this.broadcastMode = broadcastMode.     this.localMode = localMode.     this.channels = channels.     this.partitionIds = new ResultPartitionID[writers].     if (senderBufferPoolSize == -1) {         senderBufferPoolSize = Math.max(2048, writers * channels * 4).     }     if (receiverBufferPoolSize == -1) {         receiverBufferPoolSize = Math.max(2048, writers * channels * 4).     }     ioManager = new IOManagerAsync().     senderEnv = createNettyNetworkEnvironment(senderBufferPoolSize, config).     senderEnv.start().     if (localMode && senderBufferPoolSize == receiverBufferPoolSize) {         receiverEnv = senderEnv.     } else {         receiverEnv = createNettyNetworkEnvironment(receiverBufferPoolSize, config).         receiverEnv.start().     }     generatePartitionIds(). }
false;public;0;5;;public void tearDown() {     suppressExceptions(senderEnv::shutdown).     suppressExceptions(receiverEnv::shutdown).     suppressExceptions(ioManager::shutdown). }
false;public;0;19;;public SerializingLongReceiver createReceiver() throws Exception {     TaskManagerLocation senderLocation = new TaskManagerLocation(ResourceID.generate(), LOCAL_ADDRESS, senderEnv.getConnectionManager().getDataPort()).     InputGate receiverGate = createInputGate(jobId, dataSetID, executionAttemptID, senderLocation, receiverEnv, channels).     SerializingLongReceiver receiver = new SerializingLongReceiver(receiverGate, channels * partitionIds.length).     receiver.start().     return receiver. }
false;public;2;4;;public RecordWriter<T> createRecordWriter(int partitionIndex, long flushTimeout) throws Exception {     ResultPartitionWriter sender = createResultPartition(jobId, partitionIds[partitionIndex], senderEnv, channels).     return new RecordWriter<>(sender, new RoundRobinChannelSelector<T>(), flushTimeout, null). }
false;private;0;5;;private void generatePartitionIds() throws Exception {     for (int writer = 0. writer < partitionIds.length. writer++) {         partitionIds[writer] = new ResultPartitionID().     } }
false;private;2;36;;private NetworkEnvironment createNettyNetworkEnvironment(@SuppressWarnings("SameParameterValue") int bufferPoolSize, Configuration config) throws Exception {     int segmentSize = checkedDownCast(MemorySize.parse(config.getString(TaskManagerOptions.MEMORY_SEGMENT_SIZE)).getBytes()).     // we need this because many configs have been written with a "-1" entry     // similar to TaskManagerServicesConfiguration#fromConfiguration()     // -> please note that this directly influences the number of netty threads!     int slots = config.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, 1).     if (slots == -1) {         slots = 1.     }     final NetworkBufferPool bufferPool = new NetworkBufferPool(bufferPoolSize, segmentSize).     final NettyConnectionManager nettyConnectionManager = new NettyConnectionManager(new NettyConfig(LOCAL_ADDRESS, 0, segmentSize, slots, config)).     return new NetworkEnvironment(bufferPool, nettyConnectionManager, new ResultPartitionManager(), new TaskEventDispatcher(), new KvStateRegistry(), null, null, IOMode.SYNC, TaskManagerOptions.NETWORK_REQUEST_BACKOFF_INITIAL.defaultValue(), TaskManagerOptions.NETWORK_REQUEST_BACKOFF_MAX.defaultValue(), TaskManagerOptions.NETWORK_BUFFERS_PER_CHANNEL.defaultValue(), TaskManagerOptions.NETWORK_EXTRA_BUFFERS_PER_GATE.defaultValue(), true). }
false;protected;4;23;;protected ResultPartitionWriter createResultPartition(JobID jobId, ResultPartitionID partitionId, NetworkEnvironment environment, int channels) throws Exception {     ResultPartition resultPartition = new ResultPartition("sender task", new NoOpTaskActions(), jobId, partitionId, ResultPartitionType.PIPELINED_BOUNDED, channels, 1, environment.getResultPartitionManager(), new NoOpResultPartitionConsumableNotifier(), ioManager, false).     environment.setupPartition(resultPartition).     return resultPartition. }
false;private;6;42;;private InputGate createInputGate(JobID jobId, IntermediateDataSetID dataSetID, ExecutionAttemptID executionAttemptID, final TaskManagerLocation senderLocation, NetworkEnvironment environment, final int channels) throws IOException {     InputGate[] gates = new InputGate[channels].     for (int channel = 0. channel < channels. ++channel) {         int finalChannel = channel.         InputChannelDeploymentDescriptor[] channelDescriptors = Arrays.stream(partitionIds).map(partitionId -> new InputChannelDeploymentDescriptor(partitionId, localMode ? ResultPartitionLocation.createLocal() : ResultPartitionLocation.createRemote(new ConnectionID(senderLocation, finalChannel)))).toArray(InputChannelDeploymentDescriptor[]::new).         final InputGateDeploymentDescriptor gateDescriptor = new InputGateDeploymentDescriptor(dataSetID, ResultPartitionType.PIPELINED_BOUNDED, channel, channelDescriptors).         SingleInputGate gate = SingleInputGate.create("receiving task[" + channel + "]", jobId, executionAttemptID, gateDescriptor, environment, new NoOpTaskActions(), UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup()).         environment.setupInputGate(gate).         gates[channel] = gate.     }     if (channels > 1) {         return new UnionInputGate(gates).     } else {         return gates[0].     } }
false;public;3;5;;@Override public void triggerPartitionProducerStateCheck(JobID jobId, IntermediateDataSetID intermediateDataSetId, ResultPartitionID resultPartitionId) { }
false;public;1;2;;@Override public void failExternally(Throwable cause) { }
