commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void resetLatches() {     ready = new OneShotLatch().     sync = new MultiShotLatch(). }
false;public;0;67;;@Test @SuppressWarnings("unchecked") public void testCheckpointsTriggeredBySource() throws Exception {     // set up the basic test harness     final StreamTaskTestHarness<Long> testHarness = new StreamTaskTestHarness<>(SourceStreamTask::new, BasicTypeInfo.LONG_TYPE_INFO).     testHarness.setupOutputForSingletonOperatorChain().     testHarness.getExecutionConfig().setLatencyTrackingInterval(-1).     final long numElements = 10.     final long checkpointEvery = 3.     // set up the source function     ExternalCheckpointsSource source = new ExternalCheckpointsSource(numElements, checkpointEvery).     StreamConfig streamConfig = testHarness.getStreamConfig().     StreamSource<Long, ?> sourceOperator = new StreamSource<>(source).     streamConfig.setStreamOperator(sourceOperator).     streamConfig.setOperatorID(new OperatorID()).     // this starts the source thread     testHarness.invoke().     final StreamTask<Long, ?> sourceTask = testHarness.getTask().     ready.await().     // now send an external trigger that should be ignored     assertTrue(sourceTask.triggerCheckpoint(new CheckpointMetaData(32, 829), CheckpointOptions.forCheckpointWithDefaultLocation())).     // step by step let the source thread emit elements     sync.trigger().     verifyNextElement(testHarness.getOutput(), 1L).     sync.trigger().     verifyNextElement(testHarness.getOutput(), 2L).     sync.trigger().     verifyNextElement(testHarness.getOutput(), 3L).     verifyCheckpointBarrier(testHarness.getOutput(), 1L).     sync.trigger().     verifyNextElement(testHarness.getOutput(), 4L).     // now send an regular trigger command that should be ignored     assertTrue(sourceTask.triggerCheckpoint(new CheckpointMetaData(34, 900), CheckpointOptions.forCheckpointWithDefaultLocation())).     sync.trigger().     verifyNextElement(testHarness.getOutput(), 5L).     sync.trigger().     verifyNextElement(testHarness.getOutput(), 6L).     verifyCheckpointBarrier(testHarness.getOutput(), 2L).     for (long l = 7L, checkpoint = 3L. l <= numElements. l++) {         sync.trigger().         verifyNextElement(testHarness.getOutput(), l).         if (l % checkpointEvery == 0) {             verifyCheckpointBarrier(testHarness.getOutput(), checkpoint++).         }     } // done! }
false;private;2;6;;@SuppressWarnings("unchecked") private void verifyNextElement(BlockingQueue<Object> output, long expectedElement) throws InterruptedException {     Object next = output.take().     assertTrue("next element is not an event", next instanceof StreamRecord).     assertEquals("wrong event", expectedElement, ((StreamRecord<Long>) next).getValue().longValue()). }
false;private;2;5;;private void verifyCheckpointBarrier(BlockingQueue<Object> output, long checkpointId) throws InterruptedException {     Object next = output.take().     assertTrue("next element is not a checkpoint barrier", next instanceof CheckpointBarrier).     assertEquals("wrong checkpoint id", checkpointId, ((CheckpointBarrier) next).getId()). }
false;public;1;15;;@Override public void run(SourceContext<Long> ctx) throws Exception {     ready.trigger().     // for simplicity in this test, we just trigger checkpoints in ascending order     long checkpoint = 1.     for (long num = 1. num <= numEvents. num++) {         sync.await().         ctx.collect(num).         if (num % checkpointFrequency == 0) {             trigger.triggerCheckpoint(checkpoint++).         }     } }
false;public;0;2;;@Override public void cancel() { }
false;public;1;4;;@Override public void setCheckpointTrigger(CheckpointTrigger checkpointTrigger) {     this.trigger = checkpointTrigger. }
false;public;0;5;;@Override public MasterTriggerRestoreHook<Object> createMasterTriggerRestoreHook() {     // not relevant in this test     throw new UnsupportedOperationException("not implemented"). }
