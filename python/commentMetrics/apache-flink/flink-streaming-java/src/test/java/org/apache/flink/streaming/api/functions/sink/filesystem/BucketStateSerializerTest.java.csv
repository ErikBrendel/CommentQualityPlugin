commented;modifiers;parameterAmount;loc;comment;code
false;public;0;25;;@Test public void testSerializationEmpty() throws IOException {     final File testFolder = tempFolder.newFolder().     final FileSystem fs = FileSystem.get(testFolder.toURI()).     final RecoverableWriter writer = fs.createRecoverableWriter().     final Path testBucket = new Path(testFolder.getPath(), "test").     final BucketState<String> bucketState = new BucketState<>("test", testBucket, Long.MAX_VALUE, null, new HashMap<>()).     final SimpleVersionedSerializer<BucketState<String>> serializer = new BucketStateSerializer<>(writer.getResumeRecoverableSerializer(), writer.getCommitRecoverableSerializer(), SimpleVersionedStringSerializer.INSTANCE).     byte[] bytes = SimpleVersionedSerialization.writeVersionAndSerialize(serializer, bucketState).     final BucketState<String> recoveredState = SimpleVersionedSerialization.readVersionAndDeSerialize(serializer, bytes).     Assert.assertEquals(testBucket, recoveredState.getBucketPath()).     Assert.assertNull(recoveredState.getInProgressResumableFile()).     Assert.assertTrue(recoveredState.getCommittableFilesPerCheckpoint().isEmpty()). }
false;public;0;39;;@Test public void testSerializationOnlyInProgress() throws IOException {     final File testFolder = tempFolder.newFolder().     final FileSystem fs = FileSystem.get(testFolder.toURI()).     final Path testBucket = new Path(testFolder.getPath(), "test").     final RecoverableWriter writer = fs.createRecoverableWriter().     final RecoverableFsDataOutputStream stream = writer.open(testBucket).     stream.write(IN_PROGRESS_CONTENT.getBytes(Charset.forName("UTF-8"))).     final RecoverableWriter.ResumeRecoverable current = stream.persist().     final BucketState<String> bucketState = new BucketState<>("test", testBucket, Long.MAX_VALUE, current, new HashMap<>()).     final SimpleVersionedSerializer<BucketState<String>> serializer = new BucketStateSerializer<>(writer.getResumeRecoverableSerializer(), writer.getCommitRecoverableSerializer(), SimpleVersionedStringSerializer.INSTANCE).     final byte[] bytes = SimpleVersionedSerialization.writeVersionAndSerialize(serializer, bucketState).     // to simulate that everything is over for file.     stream.close().     final BucketState<String> recoveredState = SimpleVersionedSerialization.readVersionAndDeSerialize(serializer, bytes).     Assert.assertEquals(testBucket, recoveredState.getBucketPath()).     FileStatus[] statuses = fs.listStatus(testBucket.getParent()).     Assert.assertEquals(1L, statuses.length).     Assert.assertTrue(statuses[0].getPath().getPath().startsWith((new Path(testBucket.getParent(), ".test.inprogress")).toString())). }
false;public;0;78;;@Test public void testSerializationFull() throws IOException {     final int noOfTasks = 5.     final File testFolder = tempFolder.newFolder().     final FileSystem fs = FileSystem.get(testFolder.toURI()).     final RecoverableWriter writer = fs.createRecoverableWriter().     final Path bucketPath = new Path(testFolder.getPath()).     // pending for checkpoints     final Map<Long, List<RecoverableWriter.CommitRecoverable>> commitRecoverables = new HashMap<>().     for (int i = 0. i < noOfTasks. i++) {         final List<RecoverableWriter.CommitRecoverable> recoverables = new ArrayList<>().         for (int j = 0. j < 2 + i. j++) {             final Path part = new Path(bucketPath, "part-" + i + '-' + j).             final RecoverableFsDataOutputStream stream = writer.open(part).             stream.write((PENDING_CONTENT + '-' + j).getBytes(Charset.forName("UTF-8"))).             recoverables.add(stream.closeForCommit().getRecoverable()).         }         commitRecoverables.put((long) i, recoverables).     }     // in-progress     final Path testBucket = new Path(bucketPath, "test-2").     final RecoverableFsDataOutputStream stream = writer.open(testBucket).     stream.write(IN_PROGRESS_CONTENT.getBytes(Charset.forName("UTF-8"))).     final RecoverableWriter.ResumeRecoverable current = stream.persist().     final BucketState<String> bucketState = new BucketState<>("test-2", bucketPath, Long.MAX_VALUE, current, commitRecoverables).     final SimpleVersionedSerializer<BucketState<String>> serializer = new BucketStateSerializer<>(writer.getResumeRecoverableSerializer(), writer.getCommitRecoverableSerializer(), SimpleVersionedStringSerializer.INSTANCE).     stream.close().     byte[] bytes = SimpleVersionedSerialization.writeVersionAndSerialize(serializer, bucketState).     final BucketState<String> recoveredState = SimpleVersionedSerialization.readVersionAndDeSerialize(serializer, bytes).     Assert.assertEquals(bucketPath, recoveredState.getBucketPath()).     final Map<Long, List<RecoverableWriter.CommitRecoverable>> recoveredRecoverables = recoveredState.getCommittableFilesPerCheckpoint().     Assert.assertEquals(5L, recoveredRecoverables.size()).     // recover and commit     for (Map.Entry<Long, List<RecoverableWriter.CommitRecoverable>> entry : recoveredRecoverables.entrySet()) {         for (RecoverableWriter.CommitRecoverable recoverable : entry.getValue()) {             writer.recoverForCommit(recoverable).commit().         }     }     FileStatus[] filestatuses = fs.listStatus(bucketPath).     Set<String> paths = new HashSet<>(filestatuses.length).     for (FileStatus filestatus : filestatuses) {         paths.add(filestatus.getPath().getPath()).     }     for (int i = 0. i < noOfTasks. i++) {         for (int j = 0. j < 2 + i. j++) {             final String part = new Path(bucketPath, "part-" + i + '-' + j).toString().             Assert.assertTrue(paths.contains(part)).             paths.remove(part).         }     }     // only the in-progress must be left     Assert.assertEquals(1L, paths.size()).     // verify that the in-progress file is still there     Assert.assertTrue(paths.iterator().next().startsWith((new Path(testBucket.getParent(), ".test-2.inprogress").toString()))). }
false;public;0;69;;@Test public void testSerializationNullInProgress() throws IOException {     final int noOfTasks = 5.     final File testFolder = tempFolder.newFolder().     final FileSystem fs = FileSystem.get(testFolder.toURI()).     final RecoverableWriter writer = fs.createRecoverableWriter().     final Path bucketPath = new Path(testFolder.getPath()).     // pending for checkpoints     final Map<Long, List<RecoverableWriter.CommitRecoverable>> commitRecoverables = new HashMap<>().     for (int i = 0. i < noOfTasks. i++) {         final List<RecoverableWriter.CommitRecoverable> recoverables = new ArrayList<>().         for (int j = 0. j < 2 + i. j++) {             final Path part = new Path(bucketPath, "test-" + i + '-' + j).             final RecoverableFsDataOutputStream stream = writer.open(part).             stream.write((PENDING_CONTENT + '-' + j).getBytes(Charset.forName("UTF-8"))).             recoverables.add(stream.closeForCommit().getRecoverable()).         }         commitRecoverables.put((long) i, recoverables).     }     final RecoverableWriter.ResumeRecoverable current = null.     final BucketState<String> bucketState = new BucketState<>("", bucketPath, Long.MAX_VALUE, current, commitRecoverables).     final SimpleVersionedSerializer<BucketState<String>> serializer = new BucketStateSerializer<>(writer.getResumeRecoverableSerializer(), writer.getCommitRecoverableSerializer(), SimpleVersionedStringSerializer.INSTANCE).     byte[] bytes = SimpleVersionedSerialization.writeVersionAndSerialize(serializer, bucketState).     final BucketState<String> recoveredState = SimpleVersionedSerialization.readVersionAndDeSerialize(serializer, bytes).     Assert.assertEquals(bucketPath, recoveredState.getBucketPath()).     Assert.assertNull(recoveredState.getInProgressResumableFile()).     final Map<Long, List<RecoverableWriter.CommitRecoverable>> recoveredRecoverables = recoveredState.getCommittableFilesPerCheckpoint().     Assert.assertEquals(5L, recoveredRecoverables.size()).     // recover and commit     for (Map.Entry<Long, List<RecoverableWriter.CommitRecoverable>> entry : recoveredRecoverables.entrySet()) {         for (RecoverableWriter.CommitRecoverable recoverable : entry.getValue()) {             writer.recoverForCommit(recoverable).commit().         }     }     FileStatus[] filestatuses = fs.listStatus(bucketPath).     Set<String> paths = new HashSet<>(filestatuses.length).     for (FileStatus filestatus : filestatuses) {         paths.add(filestatus.getPath().getPath()).     }     for (int i = 0. i < noOfTasks. i++) {         for (int j = 0. j < 2 + i. j++) {             final String part = new Path(bucketPath, "test-" + i + '-' + j).toString().             Assert.assertTrue(paths.contains(part)).             paths.remove(part).         }     }     // only the in-progress must be left     Assert.assertTrue(paths.isEmpty()). }
