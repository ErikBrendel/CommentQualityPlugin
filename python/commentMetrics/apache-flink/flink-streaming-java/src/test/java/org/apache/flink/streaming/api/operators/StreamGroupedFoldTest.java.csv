commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public String fold(String accumulator, Integer value) throws Exception {     return accumulator + value.toString(). }
false;public;1;4;;@Override public String getKey(Integer value) {     return value.toString(). }
false;public;0;38;;@Test public void testGroupedFold() throws Exception {     KeySelector<Integer, String> keySelector = new KeySelector<Integer, String>() {          @Override         public String getKey(Integer value) {             return value.toString().         }     }.     StreamGroupedFold<Integer, String, String> operator = new StreamGroupedFold<>(new MyFolder(), "100").     operator.setOutputType(BasicTypeInfo.STRING_TYPE_INFO, new ExecutionConfig()).     OneInputStreamOperatorTestHarness<Integer, String> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, keySelector, BasicTypeInfo.STRING_TYPE_INFO).     long initialTime = 0L.     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     testHarness.open().     testHarness.processElement(new StreamRecord<>(1, initialTime + 1)).     testHarness.processElement(new StreamRecord<>(1, initialTime + 2)).     testHarness.processWatermark(new Watermark(initialTime + 2)).     testHarness.processElement(new StreamRecord<>(2, initialTime + 3)).     testHarness.processElement(new StreamRecord<>(2, initialTime + 4)).     testHarness.processElement(new StreamRecord<>(3, initialTime + 5)).     expectedOutput.add(new StreamRecord<>("1001", initialTime + 1)).     expectedOutput.add(new StreamRecord<>("10011", initialTime + 2)).     expectedOutput.add(new Watermark(initialTime + 2)).     expectedOutput.add(new StreamRecord<>("1002", initialTime + 3)).     expectedOutput.add(new StreamRecord<>("10022", initialTime + 4)).     expectedOutput.add(new StreamRecord<>("1003", initialTime + 5)).     TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput()). }
false;public;1;4;;@Override public Integer getKey(Integer value) {     return value. }
false;public;0;28;;@Test public void testOpenClose() throws Exception {     KeySelector<Integer, Integer> keySelector = new KeySelector<Integer, Integer>() {          @Override         public Integer getKey(Integer value) {             return value.         }     }.     StreamGroupedFold<Integer, String, Integer> operator = new StreamGroupedFold<>(new TestOpenCloseFoldFunction(), "init").     operator.setOutputType(BasicTypeInfo.STRING_TYPE_INFO, new ExecutionConfig()).     OneInputStreamOperatorTestHarness<Integer, String> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, keySelector, BasicTypeInfo.INT_TYPE_INFO).     long initialTime = 0L.     testHarness.open().     testHarness.processElement(new StreamRecord<>(1, initialTime)).     testHarness.processElement(new StreamRecord<>(2, initialTime)).     testHarness.close().     assertTrue("RichFunction methods where not called.", TestOpenCloseFoldFunction.closeCalled).     assertTrue("Output contains no elements.", testHarness.getOutput().size() > 0). }
false;public;1;8;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     if (closeCalled) {         fail("Close called before open.").     }     openCalled = true. }
false;public;0;8;;@Override public void close() throws Exception {     super.close().     if (!openCalled) {         fail("Open was not called before close.").     }     closeCalled = true. }
false;public;2;7;;@Override public String fold(String acc, Integer in) throws Exception {     if (!openCalled) {         fail("Open was not called before run.").     }     return acc + in. }
