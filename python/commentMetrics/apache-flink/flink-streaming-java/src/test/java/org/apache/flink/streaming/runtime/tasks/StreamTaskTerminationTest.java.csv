commented;modifiers;parameterAmount;loc;comment;code
true;public;0;93;/**  * FLINK-6833  *  * <p>Tests that a finished stream task cannot be failed by an asynchronous checkpointing operation after  * the stream task has stopped running.  */ ;/**  * FLINK-6833  *  * <p>Tests that a finished stream task cannot be failed by an asynchronous checkpointing operation after  * the stream task has stopped running.  */ @Test public void testConcurrentAsyncCheckpointCannotFailFinishedStreamTask() throws Exception {     final Configuration taskConfiguration = new Configuration().     final StreamConfig streamConfig = new StreamConfig(taskConfiguration).     final NoOpStreamOperator<Long> noOpStreamOperator = new NoOpStreamOperator<>().     final StateBackend blockingStateBackend = new BlockingStateBackend().     streamConfig.setStreamOperator(noOpStreamOperator).     streamConfig.setOperatorID(new OperatorID()).     streamConfig.setStateBackend(blockingStateBackend).     final long checkpointId = 0L.     final long checkpointTimestamp = 0L.     final JobInformation jobInformation = new JobInformation(new JobID(), "Test Job", new SerializedValue<>(new ExecutionConfig()), new Configuration(), Collections.emptyList(), Collections.emptyList()).     final TaskInformation taskInformation = new TaskInformation(new JobVertexID(), "Test Task", 1, 1, BlockingStreamTask.class.getName(), taskConfiguration).     final TaskManagerRuntimeInfo taskManagerRuntimeInfo = new TestingTaskManagerRuntimeInfo().     TaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher().     final NetworkEnvironment networkEnv = mock(NetworkEnvironment.class).     when(networkEnv.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mock(TaskKvStateRegistry.class)).     when(networkEnv.getTaskEventDispatcher()).thenReturn(taskEventDispatcher).     BlobCacheService blobService = new BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class)).     final Task task = new Task(jobInformation, taskInformation, new ExecutionAttemptID(), new AllocationID(), 0, 0, Collections.<ResultPartitionDeploymentDescriptor>emptyList(), Collections.<InputGateDeploymentDescriptor>emptyList(), 0, new MemoryManager(32L * 1024L, 1), new IOManagerAsync(), networkEnv, mock(BroadcastVariableManager.class), new TestTaskStateManager(), mock(TaskManagerActions.class), mock(InputSplitProvider.class), mock(CheckpointResponder.class), new TestGlobalAggregateManager(), blobService, new BlobLibraryCacheManager(blobService.getPermanentBlobService(), FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0]), mock(FileCache.class), taskManagerRuntimeInfo, UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(), new NoOpResultPartitionConsumableNotifier(), mock(PartitionProducerStateChecker.class), Executors.directExecutor()).     CompletableFuture<Void> taskRun = CompletableFuture.runAsync(() -> task.run(), TestingUtils.defaultExecutor()).     // wait until the stream task started running     RUN_LATCH.await().     // trigger a checkpoint     task.triggerCheckpointBarrier(checkpointId, checkpointTimestamp, CheckpointOptions.forCheckpointWithDefaultLocation()).     // wait until the task has completed execution     taskRun.get().     // check that no failure occurred     if (task.getFailureCause() != null) {         throw new Exception("Task failed", task.getFailureCause()).     }     // check that we have entered the finished state     assertEquals(ExecutionState.FINISHED, task.getExecutionState()). }
false;protected;0;3;;@Override protected void init() { }
false;protected;0;6;;@Override protected void run() throws Exception {     RUN_LATCH.trigger().     // wait until we have started an asynchronous checkpoint     CHECKPOINTING_LATCH.await(). }
false;protected;0;9;;@Override protected void cleanup() throws Exception {     // notify the asynchronous checkpoint operation that we have reached the cleanup stage --> the task     // has been stopped     CLEANUP_LATCH.trigger().     // wait until all async checkpoint threads are terminated, so that no more exceptions can be reported     Assert.assertTrue(getAsyncOperationsThreadPool().awaitTermination(30L, TimeUnit.SECONDS)). }
false;protected;0;3;;@Override protected void cancelTask() { }
false;public;1;4;;@Override public CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {     return new MemoryBackendCheckpointStorage(jobId, null, null, Integer.MAX_VALUE). }
false;public;10;14;;@Override public <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(Environment env, JobID jobID, String operatorIdentifier, TypeSerializer<K> keySerializer, int numberOfKeyGroups, KeyGroupRange keyGroupRange, TaskKvStateRegistry kvStateRegistry, TtlTimeProvider ttlTimeProvider, MetricGroup metricGroup, Collection<KeyedStateHandle> stateHandles) {     return null. }
false;public;2;8;;@Override public OperatorStateBackend createOperatorStateBackend(Environment env, String operatorIdentifier) throws Exception {     OperatorStateBackend operatorStateBackend = mock(OperatorStateBackend.class).     when(operatorStateBackend.snapshot(anyLong(), anyLong(), any(CheckpointStreamFactory.class), any(CheckpointOptions.class))).thenReturn(new FutureTask<>(new BlockingCallable())).     return operatorStateBackend. }
false;public;0;11;;@Override public SnapshotResult<OperatorStateHandle> call() throws Exception {     // notify that we have started the asynchronous checkpointed operation     CHECKPOINTING_LATCH.trigger().     // wait until we have reached the StreamTask#cleanup --> This will already cancel this FutureTask     CLEANUP_LATCH.await().     // by the StreamTask in the meantime     throw new FlinkException("Checkpointing operation failed"). }
