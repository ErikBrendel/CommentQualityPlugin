commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test public void testRestoreWithInterruptOperatorManaged() throws Exception {     testRestoreWithInterrupt(OPERATOR_MANAGED). }
false;public;0;4;;@Test public void testRestoreWithInterruptOperatorRaw() throws Exception {     testRestoreWithInterrupt(OPERATOR_RAW). }
false;public;0;4;;@Test public void testRestoreWithInterruptKeyedManaged() throws Exception {     testRestoreWithInterrupt(KEYED_MANAGED). }
false;public;0;4;;@Test public void testRestoreWithInterruptKeyedRaw() throws Exception {     testRestoreWithInterrupt(KEYED_RAW). }
false;private;1;38;;private void testRestoreWithInterrupt(int mode) throws Exception {     IN_RESTORE_LATCH.reset().     Configuration taskConfig = new Configuration().     StreamConfig cfg = new StreamConfig(taskConfig).     cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime).     switch(mode) {         case OPERATOR_MANAGED:         case OPERATOR_RAW:         case KEYED_MANAGED:         case KEYED_RAW:             cfg.setStateKeySerializer(IntSerializer.INSTANCE).             cfg.setStreamOperator(new StreamSource<>(new TestSource(mode))).             break.         default:             throw new IllegalArgumentException().     }     StreamStateHandle lockingHandle = new InterruptLockingStateHandle().     Task task = createTask(cfg, taskConfig, lockingHandle, mode).     // start the task and wait until it is in "restore"     task.startTaskThread().     IN_RESTORE_LATCH.await().     // trigger cancellation and signal to continue     task.cancelExecution().     task.getExecutingThread().join(30000).     if (task.getExecutionState() == ExecutionState.CANCELING) {         fail("Task is stuck and not canceling").     }     assertEquals(ExecutionState.CANCELED, task.getExecutionState()).     assertNull(task.getFailureCause()). }
false;private,static;4;119;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ private static Task createTask(StreamConfig streamConfig, Configuration taskConfig, StreamStateHandle state, int mode) throws IOException {     TaskEventDispatcher taskEventDispatcher = new TaskEventDispatcher().     NetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class).     when(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mock(TaskKvStateRegistry.class)).     when(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher).     Collection<KeyedStateHandle> keyedStateFromBackend = Collections.emptyList().     Collection<KeyedStateHandle> keyedStateFromStream = Collections.emptyList().     Collection<OperatorStateHandle> operatorStateBackend = Collections.emptyList().     Collection<OperatorStateHandle> operatorStateStream = Collections.emptyList().     Map<String, OperatorStateHandle.StateMetaInfo> operatorStateMetadata = new HashMap<>(1).     OperatorStateHandle.StateMetaInfo metaInfo = new OperatorStateHandle.StateMetaInfo(new long[] { 0 }, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE).     operatorStateMetadata.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo).     KeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(new KeyGroupRange(0, 0)).     Collection<OperatorStateHandle> operatorStateHandles = Collections.singletonList(new OperatorStreamStateHandle(operatorStateMetadata, state)).     List<KeyedStateHandle> keyedStateHandles = Collections.singletonList(new KeyGroupsStateHandle(keyGroupRangeOffsets, state)).     switch(mode) {         case OPERATOR_MANAGED:             operatorStateBackend = operatorStateHandles.             break.         case OPERATOR_RAW:             operatorStateStream = operatorStateHandles.             break.         case KEYED_MANAGED:             keyedStateFromBackend = keyedStateHandles.             break.         case KEYED_RAW:             keyedStateFromStream = keyedStateHandles.             break.         default:             throw new IllegalArgumentException().     }     OperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(new StateObjectCollection<>(operatorStateBackend), new StateObjectCollection<>(operatorStateStream), new StateObjectCollection<>(keyedStateFromBackend), new StateObjectCollection<>(keyedStateFromStream)).     JobVertexID jobVertexID = new JobVertexID().     OperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID).     streamConfig.setOperatorID(operatorID).     TaskStateSnapshot stateSnapshot = new TaskStateSnapshot().     stateSnapshot.putSubtaskStateByOperatorID(operatorID, operatorSubtaskState).     JobManagerTaskRestore taskRestore = new JobManagerTaskRestore(1L, stateSnapshot).     JobInformation jobInformation = new JobInformation(new JobID(), "test job name", new SerializedValue<>(new ExecutionConfig()), new Configuration(), Collections.emptyList(), Collections.emptyList()).     TaskInformation taskInformation = new TaskInformation(jobVertexID, "test task name", 1, 1, SourceStreamTask.class.getName(), taskConfig).     BlobCacheService blobService = new BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class)).     TestTaskStateManager taskStateManager = new TestTaskStateManager().     taskStateManager.setReportedCheckpointId(taskRestore.getRestoreCheckpointId()).     taskStateManager.setJobManagerTaskStateSnapshotsByCheckpointId(Collections.singletonMap(taskRestore.getRestoreCheckpointId(), taskRestore.getTaskStateSnapshot())).     return new Task(jobInformation, taskInformation, new ExecutionAttemptID(), new AllocationID(), 0, 0, Collections.<ResultPartitionDeploymentDescriptor>emptyList(), Collections.<InputGateDeploymentDescriptor>emptyList(), 0, mock(MemoryManager.class), mock(IOManager.class), networkEnvironment, mock(BroadcastVariableManager.class), taskStateManager, mock(TaskManagerActions.class), mock(InputSplitProvider.class), mock(CheckpointResponder.class), new TestGlobalAggregateManager(), blobService, new BlobLibraryCacheManager(blobService.getPermanentBlobService(), FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0]), new FileCache(new String[] { EnvironmentInformation.getTemporaryFileDirectory() }, blobService.getPermanentBlobService()), new TestingTaskManagerRuntimeInfo(), UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(), new NoOpResultPartitionConsumableNotifier(), mock(PartitionProducerStateChecker.class), mock(Executor.class)). }
false;public;1;3;;@Override public void seek(long desired) { }
false;public;0;4;;@Override public long getPos() {     return 0. }
false;public;0;5;;@Override public int read() throws IOException {     block().     throw new EOFException(). }
false;public;0;5;;@Override public void close() throws IOException {     super.close().     closed = true. }
false;public;0;31;;@Override public FSDataInputStream openInputStream() throws IOException {     closed = false.     FSDataInputStream is = new FSDataInputStream() {          @Override         public void seek(long desired) {         }          @Override         public long getPos() {             return 0.         }          @Override         public int read() throws IOException {             block().             throw new EOFException().         }          @Override         public void close() throws IOException {             super.close().             closed = true.         }     }.     return is. }
false;private;0;20;;private void block() {     IN_RESTORE_LATCH.trigger().     // an interrupt on a waiting object leads to an infinite loop     try {         synchronized (this) {             // noinspection WaitNotInLoop             wait().         }     } catch (InterruptedException e) {         while (!closed) {             try {                 synchronized (this) {                     wait().                 }             } catch (InterruptedException ignored) {             }         }     } }
false;public;0;2;;@Override public void discardState() throws Exception { }
false;public;0;4;;@Override public long getStateSize() {     return 0. }
false;public;1;4;;@Override public void run(SourceContext<Object> ctx) throws Exception {     fail("should never be called"). }
false;public;0;2;;@Override public void cancel() { }
false;public;1;4;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     fail("should never be called"). }
false;public;1;6;;@Override public void initializeState(FunctionInitializationContext context) throws Exception {     // raw keyed state is already read by timer service, all others to initialize the context...we only need to     // trigger this manually.     ((StateInitializationContext) context).getRawOperatorStateInputs().iterator().next().getStream().read(). }
