commented;modifiers;parameterAmount;loc;comment;code
false;public;0;33;;@Test public void testSocketSourceSimpleOutput() throws Exception {     ServerSocket server = new ServerSocket(0).     Socket channel = null.     try {         SocketTextStreamFunction source = new SocketTextStreamFunction(LOCALHOST, server.getLocalPort(), "\n", 0).         SocketSourceThread runner = new SocketSourceThread(source, "test1", "check").         runner.start().         channel = server.accept().         OutputStreamWriter writer = new OutputStreamWriter(channel.getOutputStream()).         writer.write("test1\n").         writer.write("check\n").         writer.flush().         runner.waitForNumElements(2).         runner.cancel().         runner.interrupt().         runner.waitUntilDone().         channel.close().     } finally {         if (channel != null) {             IOUtils.closeQuietly(channel).         }         IOUtils.closeQuietly(server).     } }
false;public;0;28;;@Test public void testExitNoRetries() throws Exception {     ServerSocket server = new ServerSocket(0).     Socket channel = null.     try {         SocketTextStreamFunction source = new SocketTextStreamFunction(LOCALHOST, server.getLocalPort(), "\n", 0).         SocketSourceThread runner = new SocketSourceThread(source).         runner.start().         channel = server.accept().         channel.close().         try {             runner.waitUntilDone().         } catch (Exception e) {             assertTrue(e.getCause() instanceof EOFException).         }     } finally {         if (channel != null) {             IOUtils.closeQuietly(channel).         }         IOUtils.closeQuietly(server).     } }
false;public;0;43;;@Test public void testSocketSourceOutputWithRetries() throws Exception {     ServerSocket server = new ServerSocket(0).     Socket channel = null.     try {         SocketTextStreamFunction source = new SocketTextStreamFunction(LOCALHOST, server.getLocalPort(), "\n", 10, 100).         SocketSourceThread runner = new SocketSourceThread(source, "test1", "check").         runner.start().         // first connection: nothing         channel = server.accept().         channel.close().         // second connection: first string         channel = server.accept().         OutputStreamWriter writer = new OutputStreamWriter(channel.getOutputStream()).         writer.write("test1\n").         writer.close().         channel.close().         // third connection: nothing         channel = server.accept().         channel.close().         // forth connection: second string         channel = server.accept().         writer = new OutputStreamWriter(channel.getOutputStream()).         writer.write("check\n").         writer.flush().         runner.waitForNumElements(2).         runner.cancel().         runner.waitUntilDone().     } finally {         if (channel != null) {             IOUtils.closeQuietly(channel).         }         IOUtils.closeQuietly(server).     } }
false;public;0;43;;@Test public void testSocketSourceOutputInfiniteRetries() throws Exception {     ServerSocket server = new ServerSocket(0).     Socket channel = null.     try {         SocketTextStreamFunction source = new SocketTextStreamFunction(LOCALHOST, server.getLocalPort(), "\n", -1, 100).         SocketSourceThread runner = new SocketSourceThread(source, "test1", "check").         runner.start().         // first connection: nothing         channel = server.accept().         channel.close().         // second connection: first string         channel = server.accept().         OutputStreamWriter writer = new OutputStreamWriter(channel.getOutputStream()).         writer.write("test1\n").         writer.close().         channel.close().         // third connection: nothing         channel = server.accept().         channel.close().         // forth connection: second string         channel = server.accept().         writer = new OutputStreamWriter(channel.getOutputStream()).         writer.write("check\n").         writer.flush().         runner.waitForNumElements(2).         runner.cancel().         runner.waitUntilDone().     } finally {         if (channel != null) {             IOUtils.closeQuietly(channel).         }         IOUtils.closeQuietly(server).     } }
false;public;0;45;;@Test public void testSocketSourceOutputAcrossRetries() throws Exception {     ServerSocket server = new ServerSocket(0).     Socket channel = null.     try {         SocketTextStreamFunction source = new SocketTextStreamFunction(LOCALHOST, server.getLocalPort(), "\n", 10, 100).         SocketSourceThread runner = new SocketSourceThread(source, "test1", "check1", "check2").         runner.start().         // first connection: nothing         channel = server.accept().         channel.close().         // second connection: first string         channel = server.accept().         OutputStreamWriter writer = new OutputStreamWriter(channel.getOutputStream()).         writer.write("te").         writer.close().         channel.close().         // third connection: nothing         channel = server.accept().         channel.close().         // forth connection: second string         channel = server.accept().         writer = new OutputStreamWriter(channel.getOutputStream()).         writer.write("st1\n").         writer.write("check1\n").         writer.write("check2\n").         writer.flush().         runner.waitForNumElements(2).         runner.cancel().         runner.waitUntilDone().     } finally {         if (channel != null) {             IOUtils.closeQuietly(channel).         }         IOUtils.closeQuietly(server).     } }
false;public;1;14;;@Override public void collect(String element) {     int pos = numElementsReceived.     // make sure waiter know of us     synchronized (sync) {         numElementsReceived++.         sync.notifyAll().     }     if (expectedData != null && expectedData.length > pos) {         assertEquals(expectedData[pos], element).     } }
false;public;2;4;;@Override public void collectWithTimestamp(String element, long timestamp) {     collect(element). }
false;public;1;4;;@Override public void emitWatermark(Watermark mark) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public void markAsTemporarilyIdle() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public Object getCheckpointLock() {     return lock. }
false;public;0;2;;@Override public void close() { }
false;public;0;62;;public void run() {     try {         SourceFunction.SourceContext<String> ctx = new SourceFunction.SourceContext<String>() {              private final Object lock = new Object().              @Override             public void collect(String element) {                 int pos = numElementsReceived.                 // make sure waiter know of us                 synchronized (sync) {                     numElementsReceived++.                     sync.notifyAll().                 }                 if (expectedData != null && expectedData.length > pos) {                     assertEquals(expectedData[pos], element).                 }             }              @Override             public void collectWithTimestamp(String element, long timestamp) {                 collect(element).             }              @Override             public void emitWatermark(Watermark mark) {                 throw new UnsupportedOperationException().             }              @Override             public void markAsTemporarilyIdle() {                 throw new UnsupportedOperationException().             }              @Override             public Object getCheckpointLock() {                 return lock.             }              @Override             public void close() {             }         }.         socketSource.run(ctx).     } catch (Throwable t) {         synchronized (sync) {             if (!canceled) {                 error = t.             }             sync.notifyAll().         }     } finally {         synchronized (sync) {             done = true.             sync.notifyAll().         }     } }
false;public;0;7;;public void cancel() {     synchronized (sync) {         canceled = true.         socketSource.cancel().         interrupt().     } }
false;public;1;17;;public void waitForNumElements(int numElements) throws InterruptedException {     synchronized (sync) {         while (error == null && !canceled && !done && numElementsReceived < numElements) {             sync.wait().         }         if (error != null) {             throw new RuntimeException("Error in source thread", error).         }         if (canceled) {             throw new RuntimeException("canceled").         }         if (done) {             throw new RuntimeException("Exited cleanly before expected number of elements").         }     } }
false;public;0;7;;public void waitUntilDone() throws InterruptedException {     join().     if (error != null) {         throw new RuntimeException("Error in source thread", error).     } }
