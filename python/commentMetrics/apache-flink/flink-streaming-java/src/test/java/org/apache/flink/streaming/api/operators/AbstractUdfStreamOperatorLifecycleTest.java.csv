commented;modifiers;parameterAmount;loc;comment;code
false;public;0;20;;@Test public void testAllMethodsRegisteredInTest() {     List<String> methodsWithSignatureString = new ArrayList<>().     for (Method method : StreamOperator.class.getMethods()) {         methodsWithSignatureString.add(method.getName() + Arrays.toString(method.getParameterTypes())).     }     Collections.sort(methodsWithSignatureString).     Assert.assertEquals("It seems like new methods have been introduced to " + StreamOperator.class + ". Please register them with this test and ensure to document their position in the lifecycle " + "(if applicable).", ALL_METHODS_STREAM_OPERATOR, methodsWithSignatureString.toString()).     methodsWithSignatureString = new ArrayList<>().     for (Method method : RichFunction.class.getMethods()) {         methodsWithSignatureString.add(method.getName() + Arrays.toString(method.getParameterTypes())).     }     Collections.sort(methodsWithSignatureString).     Assert.assertEquals("It seems like new methods have been introduced to " + RichFunction.class + ". Please register them with this test and ensure to document their position in the lifecycle " + "(if applicable).", ALL_METHODS_RICH_FUNCTION, methodsWithSignatureString.toString()). }
false;public;0;23;;@Test public void testLifeCycleFull() throws Exception {     ACTUAL_ORDER_TRACKING.clear().     Configuration taskManagerConfig = new Configuration().     StreamConfig cfg = new StreamConfig(new Configuration()).     MockSourceFunction srcFun = new MockSourceFunction().     cfg.setStreamOperator(new LifecycleTrackingStreamSource<>(srcFun, true)).     cfg.setOperatorID(new OperatorID()).     cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime).     Task task = StreamTaskTest.createTask(SourceStreamTask.class, cfg, taskManagerConfig).     task.startTaskThread().     LifecycleTrackingStreamSource.runStarted.await().     // wait for clean termination     task.getExecutingThread().join().     assertEquals(ExecutionState.FINISHED, task.getExecutionState()).     assertEquals(EXPECTED_CALL_ORDER_FULL, ACTUAL_ORDER_TRACKING). }
false;public;0;24;;@Test public void testLifeCycleCancel() throws Exception {     ACTUAL_ORDER_TRACKING.clear().     Configuration taskManagerConfig = new Configuration().     StreamConfig cfg = new StreamConfig(new Configuration()).     MockSourceFunction srcFun = new MockSourceFunction().     cfg.setStreamOperator(new LifecycleTrackingStreamSource<>(srcFun, false)).     cfg.setOperatorID(new OperatorID()).     cfg.setTimeCharacteristic(TimeCharacteristic.ProcessingTime).     Task task = StreamTaskTest.createTask(SourceStreamTask.class, cfg, taskManagerConfig).     task.startTaskThread().     LifecycleTrackingStreamSource.runStarted.await().     // this should cancel the task even though it is blocked on runFinished     task.cancelExecution().     // wait for clean termination     task.getExecutingThread().join().     assertEquals(ExecutionState.CANCELED, task.getExecutionState()).     assertEquals(EXPECTED_CALL_ORDER_CANCEL_RUNNING, ACTUAL_ORDER_TRACKING). }
false;public;1;4;;@Override public void run(SourceContext<Long> ctx) {     ACTUAL_ORDER_TRACKING.add("UDF::run"). }
false;public;0;4;;@Override public void cancel() {     ACTUAL_ORDER_TRACKING.add("UDF::cancel"). }
false;public;1;5;;@Override public void setRuntimeContext(RuntimeContext t) {     ACTUAL_ORDER_TRACKING.add("UDF::setRuntimeContext").     super.setRuntimeContext(t). }
false;public;1;5;;@Override public void open(Configuration parameters) throws Exception {     ACTUAL_ORDER_TRACKING.add("UDF::open").     super.open(parameters). }
false;public;0;5;;@Override public void close() throws Exception {     ACTUAL_ORDER_TRACKING.add("UDF::close").     super.close(). }
false;public;3;9;;@Override public void run(Object lockingObject, StreamStatusMaintainer streamStatusMaintainer, Output<StreamRecord<OUT>> collector) throws Exception {     ACTUAL_ORDER_TRACKING.add("OPERATOR::run").     super.run(lockingObject, streamStatusMaintainer, collector).     runStarted.trigger().     runFinish.await(). }
false;public;0;14;;@Override public void run() {     try {         runStarted.await().         if (getContainingTask().isCanceled() || getContainingTask().triggerCheckpoint(new CheckpointMetaData(0, System.currentTimeMillis()), CheckpointOptions.forCheckpointWithDefaultLocation())) {             LifecycleTrackingStreamSource.runFinish.trigger().         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail().     } }
false;public;3;24;;@Override public void setup(StreamTask<?, ?> containingTask, StreamConfig config, Output<StreamRecord<OUT>> output) {     ACTUAL_ORDER_TRACKING.add("OPERATOR::setup").     super.setup(containingTask, config, output).     if (simulateCheckpointing) {         testCheckpointer = new Thread() {              @Override             public void run() {                 try {                     runStarted.await().                     if (getContainingTask().isCanceled() || getContainingTask().triggerCheckpoint(new CheckpointMetaData(0, System.currentTimeMillis()), CheckpointOptions.forCheckpointWithDefaultLocation())) {                         LifecycleTrackingStreamSource.runFinish.trigger().                     }                 } catch (Exception e) {                     e.printStackTrace().                     Assert.fail().                 }             }         }.         testCheckpointer.start().     } }
false;public;1;5;;@Override public void snapshotState(StateSnapshotContext context) throws Exception {     ACTUAL_ORDER_TRACKING.add("OPERATOR::snapshotState").     super.snapshotState(context). }
false;public;1;5;;@Override public void initializeState(StateInitializationContext context) throws Exception {     ACTUAL_ORDER_TRACKING.add("OPERATOR::initializeState").     super.initializeState(context). }
false;public;1;5;;@Override public void prepareSnapshotPreBarrier(long checkpointId) throws Exception {     ACTUAL_ORDER_TRACKING.add("OPERATOR::prepareSnapshotPreBarrier").     super.prepareSnapshotPreBarrier(checkpointId). }
false;public;0;5;;@Override public void open() throws Exception {     ACTUAL_ORDER_TRACKING.add("OPERATOR::open").     super.open(). }
false;public;0;5;;@Override public void close() throws Exception {     ACTUAL_ORDER_TRACKING.add("OPERATOR::close").     super.close(). }
false;public;0;5;;@Override public void cancel() {     ACTUAL_ORDER_TRACKING.add("OPERATOR::cancel").     super.cancel(). }
false;public;0;8;;@Override public void dispose() throws Exception {     ACTUAL_ORDER_TRACKING.add("OPERATOR::dispose").     super.dispose().     if (simulateCheckpointing) {         testCheckpointer.join().     } }
