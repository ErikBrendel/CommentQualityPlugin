commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Before public void setUp() throws Exception {     loggingEvents = new ArrayList<>().     setupLogger().     targetDirectory = new ContentDump().     tmpDirectory = new ContentDump().     clock = new SettableClock().     setUpTestHarness(). }
false;public;0;8;;@After public void tearDown() throws Exception {     closeTestHarness().     if (logger != null) {         logger.removeAppender(testAppender).     }     loggingEvents = null. }
false;protected;1;4;;@Override protected void append(LoggingEvent event) {     loggingEvents.add(event). }
false;public;0;4;;@Override public void close() { }
false;public;0;4;;@Override public boolean requiresLayout() {     return false. }
true;private;0;22;/**  * Setup {@link org.apache.log4j.Logger}, the default logger implementation for tests,  * to append {@link LoggingEvent}s to {@link #loggingEvents} so that we can assert if  * the right messages were logged.  *  * @see #testLogTimeoutAlmostReachedWarningDuringCommit  * @see #testLogTimeoutAlmostReachedWarningDuringRecovery  */ ;/**  * Setup {@link org.apache.log4j.Logger}, the default logger implementation for tests,  * to append {@link LoggingEvent}s to {@link #loggingEvents} so that we can assert if  * the right messages were logged.  *  * @see #testLogTimeoutAlmostReachedWarningDuringCommit  * @see #testLogTimeoutAlmostReachedWarningDuringRecovery  */ private void setupLogger() {     Logger.getRootLogger().removeAllAppenders().     logger = Logger.getLogger(TwoPhaseCommitSinkFunction.class).     testAppender = new AppenderSkeleton() {          @Override         protected void append(LoggingEvent event) {             loggingEvents.add(event).         }          @Override         public void close() {         }          @Override         public boolean requiresLayout() {             return false.         }     }.     logger.addAppender(testAppender).     logger.setLevel(Level.WARN). }
false;private;0;5;;private void setUpTestHarness() throws Exception {     sinkFunction = new ContentDumpSinkFunction().     harness = new OneInputStreamOperatorTestHarness<>(new StreamSink<>(sinkFunction), StringSerializer.INSTANCE).     harness.setup(). }
false;private;0;3;;private void closeTestHarness() throws Exception {     harness.close(). }
false;public;0;14;;@Test public void testNotifyOfCompletedCheckpoint() throws Exception {     harness.open().     harness.processElement("42", 0).     harness.snapshot(0, 1).     harness.processElement("43", 2).     harness.snapshot(1, 3).     harness.processElement("44", 4).     harness.snapshot(2, 5).     harness.notifyOfCompletedCheckpoint(1).     assertExactlyOnce(Arrays.asList("42", "43")).     // one for checkpointId 2 and second for the currentTransaction     assertEquals(2, tmpDirectory.listFiles().size()). }
false;public;0;31;;@Test public void testFailBeforeNotify() throws Exception {     harness.open().     harness.processElement("42", 0).     harness.snapshot(0, 1).     harness.processElement("43", 2).     OperatorSubtaskState snapshot = harness.snapshot(1, 3).     tmpDirectory.setWritable(false).     try {         harness.processElement("44", 4).         harness.snapshot(2, 5).         fail("something should fail").     } catch (Exception ex) {         if (!(ex.getCause() instanceof ContentDump.NotWritableException)) {             throw ex.         }     // ignore     }     closeTestHarness().     tmpDirectory.setWritable(true).     setUpTestHarness().     harness.initializeState(snapshot).     assertExactlyOnce(Arrays.asList("42", "43")).     closeTestHarness().     assertEquals(0, tmpDirectory.listFiles().size()). }
false;public;0;31;;@Test public void testIgnoreCommitExceptionDuringRecovery() throws Exception {     clock.setEpochMilli(0).     harness.open().     harness.processElement("42", 0).     final OperatorSubtaskState snapshot = harness.snapshot(0, 1).     harness.notifyOfCompletedCheckpoint(1).     throwException.set(true).     closeTestHarness().     setUpTestHarness().     final long transactionTimeout = 1000.     sinkFunction.setTransactionTimeout(transactionTimeout).     sinkFunction.ignoreFailuresAfterTransactionTimeout().     try {         harness.initializeState(snapshot).         fail("Expected exception not thrown").     } catch (RuntimeException e) {         assertEquals("Expected exception", e.getMessage()).     }     clock.setEpochMilli(transactionTimeout + 1).     harness.initializeState(snapshot).     assertExactlyOnce(Collections.singletonList("42")). }
false;public;0;23;;@Test public void testLogTimeoutAlmostReachedWarningDuringCommit() throws Exception {     clock.setEpochMilli(0).     final long transactionTimeout = 1000.     final double warningRatio = 0.5.     sinkFunction.setTransactionTimeout(transactionTimeout).     sinkFunction.enableTransactionTimeoutWarnings(warningRatio).     harness.open().     harness.snapshot(0, 1).     final long elapsedTime = (long) ((double) transactionTimeout * warningRatio + 2).     clock.setEpochMilli(elapsedTime).     harness.notifyOfCompletedCheckpoint(1).     final List<String> logMessages = loggingEvents.stream().map(LoggingEvent::getRenderedMessage).collect(Collectors.toList()).     assertThat(logMessages, hasItem(containsString("has been open for 502 ms. " + "This is close to or even exceeding the transaction timeout of 1000 ms."))). }
false;public;0;33;;@Test public void testLogTimeoutAlmostReachedWarningDuringRecovery() throws Exception {     clock.setEpochMilli(0).     final long transactionTimeout = 1000.     final double warningRatio = 0.5.     sinkFunction.setTransactionTimeout(transactionTimeout).     sinkFunction.enableTransactionTimeoutWarnings(warningRatio).     harness.open().     final OperatorSubtaskState snapshot = harness.snapshot(0, 1).     final long elapsedTime = (long) ((double) transactionTimeout * warningRatio + 2).     clock.setEpochMilli(elapsedTime).     closeTestHarness().     setUpTestHarness().     sinkFunction.setTransactionTimeout(transactionTimeout).     sinkFunction.enableTransactionTimeoutWarnings(warningRatio).     harness.initializeState(snapshot).     harness.open().     final List<String> logMessages = loggingEvents.stream().map(LoggingEvent::getRenderedMessage).collect(Collectors.toList()).     closeTestHarness().     assertThat(logMessages, hasItem(containsString("has been open for 502 ms. " + "This is close to or even exceeding the transaction timeout of 1000 ms."))). }
false;private;1;9;;private void assertExactlyOnce(List<String> expectedValues) throws IOException {     ArrayList<String> actualValues = new ArrayList<>().     for (String name : targetDirectory.listFiles()) {         actualValues.addAll(targetDirectory.read(name)).     }     Collections.sort(actualValues).     Collections.sort(expectedValues).     assertEquals(expectedValues, actualValues). }
false;protected;3;4;;@Override protected void invoke(ContentTransaction transaction, String value, Context context) throws Exception {     transaction.tmpContentWriter.write(value). }
false;protected;0;4;;@Override protected ContentTransaction beginTransaction() throws Exception {     return new ContentTransaction(tmpDirectory.createWriter(UUID.randomUUID().toString())). }
false;protected;1;5;;@Override protected void preCommit(ContentTransaction transaction) throws Exception {     transaction.tmpContentWriter.flush().     transaction.tmpContentWriter.close(). }
false;protected;1;12;;@Override protected void commit(ContentTransaction transaction) {     if (throwException.get()) {         throw new RuntimeException("Expected exception").     }     ContentDump.move(transaction.tmpContentWriter.getName(), tmpDirectory, targetDirectory). }
false;protected;1;5;;@Override protected void abort(ContentTransaction transaction) {     transaction.tmpContentWriter.close().     tmpDirectory.delete(transaction.tmpContentWriter.getName()). }
false;public;0;4;;@Override public String toString() {     return String.format("ContentTransaction[%s]", tmpContentWriter.getName()). }
false;public;1;3;;public void setEpochMilli(long epochMilli) {     this.epochMilli = epochMilli. }
false;public;0;4;;@Override public ZoneId getZone() {     return zoneId. }
false;public;1;7;;@Override public Clock withZone(ZoneId zone) {     if (zone.equals(this.zoneId)) {         return this.     }     return new SettableClock(zone, epochMilli). }
false;public;0;4;;@Override public Instant instant() {     return Instant.ofEpochMilli(epochMilli). }
