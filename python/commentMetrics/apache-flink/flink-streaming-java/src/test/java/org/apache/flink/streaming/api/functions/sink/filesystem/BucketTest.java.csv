commented;modifiers;parameterAmount;loc;comment;code
false;public;0;17;;@Test public void shouldNotCleanupResumablesThatArePartOfTheAckedCheckpoint() throws IOException {     final File outDir = TEMP_FOLDER.newFolder().     final Path path = new Path(outDir.toURI()).     final TestRecoverableWriter recoverableWriter = getRecoverableWriter(path).     final Bucket<String, String> bucketUnderTest = createBucket(recoverableWriter, path, 0, 0).     bucketUnderTest.write("test-element", 0L).     final BucketState<String> state = bucketUnderTest.onReceptionOfCheckpoint(0L).     assertThat(state, hasActiveInProgressFile()).     bucketUnderTest.onSuccessfulCompletionOfCheckpoint(0L).     // it did not discard as this is still valid.     assertThat(recoverableWriter, hasCalledDiscard(0)). }
false;public;0;22;;@Test public void shouldCleanupOutdatedResumablesOnCheckpointAck() throws IOException {     final File outDir = TEMP_FOLDER.newFolder().     final Path path = new Path(outDir.toURI()).     final TestRecoverableWriter recoverableWriter = getRecoverableWriter(path).     final Bucket<String, String> bucketUnderTest = createBucket(recoverableWriter, path, 0, 0).     bucketUnderTest.write("test-element", 0L).     final BucketState<String> state = bucketUnderTest.onReceptionOfCheckpoint(0L).     assertThat(state, hasActiveInProgressFile()).     bucketUnderTest.onSuccessfulCompletionOfCheckpoint(0L).     bucketUnderTest.onReceptionOfCheckpoint(1L).     bucketUnderTest.onReceptionOfCheckpoint(2L).     bucketUnderTest.onSuccessfulCompletionOfCheckpoint(2L).     // that is for checkpoints 0 and 1     assertThat(recoverableWriter, hasCalledDiscard(2)). }
false;public;0;21;;@Test public void shouldCleanupResumableAfterRestoring() throws Exception {     final File outDir = TEMP_FOLDER.newFolder().     final Path path = new Path(outDir.toURI()).     final TestRecoverableWriter recoverableWriter = getRecoverableWriter(path).     final Bucket<String, String> bucketUnderTest = createBucket(recoverableWriter, path, 0, 0).     bucketUnderTest.write("test-element", 0L).     final BucketState<String> state = bucketUnderTest.onReceptionOfCheckpoint(0L).     assertThat(state, hasActiveInProgressFile()).     bucketUnderTest.onSuccessfulCompletionOfCheckpoint(0L).     final TestRecoverableWriter newRecoverableWriter = getRecoverableWriter(path).     restoreBucket(newRecoverableWriter, 0, 1, state).     // that is for checkpoints 0 and 1     assertThat(newRecoverableWriter, hasCalledDiscard(1)). }
false;public;0;18;;@Test public void shouldNotCallCleanupWithoutInProgressPartFiles() throws Exception {     final File outDir = TEMP_FOLDER.newFolder().     final Path path = new Path(outDir.toURI()).     final TestRecoverableWriter recoverableWriter = getRecoverableWriter(path).     final Bucket<String, String> bucketUnderTest = createBucket(recoverableWriter, path, 0, 0).     final BucketState<String> state = bucketUnderTest.onReceptionOfCheckpoint(0L).     assertThat(state, hasNoActiveInProgressFile()).     bucketUnderTest.onReceptionOfCheckpoint(1L).     bucketUnderTest.onReceptionOfCheckpoint(2L).     bucketUnderTest.onSuccessfulCompletionOfCheckpoint(2L).     // we have no in-progress file.     assertThat(recoverableWriter, hasCalledDiscard(0)). }
false;public;0;8;;// --------------------------- Checking Restore --------------------------- @Test public void inProgressFileShouldBeCommittedIfWriterDoesNotSupportResume() throws IOException {     final StubNonResumableWriter nonResumableWriter = new StubNonResumableWriter().     final Bucket<String, String> bucket = getRestoredBucketWithOnlyInProgressPart(nonResumableWriter).     Assert.assertThat(nonResumableWriter, hasMethodCallCountersEqualTo(1, 0, 1)).     Assert.assertThat(bucket, hasNullInProgressFile(true)). }
false;public;0;8;;@Test public void inProgressFileShouldBeRestoredIfWriterSupportsResume() throws IOException {     final StubResumableWriter resumableWriter = new StubResumableWriter().     final Bucket<String, String> bucket = getRestoredBucketWithOnlyInProgressPart(resumableWriter).     Assert.assertThat(resumableWriter, hasMethodCallCountersEqualTo(1, 1, 0)).     Assert.assertThat(bucket, hasNullInProgressFile(false)). }
false;public;0;10;;@Test public void pendingFilesShouldBeRestored() throws IOException {     final int expectedRecoverForCommitCounter = 10.     final StubNonResumableWriter writer = new StubNonResumableWriter().     final Bucket<String, String> bucket = getRestoredBucketWithOnlyPendingParts(writer, expectedRecoverForCommitCounter).     Assert.assertThat(writer, hasMethodCallCountersEqualTo(0, 0, expectedRecoverForCommitCounter)).     Assert.assertThat(bucket, hasNullInProgressFile(true)). }
false;protected;1;4;;@Override protected boolean matchesSafely(TestRecoverableWriter writer) {     return writer.getCleanupCallCounter() == times. }
false;public;1;7;;@Override public void describeTo(Description description) {     description.appendText("the TestRecoverableWriter to have called discardRecoverableState() ").appendValue(times).appendText(" times."). }
false;private,static;1;16;;// ------------------------------- Matchers -------------------------------- private static TypeSafeMatcher<TestRecoverableWriter> hasCalledDiscard(int times) {     return new TypeSafeMatcher<TestRecoverableWriter>() {          @Override         protected boolean matchesSafely(TestRecoverableWriter writer) {             return writer.getCleanupCallCounter() == times.         }          @Override         public void describeTo(Description description) {             description.appendText("the TestRecoverableWriter to have called discardRecoverableState() ").appendValue(times).appendText(" times.").         }     }. }
false;protected;1;4;;@Override protected boolean matchesSafely(BucketState<String> state) {     return state.getInProgressResumableFile() != null. }
false;public;1;4;;@Override public void describeTo(Description description) {     description.appendText("a BucketState with active in-progress file."). }
false;private,static;0;13;;private static TypeSafeMatcher<BucketState<String>> hasActiveInProgressFile() {     return new TypeSafeMatcher<BucketState<String>>() {          @Override         protected boolean matchesSafely(BucketState<String> state) {             return state.getInProgressResumableFile() != null.         }          @Override         public void describeTo(Description description) {             description.appendText("a BucketState with active in-progress file.").         }     }. }
false;protected;1;4;;@Override protected boolean matchesSafely(BucketState<String> state) {     return state.getInProgressResumableFile() == null. }
false;public;1;4;;@Override public void describeTo(Description description) {     description.appendText("a BucketState with no active in-progress file."). }
false;private,static;0;13;;private static TypeSafeMatcher<BucketState<String>> hasNoActiveInProgressFile() {     return new TypeSafeMatcher<BucketState<String>>() {          @Override         protected boolean matchesSafely(BucketState<String> state) {             return state.getInProgressResumableFile() == null.         }          @Override         public void describeTo(Description description) {             description.appendText("a BucketState with no active in-progress file.").         }     }. }
false;protected;1;5;;@Override protected boolean matchesSafely(Bucket<String, String> bucket) {     final PartFileWriter<String, String> inProgressPart = bucket.getInProgressPart().     return isNull == (inProgressPart == null). }
false;public;1;5;;@Override public void describeTo(Description description) {     description.appendText("a Bucket with its inProgressPart being ").appendText(isNull ? " null." : " not null."). }
false;private,static;1;16;;private static TypeSafeMatcher<Bucket<String, String>> hasNullInProgressFile(final boolean isNull) {     return new TypeSafeMatcher<Bucket<String, String>>() {          @Override         protected boolean matchesSafely(Bucket<String, String> bucket) {             final PartFileWriter<String, String> inProgressPart = bucket.getInProgressPart().             return isNull == (inProgressPart == null).         }          @Override         public void describeTo(Description description) {             description.appendText("a Bucket with its inProgressPart being ").appendText(isNull ? " null." : " not null.").         }     }. }
false;protected;1;6;;@Override protected boolean matchesSafely(BaseStubWriter writer) {     return writer.getSupportsResumeCallCounter() == supportsResumeCalls && writer.getRecoverCallCounter() == recoverCalls && writer.getRecoverForCommitCallCounter() == recoverForCommitCalls. }
false;public;1;8;;@Override public void describeTo(Description description) {     description.appendText("a Writer where:").appendText(" supportsResume was called ").appendValue(supportsResumeCalls).appendText(" times,").appendText(" recover was called ").appendValue(recoverCalls).appendText(" times,").appendText(" and recoverForCommit was called ").appendValue(recoverForCommitCalls).appendText(" times.").appendText("'"). }
false;private,static;3;23;;private static TypeSafeMatcher<BaseStubWriter> hasMethodCallCountersEqualTo(final int supportsResumeCalls, final int recoverCalls, final int recoverForCommitCalls) {     return new TypeSafeMatcher<BaseStubWriter>() {          @Override         protected boolean matchesSafely(BaseStubWriter writer) {             return writer.getSupportsResumeCallCounter() == supportsResumeCalls && writer.getRecoverCallCounter() == recoverCalls && writer.getRecoverForCommitCallCounter() == recoverForCommitCalls.         }          @Override         public void describeTo(Description description) {             description.appendText("a Writer where:").appendText(" supportsResume was called ").appendValue(supportsResumeCalls).appendText(" times,").appendText(" recover was called ").appendValue(recoverCalls).appendText(" times,").appendText(" and recoverForCommit was called ").appendValue(recoverForCommitCalls).appendText(" times.").appendText("'").         }     }. }
false;;0;3;;int getCleanupCallCounter() {     return cleanupCallCounter. }
false;public;0;5;;@Override public boolean requiresCleanupOfRecoverableState() {     // here we return true so that the cleanupRecoverableState() is called.     return true. }
false;public;1;5;;@Override public boolean cleanupRecoverableState(ResumeRecoverable resumable) throws IOException {     cleanupCallCounter++.     return false. }
false;public;0;4;;@Override public String toString() {     return "TestRecoverableWriter has called discardRecoverableState() " + cleanupCallCounter + " times.". }
false;;0;3;;int getSupportsResumeCallCounter() {     return supportsResumeCallCounter. }
false;;0;3;;int getRecoverCallCounter() {     return recoverCallCounter. }
false;;0;3;;int getRecoverForCommitCallCounter() {     return recoverForCommitCallCounter. }
false;public;1;5;;@Override public RecoverableFsDataOutputStream recover(ResumeRecoverable resumable) throws IOException {     recoverCallCounter++.     return new NoOpRecoverableFsDataOutputStream(). }
false;public;1;6;;@Override public RecoverableFsDataOutputStream.Committer recoverForCommit(CommitRecoverable resumable) throws IOException {     checkArgument(resumable instanceof NoOpRecoverable).     recoverForCommitCallCounter++.     return new NoOpCommitter(). }
false;public;0;5;;@Override public boolean supportsResume() {     supportsResumeCallCounter++.     return supportsResume. }
false;private,static;4;15;;private static Bucket<String, String> createBucket(final RecoverableWriter writer, final Path bucketPath, final int subtaskIdx, final int initialPartCounter) {     return Bucket.getNew(writer, subtaskIdx, bucketId, bucketPath, initialPartCounter, partFileFactory, rollingPolicy). }
false;private,static;4;15;;private static Bucket<String, String> restoreBucket(final RecoverableWriter writer, final int subtaskIndex, final long initialPartCounter, final BucketState<String> bucketState) throws Exception {     return Bucket.restore(writer, subtaskIndex, initialPartCounter, partFileFactory, rollingPolicy, bucketState). }
false;private,static;1;12;;private static TestRecoverableWriter getRecoverableWriter(Path path) {     try {         final FileSystem fs = FileSystem.get(path.toUri()).         if (!(fs instanceof LocalFileSystem)) {             fail("Expected Local FS but got a " + fs.getClass().getName() + " for path: " + path).         }         return new TestRecoverableWriter((LocalFileSystem) fs).     } catch (IOException e) {         fail().     }     return null. }
false;private;1;5;;private Bucket<String, String> getRestoredBucketWithOnlyInProgressPart(final BaseStubWriter writer) throws IOException {     final BucketState<String> stateWithOnlyInProgressFile = new BucketState<>("test", new Path(), 12345L, new NoOpRecoverable(), new HashMap<>()).     return Bucket.restore(writer, 0, 1L, partFileFactory, rollingPolicy, stateWithOnlyInProgressFile). }
false;private;2;8;;private Bucket<String, String> getRestoredBucketWithOnlyPendingParts(final BaseStubWriter writer, final int numberOfPendingParts) throws IOException {     final Map<Long, List<RecoverableWriter.CommitRecoverable>> completePartsPerCheckpoint = createPendingPartsPerCheckpoint(numberOfPendingParts).     final BucketState<String> initStateWithOnlyInProgressFile = new BucketState<>("test", new Path(), 12345L, null, completePartsPerCheckpoint).     return Bucket.restore(writer, 0, 1L, partFileFactory, rollingPolicy, initStateWithOnlyInProgressFile). }
false;private;1;9;;private Map<Long, List<RecoverableWriter.CommitRecoverable>> createPendingPartsPerCheckpoint(int noOfCheckpoints) {     final Map<Long, List<RecoverableWriter.CommitRecoverable>> pendingCommittablesPerCheckpoint = new HashMap<>().     for (int checkpointId = 0. checkpointId < noOfCheckpoints. checkpointId++) {         final List<RecoverableWriter.CommitRecoverable> pending = new ArrayList<>().         pending.add(new NoOpRecoverable()).         pendingCommittablesPerCheckpoint.put((long) checkpointId, pending).     }     return pendingCommittablesPerCheckpoint. }
