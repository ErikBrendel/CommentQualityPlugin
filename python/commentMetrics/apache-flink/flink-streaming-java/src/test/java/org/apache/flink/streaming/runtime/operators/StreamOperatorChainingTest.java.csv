commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Test public void testMultiChainingWithObjectReuse() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.getConfig().enableObjectReuse().     testMultiChaining(env). }
false;public;0;7;;@Test public void testMultiChainingWithoutObjectReuse() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.getConfig().disableObjectReuse().     testMultiChaining(env). }
false;public;2;4;;@Override public void invoke(String value, Context ctx) throws Exception {     sink1Results.add(value). }
false;public;2;4;;@Override public void invoke(String value, Context ctx) throws Exception {     sink2Results.add(value). }
true;private;1;65;/**  * Verify that multi-chaining works.  */ ;/**  * Verify that multi-chaining works.  */ private void testMultiChaining(StreamExecutionEnvironment env) throws Exception {     // the actual elements will not be used     DataStream<Integer> input = env.fromElements(1, 2, 3).     sink1Results = new ArrayList<>().     sink2Results = new ArrayList<>().     input = input.map(value -> value).     input.map(value -> "First: " + value).addSink(new SinkFunction<String>() {          @Override         public void invoke(String value, Context ctx) throws Exception {             sink1Results.add(value).         }     }).     input.map(value -> "Second: " + value).addSink(new SinkFunction<String>() {          @Override         public void invoke(String value, Context ctx) throws Exception {             sink2Results.add(value).         }     }).     // be build our own StreamTask and OperatorChain     JobGraph jobGraph = env.getStreamGraph().getJobGraph().     Assert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2).     JobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1).     Configuration configuration = chainedVertex.getConfiguration().     StreamConfig streamConfig = new StreamConfig(configuration).     StreamMap<Integer, Integer> headOperator = streamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader()).     try (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {         StreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment).         OperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask).         headOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint()).         for (StreamOperator<?> operator : operatorChain.getAllOperators()) {             if (operator != null) {                 operator.open().             }         }         headOperator.processElement(new StreamRecord<>(1)).         headOperator.processElement(new StreamRecord<>(2)).         headOperator.processElement(new StreamRecord<>(3)).         assertThat(sink1Results, contains("First: 1", "First: 2", "First: 3")).         assertThat(sink2Results, contains("Second: 1", "Second: 2", "Second: 3")).     } }
false;private;1;8;;private MockEnvironment createMockEnvironment(String taskName) {     return new MockEnvironmentBuilder().setTaskName(taskName).setMemorySize(3 * 1024 * 1024).setInputSplitProvider(new MockInputSplitProvider()).setBufferSize(1024).build(). }
false;public;0;7;;@Test public void testMultiChainingWithSplitWithObjectReuse() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.getConfig().enableObjectReuse().     testMultiChainingWithSplit(env). }
false;public;0;7;;@Test public void testMultiChainingWithSplitWithoutObjectReuse() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.getConfig().disableObjectReuse().     testMultiChainingWithSplit(env). }
false;public;1;8;;@Override public Iterable<String> select(Integer value) {     if (value.equals(1)) {         return Collections.singletonList("one").     } else {         return Collections.singletonList("other").     } }
false;public;2;4;;@Override public void invoke(String value, Context ctx) throws Exception {     sink1Results.add(value). }
false;public;2;4;;@Override public void invoke(String value, Context ctx) throws Exception {     sink2Results.add(value). }
false;public;2;4;;@Override public void invoke(String value, Context ctx) throws Exception {     sink3Results.add(value). }
true;private;1;90;/**  * Verify that multi-chaining works with object reuse enabled.  */ ;/**  * Verify that multi-chaining works with object reuse enabled.  */ private void testMultiChainingWithSplit(StreamExecutionEnvironment env) throws Exception {     // the actual elements will not be used     DataStream<Integer> input = env.fromElements(1, 2, 3).     sink1Results = new ArrayList<>().     sink2Results = new ArrayList<>().     sink3Results = new ArrayList<>().     input = input.map(value -> value).     SplitStream<Integer> split = input.split(new OutputSelector<Integer>() {          private static final long serialVersionUID = 1L.          @Override         public Iterable<String> select(Integer value) {             if (value.equals(1)) {                 return Collections.singletonList("one").             } else {                 return Collections.singletonList("other").             }         }     }).     split.select("one").map(value -> "First 1: " + value).addSink(new SinkFunction<String>() {          @Override         public void invoke(String value, Context ctx) throws Exception {             sink1Results.add(value).         }     }).     split.select("one").map(value -> "First 2: " + value).addSink(new SinkFunction<String>() {          @Override         public void invoke(String value, Context ctx) throws Exception {             sink2Results.add(value).         }     }).     split.select("other").map(value -> "Second: " + value).addSink(new SinkFunction<String>() {          @Override         public void invoke(String value, Context ctx) throws Exception {             sink3Results.add(value).         }     }).     // be build our own StreamTask and OperatorChain     JobGraph jobGraph = env.getStreamGraph().getJobGraph().     Assert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 2).     JobVertex chainedVertex = jobGraph.getVerticesSortedTopologicallyFromSources().get(1).     Configuration configuration = chainedVertex.getConfiguration().     StreamConfig streamConfig = new StreamConfig(configuration).     StreamMap<Integer, Integer> headOperator = streamConfig.getStreamOperator(Thread.currentThread().getContextClassLoader()).     try (MockEnvironment environment = createMockEnvironment(chainedVertex.getName())) {         StreamTask<Integer, StreamMap<Integer, Integer>> mockTask = createMockTask(streamConfig, environment).         OperatorChain<Integer, StreamMap<Integer, Integer>> operatorChain = createOperatorChain(streamConfig, environment, mockTask).         headOperator.setup(mockTask, streamConfig, operatorChain.getChainEntryPoint()).         for (StreamOperator<?> operator : operatorChain.getAllOperators()) {             if (operator != null) {                 operator.open().             }         }         headOperator.processElement(new StreamRecord<>(1)).         headOperator.processElement(new StreamRecord<>(2)).         headOperator.processElement(new StreamRecord<>(3)).         assertThat(sink1Results, contains("First 1: 1")).         assertThat(sink2Results, contains("First 2: 1")).         assertThat(sink3Results, contains("Second: 2", "Second: 3")).     } }
false;private;3;6;;private <IN, OT extends StreamOperator<IN>> OperatorChain<IN, OT> createOperatorChain(StreamConfig streamConfig, Environment environment, StreamTask<IN, OT> task) {     return new OperatorChain<>(task, StreamTask.createRecordWriters(streamConfig, environment)). }
false;private;2;10;;private <IN, OT extends StreamOperator<IN>> StreamTask<IN, OT> createMockTask(StreamConfig streamConfig, Environment environment) throws Exception {     // noinspection unchecked     return new MockStreamTaskBuilder(environment).setConfig(streamConfig).setExecutionConfig(new ExecutionConfig().enableObjectReuse()).build(). }
