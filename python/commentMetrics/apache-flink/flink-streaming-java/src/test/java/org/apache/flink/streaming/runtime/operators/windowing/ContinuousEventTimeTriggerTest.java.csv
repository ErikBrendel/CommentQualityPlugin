commented;modifiers;parameterAmount;loc;comment;code
true;public;0;19;/**  * Verify that the trigger doesn't fail with an NPE if we insert a timer firing when there is  * no trigger state.  */ ;/**  * Verify that the trigger doesn't fail with an NPE if we insert a timer firing when there is  * no trigger state.  */ @Test public void testTriggerHandlesAllOnTimerCalls() throws Exception {     TriggerTestHarness<Object, TimeWindow> testHarness = new TriggerTestHarness<>(ContinuousEventTimeTrigger.<TimeWindow>of(Time.milliseconds(5)), new TimeWindow.Serializer()).     assertEquals(0, testHarness.numStateEntries()).     assertEquals(0, testHarness.numProcessingTimeTimers()).     assertEquals(0, testHarness.numEventTimeTimers()).     // this will make the elements we now process fall into late windows, i.e. no trigger state     // will be created     testHarness.advanceWatermark(10).     // late fires immediately     assertEquals(TriggerResult.FIRE, testHarness.processElement(new StreamRecord<Object>(1), new TimeWindow(0, 2))).     // simulate a GC timer firing     testHarness.invokeOnEventTime(20, new TimeWindow(0, 2)). }
true;public;0;48;/**  * Verify that state &lt.TimeWindow&gt.of separate windows does not leak into other windows.  */ ;/**  * Verify that state &lt.TimeWindow&gt.of separate windows does not leak into other windows.  */ @Test public void testWindowSeparationAndFiring() throws Exception {     TriggerTestHarness<Object, TimeWindow> testHarness = new TriggerTestHarness<>(ContinuousEventTimeTrigger.<TimeWindow>of(Time.hours(1)), new TimeWindow.Serializer()).     // inject several elements     assertEquals(TriggerResult.CONTINUE, testHarness.processElement(new StreamRecord<Object>(1), new TimeWindow(0, 2))).     assertEquals(TriggerResult.CONTINUE, testHarness.processElement(new StreamRecord<Object>(1), new TimeWindow(0, 2))).     assertEquals(TriggerResult.CONTINUE, testHarness.processElement(new StreamRecord<Object>(1), new TimeWindow(0, 2))).     assertEquals(TriggerResult.CONTINUE, testHarness.processElement(new StreamRecord<Object>(1), new TimeWindow(2, 4))).     assertEquals(TriggerResult.CONTINUE, testHarness.processElement(new StreamRecord<Object>(1), new TimeWindow(2, 4))).     assertEquals(2, testHarness.numStateEntries()).     assertEquals(0, testHarness.numProcessingTimeTimers()).     assertEquals(4, testHarness.numEventTimeTimers()).     assertEquals(2, testHarness.numEventTimeTimers(new TimeWindow(0, 2))).     assertEquals(2, testHarness.numEventTimeTimers(new TimeWindow(2, 4))).     Collection<Tuple2<TimeWindow, TriggerResult>> triggerResults = testHarness.advanceWatermark(2).     boolean sawFiring = false.     for (Tuple2<TimeWindow, TriggerResult> r : triggerResults) {         if (r.f0.equals(new TimeWindow(0, 2))) {             sawFiring = true.             assertTrue(r.f1.equals(TriggerResult.FIRE)).         }     }     assertTrue(sawFiring).     assertEquals(2, testHarness.numStateEntries()).     assertEquals(0, testHarness.numProcessingTimeTimers()).     assertEquals(3, testHarness.numEventTimeTimers()).     assertEquals(1, testHarness.numEventTimeTimers(new TimeWindow(0, 2))).     assertEquals(2, testHarness.numEventTimeTimers(new TimeWindow(2, 4))).     triggerResults = testHarness.advanceWatermark(4).     sawFiring = false.     for (Tuple2<TimeWindow, TriggerResult> r : triggerResults) {         if (r.f0.equals(new TimeWindow(2, 4))) {             sawFiring = true.             assertTrue(r.f1.equals(TriggerResult.FIRE)).         }     }     assertTrue(sawFiring).     assertEquals(2, testHarness.numStateEntries()).     assertEquals(0, testHarness.numProcessingTimeTimers()).     assertEquals(2, testHarness.numEventTimeTimers()). }
true;public;0;13;/**  * Verify that late elements trigger immediately and also that we don't set a timer  * for those.  */ ;/**  * Verify that late elements trigger immediately and also that we don't set a timer  * for those.  */ @Test public void testLateElementTriggersImmediately() throws Exception {     TriggerTestHarness<Object, TimeWindow> testHarness = new TriggerTestHarness<>(ContinuousEventTimeTrigger.<TimeWindow>of(Time.hours(1)), new TimeWindow.Serializer()).     testHarness.advanceWatermark(2).     assertEquals(TriggerResult.FIRE, testHarness.processElement(new StreamRecord<Object>(1), new TimeWindow(0, 2))).     assertEquals(0, testHarness.numStateEntries()).     assertEquals(0, testHarness.numProcessingTimeTimers()).     assertEquals(0, testHarness.numEventTimeTimers()). }
true;public;0;28;/**  * Verify that clear() does not leak across windows.  */ ;/**  * Verify that clear() does not leak across windows.  */ @Test public void testClear() throws Exception {     TriggerTestHarness<Object, TimeWindow> testHarness = new TriggerTestHarness<>(ContinuousEventTimeTrigger.<TimeWindow>of(Time.hours(1)), new TimeWindow.Serializer()).     assertEquals(TriggerResult.CONTINUE, testHarness.processElement(new StreamRecord<Object>(1), new TimeWindow(0, 2))).     assertEquals(TriggerResult.CONTINUE, testHarness.processElement(new StreamRecord<Object>(1), new TimeWindow(2, 4))).     assertEquals(2, testHarness.numStateEntries()).     assertEquals(0, testHarness.numProcessingTimeTimers()).     assertEquals(4, testHarness.numEventTimeTimers()).     assertEquals(2, testHarness.numEventTimeTimers(new TimeWindow(0, 2))).     assertEquals(2, testHarness.numEventTimeTimers(new TimeWindow(2, 4))).     testHarness.clearTriggerState(new TimeWindow(2, 4)).     assertEquals(1, testHarness.numStateEntries()).     assertEquals(0, testHarness.numProcessingTimeTimers()).     assertEquals(3, testHarness.numEventTimeTimers()).     assertEquals(2, testHarness.numEventTimeTimers(new TimeWindow(0, 2))).     assertEquals(1, testHarness.numEventTimeTimers(new TimeWindow(2, 4))).     testHarness.clearTriggerState(new TimeWindow(0, 2)).     assertEquals(0, testHarness.numStateEntries()).     assertEquals(0, testHarness.numProcessingTimeTimers()).     // doesn't clean up timers     assertEquals(2, testHarness.numEventTimeTimers()). }
false;public;0;40;;@Test public void testMergingWindows() throws Exception {     TriggerTestHarness<Object, TimeWindow> testHarness = new TriggerTestHarness<>(ContinuousEventTimeTrigger.<TimeWindow>of(Time.hours(1)), new TimeWindow.Serializer()).     assertTrue(ContinuousEventTimeTrigger.<TimeWindow>of(Time.hours(1)).canMerge()).     assertEquals(TriggerResult.CONTINUE, testHarness.processElement(new StreamRecord<Object>(1), new TimeWindow(0, 2))).     assertEquals(TriggerResult.CONTINUE, testHarness.processElement(new StreamRecord<Object>(1), new TimeWindow(2, 4))).     assertEquals(2, testHarness.numStateEntries()).     assertEquals(0, testHarness.numProcessingTimeTimers()).     assertEquals(4, testHarness.numEventTimeTimers()).     assertEquals(2, testHarness.numEventTimeTimers(new TimeWindow(0, 2))).     assertEquals(2, testHarness.numEventTimeTimers(new TimeWindow(2, 4))).     testHarness.mergeWindows(new TimeWindow(0, 4), Lists.newArrayList(new TimeWindow(0, 2), new TimeWindow(2, 4))).     assertEquals(1, testHarness.numStateEntries()).     assertEquals(0, testHarness.numProcessingTimeTimers()).     // on merging, timers are not cleaned up     assertEquals(5, testHarness.numEventTimeTimers()).     assertEquals(2, testHarness.numEventTimeTimers(new TimeWindow(0, 2))).     assertEquals(2, testHarness.numEventTimeTimers(new TimeWindow(2, 4))).     assertEquals(1, testHarness.numEventTimeTimers(new TimeWindow(0, 4))).     Collection<Tuple2<TimeWindow, TriggerResult>> triggerResults = testHarness.advanceWatermark(4).     boolean sawFiring = false.     for (Tuple2<TimeWindow, TriggerResult> r : triggerResults) {         if (r.f0.equals(new TimeWindow(0, 4))) {             sawFiring = true.             assertTrue(r.f1.equals(TriggerResult.FIRE)).         }     }     assertTrue(sawFiring).     assertEquals(1, testHarness.numStateEntries()).     assertEquals(0, testHarness.numProcessingTimeTimers()).     assertEquals(1, testHarness.numEventTimeTimers()). }
