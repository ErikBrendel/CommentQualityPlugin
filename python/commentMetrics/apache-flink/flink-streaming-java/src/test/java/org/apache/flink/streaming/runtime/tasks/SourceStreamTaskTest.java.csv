commented;modifiers;parameterAmount;loc;comment;code
true;public;0;21;/**  * This test verifies that open() and close() are correctly called by the StreamTask.  */ ;/**  * This test verifies that open() and close() are correctly called by the StreamTask.  */ @Test @SuppressWarnings("unchecked") public void testOpenClose() throws Exception {     final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(SourceStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO).     testHarness.setupOutputForSingletonOperatorChain().     StreamConfig streamConfig = testHarness.getStreamConfig().     StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource()).     streamConfig.setStreamOperator(sourceOperator).     streamConfig.setOperatorID(new OperatorID()).     testHarness.invoke().     testHarness.waitForTaskCompletion().     Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled).     List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput()).     Assert.assertEquals(10, resultElements.size()). }
true;public;0;57;/**  * This test ensures that the SourceStreamTask properly serializes checkpointing  * and element emission. This also verifies that there are no concurrent invocations  * of the checkpoint method on the source operator.  *  * <p>The source emits elements and performs checkpoints. We have several checkpointer threads  * that fire checkpoint requests at the source task.  *  * <p>If element emission and checkpointing are not in series the count of elements at the  * beginning of a checkpoint and at the end of a checkpoint are not the same because the  * source kept emitting elements while the checkpoint was ongoing.  */ ;/**  * This test ensures that the SourceStreamTask properly serializes checkpointing  * and element emission. This also verifies that there are no concurrent invocations  * of the checkpoint method on the source operator.  *  * <p>The source emits elements and performs checkpoints. We have several checkpointer threads  * that fire checkpoint requests at the source task.  *  * <p>If element emission and checkpointing are not in series the count of elements at the  * beginning of a checkpoint and at the end of a checkpoint are not the same because the  * source kept emitting elements while the checkpoint was ongoing.  */ @Test @SuppressWarnings("unchecked") public void testCheckpointing() throws Exception {     final int numElements = 100.     final int numCheckpoints = 100.     final int numCheckpointers = 1.     // in ms     final int checkpointInterval = 5.     // how many random values we sum up in storeCheckpoint     final int sourceCheckpointDelay = 1000.     // in ms     final int sourceReadDelay = 1.     ExecutorService executor = Executors.newFixedThreadPool(10).     try {         final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO).         final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<>(SourceStreamTask::new, typeInfo).         testHarness.setupOutputForSingletonOperatorChain().         StreamConfig streamConfig = testHarness.getStreamConfig().         StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(numElements, sourceCheckpointDelay, sourceReadDelay)).         streamConfig.setStreamOperator(sourceOperator).         streamConfig.setOperatorID(new OperatorID()).         // prepare the         Future<Boolean>[] checkpointerResults = new Future[numCheckpointers].         // invoke this first, so the tasks are actually running when the checkpoints are scheduled         testHarness.invoke().         testHarness.waitForTaskRunning().         final StreamTask<Tuple2<Long, Integer>, ?> sourceTask = testHarness.getTask().         for (int i = 0. i < numCheckpointers. i++) {             checkpointerResults[i] = executor.submit(new Checkpointer(numCheckpoints, checkpointInterval, sourceTask)).         }         testHarness.waitForTaskCompletion().         // will be rethrown here         for (int i = 0. i < numCheckpointers. i++) {             if (!checkpointerResults[i].isDone()) {                 checkpointerResults[i].cancel(true).             }             if (!checkpointerResults[i].isCancelled()) {                 checkpointerResults[i].get().             }         }         List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput()).         Assert.assertEquals(numElements, resultElements.size()).     } finally {         executor.shutdown().     } }
false;public;1;19;;@Override public void run(SourceContext<Tuple2<Long, Integer>> ctx) {     final Object lockObject = ctx.getCheckpointLock().     while (isRunning && count < maxElements) {         // simulate some work         try {             Thread.sleep(readDelay).         } catch (InterruptedException e) {             // ignore and reset interruption state             Thread.currentThread().interrupt().         }         synchronized (lockObject) {             ctx.collect(new Tuple2<Long, Integer>(lastCheckpointId, count)).             count++.         }     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;2;21;;@Override public List<Serializable> snapshotState(long checkpointId, long timestamp) throws Exception {     if (!semaphore.tryAcquire()) {         Assert.fail("Concurrent invocation of snapshotState.").     }     int startCount = count.     lastCheckpointId = checkpointId.     long sum = 0.     for (int i = 0. i < checkpointDelay. i++) {         sum += new Random().nextLong().     }     if (startCount != count) {         semaphore.release().         // This means that next() was invoked while the snapshot was ongoing         Assert.fail("Count is different at start end end of snapshot.").     }     semaphore.release().     return Collections.<Serializable>singletonList(sum). }
false;public;1;3;;@Override public void restoreState(List<Serializable> state) throws Exception { }
false;public;0;10;;@Override public Boolean call() throws Exception {     for (int i = 0. i < numCheckpoints. i++) {         long currentCheckpointId = checkpointId.getAndIncrement().         CheckpointMetaData checkpointMetaData = new CheckpointMetaData(currentCheckpointId, 0L).         sourceTask.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation()).         Thread.sleep(checkpointInterval).     }     return true. }
false;public;1;8;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     if (closeCalled) {         Assert.fail("Close called before open.").     }     openCalled = true. }
false;public;0;8;;@Override public void close() throws Exception {     super.close().     if (!openCalled) {         Assert.fail("Open was not called before close.").     }     closeCalled = true. }
false;public;1;9;;@Override public void run(SourceContext<String> ctx) throws Exception {     if (!openCalled) {         Assert.fail("Open was not called before run.").     }     for (int i = 0. i < 10. i++) {         ctx.collect("Hello" + i).     } }
false;public;0;2;;@Override public void cancel() { }
