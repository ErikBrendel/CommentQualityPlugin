# id;timestamp;commentText;codeText;commentWords;codeWords
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenClose() throws Exception;1515519059;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenClose() throws Exception {_		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(_				SourceStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)__		streamConfig.setOperatorID(new OperatorID())___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,suppress,warnings,unchecked,public,void,test,open,close,throws,exception,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,source,stream,task,new,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,stream,config,set,operator,id,new,operator,id,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenClose() throws Exception;1517489695;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenClose() throws Exception {_		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(_				SourceStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)__		streamConfig.setOperatorID(new OperatorID())___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,suppress,warnings,unchecked,public,void,test,open,close,throws,exception,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,source,stream,task,new,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,stream,config,set,operator,id,new,operator,id,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenClose() throws Exception;1550833397;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenClose() throws Exception {_		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(_				SourceStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)__		streamConfig.setOperatorID(new OperatorID())___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,suppress,warnings,unchecked,public,void,test,open,close,throws,exception,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,source,stream,task,new,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,stream,config,set,operator,id,new,operator,id,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1445418103;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String> sourceTask = new SourceStreamTask<String>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String> sourceOperator = new StreamSource<String>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,task,new,source,stream,task,string,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,string,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1455549373;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String> sourceTask = new SourceStreamTask<String>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String> sourceOperator = new StreamSource<String>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,task,new,source,stream,task,string,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,string,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1455549456;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1460573449;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1467026067;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1475766252;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1476094958;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1478257462;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1484866642;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1486732842;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1487871589;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1492678790;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1493195810;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1495484544;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1502801814;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)__		streamConfig.setOperatorID(new OperatorID())___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,stream,config,set,operator,id,new,operator,id,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	public void testOpenClose() throws Exception;1509118643;This test verifies that open() and close() are correctly called by the StreamTask.;@Test_	public void testOpenClose() throws Exception {_		final SourceStreamTask<String, SourceFunction<String>, StreamSource<String, SourceFunction<String>>> sourceTask = new SourceStreamTask<>()__		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<String>(sourceTask, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		StreamSource<String, ?> sourceOperator = new StreamSource<>(new OpenCloseTestSource())__		streamConfig.setStreamOperator(sourceOperator)__		streamConfig.setOperatorID(new OperatorID())___		testHarness.invoke()__		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", OpenCloseTestSource.closeCalled)___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(10, resultElements.size())__	};this,test,verifies,that,open,and,close,are,correctly,called,by,the,stream,task;test,public,void,test,open,close,throws,exception,final,source,stream,task,string,source,function,string,stream,source,string,source,function,string,source,task,new,source,stream,task,final,stream,task,test,harness,string,test,harness,new,stream,task,test,harness,string,source,task,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,string,source,operator,new,stream,source,new,open,close,test,source,stream,config,set,stream,operator,source,operator,stream,config,set,operator,id,new,operator,id,test,harness,invoke,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,open,close,test,source,close,called,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,10,result,elements,size
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1445418103;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>> sourceTask = new SourceStreamTask<Tuple2<Long, Integer>>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)__	_			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>> sourceOperator = new StreamSource<Tuple2<Long, Integer>>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)__			_			_			_			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]__	_			_			testHarness.invoke()__			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}_			_			testHarness.waitForTaskCompletion()__	_			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}_	_			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,task,new,source,stream,task,tuple2,long,integer,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,tuple2,long,integer,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1455549373;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>> sourceTask = new SourceStreamTask<Tuple2<Long, Integer>>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>> sourceOperator = new StreamSource<Tuple2<Long, Integer>>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]___			_			testHarness.invoke()___			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,task,new,source,stream,task,tuple2,long,integer,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,tuple2,long,integer,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1455549456;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]___			_			testHarness.invoke()___			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1460573449;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]___			_			testHarness.invoke()___			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1467026067;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]___			_			testHarness.invoke()___			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1475766252;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]___			_			testHarness.invoke()___			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1476094958;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]___			_			testHarness.invoke()___			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1478257462;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]___			_			testHarness.invoke()___			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1484866642;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]___			_			testHarness.invoke()___			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1486732842;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)__			testHarness.setupOutputForSingletonOperatorChain()___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]___			_			testHarness.invoke()___			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1487871589;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)__			testHarness.setupOutputForSingletonOperatorChain()___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]___			_			testHarness.invoke()___			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1492678790;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)__			testHarness.setupOutputForSingletonOperatorChain()___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]___			_			testHarness.invoke()___			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1493195810;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int NUM_ELEMENTS = 100__		final int NUM_CHECKPOINTS = 100__		final int NUM_CHECKPOINTERS = 1__		final int CHECKPOINT_INTERVAL = 5_ _		final int SOURCE_CHECKPOINT_DELAY = 1000_ _		final int SOURCE_READ_DELAY = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)__			testHarness.setupOutputForSingletonOperatorChain()___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(NUM_ELEMENTS, SOURCE_CHECKPOINT_DELAY, SOURCE_READ_DELAY))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[NUM_CHECKPOINTERS]___			_			testHarness.invoke()___			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(NUM_CHECKPOINTS, CHECKPOINT_INTERVAL, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < NUM_CHECKPOINTERS_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(NUM_ELEMENTS, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,100,final,int,100,final,int,1,final,int,5,final,int,1000,final,int,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,test,harness,invoke,for,int,i,0,i,i,checkpointer,results,i,executor,submit,new,checkpointer,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1495484544;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__<p>The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__<p>If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int numElements = 100__		final int numCheckpoints = 100__		final int numCheckpointers = 1__		final int checkpointInterval = 5_ _		final int sourceCheckpointDelay = 1000_ _		final int sourceReadDelay = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)__			testHarness.setupOutputForSingletonOperatorChain()___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(numElements, sourceCheckpointDelay, sourceReadDelay))__			streamConfig.setStreamOperator(sourceOperator)___			__			Future<Boolean>[] checkpointerResults = new Future[numCheckpointers]___			_			testHarness.invoke()___			for (int i = 0_ i < numCheckpointers_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(numCheckpoints, checkpointInterval, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < numCheckpointers_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(numElements, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,p,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,p,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,num,elements,100,final,int,num,checkpoints,100,final,int,num,checkpointers,1,final,int,checkpoint,interval,5,final,int,source,checkpoint,delay,1000,final,int,source,read,delay,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,num,elements,source,checkpoint,delay,source,read,delay,stream,config,set,stream,operator,source,operator,future,boolean,checkpointer,results,new,future,num,checkpointers,test,harness,invoke,for,int,i,0,i,num,checkpointers,i,checkpointer,results,i,executor,submit,new,checkpointer,num,checkpoints,checkpoint,interval,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,num,checkpointers,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,num,elements,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1502801814;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__<p>The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__<p>If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int numElements = 100__		final int numCheckpoints = 100__		final int numCheckpointers = 1__		final int checkpointInterval = 5_ _		final int sourceCheckpointDelay = 1000_ _		final int sourceReadDelay = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)__			testHarness.setupOutputForSingletonOperatorChain()___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(numElements, sourceCheckpointDelay, sourceReadDelay))__			streamConfig.setStreamOperator(sourceOperator)__			streamConfig.setOperatorID(new OperatorID())___			__			Future<Boolean>[] checkpointerResults = new Future[numCheckpointers]___			_			testHarness.invoke()___			for (int i = 0_ i < numCheckpointers_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(numCheckpoints, checkpointInterval, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < numCheckpointers_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(numElements, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,p,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,p,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,num,elements,100,final,int,num,checkpoints,100,final,int,num,checkpointers,1,final,int,checkpoint,interval,5,final,int,source,checkpoint,delay,1000,final,int,source,read,delay,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,num,elements,source,checkpoint,delay,source,read,delay,stream,config,set,stream,operator,source,operator,stream,config,set,operator,id,new,operator,id,future,boolean,checkpointer,results,new,future,num,checkpointers,test,harness,invoke,for,int,i,0,i,num,checkpointers,i,checkpointer,results,i,executor,submit,new,checkpointer,num,checkpoints,checkpoint,interval,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,num,checkpointers,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,num,elements,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1509118643;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__<p>The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__<p>If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int numElements = 100__		final int numCheckpoints = 100__		final int numCheckpointers = 1__		final int checkpointInterval = 5_ _		final int sourceCheckpointDelay = 1000_ _		final int sourceReadDelay = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<Tuple2<Long, Integer>>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__			final SourceStreamTask<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>,_				StreamSource<Tuple2<Long, Integer>, SourceFunction<Tuple2<Long, Integer>>>> sourceTask = new SourceStreamTask<>()__			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<Tuple2<Long, Integer>>(sourceTask, typeInfo)__			testHarness.setupOutputForSingletonOperatorChain()___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(numElements, sourceCheckpointDelay, sourceReadDelay))__			streamConfig.setStreamOperator(sourceOperator)__			streamConfig.setOperatorID(new OperatorID())___			__			Future<Boolean>[] checkpointerResults = new Future[numCheckpointers]___			_			testHarness.invoke()___			for (int i = 0_ i < numCheckpointers_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(numCheckpoints, checkpointInterval, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < numCheckpointers_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(numElements, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,p,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,p,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,num,elements,100,final,int,num,checkpoints,100,final,int,num,checkpointers,1,final,int,checkpoint,interval,5,final,int,source,checkpoint,delay,1000,final,int,source,read,delay,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,tuple2,long,integer,basic,type,info,basic,type,info,final,source,stream,task,tuple2,long,integer,source,function,tuple2,long,integer,stream,source,tuple2,long,integer,source,function,tuple2,long,integer,source,task,new,source,stream,task,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,tuple2,long,integer,source,task,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,num,elements,source,checkpoint,delay,source,read,delay,stream,config,set,stream,operator,source,operator,stream,config,set,operator,id,new,operator,id,future,boolean,checkpointer,results,new,future,num,checkpointers,test,harness,invoke,for,int,i,0,i,num,checkpointers,i,checkpointer,results,i,executor,submit,new,checkpointer,num,checkpoints,checkpoint,interval,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,num,checkpointers,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,num,elements,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1515519059;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__<p>The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__<p>If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int numElements = 100__		final int numCheckpoints = 100__		final int numCheckpointers = 1__		final int checkpointInterval = 5_ _		final int sourceCheckpointDelay = 1000_ _		final int sourceReadDelay = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)___			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<>(_					SourceStreamTask::new, typeInfo)__			testHarness.setupOutputForSingletonOperatorChain()___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(numElements, sourceCheckpointDelay, sourceReadDelay))__			streamConfig.setStreamOperator(sourceOperator)__			streamConfig.setOperatorID(new OperatorID())___			__			Future<Boolean>[] checkpointerResults = new Future[numCheckpointers]___			_			testHarness.invoke()__			testHarness.waitForTaskRunning()___			final StreamTask<Tuple2<Long, Integer>, ?> sourceTask = testHarness.getTask()___			for (int i = 0_ i < numCheckpointers_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(numCheckpoints, checkpointInterval, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < numCheckpointers_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(numElements, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,p,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,p,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,num,elements,100,final,int,num,checkpoints,100,final,int,num,checkpointers,1,final,int,checkpoint,interval,5,final,int,source,checkpoint,delay,1000,final,int,source,read,delay,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,basic,type,info,basic,type,info,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,source,stream,task,new,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,num,elements,source,checkpoint,delay,source,read,delay,stream,config,set,stream,operator,source,operator,stream,config,set,operator,id,new,operator,id,future,boolean,checkpointer,results,new,future,num,checkpointers,test,harness,invoke,test,harness,wait,for,task,running,final,stream,task,tuple2,long,integer,source,task,test,harness,get,task,for,int,i,0,i,num,checkpointers,i,checkpointer,results,i,executor,submit,new,checkpointer,num,checkpoints,checkpoint,interval,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,num,checkpointers,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,num,elements,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1517489695;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__<p>The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__<p>If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int numElements = 100__		final int numCheckpoints = 100__		final int numCheckpointers = 1__		final int checkpointInterval = 5_ _		final int sourceCheckpointDelay = 1000_ _		final int sourceReadDelay = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)___			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<>(_					SourceStreamTask::new, typeInfo)__			testHarness.setupOutputForSingletonOperatorChain()___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(numElements, sourceCheckpointDelay, sourceReadDelay))__			streamConfig.setStreamOperator(sourceOperator)__			streamConfig.setOperatorID(new OperatorID())___			__			Future<Boolean>[] checkpointerResults = new Future[numCheckpointers]___			_			testHarness.invoke()__			testHarness.waitForTaskRunning()___			final StreamTask<Tuple2<Long, Integer>, ?> sourceTask = testHarness.getTask()___			for (int i = 0_ i < numCheckpointers_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(numCheckpoints, checkpointInterval, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < numCheckpointers_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(numElements, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,p,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,p,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,num,elements,100,final,int,num,checkpoints,100,final,int,num,checkpointers,1,final,int,checkpoint,interval,5,final,int,source,checkpoint,delay,1000,final,int,source,read,delay,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,basic,type,info,basic,type,info,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,source,stream,task,new,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,num,elements,source,checkpoint,delay,source,read,delay,stream,config,set,stream,operator,source,operator,stream,config,set,operator,id,new,operator,id,future,boolean,checkpointer,results,new,future,num,checkpointers,test,harness,invoke,test,harness,wait,for,task,running,final,stream,task,tuple2,long,integer,source,task,test,harness,get,task,for,int,i,0,i,num,checkpointers,i,checkpointer,results,i,executor,submit,new,checkpointer,num,checkpoints,checkpoint,interval,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,num,checkpointers,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,num,elements,result,elements,size,finally,executor,shutdown
SourceStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointing() throws Exception;1550833397;This test ensures that the SourceStreamTask properly serializes checkpointing_and element emission. This also verifies that there are no concurrent invocations_of the checkpoint method on the source operator.__<p>The source emits elements and performs checkpoints. We have several checkpointer threads_that fire checkpoint requests at the source task.__<p>If element emission and checkpointing are not in series the count of elements at the_beginning of a checkpoint and at the end of a checkpoint are not the same because the_source kept emitting elements while the checkpoint was ongoing.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointing() throws Exception {_		final int numElements = 100__		final int numCheckpoints = 100__		final int numCheckpointers = 1__		final int checkpointInterval = 5_ _		final int sourceCheckpointDelay = 1000_ _		final int sourceReadDelay = 1_ __		ExecutorService executor = Executors.newFixedThreadPool(10)__		try {_			final TupleTypeInfo<Tuple2<Long, Integer>> typeInfo = new TupleTypeInfo<>(BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)___			final StreamTaskTestHarness<Tuple2<Long, Integer>> testHarness = new StreamTaskTestHarness<>(_					SourceStreamTask::new, typeInfo)__			testHarness.setupOutputForSingletonOperatorChain()___			StreamConfig streamConfig = testHarness.getStreamConfig()__			StreamSource<Tuple2<Long, Integer>, ?> sourceOperator = new StreamSource<>(new MockSource(numElements, sourceCheckpointDelay, sourceReadDelay))__			streamConfig.setStreamOperator(sourceOperator)__			streamConfig.setOperatorID(new OperatorID())___			__			Future<Boolean>[] checkpointerResults = new Future[numCheckpointers]___			_			testHarness.invoke()__			testHarness.waitForTaskRunning()___			final StreamTask<Tuple2<Long, Integer>, ?> sourceTask = testHarness.getTask()___			for (int i = 0_ i < numCheckpointers_ i++) {_				checkpointerResults[i] = executor.submit(new Checkpointer(numCheckpoints, checkpointInterval, sourceTask))__			}__			testHarness.waitForTaskCompletion()___			_			_			for (int i = 0_ i < numCheckpointers_ i++) {_				if (!checkpointerResults[i].isDone()) {_					checkpointerResults[i].cancel(true)__				}_				if (!checkpointerResults[i].isCancelled()) {_					checkpointerResults[i].get()__				}_			}__			List<Tuple2<Long, Integer>> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__			Assert.assertEquals(numElements, resultElements.size())__		}_		finally {_			executor.shutdown()__		}_	};this,test,ensures,that,the,source,stream,task,properly,serializes,checkpointing,and,element,emission,this,also,verifies,that,there,are,no,concurrent,invocations,of,the,checkpoint,method,on,the,source,operator,p,the,source,emits,elements,and,performs,checkpoints,we,have,several,checkpointer,threads,that,fire,checkpoint,requests,at,the,source,task,p,if,element,emission,and,checkpointing,are,not,in,series,the,count,of,elements,at,the,beginning,of,a,checkpoint,and,at,the,end,of,a,checkpoint,are,not,the,same,because,the,source,kept,emitting,elements,while,the,checkpoint,was,ongoing;test,suppress,warnings,unchecked,public,void,test,checkpointing,throws,exception,final,int,num,elements,100,final,int,num,checkpoints,100,final,int,num,checkpointers,1,final,int,checkpoint,interval,5,final,int,source,checkpoint,delay,1000,final,int,source,read,delay,1,executor,service,executor,executors,new,fixed,thread,pool,10,try,final,tuple,type,info,tuple2,long,integer,type,info,new,tuple,type,info,basic,type,info,basic,type,info,final,stream,task,test,harness,tuple2,long,integer,test,harness,new,stream,task,test,harness,source,stream,task,new,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,stream,source,tuple2,long,integer,source,operator,new,stream,source,new,mock,source,num,elements,source,checkpoint,delay,source,read,delay,stream,config,set,stream,operator,source,operator,stream,config,set,operator,id,new,operator,id,future,boolean,checkpointer,results,new,future,num,checkpointers,test,harness,invoke,test,harness,wait,for,task,running,final,stream,task,tuple2,long,integer,source,task,test,harness,get,task,for,int,i,0,i,num,checkpointers,i,checkpointer,results,i,executor,submit,new,checkpointer,num,checkpoints,checkpoint,interval,source,task,test,harness,wait,for,task,completion,for,int,i,0,i,num,checkpointers,i,if,checkpointer,results,i,is,done,checkpointer,results,i,cancel,true,if,checkpointer,results,i,is,cancelled,checkpointer,results,i,get,list,tuple2,long,integer,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,num,elements,result,elements,size,finally,executor,shutdown
