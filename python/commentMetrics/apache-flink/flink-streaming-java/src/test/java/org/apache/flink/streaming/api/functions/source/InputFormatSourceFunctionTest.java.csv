commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test public void testNormalOp() throws Exception {     testFormatLifecycle(false). }
false;public;0;4;;@Test public void testCancelation() throws Exception {     testFormatLifecycle(true). }
false;private;1;36;;private void testFormatLifecycle(final boolean midCancel) throws Exception {     final int noOfSplits = 5.     final int cancelAt = 2.     final LifeCycleTestInputFormat format = new LifeCycleTestInputFormat().     final InputFormatSourceFunction<Integer> reader = new InputFormatSourceFunction<>(format, TypeInformation.of(Integer.class)).     try (MockEnvironment environment = new MockEnvironmentBuilder().setTaskName("no").setMemorySize(4 * MemoryManager.DEFAULT_PAGE_SIZE).build()) {         reader.setRuntimeContext(new MockRuntimeContext(format, noOfSplits, environment)).         Assert.assertTrue(!format.isConfigured).         Assert.assertTrue(!format.isInputFormatOpen).         Assert.assertTrue(!format.isSplitOpen).         reader.open(new Configuration()).         Assert.assertTrue(format.isConfigured).         TestSourceContext ctx = new TestSourceContext(reader, format, midCancel, cancelAt).         reader.run(ctx).         int splitsSeen = ctx.getSplitsSeen().         Assert.assertTrue(midCancel ? splitsSeen == cancelAt : splitsSeen == noOfSplits).         // we have exhausted the splits so the         // format and splits should be closed by now         Assert.assertTrue(!format.isSplitOpen).         Assert.assertTrue(!format.isInputFormatOpen).     } }
false;public;0;7;;@Override public void openInputFormat() {     Assert.assertTrue(isConfigured).     Assert.assertTrue(!isInputFormatOpen).     Assert.assertTrue(!isSplitOpen).     this.isInputFormatOpen = true. }
false;public;0;5;;@Override public void closeInputFormat() {     Assert.assertTrue(!isSplitOpen).     this.isInputFormatOpen = false. }
false;public;1;5;;@Override public void configure(Configuration parameters) {     Assert.assertTrue(!isConfigured).     this.isConfigured = true. }
false;public;1;4;;@Override public BaseStatistics getStatistics(BaseStatistics cachedStatistics) throws IOException {     return null. }
false;public;0;4;;@Override public int getSplitNumber() {     return idx. }
false;public;1;17;;@Override public InputSplit[] createInputSplits(int minNumSplits) throws IOException {     Assert.assertTrue(isConfigured).     InputSplit[] splits = new InputSplit[minNumSplits].     for (int i = 0. i < minNumSplits. i++) {         final int idx = i.         splits[idx] = new InputSplit() {              private static final long serialVersionUID = -1480792932361908285L.              @Override             public int getSplitNumber() {                 return idx.             }         }.     }     return splits. }
false;public;1;4;;@Override public InputSplitAssigner getInputSplitAssigner(InputSplit[] inputSplits) {     return null. }
false;public;1;11;;@Override public void open(InputSplit split) throws IOException {     // whenever a new split opens,     // the previous should have been closed     Assert.assertTrue(isInputFormatOpen).     Assert.assertTrue(isConfigured).     Assert.assertTrue(!isSplitOpen).     isSplitOpen = true.     eos = false. }
false;public;0;11;;@Override public boolean reachedEnd() throws IOException {     Assert.assertTrue(isInputFormatOpen).     Assert.assertTrue(isConfigured).     Assert.assertTrue(isSplitOpen).     if (!eos) {         reachedEndCalls++.     }     return eos. }
false;public;1;11;;@Override public Integer nextRecord(Integer reuse) throws IOException {     Assert.assertTrue(isInputFormatOpen).     Assert.assertTrue(isConfigured).     Assert.assertTrue(isSplitOpen).     Assert.assertTrue(reachedEndCalls == ++nextRecordCalls).     eos = true.     return splitCounter++. }
false;public;0;4;;@Override public void close() throws IOException {     this.isSplitOpen = false. }
false;public;1;10;;@Override public void collect(Integer element) {     Assert.assertTrue(format.isSplitOpen).     Assert.assertTrue(splitIdx == element).     if (shouldCancel && splitIdx == cancelAt) {         reader.cancel().     } else {         splitIdx++.     } }
false;public;2;4;;@Override public void collectWithTimestamp(Integer element, long timestamp) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public void emitWatermark(Watermark mark) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public void markAsTemporarilyIdle() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public Object getCheckpointLock() {     return null. }
false;public;0;4;;@Override public void close() {     throw new UnsupportedOperationException(). }
false;public;0;3;;public int getSplitsSeen() {     return this.splitIdx. }
false;public;0;4;;@Override public MetricGroup getMetricGroup() {     return new UnregisteredMetricsGroup(). }
false;public;1;7;;@Override public InputSplit getNextInputSplit(ClassLoader userCodeClassLoader) {     if (nextSplit < inputSplits.length) {         return inputSplits[nextSplit++].     }     return null. }
false;public;0;19;;@Override public InputSplitProvider getInputSplitProvider() {     try {         this.inputSplits = format.createInputSplits(noOfSplits).         Assert.assertTrue(inputSplits.length == noOfSplits).     } catch (IOException e) {         e.printStackTrace().     }     return new InputSplitProvider() {          @Override         public InputSplit getNextInputSplit(ClassLoader userCodeClassLoader) {             if (nextSplit < inputSplits.length) {                 return inputSplits[nextSplit++].             }             return null.         }     }. }
false;public;0;4;;@Override public ExecutionConfig getExecutionConfig() {     return new ExecutionConfig(). }
false;public;0;4;;@Override public OperatorID getOperatorID() {     return new OperatorID(). }
