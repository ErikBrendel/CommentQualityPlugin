commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public String map1(Double value) {     return value.toString(). }
false;public;1;4;;@Override public String map2(Integer value) {     return value.toString(). }
false;public;0;40;;@Test public void testCoMap() throws Exception {     CoStreamMap<Double, Integer, String> operator = new CoStreamMap<Double, Integer, String>(new MyCoMap()).     TwoInputStreamOperatorTestHarness<Double, Integer, String> testHarness = new TwoInputStreamOperatorTestHarness<Double, Integer, String>(operator).     long initialTime = 0L.     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>().     testHarness.open().     testHarness.processElement1(new StreamRecord<Double>(1.1d, initialTime + 1)).     testHarness.processElement1(new StreamRecord<Double>(1.2d, initialTime + 2)).     testHarness.processElement1(new StreamRecord<Double>(1.3d, initialTime + 3)).     testHarness.processWatermark1(new Watermark(initialTime + 3)).     testHarness.processElement1(new StreamRecord<Double>(1.4d, initialTime + 4)).     testHarness.processElement1(new StreamRecord<Double>(1.5d, initialTime + 5)).     testHarness.processElement2(new StreamRecord<Integer>(1, initialTime + 1)).     testHarness.processElement2(new StreamRecord<Integer>(2, initialTime + 2)).     testHarness.processWatermark2(new Watermark(initialTime + 2)).     testHarness.processElement2(new StreamRecord<Integer>(3, initialTime + 3)).     testHarness.processElement2(new StreamRecord<Integer>(4, initialTime + 4)).     testHarness.processElement2(new StreamRecord<Integer>(5, initialTime + 5)).     expectedOutput.add(new StreamRecord<String>("1.1", initialTime + 1)).     expectedOutput.add(new StreamRecord<String>("1.2", initialTime + 2)).     expectedOutput.add(new StreamRecord<String>("1.3", initialTime + 3)).     expectedOutput.add(new StreamRecord<String>("1.4", initialTime + 4)).     expectedOutput.add(new StreamRecord<String>("1.5", initialTime + 5)).     expectedOutput.add(new StreamRecord<String>("1", initialTime + 1)).     expectedOutput.add(new StreamRecord<String>("2", initialTime + 2)).     expectedOutput.add(new Watermark(initialTime + 2)).     expectedOutput.add(new StreamRecord<String>("3", initialTime + 3)).     expectedOutput.add(new StreamRecord<String>("4", initialTime + 4)).     expectedOutput.add(new StreamRecord<String>("5", initialTime + 5)).     TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput()). }
false;public;0;18;;@Test public void testOpenClose() throws Exception {     CoStreamMap<Double, Integer, String> operator = new CoStreamMap<Double, Integer, String>(new TestOpenCloseCoMapFunction()).     TwoInputStreamOperatorTestHarness<Double, Integer, String> testHarness = new TwoInputStreamOperatorTestHarness<Double, Integer, String>(operator).     long initialTime = 0L.     testHarness.open().     testHarness.processElement1(new StreamRecord<Double>(74d, initialTime)).     testHarness.processElement2(new StreamRecord<Integer>(42, initialTime)).     testHarness.close().     Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseCoMapFunction.closeCalled).     Assert.assertTrue("Output contains no elements.", testHarness.getOutput().size() > 0). }
false;public;1;8;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     if (closeCalled) {         Assert.fail("Close called before open.").     }     openCalled = true. }
false;public;0;8;;@Override public void close() throws Exception {     super.close().     if (!openCalled) {         Assert.fail("Open was not called before close.").     }     closeCalled = true. }
false;public;1;7;;@Override public String map1(Double value) throws Exception {     if (!openCalled) {         Assert.fail("Open was not called before run.").     }     return value.toString(). }
false;public;1;7;;@Override public String map2(Integer value) throws Exception {     if (!openCalled) {         Assert.fail("Open was not called before run.").     }     return value.toString(). }
