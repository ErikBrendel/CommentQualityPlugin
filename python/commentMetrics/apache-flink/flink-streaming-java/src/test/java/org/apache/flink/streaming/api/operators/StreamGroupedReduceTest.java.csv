commented;modifiers;parameterAmount;loc;comment;code
false;public;0;31;;@Test public void testGroupedReduce() throws Exception {     KeySelector<Integer, Integer> keySelector = new IntegerKeySelector().     StreamGroupedReduce<Integer> operator = new StreamGroupedReduce<>(new MyReducer(), IntSerializer.INSTANCE).     OneInputStreamOperatorTestHarness<Integer, Integer> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, keySelector, BasicTypeInfo.INT_TYPE_INFO).     long initialTime = 0L.     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     testHarness.open().     testHarness.processElement(new StreamRecord<>(1, initialTime + 1)).     testHarness.processElement(new StreamRecord<>(1, initialTime + 2)).     testHarness.processWatermark(new Watermark(initialTime + 2)).     testHarness.processElement(new StreamRecord<>(2, initialTime + 3)).     testHarness.processElement(new StreamRecord<>(2, initialTime + 4)).     testHarness.processElement(new StreamRecord<>(3, initialTime + 5)).     expectedOutput.add(new StreamRecord<>(1, initialTime + 1)).     expectedOutput.add(new StreamRecord<>(2, initialTime + 2)).     expectedOutput.add(new Watermark(initialTime + 2)).     expectedOutput.add(new StreamRecord<>(2, initialTime + 3)).     expectedOutput.add(new StreamRecord<>(4, initialTime + 4)).     expectedOutput.add(new StreamRecord<>(3, initialTime + 5)).     TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput()). }
false;public;0;22;;@Test public void testOpenClose() throws Exception {     KeySelector<Integer, Integer> keySelector = new IntegerKeySelector().     StreamGroupedReduce<Integer> operator = new StreamGroupedReduce<>(new TestOpenCloseReduceFunction(), IntSerializer.INSTANCE).     OneInputStreamOperatorTestHarness<Integer, Integer> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(operator, keySelector, BasicTypeInfo.INT_TYPE_INFO).     long initialTime = 0L.     testHarness.open().     testHarness.processElement(new StreamRecord<>(1, initialTime)).     testHarness.processElement(new StreamRecord<>(2, initialTime)).     testHarness.close().     Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseReduceFunction.closeCalled).     Assert.assertTrue("Output contains no elements.", testHarness.getOutput().size() > 0). }
false;public;1;8;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     if (closeCalled) {         Assert.fail("Close called before open.").     }     openCalled = true. }
false;public;0;8;;@Override public void close() throws Exception {     super.close().     if (!openCalled) {         Assert.fail("Open was not called before close.").     }     closeCalled = true. }
false;public;2;7;;@Override public Integer reduce(Integer in1, Integer in2) throws Exception {     if (!openCalled) {         Assert.fail("Open was not called before run.").     }     return in1 + in2. }
false;public;2;4;;@Override public Integer reduce(Integer value1, Integer value2) throws Exception {     return value1 + value2. }
false;public;1;4;;@Override public Integer getKey(Integer value) throws Exception {     return value. }
