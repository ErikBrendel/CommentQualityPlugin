commented;modifiers;parameterAmount;loc;comment;code
false;public;0;44;;@Test public void testWithTwoChannelsAndRandomBarriers() {     IOManager ioMan = null.     NetworkBufferPool networkBufferPool1 = null.     NetworkBufferPool networkBufferPool2 = null.     try {         ioMan = new IOManagerAsync().         networkBufferPool1 = new NetworkBufferPool(100, PAGE_SIZE).         networkBufferPool2 = new NetworkBufferPool(100, PAGE_SIZE).         BufferPool pool1 = networkBufferPool1.createBufferPool(100, 100).         BufferPool pool2 = networkBufferPool2.createBufferPool(100, 100).         RandomGeneratingInputGate myIG = new RandomGeneratingInputGate(new BufferPool[] { pool1, pool2 }, new BarrierGenerator[] { new CountBarrier(100000), new RandomBarrier(100000) }).         BarrierBuffer barrierBuffer = new BarrierBuffer(myIG, new BufferSpiller(ioMan, myIG.getPageSize())).         for (int i = 0. i < 2000000. i++) {             BufferOrEvent boe = barrierBuffer.getNextNonBlocked().             if (boe.isBuffer()) {                 boe.getBuffer().recycleBuffer().             }         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } finally {         if (ioMan != null) {             ioMan.shutdown().         }         if (networkBufferPool1 != null) {             networkBufferPool1.destroyAllBufferPools().             networkBufferPool1.destroy().         }         if (networkBufferPool2 != null) {             networkBufferPool2.destroyAllBufferPools().             networkBufferPool2.destroy().         }     } }
false;;0;1;;boolean isNextBarrier().
false;public;0;4;;@Override public boolean isNextBarrier() {     return rnd.nextDouble() < threshold. }
false;public;0;4;;@Override public boolean isNextBarrier() {     return c++ % every == 0. }
false;public;0;4;;@Override public int getNumberOfInputChannels() {     return numberOfChannels. }
false;public;0;4;;@Override public String getOwningTaskName() {     return owningTaskName. }
false;public;0;4;;@Override public boolean isFinished() {     return false. }
false;public;0;2;;@Override public void requestPartitions() { }
false;public;0;18;;@Override public Optional<BufferOrEvent> getNextBufferOrEvent() throws IOException, InterruptedException {     currentChannel = (currentChannel + 1) % numberOfChannels.     if (barrierGens[currentChannel].isNextBarrier()) {         return Optional.of(new BufferOrEvent(new CheckpointBarrier(++currentBarriers[currentChannel], System.currentTimeMillis(), CheckpointOptions.forCheckpointWithDefaultLocation()), currentChannel)).     } else {         Buffer buffer = bufferPools[currentChannel].requestBuffer().         buffer.getMemorySegment().putLong(0, c++).         return Optional.of(new BufferOrEvent(buffer, currentChannel)).     } }
false;public;0;4;;@Override public Optional<BufferOrEvent> pollNextBufferOrEvent() throws IOException, InterruptedException {     return getNextBufferOrEvent(). }
false;public;1;2;;@Override public void sendTaskEvent(TaskEvent event) { }
false;public;1;2;;@Override public void registerListener(InputGateListener listener) { }
false;public;0;4;;@Override public int getPageSize() {     return PAGE_SIZE. }
