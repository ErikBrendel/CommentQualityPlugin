commented;modifiers;parameterAmount;loc;comment;code
false;private;0;48;;@SuppressWarnings("unchecked") private void setupInputChannels() throws IOException, InterruptedException {     for (int i = 0. i < numInputChannels. i++) {         final int channelIndex = i.         final RecordSerializer<SerializationDelegate<Object>> recordSerializer = new SpanningRecordSerializer<SerializationDelegate<Object>>().         final SerializationDelegate<Object> delegate = (SerializationDelegate<Object>) (SerializationDelegate<?>) new SerializationDelegate<StreamElement>(new StreamElementSerializer<T>(serializer)).         inputQueues[channelIndex] = new ConcurrentLinkedQueue<InputValue<Object>>().         inputChannels[channelIndex] = new TestInputChannel(inputGate, i).         final BufferAndAvailabilityProvider answer = () -> {             ConcurrentLinkedQueue<InputValue<Object>> inputQueue = inputQueues[channelIndex].             InputValue<Object> input.             boolean moreAvailable.             synchronized (inputQueue) {                 input = inputQueue.poll().                 moreAvailable = !inputQueue.isEmpty().             }             if (input != null && input.isStreamEnd()) {                 inputChannels[channelIndex].setReleased().                 return Optional.of(new BufferAndAvailability(EventSerializer.toBuffer(EndOfPartitionEvent.INSTANCE), moreAvailable, 0)).             } else if (input != null && input.isStreamRecord()) {                 Object inputElement = input.getStreamRecord().                 delegate.setInstance(inputElement).                 recordSerializer.serializeRecord(delegate).                 BufferBuilder bufferBuilder = createBufferBuilder(bufferSize).                 recordSerializer.copyToBufferBuilder(bufferBuilder).                 bufferBuilder.finish().                 // Call getCurrentBuffer to ensure size is set                 return Optional.of(new BufferAndAvailability(buildSingleBuffer(bufferBuilder), moreAvailable, 0)).             } else if (input != null && input.isEvent()) {                 AbstractEvent event = input.getEvent().                 return Optional.of(new BufferAndAvailability(EventSerializer.toBuffer(event), moreAvailable, 0)).             } else {                 return Optional.empty().             }         }.         inputChannels[channelIndex].addBufferAndAvailability(answer).         inputGate.setInputChannel(new IntermediateResultPartitionID(), inputChannels[channelIndex]).     } }
false;public;2;7;;public void sendElement(Object element, int channel) {     synchronized (inputQueues[channel]) {         inputQueues[channel].add(InputValue.element(element)).         inputQueues[channel].notifyAll().     }     inputGate.notifyChannelNonEmpty(inputChannels[channel]). }
false;public;2;7;;public void sendEvent(AbstractEvent event, int channel) {     synchronized (inputQueues[channel]) {         inputQueues[channel].add(InputValue.event(event)).         inputQueues[channel].notifyAll().     }     inputGate.notifyChannelNonEmpty(inputChannels[channel]). }
false;public;0;9;;public void endInput() {     for (int i = 0. i < numInputChannels. i++) {         synchronized (inputQueues[i]) {             inputQueues[i].add(InputValue.streamEnd()).             inputQueues[i].notifyAll().         }         inputGate.notifyChannelNonEmpty(inputChannels[i]).     } }
true;public;0;16;/**  * Returns true iff all input queues are empty.  */ ;/**  * Returns true iff all input queues are empty.  */ public boolean allQueuesEmpty() {     for (int i = 0. i < numInputChannels. i++) {         if (inputQueues[i].size() > 0) {             return false.         }     }     return true. }
false;public,static;1;3;;public static <X> InputValue<X> element(Object element) {     return new InputValue<X>(element, false, false, true). }
false;public,static;0;3;;public static <X> InputValue<X> streamEnd() {     return new InputValue<X>(null, true, false, false). }
false;public,static;1;3;;public static <X> InputValue<X> event(AbstractEvent event) {     return new InputValue<X>(event, false, true, false). }
false;public;0;3;;public Object getStreamRecord() {     return elementOrEvent. }
false;public;0;3;;public AbstractEvent getEvent() {     return (AbstractEvent) elementOrEvent. }
false;public;0;3;;public boolean isStreamEnd() {     return isStreamEnd. }
false;public;0;3;;public boolean isStreamRecord() {     return isStreamRecord. }
false;public;0;3;;public boolean isEvent() {     return isEvent. }
