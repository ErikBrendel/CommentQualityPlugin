commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;6;;@Parameters(name = "lhs faster than rhs: {0}") public static Collection<Object[]> data() {     return Arrays.asList(new Object[][] { { true }, { false } }). }
false;public;0;31;;@Test public void testImplementationMirrorsCorrectly() throws Exception {     long lowerBound = 1.     long upperBound = 3.     boolean lowerBoundInclusive = true.     boolean upperBoundInclusive = false.     setupHarness(lowerBound, lowerBoundInclusive, upperBound, upperBoundInclusive).processElementsAndWatermarks(1, 4).andExpect(streamRecordOf(1, 2), streamRecordOf(1, 3), streamRecordOf(2, 3), streamRecordOf(2, 4), streamRecordOf(3, 4)).noLateRecords().close().     setupHarness(-1 * upperBound, upperBoundInclusive, -1 * lowerBound, lowerBoundInclusive).processElementsAndWatermarks(1, 4).andExpect(streamRecordOf(2, 1), streamRecordOf(3, 1), streamRecordOf(3, 2), streamRecordOf(4, 2), streamRecordOf(4, 3)).noLateRecords().close(). }
false;public;0;15;;// lhs - 2 <= rhs <= rhs + 2 @Test public void testNegativeInclusiveAndNegativeInclusive() throws Exception {     setupHarness(-2, true, -1, true).processElementsAndWatermarks(1, 4).andExpect(streamRecordOf(2, 1), streamRecordOf(3, 1), streamRecordOf(3, 2), streamRecordOf(4, 2), streamRecordOf(4, 3)).noLateRecords().close(). }
false;public;0;20;;// lhs - 1 <= rhs <= rhs + 1 @Test public void testNegativeInclusiveAndPositiveInclusive() throws Exception {     setupHarness(-1, true, 1, true).processElementsAndWatermarks(1, 4).andExpect(streamRecordOf(1, 1), streamRecordOf(1, 2), streamRecordOf(2, 1), streamRecordOf(2, 2), streamRecordOf(2, 3), streamRecordOf(3, 2), streamRecordOf(3, 3), streamRecordOf(3, 4), streamRecordOf(4, 3), streamRecordOf(4, 4)).noLateRecords().close(). }
false;public;0;15;;// lhs + 1 <= rhs <= lhs + 2 @Test public void testPositiveInclusiveAndPositiveInclusive() throws Exception {     setupHarness(1, true, 2, true).processElementsAndWatermarks(1, 4).andExpect(streamRecordOf(1, 2), streamRecordOf(1, 3), streamRecordOf(2, 3), streamRecordOf(2, 4), streamRecordOf(3, 4)).noLateRecords().close(). }
false;public;0;12;;@Test public void testNegativeExclusiveAndNegativeExlusive() throws Exception {     setupHarness(-3, false, -1, false).processElementsAndWatermarks(1, 4).andExpect(streamRecordOf(3, 1), streamRecordOf(4, 2)).noLateRecords().close(). }
false;public;0;14;;@Test public void testNegativeExclusiveAndPositiveExlusive() throws Exception {     setupHarness(-1, false, 1, false).processElementsAndWatermarks(1, 4).andExpect(streamRecordOf(1, 1), streamRecordOf(2, 2), streamRecordOf(3, 3), streamRecordOf(4, 4)).noLateRecords().close(). }
false;public;0;12;;@Test public void testPositiveExclusiveAndPositiveExlusive() throws Exception {     setupHarness(1, false, 3, false).processElementsAndWatermarks(1, 4).andExpect(streamRecordOf(1, 3), streamRecordOf(2, 4)).noLateRecords().close(). }
false;public;0;36;;@Test public void testStateCleanupNegativeInclusiveNegativeInclusive() throws Exception {     setupHarness(-1, true, 0, true).processElement1(1).processElement1(2).processElement1(3).processElement1(4).processElement1(5).processElement2(1).processElement2(2).processElement2(3).processElement2(4).processElement2(// fill both buffers with values     5).processWatermark1(1).processWatermark2(// set common watermark to 1 and check that data is cleaned     1).assertLeftBufferContainsOnly(2, 3, 4, 5).assertRightBufferContainsOnly(1, 2, 3, 4, 5).processWatermark1(// set common watermark to 4 and check that data is cleaned     4).processWatermark2(4).assertLeftBufferContainsOnly(5).assertRightBufferContainsOnly(4, 5).processWatermark1(// set common watermark to 6 and check that data all buffers are empty     6).processWatermark2(6).assertLeftBufferEmpty().assertRightBufferEmpty().close(). }
false;public;0;35;;@Test public void testStateCleanupNegativePositiveNegativeExlusive() throws Exception {     setupHarness(-2, false, 1, false).processElement1(1).processElement1(2).processElement1(3).processElement1(4).processElement1(5).processElement2(1).processElement2(2).processElement2(3).processElement2(4).processElement2(// fill both buffers with values     5).processWatermark1(1).processWatermark2(// set common watermark to 1 and check that data is cleaned     1).assertLeftBufferContainsOnly(2, 3, 4, 5).assertRightBufferContainsOnly(1, 2, 3, 4, 5).processWatermark1(// set common watermark to 4 and check that data is cleaned     4).processWatermark2(4).assertLeftBufferContainsOnly(5).assertRightBufferContainsOnly(4, 5).processWatermark1(// set common watermark to 6 and check that data all buffers are empty     6).processWatermark2(6).assertLeftBufferEmpty().assertRightBufferEmpty().close(). }
false;public;0;35;;@Test public void testStateCleanupPositiveInclusivePositiveInclusive() throws Exception {     setupHarness(0, true, 1, true).processElement1(1).processElement1(2).processElement1(3).processElement1(4).processElement1(5).processElement2(1).processElement2(2).processElement2(3).processElement2(4).processElement2(// fill both buffers with values     5).processWatermark1(1).processWatermark2(// set common watermark to 1 and check that data is cleaned     1).assertLeftBufferContainsOnly(1, 2, 3, 4, 5).assertRightBufferContainsOnly(2, 3, 4, 5).processWatermark1(// set common watermark to 4 and check that data is cleaned     4).processWatermark2(4).assertLeftBufferContainsOnly(4, 5).assertRightBufferContainsOnly(5).processWatermark1(// set common watermark to 6 and check that data all buffers are empty     6).processWatermark2(6).assertLeftBufferEmpty().assertRightBufferEmpty().close(). }
false;public;0;35;;@Test public void testStateCleanupPositiveExlusivePositiveExclusive() throws Exception {     setupHarness(-1, false, 2, false).processElement1(1).processElement1(2).processElement1(3).processElement1(4).processElement1(5).processElement2(1).processElement2(2).processElement2(3).processElement2(4).processElement2(// fill both buffers with values     5).processWatermark1(1).processWatermark2(// set common watermark to 1 and check that data is cleaned     1).assertLeftBufferContainsOnly(1, 2, 3, 4, 5).assertRightBufferContainsOnly(2, 3, 4, 5).processWatermark1(// set common watermark to 4 and check that data is cleaned     4).processWatermark2(4).assertLeftBufferContainsOnly(4, 5).assertRightBufferContainsOnly(5).processWatermark1(// set common watermark to 6 and check that data all buffers are empty     6).processWatermark2(6).assertLeftBufferEmpty().assertRightBufferEmpty().close(). }
false;public;0;90;;@Test public void testRestoreFromSnapshot() throws Exception {     // config     int lowerBound = -1.     boolean lowerBoundInclusive = true.     int upperBound = 1.     boolean upperBoundInclusive = true.     // create first test harness     OperatorSubtaskState handles.     List<StreamRecord<Tuple2<TestElem, TestElem>>> expectedOutput.     try (TestHarness testHarness = createTestHarness(lowerBound, lowerBoundInclusive, upperBound, upperBoundInclusive)) {         testHarness.setup().         testHarness.open().         // process elements with first test harness         testHarness.processElement1(createStreamRecord(1, "lhs")).         testHarness.processWatermark1(new Watermark(1)).         testHarness.processElement2(createStreamRecord(1, "rhs")).         testHarness.processWatermark2(new Watermark(1)).         testHarness.processElement1(createStreamRecord(2, "lhs")).         testHarness.processWatermark1(new Watermark(2)).         testHarness.processElement2(createStreamRecord(2, "rhs")).         testHarness.processWatermark2(new Watermark(2)).         testHarness.processElement1(createStreamRecord(3, "lhs")).         testHarness.processWatermark1(new Watermark(3)).         testHarness.processElement2(createStreamRecord(3, "rhs")).         testHarness.processWatermark2(new Watermark(3)).         // snapshot and validate output         handles = testHarness.snapshot(0, 0).         testHarness.close().         expectedOutput = Lists.newArrayList(streamRecordOf(1, 1), streamRecordOf(1, 2), streamRecordOf(2, 1), streamRecordOf(2, 2), streamRecordOf(2, 3), streamRecordOf(3, 2), streamRecordOf(3, 3)).         TestHarnessUtil.assertNoLateRecords(testHarness.getOutput()).         assertOutput(expectedOutput, testHarness.getOutput()).     }     try (TestHarness newTestHarness = createTestHarness(lowerBound, lowerBoundInclusive, upperBound, upperBoundInclusive)) {         // create new test harness from snapshpt         newTestHarness.setup().         newTestHarness.initializeState(handles).         newTestHarness.open().         // process elements         newTestHarness.processElement1(createStreamRecord(4, "lhs")).         newTestHarness.processWatermark1(new Watermark(4)).         newTestHarness.processElement2(createStreamRecord(4, "rhs")).         newTestHarness.processWatermark2(new Watermark(4)).         // assert expected output         expectedOutput = Lists.newArrayList(streamRecordOf(3, 4), streamRecordOf(4, 3), streamRecordOf(4, 4)).         TestHarnessUtil.assertNoLateRecords(newTestHarness.getOutput()).         assertOutput(expectedOutput, newTestHarness.getOutput()).     } }
false;public;4;8;;@Override public void processElement(TestElem left, TestElem right, Context ctx, Collector<Tuple2<TestElem, TestElem>> out) throws Exception {     Assert.assertEquals(left.ts, ctx.getLeftTimestamp()). }
false;public;0;36;;@Test public void testContextCorrectLeftTimestamp() throws Exception {     IntervalJoinOperator<String, TestElem, TestElem, Tuple2<TestElem, TestElem>> op = new IntervalJoinOperator<>(-1, 1, true, true, TestElem.serializer(), TestElem.serializer(), new ProcessJoinFunction<TestElem, TestElem, Tuple2<TestElem, TestElem>>() {          @Override         public void processElement(TestElem left, TestElem right, Context ctx, Collector<Tuple2<TestElem, TestElem>> out) throws Exception {             Assert.assertEquals(left.ts, ctx.getLeftTimestamp()).         }     }).     try (TestHarness testHarness = new TestHarness(op, (elem) -> elem.key, (elem) -> elem.key, TypeInformation.of(String.class))) {         testHarness.setup().         testHarness.open().         processElementsAndWatermarks(testHarness).     } }
false;public;4;8;;@Override public void processElement(TestElem left, TestElem right, Context ctx, Collector<Tuple2<TestElem, TestElem>> out) throws Exception {     Assert.assertEquals(Math.max(left.ts, right.ts), ctx.getTimestamp()). }
false;public;0;38;;@Test public void testReturnsCorrectTimestamp() throws Exception {     IntervalJoinOperator<String, TestElem, TestElem, Tuple2<TestElem, TestElem>> op = new IntervalJoinOperator<>(-1, 1, true, true, TestElem.serializer(), TestElem.serializer(), new ProcessJoinFunction<TestElem, TestElem, Tuple2<TestElem, TestElem>>() {          private static final long serialVersionUID = 1L.          @Override         public void processElement(TestElem left, TestElem right, Context ctx, Collector<Tuple2<TestElem, TestElem>> out) throws Exception {             Assert.assertEquals(Math.max(left.ts, right.ts), ctx.getTimestamp()).         }     }).     try (TestHarness testHarness = new TestHarness(op, (elem) -> elem.key, (elem) -> elem.key, TypeInformation.of(String.class))) {         testHarness.setup().         testHarness.open().         processElementsAndWatermarks(testHarness).     } }
false;public;4;8;;@Override public void processElement(TestElem left, TestElem right, Context ctx, Collector<Tuple2<TestElem, TestElem>> out) throws Exception {     Assert.assertEquals(right.ts, ctx.getRightTimestamp()). }
false;public;0;36;;@Test public void testContextCorrectRightTimestamp() throws Exception {     IntervalJoinOperator<String, TestElem, TestElem, Tuple2<TestElem, TestElem>> op = new IntervalJoinOperator<>(-1, 1, true, true, TestElem.serializer(), TestElem.serializer(), new ProcessJoinFunction<TestElem, TestElem, Tuple2<TestElem, TestElem>>() {          @Override         public void processElement(TestElem left, TestElem right, Context ctx, Collector<Tuple2<TestElem, TestElem>> out) throws Exception {             Assert.assertEquals(right.ts, ctx.getRightTimestamp()).         }     }).     try (TestHarness testHarness = new TestHarness(op, (elem) -> elem.key, (elem) -> elem.key, TypeInformation.of(String.class))) {         testHarness.setup().         testHarness.open().         processElementsAndWatermarks(testHarness).     } }
false;public;0;10;;@Test(expected = FlinkException.class) public void testFailsWithNoTimestampsLeft() throws Exception {     TestHarness newTestHarness = createTestHarness(0L, true, 0L, true).     newTestHarness.setup().     newTestHarness.open().     // note that the StreamRecord has no timestamp in constructor     newTestHarness.processElement1(new StreamRecord<>(new TestElem(0, "lhs"))). }
false;public;0;11;;@Test(expected = FlinkException.class) public void testFailsWithNoTimestampsRight() throws Exception {     try (TestHarness newTestHarness = createTestHarness(0L, true, 0L, true)) {         newTestHarness.setup().         newTestHarness.open().         // note that the StreamRecord has no timestamp in constructor         newTestHarness.processElement2(new StreamRecord<>(new TestElem(0, "rhs"))).     } }
false;public;0;38;;@Test public void testDiscardsLateData() throws Exception {     setupHarness(-1, true, 1, true).processElement1(1).processElement2(1).processElement1(2).processElement2(2).processElement1(3).processElement2(3).processWatermark1(3).processWatermark2(3).processElement1(// this element is late and should not be joined again     1).processElement1(4).processElement2(4).processElement1(5).processElement2(5).andExpect(streamRecordOf(1, 1), streamRecordOf(1, 2), streamRecordOf(2, 1), streamRecordOf(2, 2), streamRecordOf(2, 3), streamRecordOf(3, 2), streamRecordOf(3, 3), streamRecordOf(3, 4), streamRecordOf(4, 3), streamRecordOf(4, 4), streamRecordOf(4, 5), streamRecordOf(5, 4), streamRecordOf(5, 5)).noLateRecords().close(). }
false;private;1;4;;private void assertEmpty(MapState<Long, ?> state) throws Exception {     boolean stateIsEmpty = Iterables.size(state.keys()) == 0.     Assert.assertTrue("state not empty", stateIsEmpty). }
false;private;2;9;;private void assertContainsOnly(MapState<Long, ?> state, long... ts) throws Exception {     for (long t : ts) {         String message = "Keys not found in state. \n Expected: " + Arrays.toString(ts) + "\n Actual:   " + state.keys().         Assert.assertTrue(message, state.contains(t)).     }     String message = "Too many objects in state. \n Expected: " + Arrays.toString(ts) + "\n Actual:   " + state.keys().     Assert.assertEquals(message, ts.length, Iterables.size(state.keys())). }
false;private;2;21;;private void assertOutput(Iterable<StreamRecord<Tuple2<TestElem, TestElem>>> expectedOutput, Queue<Object> actualOutput) {     int actualSize = actualOutput.stream().filter(elem -> elem instanceof StreamRecord).collect(Collectors.toList()).size().     int expectedSize = Iterables.size(expectedOutput).     Assert.assertEquals("Expected and actual size of stream records different", expectedSize, actualSize).     for (StreamRecord<Tuple2<TestElem, TestElem>> record : expectedOutput) {         Assert.assertTrue(actualOutput.contains(record)).     } }
false;private;4;23;;private TestHarness createTestHarness(long lowerBound, boolean lowerBoundInclusive, long upperBound, boolean upperBoundInclusive) throws Exception {     IntervalJoinOperator<String, TestElem, TestElem, Tuple2<TestElem, TestElem>> operator = new IntervalJoinOperator<>(lowerBound, upperBound, lowerBoundInclusive, upperBoundInclusive, TestElem.serializer(), TestElem.serializer(), new PassthroughFunction()).     return new TestHarness(operator, // key     (elem) -> elem.key, // key     (elem) -> elem.key, TypeInformation.of(String.class)). }
false;private;4;25;;private JoinTestBuilder setupHarness(long lowerBound, boolean lowerBoundInclusive, long upperBound, boolean upperBoundInclusive) throws Exception {     IntervalJoinOperator<String, TestElem, TestElem, Tuple2<TestElem, TestElem>> operator = new IntervalJoinOperator<>(lowerBound, upperBound, lowerBoundInclusive, upperBoundInclusive, TestElem.serializer(), TestElem.serializer(), new PassthroughFunction()).     TestHarness t = new TestHarness(operator, // key     (elem) -> elem.key, // key     (elem) -> elem.key, TypeInformation.of(String.class)).     return new JoinTestBuilder(t, operator). }
false;public;0;3;;public TestHarness get() {     return testHarness. }
false;public;1;4;;public JoinTestBuilder processElement1(int ts) throws Exception {     testHarness.processElement1(createStreamRecord(ts, "lhs")).     return this. }
false;public;1;4;;public JoinTestBuilder processElement2(int ts) throws Exception {     testHarness.processElement2(createStreamRecord(ts, "rhs")).     return this. }
false;public;1;4;;public JoinTestBuilder processWatermark1(int ts) throws Exception {     testHarness.processWatermark1(new Watermark(ts)).     return this. }
false;public;1;4;;public JoinTestBuilder processWatermark2(int ts) throws Exception {     testHarness.processWatermark2(new Watermark(ts)).     return this. }
false;public;2;29;;public JoinTestBuilder processElementsAndWatermarks(int from, int to) throws Exception {     if (lhsFasterThanRhs) {         // add to lhs         for (int i = from. i <= to. i++) {             testHarness.processElement1(createStreamRecord(i, "lhs")).             testHarness.processWatermark1(new Watermark(i)).         }         // add to rhs         for (int i = from. i <= to. i++) {             testHarness.processElement2(createStreamRecord(i, "rhs")).             testHarness.processWatermark2(new Watermark(i)).         }     } else {         // add to rhs         for (int i = from. i <= to. i++) {             testHarness.processElement2(createStreamRecord(i, "rhs")).             testHarness.processWatermark2(new Watermark(i)).         }         // add to lhs         for (int i = from. i <= to. i++) {             testHarness.processElement1(createStreamRecord(i, "lhs")).             testHarness.processWatermark1(new Watermark(i)).         }     }     return this. }
false;public,final;1;5;;@SafeVarargs public final JoinTestBuilder andExpect(StreamRecord<Tuple2<TestElem, TestElem>>... elems) {     assertOutput(Lists.newArrayList(elems), testHarness.getOutput()).     return this. }
false;public;1;9;;public JoinTestBuilder assertLeftBufferContainsOnly(long... timestamps) {     try {         assertContainsOnly(operator.getLeftBuffer(), timestamps).     } catch (Exception e) {         throw new RuntimeException(e).     }     return this. }
false;public;1;9;;public JoinTestBuilder assertRightBufferContainsOnly(long... timestamps) {     try {         assertContainsOnly(operator.getRightBuffer(), timestamps).     } catch (Exception e) {         throw new RuntimeException(e).     }     return this. }
false;public;0;8;;public JoinTestBuilder assertLeftBufferEmpty() {     try {         assertEmpty(operator.getLeftBuffer()).     } catch (Exception e) {         throw new RuntimeException(e).     }     return this. }
false;public;0;8;;public JoinTestBuilder assertRightBufferEmpty() {     try {         assertEmpty(operator.getRightBuffer()).     } catch (Exception e) {         throw new RuntimeException(e).     }     return this. }
false;public;0;4;;public JoinTestBuilder noLateRecords() {     TestHarnessUtil.assertNoLateRecords(this.testHarness.getOutput()).     return this. }
false;public;0;3;;public void close() throws Exception {     testHarness.close(). }
false;public;4;8;;@Override public void processElement(TestElem left, TestElem right, Context ctx, Collector<Tuple2<TestElem, TestElem>> out) throws Exception {     out.collect(Tuple2.of(left, right)). }
false;private;2;10;;private StreamRecord<Tuple2<TestElem, TestElem>> streamRecordOf(long lhsTs, long rhsTs) {     TestElem lhs = new TestElem(lhsTs, "lhs").     TestElem rhs = new TestElem(rhsTs, "rhs").     long ts = Math.max(lhsTs, rhsTs).     return new StreamRecord<>(Tuple2.of(lhs, rhs), ts). }
false;public;1;22;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     TestElem testElem = (TestElem) o.     if (ts != testElem.ts) {         return false.     }     if (key != null ? !key.equals(testElem.key) : testElem.key != null) {         return false.     }     return source != null ? source.equals(testElem.source) : testElem.source == null. }
false;public;0;7;;@Override public int hashCode() {     int result = key != null ? key.hashCode() : 0.     result = 31 * result + (int) (ts ^ (ts >>> 32)).     result = 31 * result + (source != null ? source.hashCode() : 0).     return result. }
false;public;0;4;;@Override public String toString() {     return this.source + ":" + this.ts. }
false;public,static;0;4;;public static TypeSerializer<TestElem> serializer() {     return TypeInformation.of(new TypeHint<TestElem>() {     }).createSerializer(new ExecutionConfig()). }
false;private,static;2;4;;private static StreamRecord<TestElem> createStreamRecord(long ts, String source) {     TestElem testElem = new TestElem(ts, source).     return new StreamRecord<>(testElem, ts). }
false;private;1;27;;private void processElementsAndWatermarks(TestHarness testHarness) throws Exception {     if (lhsFasterThanRhs) {         // add to lhs         for (int i = 1. i <= 4. i++) {             testHarness.processElement1(createStreamRecord(i, "lhs")).             testHarness.processWatermark1(new Watermark(i)).         }         // add to rhs         for (int i = 1. i <= 4. i++) {             testHarness.processElement2(createStreamRecord(i, "rhs")).             testHarness.processWatermark2(new Watermark(i)).         }     } else {         // add to rhs         for (int i = 1. i <= 4. i++) {             testHarness.processElement2(createStreamRecord(i, "rhs")).             testHarness.processWatermark2(new Watermark(i)).         }         // add to lhs         for (int i = 1. i <= 4. i++) {             testHarness.processElement1(createStreamRecord(i, "lhs")).             testHarness.processWatermark1(new Watermark(i)).         }     } }
