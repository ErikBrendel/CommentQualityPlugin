# id;timestamp;commentText;codeText;commentWords;codeWords
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1493975289;FLINK-6435__Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1495484544;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1502801814;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1503407113;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1508850407;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1509118643;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1513102156;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1515519059;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1515669171;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1516626397;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1517489695;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1519039284;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1519567828;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1519568061;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1526978549;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1526978549;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOrderedWaitTimeoutHandling() throws Exception;1527946901;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testOrderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,ordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1482206691;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1482206691;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1482522862;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1485357390;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1486328221;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1486732842;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1487762095;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1487871589;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1493975289;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1495484544;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1502801814;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1503407113;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1508850407;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1509118643;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1513102156;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1515519059;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1515669171;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1516626397;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1517489695;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1519039284;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1519567828;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1519568061;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1526978549;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1526978549;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingUnordered() throws Exception;1527946901;Test the AsyncWaitOperator with unordered mode and processing time.;@Test_	public void testProcessingUnordered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,processing,time;test,public,void,test,processing,unordered,throws,exception,test,processing,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1482206691;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1482206691;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1482522862;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1485357390;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1486328221;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1486732842;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1487762095;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1487871589;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1493975289;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1495484544;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1502801814;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1503407113;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1508850407;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1509118643;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1513102156;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1515519059;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1515669171;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1516626397;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1517489695;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1519039284;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1519567828;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1519568061;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1526978549;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1526978549;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testWaterMarkUnordered() throws Exception;1527946901;Test the AsyncWaitOperator with unordered mode and event time.;@Test_	public void testWaterMarkUnordered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.UNORDERED)__	};test,the,async,wait,operator,with,unordered,mode,and,event,time;test,public,void,test,water,mark,unordered,throws,exception,test,event,time,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1485357390;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = mock(Environment.class)__		when(environment.getMetricGroup()).thenReturn(new UnregisteredTaskMetricsGroup())__		when(environment.getTaskManagerInfo()).thenReturn(new TestingTaskManagerRuntimeInfo())__		when(environment.getUserClassLoader()).thenReturn(getClass().getClassLoader())__		when(environment.getTaskInfo()).thenReturn(new TaskInfo(_			"testTask",_			1,_			0,_			1,_			0))__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,mock,environment,class,when,environment,get,metric,group,then,return,new,unregistered,task,metrics,group,when,environment,get,task,manager,info,then,return,new,testing,task,manager,runtime,info,when,environment,get,user,class,loader,then,return,get,class,get,class,loader,when,environment,get,task,info,then,return,new,task,info,test,task,1,0,1,0,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1486328221;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = mock(Environment.class)__		when(environment.getMetricGroup()).thenReturn(new UnregisteredTaskMetricsGroup())__		when(environment.getTaskManagerInfo()).thenReturn(new TestingTaskManagerRuntimeInfo())__		when(environment.getUserClassLoader()).thenReturn(getClass().getClassLoader())__		when(environment.getTaskInfo()).thenReturn(new TaskInfo(_			"testTask",_			1,_			0,_			1,_			0))__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,mock,environment,class,when,environment,get,metric,group,then,return,new,unregistered,task,metrics,group,when,environment,get,task,manager,info,then,return,new,testing,task,manager,runtime,info,when,environment,get,user,class,loader,then,return,get,class,get,class,loader,when,environment,get,task,info,then,return,new,task,info,test,task,1,0,1,0,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1486732842;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = mock(Environment.class)__		when(environment.getMetricGroup()).thenReturn(new UnregisteredTaskMetricsGroup())__		when(environment.getTaskManagerInfo()).thenReturn(new TestingTaskManagerRuntimeInfo())__		when(environment.getUserClassLoader()).thenReturn(getClass().getClassLoader())__		when(environment.getTaskInfo()).thenReturn(new TaskInfo(_			"testTask",_			1,_			0,_			1,_			0))__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,mock,environment,class,when,environment,get,metric,group,then,return,new,unregistered,task,metrics,group,when,environment,get,task,manager,info,then,return,new,testing,task,manager,runtime,info,when,environment,get,user,class,loader,then,return,get,class,get,class,loader,when,environment,get,task,info,then,return,new,task,info,test,task,1,0,1,0,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1487762095;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = mock(Environment.class)__		when(environment.getMetricGroup()).thenReturn(new UnregisteredTaskMetricsGroup())__		when(environment.getTaskManagerInfo()).thenReturn(new TestingTaskManagerRuntimeInfo())__		when(environment.getUserClassLoader()).thenReturn(getClass().getClassLoader())__		when(environment.getTaskInfo()).thenReturn(new TaskInfo(_			"testTask",_			1,_			0,_			1,_			0))__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,mock,environment,class,when,environment,get,metric,group,then,return,new,unregistered,task,metrics,group,when,environment,get,task,manager,info,then,return,new,testing,task,manager,runtime,info,when,environment,get,user,class,loader,then,return,get,class,get,class,loader,when,environment,get,task,info,then,return,new,task,info,test,task,1,0,1,0,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1487871589;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = mock(Environment.class)__		when(environment.getMetricGroup()).thenReturn(new UnregisteredTaskMetricsGroup())__		when(environment.getTaskManagerInfo()).thenReturn(new TestingTaskManagerRuntimeInfo())__		when(environment.getUserClassLoader()).thenReturn(getClass().getClassLoader())__		when(environment.getTaskInfo()).thenReturn(new TaskInfo(_			"testTask",_			1,_			0,_			1,_			0))__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,mock,environment,class,when,environment,get,metric,group,then,return,new,unregistered,task,metrics,group,when,environment,get,task,manager,info,then,return,new,testing,task,manager,runtime,info,when,environment,get,user,class,loader,then,return,get,class,get,class,loader,when,environment,get,task,info,then,return,new,task,info,test,task,1,0,1,0,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1493975289;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = createMockEnvironment()__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,create,mock,environment,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1495484544;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = createMockEnvironment()__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,create,mock,environment,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1502801814;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = createMockEnvironment()__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,create,mock,environment,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1503407113;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = createMockEnvironment()__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,create,mock,environment,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1508850407;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = createMockEnvironment()__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,create,mock,environment,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1509118643;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = createMockEnvironment()__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,create,mock,environment,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1513102156;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = createMockEnvironment()__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,create,mock,environment,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1515519059;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = createMockEnvironment()__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,create,mock,environment,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1515669171;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		Environment environment = createMockEnvironment()__		doNothing().when(environment).failExternally(failureReason.capture())___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		_		try {_			verify(environment, never()).failExternally(any(Throwable.class))__		} catch (Error e) {_			_			_			e.addSuppressed(failureReason.getValue())__			throw e__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,environment,environment,create,mock,environment,do,nothing,when,environment,fail,externally,failure,reason,capture,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,try,verify,environment,never,fail,externally,any,throwable,class,catch,error,e,e,add,suppressed,failure,reason,get,value,throw,e
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1516626397;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		MockEnvironment environment = createMockEnvironment()___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		Assert.assertNull(environment.getFailExternallyCause())__	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,mock,environment,environment,create,mock,environment,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,assert,assert,null,environment,get,fail,externally,cause
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1517489695;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		MockEnvironment environment = createMockEnvironment()___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}__		Assert.assertNull(environment.getFailExternallyCause())__	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,mock,environment,environment,create,mock,environment,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close,assert,assert,null,environment,get,fail,externally,cause
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1519039284;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		MockEnvironment environment = createMockEnvironment()___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,mock,environment,environment,create,mock,environment,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1519567828;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		MockEnvironment environment = createMockEnvironment()___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,mock,environment,environment,create,mock,environment,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1519568061;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		MockEnvironment environment = createMockEnvironment()___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,mock,environment,environment,create,mock,environment,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1526978549;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		MockEnvironment environment = createMockEnvironment()___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,mock,environment,environment,create,mock,environment,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1526978549;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		MockEnvironment environment = createMockEnvironment()___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = new MockStreamConfig()__		streamConfig.setTypeSerializerIn1(IntSerializer.INSTANCE)___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,mock,environment,environment,create,mock,environment,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,new,mock,stream,config,stream,config,set,type,serializer,in1,int,serializer,instance,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close
AsyncWaitOperatorTest -> @Test(timeout = 10000L) 	public void testClosingWithBlockedEmitter() throws Exception;1527946901;Test case for FLINK-5638: Tests that the async wait operator can be closed even if the_emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async_wait operators where the latter operator's queue is currently full).__<p>Note that this test does not enforce the exact strict ordering because with the fix it is no_longer possible. However, it provokes the described situation without the fix.;@Test(timeout = 10000L)_	public void testClosingWithBlockedEmitter() throws Exception {_		final Object lock = new Object()___		ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class)___		MockEnvironment environment = createMockEnvironment()___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService())___		StreamConfig streamConfig = new MockStreamConfig()__		streamConfig.setTypeSerializerIn1(IntSerializer.INSTANCE)___		final OneShotLatch closingLatch = new OneShotLatch()__		final OneShotLatch outputLatch = new OneShotLatch()___		Output<StreamRecord<Integer>> output = mock(Output.class)__		doAnswer(new Answer() {_			@Override_			public Object answer(InvocationOnMock invocation) throws Throwable {_				assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock))___				outputLatch.trigger()___				_				while (!closingLatch.isTriggered()) {_					lock.wait()__				}__				return null__			}_		}).when(output).collect(any(StreamRecord.class))___		AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(_			new MyAsyncFunction(),_			1000L,_			1,_			AsyncDataStream.OutputMode.ORDERED,_			closingLatch)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		synchronized (lock) {_			operator.processElement(new StreamRecord<>(42))__		}__		outputLatch.await()___		synchronized (lock) {_			operator.close()__		}_	};test,case,for,flink,5638,tests,that,the,async,wait,operator,can,be,closed,even,if,the,emitter,is,currently,waiting,on,the,checkpoint,lock,e,g,in,the,case,of,two,chained,async,wait,operators,where,the,latter,operator,s,queue,is,currently,full,p,note,that,this,test,does,not,enforce,the,exact,strict,ordering,because,with,the,fix,it,is,no,longer,possible,however,it,provokes,the,described,situation,without,the,fix;test,timeout,10000l,public,void,test,closing,with,blocked,emitter,throws,exception,final,object,lock,new,object,argument,captor,throwable,failure,reason,argument,captor,for,class,throwable,class,mock,environment,environment,create,mock,environment,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,new,test,processing,time,service,stream,config,stream,config,new,mock,stream,config,stream,config,set,type,serializer,in1,int,serializer,instance,final,one,shot,latch,closing,latch,new,one,shot,latch,final,one,shot,latch,output,latch,new,one,shot,latch,output,stream,record,integer,output,mock,output,class,do,answer,new,answer,override,public,object,answer,invocation,on,mock,invocation,throws,throwable,assert,true,output,should,happen,under,the,checkpoint,lock,thread,current,thread,holds,lock,lock,output,latch,trigger,while,closing,latch,is,triggered,lock,wait,return,null,when,output,collect,any,stream,record,class,async,wait,operator,integer,integer,operator,new,test,async,wait,operator,new,my,async,function,1000l,1,async,data,stream,output,mode,ordered,closing,latch,operator,setup,containing,task,stream,config,output,operator,open,synchronized,lock,operator,process,element,new,stream,record,42,output,latch,await,synchronized,lock,operator,close
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1493975289;FLINK-6435__Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1495484544;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1502801814;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1503407113;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1508850407;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1509118643;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1513102156;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1515519059;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1515669171;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1516626397;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1517489695;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1519039284;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1519567828;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1519568061;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1526978549;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1526978549;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testOrderedWaitUserExceptionHandling() throws Exception;1527946901;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testOrderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,ordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1493975289;FLINK-6435__Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1495484544;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1502801814;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1503407113;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1508850407;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1509118643;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1513102156;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1515519059;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1515669171;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1516626397;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1517489695;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1519039284;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1519567828;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1519568061;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1526978549;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1526978549;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testUnorderedWaitTimeoutHandling() throws Exception;1527946901;FLINK-6435__<p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that_a StreamElementQueueEntry is completed in case of a timeout exception.;@Test_	public void testUnorderedWaitTimeoutHandling() throws Exception {_		testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,timeout,exceptions,are,properly,handled,in,ordered,output,mode,the,proper,handling,means,that,a,stream,element,queue,entry,is,completed,in,case,of,a,timeout,exception;test,public,void,test,unordered,wait,timeout,handling,throws,exception,test,timeout,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1482206691;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1482206691;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1482522862;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1485357390;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1486328221;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1486732842;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1487762095;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1487871589;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1493975289;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1495484544;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1502801814;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1503407113;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1508850407;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1509118643;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1513102156;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1515519059;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1515669171;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1516626397;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1517489695;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1519039284;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1519567828;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1519568061;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1526978549;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1526978549;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testProcessingTimeOrdered() throws Exception;1527946901;Test the AsyncWaitOperator with ordered mode and processing time.;@Test_	public void testProcessingTimeOrdered() throws Exception {_		testProcessingTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,processing,time;test,public,void,test,processing,time,ordered,throws,exception,test,processing,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1482206691;Tests that the AsyncWaitOperator works together with chaining;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1482206691;Tests that the AsyncWaitOperator works together with chaining;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1482522862;Tests that the AsyncWaitOperator works together with chaining;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1485357390;Tests that the AsyncWaitOperator works together with chaining;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1486328221;Tests that the AsyncWaitOperator works together with chaining;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1486732842;Tests that the AsyncWaitOperator works together with chaining;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1487762095;Tests that the AsyncWaitOperator works together with chaining;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1487871589;Tests that the AsyncWaitOperator works together with chaining;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1493975289;Tests that the AsyncWaitOperator works together with chaining;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1495484544;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1502801814;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1503407113;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1508850407;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1509118643;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1513102156;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTask<Integer, Integer> task = new OneInputStreamTask<>()__		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =_				new OneInputStreamTaskTestHarness<>(task, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,integer,integer,task,new,one,input,stream,task,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,task,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1515519059;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1515669171;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1516626397;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1517489695;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1519039284;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1519567828;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1519568061;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1526978549;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1526978549;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testOperatorChainWithProcessingTime() throws Exception;1527946901;Tests that the AsyncWaitOperator works together with chaining.;@Test_	public void testOperatorChainWithProcessingTime() throws Exception {__		JobVertex chainedVertex = createChainedVertex(false)___		final OneInputStreamTaskTestHarness<Integer, Integer> testHarness = new OneInputStreamTaskTestHarness<>(_				OneInputStreamTask::new,_				1, 1,_				BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		testHarness.taskConfig = chainedVertex.getConfiguration()___		final StreamConfig streamConfig = testHarness.getStreamConfig()__		final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration())__		final AsyncWaitOperator<Integer, Integer> headOperator =_				operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader())__		streamConfig.setStreamOperator(headOperator)___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		long initialTimestamp = 0L___		testHarness.processElement(new StreamRecord<>(5, initialTimestamp))__		testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L))__		testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L))__		testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L))__		testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L))___		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()__		expectedOutput.add(new StreamRecord<>(22, initialTimestamp))__		expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L))__		expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L))__		expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L))__		expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L))___		TestHarnessUtil.assertOutputEqualsSorted(_				"Test for chained operator with AsyncWaitOperator failed",_				expectedOutput,_				testHarness.getOutput(),_				new StreamRecordComparator())__	};tests,that,the,async,wait,operator,works,together,with,chaining;test,public,void,test,operator,chain,with,processing,time,throws,exception,job,vertex,chained,vertex,create,chained,vertex,false,final,one,input,stream,task,test,harness,integer,integer,test,harness,new,one,input,stream,task,test,harness,one,input,stream,task,new,1,1,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,test,harness,task,config,chained,vertex,get,configuration,final,stream,config,stream,config,test,harness,get,stream,config,final,stream,config,operator,chain,stream,config,new,stream,config,chained,vertex,get,configuration,final,async,wait,operator,integer,integer,head,operator,operator,chain,stream,config,get,stream,operator,async,wait,operator,test,class,get,class,loader,stream,config,set,stream,operator,head,operator,test,harness,invoke,test,harness,wait,for,task,running,long,initial,timestamp,0l,test,harness,process,element,new,stream,record,5,initial,timestamp,test,harness,process,element,new,stream,record,6,initial,timestamp,1l,test,harness,process,element,new,stream,record,7,initial,timestamp,2l,test,harness,process,element,new,stream,record,8,initial,timestamp,3l,test,harness,process,element,new,stream,record,9,initial,timestamp,4l,test,harness,end,input,test,harness,wait,for,task,completion,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,22,initial,timestamp,expected,output,add,new,stream,record,26,initial,timestamp,1l,expected,output,add,new,stream,record,30,initial,timestamp,2l,expected,output,add,new,stream,record,34,initial,timestamp,3l,expected,output,add,new,stream,record,38,initial,timestamp,4l,test,harness,util,assert,output,equals,sorted,test,for,chained,operator,with,async,wait,operator,failed,expected,output,test,harness,get,output,new,stream,record,comparator
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1482206691;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1482206691;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1482522862;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1485357390;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1486328221;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1486732842;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1487762095;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1487871589;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1493975289;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1495484544;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1502801814;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1503407113;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1508850407;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1509118643;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1513102156;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1515519059;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1515669171;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1516626397;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1517489695;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1519039284;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1519567828;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1519568061;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1526978549;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1526978549;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test 	public void testEventTimeOrdered() throws Exception;1527946901;Test the AsyncWaitOperator with ordered mode and event time.;@Test_	public void testEventTimeOrdered() throws Exception {_		testEventTime(AsyncDataStream.OutputMode.ORDERED)__	};test,the,async,wait,operator,with,ordered,mode,and,event,time;test,public,void,test,event,time,ordered,throws,exception,test,event,time,async,data,stream,output,mode,ordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1493975289;FLINK-6435__Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1495484544;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1502801814;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1503407113;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1508850407;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1509118643;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1513102156;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1515519059;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1515669171;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1516626397;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1517489695;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1519039284;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1519567828;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1519568061;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1526978549;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1526978549;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 2000) 	public void testUnorderedWaitUserExceptionHandling() throws Exception;1527946901;FLINK-6435__<p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until_another StreamElementQueueEntry is properly completed before it is collected.;@Test(timeout = 2000)_	public void testUnorderedWaitUserExceptionHandling() throws Exception {_		testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED)__	};flink,6435,p,tests,that,a,user,exception,triggers,the,completion,of,a,stream,element,queue,entry,and,does,not,wait,to,until,another,stream,element,queue,entry,is,properly,completed,before,it,is,collected;test,timeout,2000,public,void,test,unordered,wait,user,exception,handling,throws,exception,test,user,exception,handling,async,data,stream,output,mode,unordered
AsyncWaitOperatorTest -> @Test(timeout = 10000) 	public void testRestartWithFullQueue() throws Exception;1515669171;Tests that the AysncWaitOperator can restart if checkpointed queue was full.__<p>See FLINK-7949;@Test(timeout = 10000)_	public void testRestartWithFullQueue() throws Exception {_		int capacity = 10___		_		final CompletableFuture<Void> trigger = new CompletableFuture<>()__		final ControllableAsyncFunction<Integer> controllableAsyncFunction = new ControllableAsyncFunction<>(trigger)___		final OneInputStreamOperatorTestHarness<Integer, Integer> snapshotHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				controllableAsyncFunction, _				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		snapshotHarness.open()___		final OperatorStateHandles snapshot___		final ArrayList<Integer> expectedOutput = new ArrayList<>(capacity + 1)___		try {_			synchronized (snapshotHarness.getCheckpointLock()) {_				for (int i = 0_ i < capacity_ i++) {_					snapshotHarness.processElement(i, 0L)__					expectedOutput.add(i)__				}_			}__			expectedOutput.add(capacity)___			final OneShotLatch lastElement = new OneShotLatch()___			final CheckedThread lastElementWriter = new CheckedThread() {_				@Override_				public void go() throws Exception {_					synchronized (snapshotHarness.getCheckpointLock()) {_						lastElement.trigger()__						snapshotHarness.processElement(capacity, 0L)__					}_				}_			}___			lastElementWriter.start()___			lastElement.await()___			synchronized (snapshotHarness.getCheckpointLock()) {_				_				_				snapshot = snapshotHarness.snapshot(0L, 0L)__			}__			_			trigger.complete(null)__		} finally {_			synchronized (snapshotHarness.getCheckpointLock()) {_				snapshotHarness.close()__			}_		}__		_		final OneInputStreamOperatorTestHarness<Integer, Integer> recoverHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				new ControllableAsyncFunction<>(CompletableFuture.completedFuture(null)),_				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		recoverHarness.initializeState(snapshot)___		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.open()__		}__		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.close()__		}__		final ConcurrentLinkedQueue<Object> output = recoverHarness.getOutput()___		assertThat(output.size(), Matchers.equalTo(capacity + 1))___		final ArrayList<Integer> outputElements = new ArrayList<>(capacity + 1)___		for (int i = 0_ i < capacity + 1_ i++) {_			StreamRecord<Integer> streamRecord = ((StreamRecord<Integer>) output.poll())__			outputElements.add(streamRecord.getValue())__		}__		assertThat(outputElements, Matchers.equalTo(expectedOutput))__	};tests,that,the,aysnc,wait,operator,can,restart,if,checkpointed,queue,was,full,p,see,flink,7949;test,timeout,10000,public,void,test,restart,with,full,queue,throws,exception,int,capacity,10,final,completable,future,void,trigger,new,completable,future,final,controllable,async,function,integer,controllable,async,function,new,controllable,async,function,trigger,final,one,input,stream,operator,test,harness,integer,integer,snapshot,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,controllable,async,function,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,snapshot,harness,open,final,operator,state,handles,snapshot,final,array,list,integer,expected,output,new,array,list,capacity,1,try,synchronized,snapshot,harness,get,checkpoint,lock,for,int,i,0,i,capacity,i,snapshot,harness,process,element,i,0l,expected,output,add,i,expected,output,add,capacity,final,one,shot,latch,last,element,new,one,shot,latch,final,checked,thread,last,element,writer,new,checked,thread,override,public,void,go,throws,exception,synchronized,snapshot,harness,get,checkpoint,lock,last,element,trigger,snapshot,harness,process,element,capacity,0l,last,element,writer,start,last,element,await,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,snapshot,harness,snapshot,0l,0l,trigger,complete,null,finally,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,harness,close,final,one,input,stream,operator,test,harness,integer,integer,recover,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,new,controllable,async,function,completable,future,completed,future,null,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,recover,harness,initialize,state,snapshot,synchronized,recover,harness,get,checkpoint,lock,recover,harness,open,synchronized,recover,harness,get,checkpoint,lock,recover,harness,close,final,concurrent,linked,queue,object,output,recover,harness,get,output,assert,that,output,size,matchers,equal,to,capacity,1,final,array,list,integer,output,elements,new,array,list,capacity,1,for,int,i,0,i,capacity,1,i,stream,record,integer,stream,record,stream,record,integer,output,poll,output,elements,add,stream,record,get,value,assert,that,output,elements,matchers,equal,to,expected,output
AsyncWaitOperatorTest -> @Test(timeout = 10000) 	public void testRestartWithFullQueue() throws Exception;1516626397;Tests that the AysncWaitOperator can restart if checkpointed queue was full.__<p>See FLINK-7949;@Test(timeout = 10000)_	public void testRestartWithFullQueue() throws Exception {_		int capacity = 10___		_		final CompletableFuture<Void> trigger = new CompletableFuture<>()__		final ControllableAsyncFunction<Integer> controllableAsyncFunction = new ControllableAsyncFunction<>(trigger)___		final OneInputStreamOperatorTestHarness<Integer, Integer> snapshotHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				controllableAsyncFunction, _				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		snapshotHarness.open()___		final OperatorStateHandles snapshot___		final ArrayList<Integer> expectedOutput = new ArrayList<>(capacity + 1)___		try {_			synchronized (snapshotHarness.getCheckpointLock()) {_				for (int i = 0_ i < capacity_ i++) {_					snapshotHarness.processElement(i, 0L)__					expectedOutput.add(i)__				}_			}__			expectedOutput.add(capacity)___			final OneShotLatch lastElement = new OneShotLatch()___			final CheckedThread lastElementWriter = new CheckedThread() {_				@Override_				public void go() throws Exception {_					synchronized (snapshotHarness.getCheckpointLock()) {_						lastElement.trigger()__						snapshotHarness.processElement(capacity, 0L)__					}_				}_			}___			lastElementWriter.start()___			lastElement.await()___			synchronized (snapshotHarness.getCheckpointLock()) {_				_				_				snapshot = snapshotHarness.snapshot(0L, 0L)__			}__			_			trigger.complete(null)__		} finally {_			synchronized (snapshotHarness.getCheckpointLock()) {_				snapshotHarness.close()__			}_		}__		_		final OneInputStreamOperatorTestHarness<Integer, Integer> recoverHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				new ControllableAsyncFunction<>(CompletableFuture.completedFuture(null)),_				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		recoverHarness.initializeState(snapshot)___		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.open()__		}__		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.close()__		}__		final ConcurrentLinkedQueue<Object> output = recoverHarness.getOutput()___		assertThat(output.size(), Matchers.equalTo(capacity + 1))___		final ArrayList<Integer> outputElements = new ArrayList<>(capacity + 1)___		for (int i = 0_ i < capacity + 1_ i++) {_			StreamRecord<Integer> streamRecord = ((StreamRecord<Integer>) output.poll())__			outputElements.add(streamRecord.getValue())__		}__		assertThat(outputElements, Matchers.equalTo(expectedOutput))__	};tests,that,the,aysnc,wait,operator,can,restart,if,checkpointed,queue,was,full,p,see,flink,7949;test,timeout,10000,public,void,test,restart,with,full,queue,throws,exception,int,capacity,10,final,completable,future,void,trigger,new,completable,future,final,controllable,async,function,integer,controllable,async,function,new,controllable,async,function,trigger,final,one,input,stream,operator,test,harness,integer,integer,snapshot,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,controllable,async,function,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,snapshot,harness,open,final,operator,state,handles,snapshot,final,array,list,integer,expected,output,new,array,list,capacity,1,try,synchronized,snapshot,harness,get,checkpoint,lock,for,int,i,0,i,capacity,i,snapshot,harness,process,element,i,0l,expected,output,add,i,expected,output,add,capacity,final,one,shot,latch,last,element,new,one,shot,latch,final,checked,thread,last,element,writer,new,checked,thread,override,public,void,go,throws,exception,synchronized,snapshot,harness,get,checkpoint,lock,last,element,trigger,snapshot,harness,process,element,capacity,0l,last,element,writer,start,last,element,await,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,snapshot,harness,snapshot,0l,0l,trigger,complete,null,finally,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,harness,close,final,one,input,stream,operator,test,harness,integer,integer,recover,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,new,controllable,async,function,completable,future,completed,future,null,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,recover,harness,initialize,state,snapshot,synchronized,recover,harness,get,checkpoint,lock,recover,harness,open,synchronized,recover,harness,get,checkpoint,lock,recover,harness,close,final,concurrent,linked,queue,object,output,recover,harness,get,output,assert,that,output,size,matchers,equal,to,capacity,1,final,array,list,integer,output,elements,new,array,list,capacity,1,for,int,i,0,i,capacity,1,i,stream,record,integer,stream,record,stream,record,integer,output,poll,output,elements,add,stream,record,get,value,assert,that,output,elements,matchers,equal,to,expected,output
AsyncWaitOperatorTest -> @Test(timeout = 10000) 	public void testRestartWithFullQueue() throws Exception;1517489695;Tests that the AysncWaitOperator can restart if checkpointed queue was full.__<p>See FLINK-7949;@Test(timeout = 10000)_	public void testRestartWithFullQueue() throws Exception {_		int capacity = 10___		_		final CompletableFuture<Void> trigger = new CompletableFuture<>()__		final ControllableAsyncFunction<Integer> controllableAsyncFunction = new ControllableAsyncFunction<>(trigger)___		final OneInputStreamOperatorTestHarness<Integer, Integer> snapshotHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				controllableAsyncFunction, _				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		snapshotHarness.open()___		final OperatorStateHandles snapshot___		final ArrayList<Integer> expectedOutput = new ArrayList<>(capacity + 1)___		try {_			synchronized (snapshotHarness.getCheckpointLock()) {_				for (int i = 0_ i < capacity_ i++) {_					snapshotHarness.processElement(i, 0L)__					expectedOutput.add(i)__				}_			}__			expectedOutput.add(capacity)___			final OneShotLatch lastElement = new OneShotLatch()___			final CheckedThread lastElementWriter = new CheckedThread() {_				@Override_				public void go() throws Exception {_					synchronized (snapshotHarness.getCheckpointLock()) {_						lastElement.trigger()__						snapshotHarness.processElement(capacity, 0L)__					}_				}_			}___			lastElementWriter.start()___			lastElement.await()___			synchronized (snapshotHarness.getCheckpointLock()) {_				_				_				snapshot = snapshotHarness.snapshot(0L, 0L)__			}__			_			trigger.complete(null)__		} finally {_			synchronized (snapshotHarness.getCheckpointLock()) {_				snapshotHarness.close()__			}_		}__		_		final OneInputStreamOperatorTestHarness<Integer, Integer> recoverHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				new ControllableAsyncFunction<>(CompletableFuture.completedFuture(null)),_				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		recoverHarness.initializeState(snapshot)___		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.open()__		}__		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.close()__		}__		final ConcurrentLinkedQueue<Object> output = recoverHarness.getOutput()___		assertThat(output.size(), Matchers.equalTo(capacity + 1))___		final ArrayList<Integer> outputElements = new ArrayList<>(capacity + 1)___		for (int i = 0_ i < capacity + 1_ i++) {_			StreamRecord<Integer> streamRecord = ((StreamRecord<Integer>) output.poll())__			outputElements.add(streamRecord.getValue())__		}__		assertThat(outputElements, Matchers.equalTo(expectedOutput))__	};tests,that,the,aysnc,wait,operator,can,restart,if,checkpointed,queue,was,full,p,see,flink,7949;test,timeout,10000,public,void,test,restart,with,full,queue,throws,exception,int,capacity,10,final,completable,future,void,trigger,new,completable,future,final,controllable,async,function,integer,controllable,async,function,new,controllable,async,function,trigger,final,one,input,stream,operator,test,harness,integer,integer,snapshot,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,controllable,async,function,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,snapshot,harness,open,final,operator,state,handles,snapshot,final,array,list,integer,expected,output,new,array,list,capacity,1,try,synchronized,snapshot,harness,get,checkpoint,lock,for,int,i,0,i,capacity,i,snapshot,harness,process,element,i,0l,expected,output,add,i,expected,output,add,capacity,final,one,shot,latch,last,element,new,one,shot,latch,final,checked,thread,last,element,writer,new,checked,thread,override,public,void,go,throws,exception,synchronized,snapshot,harness,get,checkpoint,lock,last,element,trigger,snapshot,harness,process,element,capacity,0l,last,element,writer,start,last,element,await,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,snapshot,harness,snapshot,0l,0l,trigger,complete,null,finally,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,harness,close,final,one,input,stream,operator,test,harness,integer,integer,recover,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,new,controllable,async,function,completable,future,completed,future,null,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,recover,harness,initialize,state,snapshot,synchronized,recover,harness,get,checkpoint,lock,recover,harness,open,synchronized,recover,harness,get,checkpoint,lock,recover,harness,close,final,concurrent,linked,queue,object,output,recover,harness,get,output,assert,that,output,size,matchers,equal,to,capacity,1,final,array,list,integer,output,elements,new,array,list,capacity,1,for,int,i,0,i,capacity,1,i,stream,record,integer,stream,record,stream,record,integer,output,poll,output,elements,add,stream,record,get,value,assert,that,output,elements,matchers,equal,to,expected,output
AsyncWaitOperatorTest -> @Test(timeout = 10000) 	public void testRestartWithFullQueue() throws Exception;1519039284;Tests that the AysncWaitOperator can restart if checkpointed queue was full.__<p>See FLINK-7949;@Test(timeout = 10000)_	public void testRestartWithFullQueue() throws Exception {_		int capacity = 10___		_		final CompletableFuture<Void> trigger = new CompletableFuture<>()__		final ControllableAsyncFunction<Integer> controllableAsyncFunction = new ControllableAsyncFunction<>(trigger)___		final OneInputStreamOperatorTestHarness<Integer, Integer> snapshotHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				controllableAsyncFunction, _				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		snapshotHarness.open()___		final OperatorStateHandles snapshot___		final ArrayList<Integer> expectedOutput = new ArrayList<>(capacity + 1)___		try {_			synchronized (snapshotHarness.getCheckpointLock()) {_				for (int i = 0_ i < capacity_ i++) {_					snapshotHarness.processElement(i, 0L)__					expectedOutput.add(i)__				}_			}__			expectedOutput.add(capacity)___			final OneShotLatch lastElement = new OneShotLatch()___			final CheckedThread lastElementWriter = new CheckedThread() {_				@Override_				public void go() throws Exception {_					synchronized (snapshotHarness.getCheckpointLock()) {_						lastElement.trigger()__						snapshotHarness.processElement(capacity, 0L)__					}_				}_			}___			lastElementWriter.start()___			lastElement.await()___			synchronized (snapshotHarness.getCheckpointLock()) {_				_				_				snapshot = snapshotHarness.snapshot(0L, 0L)__			}__			_			trigger.complete(null)__		} finally {_			synchronized (snapshotHarness.getCheckpointLock()) {_				snapshotHarness.close()__			}_		}__		_		final OneInputStreamOperatorTestHarness<Integer, Integer> recoverHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				new ControllableAsyncFunction<>(CompletableFuture.completedFuture(null)),_				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		recoverHarness.initializeState(snapshot)___		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.open()__		}__		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.close()__		}__		final ConcurrentLinkedQueue<Object> output = recoverHarness.getOutput()___		assertThat(output.size(), Matchers.equalTo(capacity + 1))___		final ArrayList<Integer> outputElements = new ArrayList<>(capacity + 1)___		for (int i = 0_ i < capacity + 1_ i++) {_			StreamRecord<Integer> streamRecord = ((StreamRecord<Integer>) output.poll())__			outputElements.add(streamRecord.getValue())__		}__		assertThat(outputElements, Matchers.equalTo(expectedOutput))__	};tests,that,the,aysnc,wait,operator,can,restart,if,checkpointed,queue,was,full,p,see,flink,7949;test,timeout,10000,public,void,test,restart,with,full,queue,throws,exception,int,capacity,10,final,completable,future,void,trigger,new,completable,future,final,controllable,async,function,integer,controllable,async,function,new,controllable,async,function,trigger,final,one,input,stream,operator,test,harness,integer,integer,snapshot,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,controllable,async,function,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,snapshot,harness,open,final,operator,state,handles,snapshot,final,array,list,integer,expected,output,new,array,list,capacity,1,try,synchronized,snapshot,harness,get,checkpoint,lock,for,int,i,0,i,capacity,i,snapshot,harness,process,element,i,0l,expected,output,add,i,expected,output,add,capacity,final,one,shot,latch,last,element,new,one,shot,latch,final,checked,thread,last,element,writer,new,checked,thread,override,public,void,go,throws,exception,synchronized,snapshot,harness,get,checkpoint,lock,last,element,trigger,snapshot,harness,process,element,capacity,0l,last,element,writer,start,last,element,await,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,snapshot,harness,snapshot,0l,0l,trigger,complete,null,finally,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,harness,close,final,one,input,stream,operator,test,harness,integer,integer,recover,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,new,controllable,async,function,completable,future,completed,future,null,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,recover,harness,initialize,state,snapshot,synchronized,recover,harness,get,checkpoint,lock,recover,harness,open,synchronized,recover,harness,get,checkpoint,lock,recover,harness,close,final,concurrent,linked,queue,object,output,recover,harness,get,output,assert,that,output,size,matchers,equal,to,capacity,1,final,array,list,integer,output,elements,new,array,list,capacity,1,for,int,i,0,i,capacity,1,i,stream,record,integer,stream,record,stream,record,integer,output,poll,output,elements,add,stream,record,get,value,assert,that,output,elements,matchers,equal,to,expected,output
AsyncWaitOperatorTest -> @Test(timeout = 10000) 	public void testRestartWithFullQueue() throws Exception;1519567828;Tests that the AysncWaitOperator can restart if checkpointed queue was full.__<p>See FLINK-7949;@Test(timeout = 10000)_	public void testRestartWithFullQueue() throws Exception {_		int capacity = 10___		_		final CompletableFuture<Void> trigger = new CompletableFuture<>()__		final ControllableAsyncFunction<Integer> controllableAsyncFunction = new ControllableAsyncFunction<>(trigger)___		final OneInputStreamOperatorTestHarness<Integer, Integer> snapshotHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				controllableAsyncFunction, _				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		snapshotHarness.open()___		final OperatorSubtaskState snapshot___		final ArrayList<Integer> expectedOutput = new ArrayList<>(capacity + 1)___		try {_			synchronized (snapshotHarness.getCheckpointLock()) {_				for (int i = 0_ i < capacity_ i++) {_					snapshotHarness.processElement(i, 0L)__					expectedOutput.add(i)__				}_			}__			expectedOutput.add(capacity)___			final OneShotLatch lastElement = new OneShotLatch()___			final CheckedThread lastElementWriter = new CheckedThread() {_				@Override_				public void go() throws Exception {_					synchronized (snapshotHarness.getCheckpointLock()) {_						lastElement.trigger()__						snapshotHarness.processElement(capacity, 0L)__					}_				}_			}___			lastElementWriter.start()___			lastElement.await()___			synchronized (snapshotHarness.getCheckpointLock()) {_				_				_				snapshot = snapshotHarness.snapshot(0L, 0L)__			}__			_			trigger.complete(null)__		} finally {_			synchronized (snapshotHarness.getCheckpointLock()) {_				snapshotHarness.close()__			}_		}__		_		final OneInputStreamOperatorTestHarness<Integer, Integer> recoverHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				new ControllableAsyncFunction<>(CompletableFuture.completedFuture(null)),_				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		recoverHarness.initializeState(snapshot)___		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.open()__		}__		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.close()__		}__		final ConcurrentLinkedQueue<Object> output = recoverHarness.getOutput()___		assertThat(output.size(), Matchers.equalTo(capacity + 1))___		final ArrayList<Integer> outputElements = new ArrayList<>(capacity + 1)___		for (int i = 0_ i < capacity + 1_ i++) {_			StreamRecord<Integer> streamRecord = ((StreamRecord<Integer>) output.poll())__			outputElements.add(streamRecord.getValue())__		}__		assertThat(outputElements, Matchers.equalTo(expectedOutput))__	};tests,that,the,aysnc,wait,operator,can,restart,if,checkpointed,queue,was,full,p,see,flink,7949;test,timeout,10000,public,void,test,restart,with,full,queue,throws,exception,int,capacity,10,final,completable,future,void,trigger,new,completable,future,final,controllable,async,function,integer,controllable,async,function,new,controllable,async,function,trigger,final,one,input,stream,operator,test,harness,integer,integer,snapshot,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,controllable,async,function,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,snapshot,harness,open,final,operator,subtask,state,snapshot,final,array,list,integer,expected,output,new,array,list,capacity,1,try,synchronized,snapshot,harness,get,checkpoint,lock,for,int,i,0,i,capacity,i,snapshot,harness,process,element,i,0l,expected,output,add,i,expected,output,add,capacity,final,one,shot,latch,last,element,new,one,shot,latch,final,checked,thread,last,element,writer,new,checked,thread,override,public,void,go,throws,exception,synchronized,snapshot,harness,get,checkpoint,lock,last,element,trigger,snapshot,harness,process,element,capacity,0l,last,element,writer,start,last,element,await,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,snapshot,harness,snapshot,0l,0l,trigger,complete,null,finally,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,harness,close,final,one,input,stream,operator,test,harness,integer,integer,recover,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,new,controllable,async,function,completable,future,completed,future,null,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,recover,harness,initialize,state,snapshot,synchronized,recover,harness,get,checkpoint,lock,recover,harness,open,synchronized,recover,harness,get,checkpoint,lock,recover,harness,close,final,concurrent,linked,queue,object,output,recover,harness,get,output,assert,that,output,size,matchers,equal,to,capacity,1,final,array,list,integer,output,elements,new,array,list,capacity,1,for,int,i,0,i,capacity,1,i,stream,record,integer,stream,record,stream,record,integer,output,poll,output,elements,add,stream,record,get,value,assert,that,output,elements,matchers,equal,to,expected,output
AsyncWaitOperatorTest -> @Test(timeout = 10000) 	public void testRestartWithFullQueue() throws Exception;1519568061;Tests that the AysncWaitOperator can restart if checkpointed queue was full.__<p>See FLINK-7949;@Test(timeout = 10000)_	public void testRestartWithFullQueue() throws Exception {_		int capacity = 10___		_		final CompletableFuture<Void> trigger = new CompletableFuture<>()__		final ControllableAsyncFunction<Integer> controllableAsyncFunction = new ControllableAsyncFunction<>(trigger)___		final OneInputStreamOperatorTestHarness<Integer, Integer> snapshotHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				controllableAsyncFunction, _				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		snapshotHarness.open()___		final OperatorSubtaskState snapshot___		final ArrayList<Integer> expectedOutput = new ArrayList<>(capacity + 1)___		try {_			synchronized (snapshotHarness.getCheckpointLock()) {_				for (int i = 0_ i < capacity_ i++) {_					snapshotHarness.processElement(i, 0L)__					expectedOutput.add(i)__				}_			}__			expectedOutput.add(capacity)___			final OneShotLatch lastElement = new OneShotLatch()___			final CheckedThread lastElementWriter = new CheckedThread() {_				@Override_				public void go() throws Exception {_					synchronized (snapshotHarness.getCheckpointLock()) {_						lastElement.trigger()__						snapshotHarness.processElement(capacity, 0L)__					}_				}_			}___			lastElementWriter.start()___			lastElement.await()___			synchronized (snapshotHarness.getCheckpointLock()) {_				_				_				snapshot = snapshotHarness.snapshot(0L, 0L)__			}__			_			trigger.complete(null)__		} finally {_			synchronized (snapshotHarness.getCheckpointLock()) {_				snapshotHarness.close()__			}_		}__		_		final OneInputStreamOperatorTestHarness<Integer, Integer> recoverHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				new ControllableAsyncFunction<>(CompletableFuture.completedFuture(null)),_				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		recoverHarness.initializeState(snapshot)___		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.open()__		}__		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.close()__		}__		final ConcurrentLinkedQueue<Object> output = recoverHarness.getOutput()___		assertThat(output.size(), Matchers.equalTo(capacity + 1))___		final ArrayList<Integer> outputElements = new ArrayList<>(capacity + 1)___		for (int i = 0_ i < capacity + 1_ i++) {_			StreamRecord<Integer> streamRecord = ((StreamRecord<Integer>) output.poll())__			outputElements.add(streamRecord.getValue())__		}__		assertThat(outputElements, Matchers.equalTo(expectedOutput))__	};tests,that,the,aysnc,wait,operator,can,restart,if,checkpointed,queue,was,full,p,see,flink,7949;test,timeout,10000,public,void,test,restart,with,full,queue,throws,exception,int,capacity,10,final,completable,future,void,trigger,new,completable,future,final,controllable,async,function,integer,controllable,async,function,new,controllable,async,function,trigger,final,one,input,stream,operator,test,harness,integer,integer,snapshot,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,controllable,async,function,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,snapshot,harness,open,final,operator,subtask,state,snapshot,final,array,list,integer,expected,output,new,array,list,capacity,1,try,synchronized,snapshot,harness,get,checkpoint,lock,for,int,i,0,i,capacity,i,snapshot,harness,process,element,i,0l,expected,output,add,i,expected,output,add,capacity,final,one,shot,latch,last,element,new,one,shot,latch,final,checked,thread,last,element,writer,new,checked,thread,override,public,void,go,throws,exception,synchronized,snapshot,harness,get,checkpoint,lock,last,element,trigger,snapshot,harness,process,element,capacity,0l,last,element,writer,start,last,element,await,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,snapshot,harness,snapshot,0l,0l,trigger,complete,null,finally,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,harness,close,final,one,input,stream,operator,test,harness,integer,integer,recover,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,new,controllable,async,function,completable,future,completed,future,null,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,recover,harness,initialize,state,snapshot,synchronized,recover,harness,get,checkpoint,lock,recover,harness,open,synchronized,recover,harness,get,checkpoint,lock,recover,harness,close,final,concurrent,linked,queue,object,output,recover,harness,get,output,assert,that,output,size,matchers,equal,to,capacity,1,final,array,list,integer,output,elements,new,array,list,capacity,1,for,int,i,0,i,capacity,1,i,stream,record,integer,stream,record,stream,record,integer,output,poll,output,elements,add,stream,record,get,value,assert,that,output,elements,matchers,equal,to,expected,output
AsyncWaitOperatorTest -> @Test(timeout = 10000) 	public void testRestartWithFullQueue() throws Exception;1526978549;Tests that the AysncWaitOperator can restart if checkpointed queue was full.__<p>See FLINK-7949;@Test(timeout = 10000)_	public void testRestartWithFullQueue() throws Exception {_		int capacity = 10___		_		final CompletableFuture<Void> trigger = new CompletableFuture<>()__		final ControllableAsyncFunction<Integer> controllableAsyncFunction = new ControllableAsyncFunction<>(trigger)___		final OneInputStreamOperatorTestHarness<Integer, Integer> snapshotHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				controllableAsyncFunction, _				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		snapshotHarness.open()___		final OperatorSubtaskState snapshot___		final ArrayList<Integer> expectedOutput = new ArrayList<>(capacity + 1)___		try {_			synchronized (snapshotHarness.getCheckpointLock()) {_				for (int i = 0_ i < capacity_ i++) {_					snapshotHarness.processElement(i, 0L)__					expectedOutput.add(i)__				}_			}__			expectedOutput.add(capacity)___			final OneShotLatch lastElement = new OneShotLatch()___			final CheckedThread lastElementWriter = new CheckedThread() {_				@Override_				public void go() throws Exception {_					synchronized (snapshotHarness.getCheckpointLock()) {_						lastElement.trigger()__						snapshotHarness.processElement(capacity, 0L)__					}_				}_			}___			lastElementWriter.start()___			lastElement.await()___			synchronized (snapshotHarness.getCheckpointLock()) {_				_				_				snapshot = snapshotHarness.snapshot(0L, 0L)__			}__			_			trigger.complete(null)__		} finally {_			synchronized (snapshotHarness.getCheckpointLock()) {_				snapshotHarness.close()__			}_		}__		_		final OneInputStreamOperatorTestHarness<Integer, Integer> recoverHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				new ControllableAsyncFunction<>(CompletableFuture.completedFuture(null)),_				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		recoverHarness.initializeState(snapshot)___		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.open()__		}__		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.close()__		}__		final ConcurrentLinkedQueue<Object> output = recoverHarness.getOutput()___		assertThat(output.size(), Matchers.equalTo(capacity + 1))___		final ArrayList<Integer> outputElements = new ArrayList<>(capacity + 1)___		for (int i = 0_ i < capacity + 1_ i++) {_			StreamRecord<Integer> streamRecord = ((StreamRecord<Integer>) output.poll())__			outputElements.add(streamRecord.getValue())__		}__		assertThat(outputElements, Matchers.equalTo(expectedOutput))__	};tests,that,the,aysnc,wait,operator,can,restart,if,checkpointed,queue,was,full,p,see,flink,7949;test,timeout,10000,public,void,test,restart,with,full,queue,throws,exception,int,capacity,10,final,completable,future,void,trigger,new,completable,future,final,controllable,async,function,integer,controllable,async,function,new,controllable,async,function,trigger,final,one,input,stream,operator,test,harness,integer,integer,snapshot,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,controllable,async,function,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,snapshot,harness,open,final,operator,subtask,state,snapshot,final,array,list,integer,expected,output,new,array,list,capacity,1,try,synchronized,snapshot,harness,get,checkpoint,lock,for,int,i,0,i,capacity,i,snapshot,harness,process,element,i,0l,expected,output,add,i,expected,output,add,capacity,final,one,shot,latch,last,element,new,one,shot,latch,final,checked,thread,last,element,writer,new,checked,thread,override,public,void,go,throws,exception,synchronized,snapshot,harness,get,checkpoint,lock,last,element,trigger,snapshot,harness,process,element,capacity,0l,last,element,writer,start,last,element,await,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,snapshot,harness,snapshot,0l,0l,trigger,complete,null,finally,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,harness,close,final,one,input,stream,operator,test,harness,integer,integer,recover,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,new,controllable,async,function,completable,future,completed,future,null,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,recover,harness,initialize,state,snapshot,synchronized,recover,harness,get,checkpoint,lock,recover,harness,open,synchronized,recover,harness,get,checkpoint,lock,recover,harness,close,final,concurrent,linked,queue,object,output,recover,harness,get,output,assert,that,output,size,matchers,equal,to,capacity,1,final,array,list,integer,output,elements,new,array,list,capacity,1,for,int,i,0,i,capacity,1,i,stream,record,integer,stream,record,stream,record,integer,output,poll,output,elements,add,stream,record,get,value,assert,that,output,elements,matchers,equal,to,expected,output
AsyncWaitOperatorTest -> @Test(timeout = 10000) 	public void testRestartWithFullQueue() throws Exception;1526978549;Tests that the AysncWaitOperator can restart if checkpointed queue was full.__<p>See FLINK-7949;@Test(timeout = 10000)_	public void testRestartWithFullQueue() throws Exception {_		int capacity = 10___		_		final CompletableFuture<Void> trigger = new CompletableFuture<>()__		final ControllableAsyncFunction<Integer> controllableAsyncFunction = new ControllableAsyncFunction<>(trigger)___		final OneInputStreamOperatorTestHarness<Integer, Integer> snapshotHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				controllableAsyncFunction, _				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		snapshotHarness.open()___		final OperatorSubtaskState snapshot___		final ArrayList<Integer> expectedOutput = new ArrayList<>(capacity + 1)___		try {_			synchronized (snapshotHarness.getCheckpointLock()) {_				for (int i = 0_ i < capacity_ i++) {_					snapshotHarness.processElement(i, 0L)__					expectedOutput.add(i)__				}_			}__			expectedOutput.add(capacity)___			final OneShotLatch lastElement = new OneShotLatch()___			final CheckedThread lastElementWriter = new CheckedThread() {_				@Override_				public void go() throws Exception {_					synchronized (snapshotHarness.getCheckpointLock()) {_						lastElement.trigger()__						snapshotHarness.processElement(capacity, 0L)__					}_				}_			}___			lastElementWriter.start()___			lastElement.await()___			synchronized (snapshotHarness.getCheckpointLock()) {_				_				_				snapshot = snapshotHarness.snapshot(0L, 0L)__			}__			_			trigger.complete(null)__		} finally {_			synchronized (snapshotHarness.getCheckpointLock()) {_				snapshotHarness.close()__			}_		}__		_		final OneInputStreamOperatorTestHarness<Integer, Integer> recoverHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				new ControllableAsyncFunction<>(CompletableFuture.completedFuture(null)),_				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		recoverHarness.initializeState(snapshot)___		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.open()__		}__		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.close()__		}__		final ConcurrentLinkedQueue<Object> output = recoverHarness.getOutput()___		assertThat(output.size(), Matchers.equalTo(capacity + 1))___		final ArrayList<Integer> outputElements = new ArrayList<>(capacity + 1)___		for (int i = 0_ i < capacity + 1_ i++) {_			StreamRecord<Integer> streamRecord = ((StreamRecord<Integer>) output.poll())__			outputElements.add(streamRecord.getValue())__		}__		assertThat(outputElements, Matchers.equalTo(expectedOutput))__	};tests,that,the,aysnc,wait,operator,can,restart,if,checkpointed,queue,was,full,p,see,flink,7949;test,timeout,10000,public,void,test,restart,with,full,queue,throws,exception,int,capacity,10,final,completable,future,void,trigger,new,completable,future,final,controllable,async,function,integer,controllable,async,function,new,controllable,async,function,trigger,final,one,input,stream,operator,test,harness,integer,integer,snapshot,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,controllable,async,function,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,snapshot,harness,open,final,operator,subtask,state,snapshot,final,array,list,integer,expected,output,new,array,list,capacity,1,try,synchronized,snapshot,harness,get,checkpoint,lock,for,int,i,0,i,capacity,i,snapshot,harness,process,element,i,0l,expected,output,add,i,expected,output,add,capacity,final,one,shot,latch,last,element,new,one,shot,latch,final,checked,thread,last,element,writer,new,checked,thread,override,public,void,go,throws,exception,synchronized,snapshot,harness,get,checkpoint,lock,last,element,trigger,snapshot,harness,process,element,capacity,0l,last,element,writer,start,last,element,await,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,snapshot,harness,snapshot,0l,0l,trigger,complete,null,finally,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,harness,close,final,one,input,stream,operator,test,harness,integer,integer,recover,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,new,controllable,async,function,completable,future,completed,future,null,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,recover,harness,initialize,state,snapshot,synchronized,recover,harness,get,checkpoint,lock,recover,harness,open,synchronized,recover,harness,get,checkpoint,lock,recover,harness,close,final,concurrent,linked,queue,object,output,recover,harness,get,output,assert,that,output,size,matchers,equal,to,capacity,1,final,array,list,integer,output,elements,new,array,list,capacity,1,for,int,i,0,i,capacity,1,i,stream,record,integer,stream,record,stream,record,integer,output,poll,output,elements,add,stream,record,get,value,assert,that,output,elements,matchers,equal,to,expected,output
AsyncWaitOperatorTest -> @Test(timeout = 10000) 	public void testRestartWithFullQueue() throws Exception;1527946901;Tests that the AysncWaitOperator can restart if checkpointed queue was full.__<p>See FLINK-7949;@Test(timeout = 10000)_	public void testRestartWithFullQueue() throws Exception {_		int capacity = 10___		_		final CompletableFuture<Void> trigger = new CompletableFuture<>()__		final ControllableAsyncFunction<Integer> controllableAsyncFunction = new ControllableAsyncFunction<>(trigger)___		final OneInputStreamOperatorTestHarness<Integer, Integer> snapshotHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				controllableAsyncFunction, _				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		snapshotHarness.open()___		final OperatorSubtaskState snapshot___		final ArrayList<Integer> expectedOutput = new ArrayList<>(capacity + 1)___		try {_			synchronized (snapshotHarness.getCheckpointLock()) {_				for (int i = 0_ i < capacity_ i++) {_					snapshotHarness.processElement(i, 0L)__					expectedOutput.add(i)__				}_			}__			expectedOutput.add(capacity)___			final OneShotLatch lastElement = new OneShotLatch()___			final CheckedThread lastElementWriter = new CheckedThread() {_				@Override_				public void go() throws Exception {_					synchronized (snapshotHarness.getCheckpointLock()) {_						lastElement.trigger()__						snapshotHarness.processElement(capacity, 0L)__					}_				}_			}___			lastElementWriter.start()___			lastElement.await()___			synchronized (snapshotHarness.getCheckpointLock()) {_				_				_				snapshot = snapshotHarness.snapshot(0L, 0L)__			}__			_			trigger.complete(null)__		} finally {_			synchronized (snapshotHarness.getCheckpointLock()) {_				snapshotHarness.close()__			}_		}__		_		final OneInputStreamOperatorTestHarness<Integer, Integer> recoverHarness = new OneInputStreamOperatorTestHarness<>(_			new AsyncWaitOperator<>(_				new ControllableAsyncFunction<>(CompletableFuture.completedFuture(null)),_				1000L,_				capacity,_				AsyncDataStream.OutputMode.ORDERED),_			IntSerializer.INSTANCE)___		recoverHarness.initializeState(snapshot)___		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.open()__		}__		synchronized (recoverHarness.getCheckpointLock()) {_			recoverHarness.close()__		}__		final ConcurrentLinkedQueue<Object> output = recoverHarness.getOutput()___		assertThat(output.size(), Matchers.equalTo(capacity + 1))___		final ArrayList<Integer> outputElements = new ArrayList<>(capacity + 1)___		for (int i = 0_ i < capacity + 1_ i++) {_			StreamRecord<Integer> streamRecord = ((StreamRecord<Integer>) output.poll())__			outputElements.add(streamRecord.getValue())__		}__		assertThat(outputElements, Matchers.equalTo(expectedOutput))__	};tests,that,the,aysnc,wait,operator,can,restart,if,checkpointed,queue,was,full,p,see,flink,7949;test,timeout,10000,public,void,test,restart,with,full,queue,throws,exception,int,capacity,10,final,completable,future,void,trigger,new,completable,future,final,controllable,async,function,integer,controllable,async,function,new,controllable,async,function,trigger,final,one,input,stream,operator,test,harness,integer,integer,snapshot,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,controllable,async,function,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,snapshot,harness,open,final,operator,subtask,state,snapshot,final,array,list,integer,expected,output,new,array,list,capacity,1,try,synchronized,snapshot,harness,get,checkpoint,lock,for,int,i,0,i,capacity,i,snapshot,harness,process,element,i,0l,expected,output,add,i,expected,output,add,capacity,final,one,shot,latch,last,element,new,one,shot,latch,final,checked,thread,last,element,writer,new,checked,thread,override,public,void,go,throws,exception,synchronized,snapshot,harness,get,checkpoint,lock,last,element,trigger,snapshot,harness,process,element,capacity,0l,last,element,writer,start,last,element,await,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,snapshot,harness,snapshot,0l,0l,trigger,complete,null,finally,synchronized,snapshot,harness,get,checkpoint,lock,snapshot,harness,close,final,one,input,stream,operator,test,harness,integer,integer,recover,harness,new,one,input,stream,operator,test,harness,new,async,wait,operator,new,controllable,async,function,completable,future,completed,future,null,1000l,capacity,async,data,stream,output,mode,ordered,int,serializer,instance,recover,harness,initialize,state,snapshot,synchronized,recover,harness,get,checkpoint,lock,recover,harness,open,synchronized,recover,harness,get,checkpoint,lock,recover,harness,close,final,concurrent,linked,queue,object,output,recover,harness,get,output,assert,that,output,size,matchers,equal,to,capacity,1,final,array,list,integer,output,elements,new,array,list,capacity,1,for,int,i,0,i,capacity,1,i,stream,record,integer,stream,record,stream,record,integer,output,poll,output,elements,add,stream,record,get,value,assert,that,output,elements,matchers,equal,to,expected,output
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1486328221;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = mock(Environment.class)__		when(environment.getMetricGroup()).thenReturn(new UnregisteredTaskMetricsGroup())__		when(environment.getTaskManagerInfo()).thenReturn(new TestingTaskManagerRuntimeInfo())__		when(environment.getUserClassLoader()).thenReturn(getClass().getClassLoader())__		when(environment.getTaskInfo()).thenReturn(new TaskInfo(_			"testTask",_			1,_			0,_			1,_			0))___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, AsyncCollector<Integer> collector) throws Exception {_					collector.collect(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,mock,environment,class,when,environment,get,metric,group,then,return,new,unregistered,task,metrics,group,when,environment,get,task,manager,info,then,return,new,testing,task,manager,runtime,info,when,environment,get,user,class,loader,then,return,get,class,get,class,loader,when,environment,get,task,info,then,return,new,task,info,test,task,1,0,1,0,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,async,collector,integer,collector,throws,exception,collector,collect,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1486732842;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = mock(Environment.class)__		when(environment.getMetricGroup()).thenReturn(new UnregisteredTaskMetricsGroup())__		when(environment.getTaskManagerInfo()).thenReturn(new TestingTaskManagerRuntimeInfo())__		when(environment.getUserClassLoader()).thenReturn(getClass().getClassLoader())__		when(environment.getTaskInfo()).thenReturn(new TaskInfo(_			"testTask",_			1,_			0,_			1,_			0))___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, AsyncCollector<Integer> collector) throws Exception {_					collector.collect(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,mock,environment,class,when,environment,get,metric,group,then,return,new,unregistered,task,metrics,group,when,environment,get,task,manager,info,then,return,new,testing,task,manager,runtime,info,when,environment,get,user,class,loader,then,return,get,class,get,class,loader,when,environment,get,task,info,then,return,new,task,info,test,task,1,0,1,0,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,async,collector,integer,collector,throws,exception,collector,collect,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1487762095;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = mock(Environment.class)__		when(environment.getMetricGroup()).thenReturn(new UnregisteredTaskMetricsGroup())__		when(environment.getTaskManagerInfo()).thenReturn(new TestingTaskManagerRuntimeInfo())__		when(environment.getUserClassLoader()).thenReturn(getClass().getClassLoader())__		when(environment.getTaskInfo()).thenReturn(new TaskInfo(_			"testTask",_			1,_			0,_			1,_			0))___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, AsyncCollector<Integer> collector) throws Exception {_					collector.collect(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,mock,environment,class,when,environment,get,metric,group,then,return,new,unregistered,task,metrics,group,when,environment,get,task,manager,info,then,return,new,testing,task,manager,runtime,info,when,environment,get,user,class,loader,then,return,get,class,get,class,loader,when,environment,get,task,info,then,return,new,task,info,test,task,1,0,1,0,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,async,collector,integer,collector,throws,exception,collector,collect,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1487871589;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = mock(Environment.class)__		when(environment.getMetricGroup()).thenReturn(new UnregisteredTaskMetricsGroup())__		when(environment.getTaskManagerInfo()).thenReturn(new TestingTaskManagerRuntimeInfo())__		when(environment.getUserClassLoader()).thenReturn(getClass().getClassLoader())__		when(environment.getTaskInfo()).thenReturn(new TaskInfo(_			"testTask",_			1,_			0,_			1,_			0))___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, AsyncCollector<Integer> collector) throws Exception {_					collector.collect(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,mock,environment,class,when,environment,get,metric,group,then,return,new,unregistered,task,metrics,group,when,environment,get,task,manager,info,then,return,new,testing,task,manager,runtime,info,when,environment,get,user,class,loader,then,return,get,class,get,class,loader,when,environment,get,task,info,then,return,new,task,info,test,task,1,0,1,0,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,async,collector,integer,collector,throws,exception,collector,collect,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1493975289;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, AsyncCollector<Integer> collector) throws Exception {_					collector.collect(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,async,collector,integer,collector,throws,exception,collector,collect,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1495484544;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, AsyncCollector<Integer> collector) throws Exception {_					collector.collect(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,async,collector,integer,collector,throws,exception,collector,collect,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1502801814;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, AsyncCollector<Integer> collector) throws Exception {_					collector.collect(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,async,collector,integer,collector,throws,exception,collector,collect,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1503407113;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1508850407;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1509118643;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1513102156;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1515519059;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1515669171;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1516626397;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1517489695;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1519039284;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1519567828;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1519568061;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1526978549;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = mock(StreamConfig.class)__		doReturn(IntSerializer.INSTANCE).when(streamConfig).getTypeSerializerIn1(any(ClassLoader.class))___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,mock,stream,config,class,do,return,int,serializer,instance,when,stream,config,get,type,serializer,in1,any,class,loader,class,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1526978549;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = new MockStreamConfig()__		streamConfig.setTypeSerializerIn1(IntSerializer.INSTANCE)___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,new,mock,stream,config,stream,config,set,type,serializer,in1,int,serializer,instance,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
AsyncWaitOperatorTest -> @Test 	public void testTimeoutCleanup() throws Exception;1527946901;FLINK-5652_Tests that registered timers are properly canceled upon completion of a_{@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold_a reference on the StreamRecordQueueEntry.;@Test_	public void testTimeoutCleanup() throws Exception {_		final Object lock = new Object()___		final long timeout = 100000L__		final long timestamp = 1L___		Environment environment = createMockEnvironment()___		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class)___		ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class)__		when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp)__		doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class))___		StreamTask<?, ?> containingTask = mock(StreamTask.class)__		when(containingTask.getEnvironment()).thenReturn(environment)__		when(containingTask.getCheckpointLock()).thenReturn(lock)__		when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService)___		StreamConfig streamConfig = new MockStreamConfig()__		streamConfig.setTypeSerializerIn1(IntSerializer.INSTANCE)___		Output<StreamRecord<Integer>> output = mock(Output.class)___		AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(_			new AsyncFunction<Integer, Integer>() {_				private static final long serialVersionUID = -3718276118074877073L___				@Override_				public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {_					resultFuture.complete(Collections.singletonList(input))__				}_			},_			timeout,_			1,_			AsyncDataStream.OutputMode.UNORDERED)___		operator.setup(_			containingTask,_			streamConfig,_			output)___		operator.open()___		final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp)___		synchronized (lock) {_			_			operator.processElement(streamRecord)__		}__		synchronized (lock) {_			_			operator.close()__		}__		_		verify(output).collect(eq(streamRecord))__		verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class))___		_		verify(scheduledFuture).cancel(eq(true))__	};flink,5652,tests,that,registered,timers,are,properly,canceled,upon,completion,of,a,link,stream,record,queue,entry,in,order,to,avoid,resource,leaks,because,trigger,tasks,hold,a,reference,on,the,stream,record,queue,entry;test,public,void,test,timeout,cleanup,throws,exception,final,object,lock,new,object,final,long,timeout,100000l,final,long,timestamp,1l,environment,environment,create,mock,environment,scheduled,future,scheduled,future,mock,scheduled,future,class,processing,time,service,processing,time,service,mock,processing,time,service,class,when,processing,time,service,get,current,processing,time,then,return,timestamp,do,return,scheduled,future,when,processing,time,service,register,timer,any,long,any,processing,time,callback,class,stream,task,containing,task,mock,stream,task,class,when,containing,task,get,environment,then,return,environment,when,containing,task,get,checkpoint,lock,then,return,lock,when,containing,task,get,processing,time,service,then,return,processing,time,service,stream,config,stream,config,new,mock,stream,config,stream,config,set,type,serializer,in1,int,serializer,instance,output,stream,record,integer,output,mock,output,class,async,wait,operator,integer,integer,operator,new,async,wait,operator,new,async,function,integer,integer,private,static,final,long,serial,version,uid,3718276118074877073l,override,public,void,async,invoke,integer,input,result,future,integer,result,future,throws,exception,result,future,complete,collections,singleton,list,input,timeout,1,async,data,stream,output,mode,unordered,operator,setup,containing,task,stream,config,output,operator,open,final,stream,record,integer,stream,record,new,stream,record,42,timestamp,synchronized,lock,operator,process,element,stream,record,synchronized,lock,operator,close,verify,output,collect,eq,stream,record,verify,processing,time,service,register,timer,eq,processing,time,service,get,current,processing,time,timeout,any,processing,time,callback,class,verify,scheduled,future,cancel,eq,true
