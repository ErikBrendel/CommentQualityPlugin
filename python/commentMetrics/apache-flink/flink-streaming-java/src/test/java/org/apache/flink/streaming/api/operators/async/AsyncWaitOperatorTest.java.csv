commented;modifiers;parameterAmount;loc;comment;code
false;public;1;12;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     synchronized (MyAsyncFunction.class) {         if (counter == 0) {             executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE).         }         ++counter.     } }
false;public;0;6;;@Override public void close() throws Exception {     super.close().     freeExecutor(). }
false;private;0;19;;private void freeExecutor() {     synchronized (MyAsyncFunction.class) {         --counter.         if (counter == 0) {             executorService.shutdown().             try {                 if (!executorService.awaitTermination(TERMINATION_TIMEOUT, TimeUnit.MILLISECONDS)) {                     executorService.shutdownNow().                 }             } catch (InterruptedException interrupted) {                 executorService.shutdownNow().                 Thread.currentThread().interrupt().             }         }     } }
false;public;0;4;;@Override public void run() {     resultFuture.complete(Collections.singletonList(input * 2)). }
false;public;2;9;;@Override public void asyncInvoke(final Integer input, final ResultFuture<Integer> resultFuture) throws Exception {     executorService.submit(new Runnable() {          @Override         public void run() {             resultFuture.complete(Collections.singletonList(input * 2)).         }     }). }
false;public;0;11;;@Override public void run() {     try {         latch.await().     } catch (InterruptedException e) {     // do nothing     }     resultFuture.complete(Collections.singletonList(input)). }
false;public;2;16;;@Override public void asyncInvoke(final Integer input, final ResultFuture<Integer> resultFuture) throws Exception {     this.executorService.submit(new Runnable() {          @Override         public void run() {             try {                 latch.await().             } catch (InterruptedException e) {             // do nothing             }             resultFuture.complete(Collections.singletonList(input)).         }     }). }
false;public,static;0;3;;public static void countDown() {     latch.countDown(). }
false;public;2;4;;@Override public void timeout(Integer input, ResultFuture<Integer> resultFuture) throws Exception {     resultFuture.complete(Collections.singletonList(input * 3)). }
false;public;2;20;;@Override public int compare(Object o1, Object o2) {     if (o1 instanceof Watermark || o2 instanceof Watermark) {         return 0.     } else {         StreamRecord<Integer> sr0 = (StreamRecord<Integer>) o1.         StreamRecord<Integer> sr1 = (StreamRecord<Integer>) o2.         if (sr0.getTimestamp() != sr1.getTimestamp()) {             return (int) (sr0.getTimestamp() - sr1.getTimestamp()).         }         int comparison = sr0.getValue().compareTo(sr1.getValue()).         if (comparison != 0) {             return comparison.         } else {             return sr0.getValue() - sr1.getValue().         }     } }
true;public;0;4;/**  * Test the AsyncWaitOperator with ordered mode and event time.  */ ;/**  * Test the AsyncWaitOperator with ordered mode and event time.  */ @Test public void testEventTimeOrdered() throws Exception {     testEventTime(AsyncDataStream.OutputMode.ORDERED). }
true;public;0;4;/**  * Test the AsyncWaitOperator with unordered mode and event time.  */ ;/**  * Test the AsyncWaitOperator with unordered mode and event time.  */ @Test public void testWaterMarkUnordered() throws Exception {     testEventTime(AsyncDataStream.OutputMode.UNORDERED). }
false;private;1;48;;private void testEventTime(AsyncDataStream.OutputMode mode) throws Exception {     final AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(new MyAsyncFunction(), TIMEOUT, 2, mode).     final OneInputStreamOperatorTestHarness<Integer, Integer> testHarness = new OneInputStreamOperatorTestHarness<>(operator, IntSerializer.INSTANCE).     final long initialTime = 0L.     final ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     testHarness.open().     synchronized (testHarness.getCheckpointLock()) {         testHarness.processElement(new StreamRecord<>(1, initialTime + 1)).         testHarness.processElement(new StreamRecord<>(2, initialTime + 2)).         testHarness.processWatermark(new Watermark(initialTime + 2)).         testHarness.processElement(new StreamRecord<>(3, initialTime + 3)).     }     // wait until all async collectors in the buffer have been emitted out.     synchronized (testHarness.getCheckpointLock()) {         testHarness.close().     }     expectedOutput.add(new StreamRecord<>(2, initialTime + 1)).     expectedOutput.add(new StreamRecord<>(4, initialTime + 2)).     expectedOutput.add(new Watermark(initialTime + 2)).     expectedOutput.add(new StreamRecord<>(6, initialTime + 3)).     if (AsyncDataStream.OutputMode.ORDERED == mode) {         TestHarnessUtil.assertOutputEquals("Output with watermark was not correct.", expectedOutput, testHarness.getOutput()).     } else {         Object[] jobOutputQueue = testHarness.getOutput().toArray().         Assert.assertEquals("Watermark should be at index 2", new Watermark(initialTime + 2), jobOutputQueue[2]).         Assert.assertEquals("StreamRecord 3 should be at the end", new StreamRecord<>(6, initialTime + 3), jobOutputQueue[3]).         TestHarnessUtil.assertOutputEqualsSorted("Output for StreamRecords does not match", expectedOutput, testHarness.getOutput(), new StreamRecordComparator()).     } }
true;public;0;4;/**  * Test the AsyncWaitOperator with ordered mode and processing time.  */ ;/**  * Test the AsyncWaitOperator with ordered mode and processing time.  */ @Test public void testProcessingTimeOrdered() throws Exception {     testProcessingTime(AsyncDataStream.OutputMode.ORDERED). }
true;public;0;4;/**  * Test the AsyncWaitOperator with unordered mode and processing time.  */ ;/**  * Test the AsyncWaitOperator with unordered mode and processing time.  */ @Test public void testProcessingUnordered() throws Exception {     testProcessingTime(AsyncDataStream.OutputMode.UNORDERED). }
false;private;1;46;;private void testProcessingTime(AsyncDataStream.OutputMode mode) throws Exception {     final AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(new MyAsyncFunction(), TIMEOUT, 6, mode).     final OneInputStreamOperatorTestHarness<Integer, Integer> testHarness = new OneInputStreamOperatorTestHarness<>(operator, IntSerializer.INSTANCE).     final long initialTime = 0L.     final Queue<Object> expectedOutput = new ArrayDeque<>().     testHarness.open().     synchronized (testHarness.getCheckpointLock()) {         testHarness.processElement(new StreamRecord<>(1, initialTime + 1)).         testHarness.processElement(new StreamRecord<>(2, initialTime + 2)).         testHarness.processElement(new StreamRecord<>(3, initialTime + 3)).         testHarness.processElement(new StreamRecord<>(4, initialTime + 4)).         testHarness.processElement(new StreamRecord<>(5, initialTime + 5)).         testHarness.processElement(new StreamRecord<>(6, initialTime + 6)).         testHarness.processElement(new StreamRecord<>(7, initialTime + 7)).         testHarness.processElement(new StreamRecord<>(8, initialTime + 8)).     }     expectedOutput.add(new StreamRecord<>(2, initialTime + 1)).     expectedOutput.add(new StreamRecord<>(4, initialTime + 2)).     expectedOutput.add(new StreamRecord<>(6, initialTime + 3)).     expectedOutput.add(new StreamRecord<>(8, initialTime + 4)).     expectedOutput.add(new StreamRecord<>(10, initialTime + 5)).     expectedOutput.add(new StreamRecord<>(12, initialTime + 6)).     expectedOutput.add(new StreamRecord<>(14, initialTime + 7)).     expectedOutput.add(new StreamRecord<>(16, initialTime + 8)).     synchronized (testHarness.getCheckpointLock()) {         testHarness.close().     }     if (mode == AsyncDataStream.OutputMode.ORDERED) {         TestHarnessUtil.assertOutputEquals("ORDERED Output was not correct.", expectedOutput, testHarness.getOutput()).     } else {         TestHarnessUtil.assertOutputEqualsSorted("UNORDERED Output was not correct.", expectedOutput, testHarness.getOutput(), new StreamRecordComparator()).     } }
true;public;0;46;/**  * 	Tests that the AsyncWaitOperator works together with chaining.  */ ;/**  * 	Tests that the AsyncWaitOperator works together with chaining.  */ @Test public void testOperatorChainWithProcessingTime() throws Exception {     JobVertex chainedVertex = createChainedVertex(false).     final OneInputStreamTaskTestHarness<Integer, Integer> testHarness = new OneInputStreamTaskTestHarness<>(OneInputStreamTask::new, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO).     testHarness.setupOutputForSingletonOperatorChain().     testHarness.taskConfig = chainedVertex.getConfiguration().     final StreamConfig streamConfig = testHarness.getStreamConfig().     final StreamConfig operatorChainStreamConfig = new StreamConfig(chainedVertex.getConfiguration()).     final AsyncWaitOperator<Integer, Integer> headOperator = operatorChainStreamConfig.getStreamOperator(AsyncWaitOperatorTest.class.getClassLoader()).     streamConfig.setStreamOperator(headOperator).     testHarness.invoke().     testHarness.waitForTaskRunning().     long initialTimestamp = 0L.     testHarness.processElement(new StreamRecord<>(5, initialTimestamp)).     testHarness.processElement(new StreamRecord<>(6, initialTimestamp + 1L)).     testHarness.processElement(new StreamRecord<>(7, initialTimestamp + 2L)).     testHarness.processElement(new StreamRecord<>(8, initialTimestamp + 3L)).     testHarness.processElement(new StreamRecord<>(9, initialTimestamp + 4L)).     testHarness.endInput().     testHarness.waitForTaskCompletion().     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     expectedOutput.add(new StreamRecord<>(22, initialTimestamp)).     expectedOutput.add(new StreamRecord<>(26, initialTimestamp + 1L)).     expectedOutput.add(new StreamRecord<>(30, initialTimestamp + 2L)).     expectedOutput.add(new StreamRecord<>(34, initialTimestamp + 3L)).     expectedOutput.add(new StreamRecord<>(38, initialTimestamp + 4L)).     TestHarnessUtil.assertOutputEqualsSorted("Test for chained operator with AsyncWaitOperator failed", expectedOutput, testHarness.getOutput(), new StreamRecordComparator()). }
false;public;1;4;;@Override public void open(Configuration parameters) throws Exception {     initialValue = 1. }
false;public;1;4;;@Override public Integer map(Integer value) throws Exception {     return initialValue + value. }
false;public;1;4;;@Override public Integer map(Integer value) throws Exception {     return value. }
false;private;1;67;;private JobVertex createChainedVertex(boolean withLazyFunction) {     StreamExecutionEnvironment chainEnv = StreamExecutionEnvironment.getExecutionEnvironment().     // the input is only used to construct a chained operator, and they will not be used in the real tests.     DataStream<Integer> input = chainEnv.fromElements(1, 2, 3).     if (withLazyFunction) {         input = AsyncDataStream.orderedWait(input, new LazyAsyncFunction(), TIMEOUT, TimeUnit.MILLISECONDS, 6).     } else {         input = AsyncDataStream.orderedWait(input, new MyAsyncFunction(), TIMEOUT, TimeUnit.MILLISECONDS, 6).     }     // the map function is designed to chain after async function. we place an Integer object in it and     // it is initialized in the open() method.     // it is used to verify that operators in the operator chain should be opened from the tail to the head,     // so the result from AsyncWaitOperator can pass down successfully and correctly.     // if not, the test can not be passed.     input = input.map(new RichMapFunction<Integer, Integer>() {          private static final long serialVersionUID = 1L.          private Integer initialValue = null.          @Override         public void open(Configuration parameters) throws Exception {             initialValue = 1.         }          @Override         public Integer map(Integer value) throws Exception {             return initialValue + value.         }     }).     input = AsyncDataStream.unorderedWait(input, new MyAsyncFunction(), TIMEOUT, TimeUnit.MILLISECONDS, 3).     input.map(new MapFunction<Integer, Integer>() {          private static final long serialVersionUID = 5162085254238405527L.          @Override         public Integer map(Integer value) throws Exception {             return value.         }     }).startNewChain().addSink(new DiscardingSink<Integer>()).     // be build our own OperatorChain     final JobGraph jobGraph = chainEnv.getStreamGraph().getJobGraph().     Assert.assertTrue(jobGraph.getVerticesSortedTopologicallyFromSources().size() == 3).     return jobGraph.getVerticesSortedTopologicallyFromSources().get(1). }
false;public;0;113;;@Test public void testStateSnapshotAndRestore() throws Exception {     final OneInputStreamTaskTestHarness<Integer, Integer> testHarness = new OneInputStreamTaskTestHarness<>(OneInputStreamTask::new, 1, 1, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO).     testHarness.setupOutputForSingletonOperatorChain().     AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(new LazyAsyncFunction(), TIMEOUT, 3, AsyncDataStream.OutputMode.ORDERED).     final StreamConfig streamConfig = testHarness.getStreamConfig().     OperatorID operatorID = new OperatorID(42L, 4711L).     streamConfig.setStreamOperator(operator).     streamConfig.setOperatorID(operatorID).     final TestTaskStateManager taskStateManagerMock = testHarness.getTaskStateManager().     taskStateManagerMock.setWaitForReportLatch(new OneShotLatch()).     testHarness.invoke().     testHarness.waitForTaskRunning().     final OneInputStreamTask<Integer, Integer> task = testHarness.getTask().     final long initialTime = 0L.     testHarness.processElement(new StreamRecord<>(1, initialTime + 1)).     testHarness.processElement(new StreamRecord<>(2, initialTime + 2)).     testHarness.processElement(new StreamRecord<>(3, initialTime + 3)).     testHarness.processElement(new StreamRecord<>(4, initialTime + 4)).     testHarness.waitForInputProcessing().     final long checkpointId = 1L.     final long checkpointTimestamp = 1L.     final CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, checkpointTimestamp).     task.triggerCheckpoint(checkpointMetaData, CheckpointOptions.forCheckpointWithDefaultLocation()).     taskStateManagerMock.getWaitForReportLatch().await().     assertEquals(checkpointId, taskStateManagerMock.getReportedCheckpointId()).     LazyAsyncFunction.countDown().     testHarness.endInput().     testHarness.waitForTaskCompletion().     // set the operator state from previous attempt into the restored one     TaskStateSnapshot subtaskStates = taskStateManagerMock.getLastJobManagerTaskStateSnapshot().     final OneInputStreamTaskTestHarness<Integer, Integer> restoredTaskHarness = new OneInputStreamTaskTestHarness<>(OneInputStreamTask::new, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO).     restoredTaskHarness.setTaskStateSnapshot(checkpointId, subtaskStates).     restoredTaskHarness.setupOutputForSingletonOperatorChain().     AsyncWaitOperator<Integer, Integer> restoredOperator = new AsyncWaitOperator<>(new MyAsyncFunction(), TIMEOUT, 6, AsyncDataStream.OutputMode.ORDERED).     restoredTaskHarness.getStreamConfig().setStreamOperator(restoredOperator).     restoredTaskHarness.getStreamConfig().setOperatorID(operatorID).     restoredTaskHarness.invoke().     restoredTaskHarness.waitForTaskRunning().     final OneInputStreamTask<Integer, Integer> restoredTask = restoredTaskHarness.getTask().     restoredTaskHarness.processElement(new StreamRecord<>(5, initialTime + 5)).     restoredTaskHarness.processElement(new StreamRecord<>(6, initialTime + 6)).     restoredTaskHarness.processElement(new StreamRecord<>(7, initialTime + 7)).     // trigger the checkpoint while processing stream elements     restoredTask.triggerCheckpoint(new CheckpointMetaData(checkpointId, checkpointTimestamp), CheckpointOptions.forCheckpointWithDefaultLocation()).     restoredTaskHarness.processElement(new StreamRecord<>(8, initialTime + 8)).     restoredTaskHarness.endInput().     restoredTaskHarness.waitForTaskCompletion().     ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     expectedOutput.add(new StreamRecord<>(2, initialTime + 1)).     expectedOutput.add(new StreamRecord<>(4, initialTime + 2)).     expectedOutput.add(new StreamRecord<>(6, initialTime + 3)).     expectedOutput.add(new StreamRecord<>(8, initialTime + 4)).     expectedOutput.add(new StreamRecord<>(10, initialTime + 5)).     expectedOutput.add(new StreamRecord<>(12, initialTime + 6)).     expectedOutput.add(new StreamRecord<>(14, initialTime + 7)).     expectedOutput.add(new StreamRecord<>(16, initialTime + 8)).     // remove CheckpointBarrier which is not expected     Iterator<Object> iterator = restoredTaskHarness.getOutput().iterator().     while (iterator.hasNext()) {         if (iterator.next() instanceof CheckpointBarrier) {             iterator.remove().         }     }     TestHarnessUtil.assertOutputEquals("StateAndRestored Test Output was not correct.", expectedOutput, restoredTaskHarness.getOutput()). }
false;public;0;7;;@Test public void testAsyncTimeoutFailure() throws Exception {     testAsyncTimeout(new LazyAsyncFunction(), Optional.of(TimeoutException.class), new StreamRecord<>(2, 5L)). }
false;public;0;8;;@Test public void testAsyncTimeoutIgnore() throws Exception {     testAsyncTimeout(new IgnoreTimeoutLazyAsyncFunction(), Optional.empty(), new StreamRecord<>(3, 0L), new StreamRecord<>(2, 5L)). }
false;private;3;52;;private void testAsyncTimeout(LazyAsyncFunction lazyAsyncFunction, Optional<Class<? extends Throwable>> expectedException, StreamRecord<Integer>... expectedRecords) throws Exception {     final long timeout = 10L.     final AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(lazyAsyncFunction, timeout, 2, AsyncDataStream.OutputMode.ORDERED).     final MockEnvironment mockEnvironment = createMockEnvironment().     mockEnvironment.setExpectedExternalFailureCause(Throwable.class).     final OneInputStreamOperatorTestHarness<Integer, Integer> testHarness = new OneInputStreamOperatorTestHarness<>(operator, IntSerializer.INSTANCE, mockEnvironment).     final long initialTime = 0L.     final ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>().     testHarness.open().     testHarness.setProcessingTime(initialTime).     synchronized (testHarness.getCheckpointLock()) {         testHarness.processElement(new StreamRecord<>(1, initialTime)).         testHarness.setProcessingTime(initialTime + 5L).         testHarness.processElement(new StreamRecord<>(2, initialTime + 5L)).     }     // trigger the timeout of the first stream record     testHarness.setProcessingTime(initialTime + timeout + 1L).     // allow the second async stream record to be processed     lazyAsyncFunction.countDown().     // wait until all async collectors in the buffer have been emitted out.     synchronized (testHarness.getCheckpointLock()) {         testHarness.close().     }     expectedOutput.addAll(Arrays.asList(expectedRecords)).     TestHarnessUtil.assertOutputEquals("Output with watermark was not correct.", expectedOutput, testHarness.getOutput()).     if (expectedException.isPresent()) {         assertTrue(mockEnvironment.getActualExternalFailureCause().isPresent()).         assertTrue(ExceptionUtils.findThrowable(mockEnvironment.getActualExternalFailureCause().get(), expectedException.get()).isPresent()).     } }
false;private;0;9;;@Nonnull private MockEnvironment createMockEnvironment() {     return new MockEnvironmentBuilder().setTaskName("foobarTask").setMemorySize(1024 * 1024L).setInputSplitProvider(new MockInputSplitProvider()).setBufferSize(4 * 1024).build(). }
false;public;1;13;;@Override public Object answer(InvocationOnMock invocation) throws Throwable {     assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock)).     outputLatch.trigger().     // wait until we're in the closing method of the operator     while (!closingLatch.isTriggered()) {         lock.wait().     }     return null. }
true;public;0;60;/**  * Test case for FLINK-5638: Tests that the async wait operator can be closed even if the  * emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async  * wait operators where the latter operator's queue is currently full).  *  * <p>Note that this test does not enforce the exact strict ordering because with the fix it is no  * longer possible. However, it provokes the described situation without the fix.  */ ;/**  * Test case for FLINK-5638: Tests that the async wait operator can be closed even if the  * emitter is currently waiting on the checkpoint lock (e.g. in the case of two chained async  * wait operators where the latter operator's queue is currently full).  *  * <p>Note that this test does not enforce the exact strict ordering because with the fix it is no  * longer possible. However, it provokes the described situation without the fix.  */ @Test(timeout = 10000L) public void testClosingWithBlockedEmitter() throws Exception {     final Object lock = new Object().     ArgumentCaptor<Throwable> failureReason = ArgumentCaptor.forClass(Throwable.class).     MockEnvironment environment = createMockEnvironment().     StreamTask<?, ?> containingTask = mock(StreamTask.class).     when(containingTask.getEnvironment()).thenReturn(environment).     when(containingTask.getCheckpointLock()).thenReturn(lock).     when(containingTask.getProcessingTimeService()).thenReturn(new TestProcessingTimeService()).     StreamConfig streamConfig = new MockStreamConfig().     streamConfig.setTypeSerializerIn1(IntSerializer.INSTANCE).     final OneShotLatch closingLatch = new OneShotLatch().     final OneShotLatch outputLatch = new OneShotLatch().     Output<StreamRecord<Integer>> output = mock(Output.class).     doAnswer(new Answer() {          @Override         public Object answer(InvocationOnMock invocation) throws Throwable {             assertTrue("Output should happen under the checkpoint lock.", Thread.currentThread().holdsLock(lock)).             outputLatch.trigger().             // wait until we're in the closing method of the operator             while (!closingLatch.isTriggered()) {                 lock.wait().             }             return null.         }     }).when(output).collect(any(StreamRecord.class)).     AsyncWaitOperator<Integer, Integer> operator = new TestAsyncWaitOperator<>(new MyAsyncFunction(), 1000L, 1, AsyncDataStream.OutputMode.ORDERED, closingLatch).     operator.setup(containingTask, streamConfig, output).     operator.open().     synchronized (lock) {         operator.processElement(new StreamRecord<>(42)).     }     outputLatch.await().     synchronized (lock) {         operator.close().     } }
false;public;0;6;;@Override public void close() throws Exception {     closingLatch.trigger().     checkpointingLock.notifyAll().     super.close(). }
false;public;2;4;;@Override public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {     resultFuture.complete(Collections.singletonList(input)). }
true;public;0;64;/**  * FLINK-5652  * Tests that registered timers are properly canceled upon completion of a  * {@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold  * a reference on the StreamRecordQueueEntry.  */ ;/**  * FLINK-5652  * Tests that registered timers are properly canceled upon completion of a  * {@link StreamRecordQueueEntry} in order to avoid resource leaks because TriggerTasks hold  * a reference on the StreamRecordQueueEntry.  */ @Test public void testTimeoutCleanup() throws Exception {     final Object lock = new Object().     final long timeout = 100000L.     final long timestamp = 1L.     Environment environment = createMockEnvironment().     ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class).     ProcessingTimeService processingTimeService = mock(ProcessingTimeService.class).     when(processingTimeService.getCurrentProcessingTime()).thenReturn(timestamp).     doReturn(scheduledFuture).when(processingTimeService).registerTimer(anyLong(), any(ProcessingTimeCallback.class)).     StreamTask<?, ?> containingTask = mock(StreamTask.class).     when(containingTask.getEnvironment()).thenReturn(environment).     when(containingTask.getCheckpointLock()).thenReturn(lock).     when(containingTask.getProcessingTimeService()).thenReturn(processingTimeService).     StreamConfig streamConfig = new MockStreamConfig().     streamConfig.setTypeSerializerIn1(IntSerializer.INSTANCE).     Output<StreamRecord<Integer>> output = mock(Output.class).     AsyncWaitOperator<Integer, Integer> operator = new AsyncWaitOperator<>(new AsyncFunction<Integer, Integer>() {          private static final long serialVersionUID = -3718276118074877073L.          @Override         public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {             resultFuture.complete(Collections.singletonList(input)).         }     }, timeout, 1, AsyncDataStream.OutputMode.UNORDERED).     operator.setup(containingTask, streamConfig, output).     operator.open().     final StreamRecord<Integer> streamRecord = new StreamRecord<>(42, timestamp).     synchronized (lock) {         // processing an element will register a timeout         operator.processElement(streamRecord).     }     synchronized (lock) {         // closing the operator waits until all inputs have been processed         operator.close().     }     // check that we actually outputted the result of the single input     verify(output).collect(eq(streamRecord)).     verify(processingTimeService).registerTimer(eq(processingTimeService.getCurrentProcessingTime() + timeout), any(ProcessingTimeCallback.class)).     // check that we have cancelled our registered timeout     verify(scheduledFuture).cancel(eq(true)). }
true;public;0;4;/**  * FLINK-6435  *  * <p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until  * another StreamElementQueueEntry is properly completed before it is collected.  */ ;/**  * FLINK-6435  *  * <p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until  * another StreamElementQueueEntry is properly completed before it is collected.  */ @Test(timeout = 2000) public void testOrderedWaitUserExceptionHandling() throws Exception {     testUserExceptionHandling(AsyncDataStream.OutputMode.ORDERED). }
true;public;0;4;/**  * FLINK-6435  *  * <p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until  * another StreamElementQueueEntry is properly completed before it is collected.  */ ;/**  * FLINK-6435  *  * <p>Tests that a user exception triggers the completion of a StreamElementQueueEntry and does not wait to until  * another StreamElementQueueEntry is properly completed before it is collected.  */ @Test(timeout = 2000) public void testUnorderedWaitUserExceptionHandling() throws Exception {     testUserExceptionHandling(AsyncDataStream.OutputMode.UNORDERED). }
false;private;1;30;;private void testUserExceptionHandling(AsyncDataStream.OutputMode outputMode) throws Exception {     UserExceptionAsyncFunction asyncWaitFunction = new UserExceptionAsyncFunction().     long timeout = 2000L.     AsyncWaitOperator<Integer, Integer> asyncWaitOperator = new AsyncWaitOperator<>(asyncWaitFunction, TIMEOUT, 2, outputMode).     final MockEnvironment mockEnvironment = createMockEnvironment().     mockEnvironment.setExpectedExternalFailureCause(Throwable.class).     OneInputStreamOperatorTestHarness<Integer, Integer> harness = new OneInputStreamOperatorTestHarness<>(asyncWaitOperator, IntSerializer.INSTANCE, mockEnvironment).     harness.open().     synchronized (harness.getCheckpointLock()) {         harness.processElement(1, 1L).     }     synchronized (harness.getCheckpointLock()) {         harness.close().     }     assertTrue(harness.getEnvironment().getActualExternalFailureCause().isPresent()). }
false;public;2;4;;@Override public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture) throws Exception {     resultFuture.completeExceptionally(new Exception("Test exception")). }
true;public;0;4;/**  * FLINK-6435  *  * <p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that  * a StreamElementQueueEntry is completed in case of a timeout exception.  */ ;/**  * FLINK-6435  *  * <p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that  * a StreamElementQueueEntry is completed in case of a timeout exception.  */ @Test public void testOrderedWaitTimeoutHandling() throws Exception {     testTimeoutExceptionHandling(AsyncDataStream.OutputMode.ORDERED). }
true;public;0;4;/**  * FLINK-6435  *  * <p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that  * a StreamElementQueueEntry is completed in case of a timeout exception.  */ ;/**  * FLINK-6435  *  * <p>Tests that timeout exceptions are properly handled in ordered output mode. The proper handling means that  * a StreamElementQueueEntry is completed in case of a timeout exception.  */ @Test public void testUnorderedWaitTimeoutHandling() throws Exception {     testTimeoutExceptionHandling(AsyncDataStream.OutputMode.UNORDERED). }
false;private;1;30;;private void testTimeoutExceptionHandling(AsyncDataStream.OutputMode outputMode) throws Exception {     AsyncFunction<Integer, Integer> asyncFunction = new NoOpAsyncFunction<>().     // 1 milli second     long timeout = 10L.     AsyncWaitOperator<Integer, Integer> asyncWaitOperator = new AsyncWaitOperator<>(asyncFunction, timeout, 2, outputMode).     final MockEnvironment mockEnvironment = createMockEnvironment().     mockEnvironment.setExpectedExternalFailureCause(Throwable.class).     OneInputStreamOperatorTestHarness<Integer, Integer> harness = new OneInputStreamOperatorTestHarness<>(asyncWaitOperator, IntSerializer.INSTANCE, mockEnvironment).     harness.open().     synchronized (harness.getCheckpointLock()) {         harness.processElement(1, 1L).     }     harness.setProcessingTime(10L).     synchronized (harness.getCheckpointLock()) {         harness.close().     } }
false;public;0;7;;@Override public void go() throws Exception {     synchronized (snapshotHarness.getCheckpointLock()) {         lastElement.trigger().         snapshotHarness.processElement(capacity, 0L).     } }
true;public;0;94;/**  * Tests that the AysncWaitOperator can restart if checkpointed queue was full.  *  * <p>See FLINK-7949  */ ;/**  * Tests that the AysncWaitOperator can restart if checkpointed queue was full.  *  * <p>See FLINK-7949  */ @Test(timeout = 10000) public void testRestartWithFullQueue() throws Exception {     int capacity = 10.     // 1. create the snapshot which contains capacity + 1 elements     final CompletableFuture<Void> trigger = new CompletableFuture<>().     final ControllableAsyncFunction<Integer> controllableAsyncFunction = new ControllableAsyncFunction<>(trigger).     final OneInputStreamOperatorTestHarness<Integer, Integer> snapshotHarness = new OneInputStreamOperatorTestHarness<>(new AsyncWaitOperator<>(// the NoOpAsyncFunction is like a blocking function     controllableAsyncFunction, 1000L, capacity, AsyncDataStream.OutputMode.ORDERED), IntSerializer.INSTANCE).     snapshotHarness.open().     final OperatorSubtaskState snapshot.     final ArrayList<Integer> expectedOutput = new ArrayList<>(capacity + 1).     try {         synchronized (snapshotHarness.getCheckpointLock()) {             for (int i = 0. i < capacity. i++) {                 snapshotHarness.processElement(i, 0L).                 expectedOutput.add(i).             }         }         expectedOutput.add(capacity).         final OneShotLatch lastElement = new OneShotLatch().         final CheckedThread lastElementWriter = new CheckedThread() {              @Override             public void go() throws Exception {                 synchronized (snapshotHarness.getCheckpointLock()) {                     lastElement.trigger().                     snapshotHarness.processElement(capacity, 0L).                 }             }         }.         lastElementWriter.start().         lastElement.await().         synchronized (snapshotHarness.getCheckpointLock()) {             // execute the snapshot within the checkpoint lock, because then it is guaranteed             // that the lastElementWriter has written the exceeding element             snapshot = snapshotHarness.snapshot(0L, 0L).         }         // trigger the computation to make the close call finish         trigger.complete(null).     } finally {         synchronized (snapshotHarness.getCheckpointLock()) {             snapshotHarness.close().         }     }     // 2. restore the snapshot and check that we complete     final OneInputStreamOperatorTestHarness<Integer, Integer> recoverHarness = new OneInputStreamOperatorTestHarness<>(new AsyncWaitOperator<>(new ControllableAsyncFunction<>(CompletableFuture.completedFuture(null)), 1000L, capacity, AsyncDataStream.OutputMode.ORDERED), IntSerializer.INSTANCE).     recoverHarness.initializeState(snapshot).     synchronized (recoverHarness.getCheckpointLock()) {         recoverHarness.open().     }     synchronized (recoverHarness.getCheckpointLock()) {         recoverHarness.close().     }     final ConcurrentLinkedQueue<Object> output = recoverHarness.getOutput().     assertThat(output.size(), Matchers.equalTo(capacity + 1)).     final ArrayList<Integer> outputElements = new ArrayList<>(capacity + 1).     for (int i = 0. i < capacity + 1. i++) {         StreamRecord<Integer> streamRecord = ((StreamRecord<Integer>) output.poll()).         outputElements.add(streamRecord.getValue()).     }     assertThat(outputElements, Matchers.equalTo(expectedOutput)). }
false;public;2;4;;@Override public void asyncInvoke(IN input, ResultFuture<IN> resultFuture) throws Exception {     trigger.thenAccept(v -> resultFuture.complete(Collections.singleton(input))). }
false;public;2;4;;@Override public void asyncInvoke(IN input, ResultFuture<OUT> resultFuture) throws Exception { // no op }
