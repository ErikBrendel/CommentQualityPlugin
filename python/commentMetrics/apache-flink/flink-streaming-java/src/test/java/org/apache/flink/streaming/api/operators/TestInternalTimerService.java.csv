commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public long currentProcessingTime() {     return currentProcessingTime. }
false;public;0;4;;@Override public long currentWatermark() {     return currentWatermark. }
false;public;2;9;;@Override public void registerProcessingTimeTimer(N namespace, long time) {     @SuppressWarnings("unchecked")     Timer<K, N> timer = new Timer<>(time, (K) keyContext.getCurrentKey(), namespace).     // make sure we only put one timer per key into the queue     if (processingTimeTimers.add(timer)) {         processingTimeTimersQueue.add(timer).     } }
false;public;2;8;;@Override public void registerEventTimeTimer(N namespace, long time) {     @SuppressWarnings("unchecked")     Timer<K, N> timer = new Timer<>(time, (K) keyContext.getCurrentKey(), namespace).     if (watermarkTimers.add(timer)) {         watermarkTimersQueue.add(timer).     } }
false;public;2;9;;@Override public void deleteProcessingTimeTimer(N namespace, long time) {     @SuppressWarnings("unchecked")     Timer<K, N> timer = new Timer<>(time, (K) keyContext.getCurrentKey(), namespace).     if (processingTimeTimers.remove(timer)) {         processingTimeTimersQueue.remove(timer).     } }
false;public;2;8;;@Override public void deleteEventTimeTimer(N namespace, long time) {     @SuppressWarnings("unchecked")     Timer<K, N> timer = new Timer<>(time, (K) keyContext.getCurrentKey(), namespace).     if (watermarkTimers.remove(timer)) {         watermarkTimersQueue.remove(timer).     } }
false;public;1;15;;public Collection<Timer<K, N>> advanceProcessingTime(long time) throws Exception {     List<Timer<K, N>> result = new ArrayList<>().     Timer<K, N> timer = processingTimeTimersQueue.peek().     while (timer != null && timer.timestamp <= time) {         processingTimeTimers.remove(timer).         processingTimeTimersQueue.remove().         result.add(timer).         timer = processingTimeTimersQueue.peek().     }     currentProcessingTime = time.     return result. }
false;public;1;15;;public Collection<Timer<K, N>> advanceWatermark(long time) throws Exception {     List<Timer<K, N>> result = new ArrayList<>().     Timer<K, N> timer = watermarkTimersQueue.peek().     while (timer != null && timer.timestamp <= time) {         watermarkTimers.remove(timer).         watermarkTimersQueue.remove().         result.add(timer).         timer = watermarkTimersQueue.peek().     }     currentWatermark = time.     return result. }
false;public;0;3;;public long getTimestamp() {     return timestamp. }
false;public;0;3;;public K getKey() {     return key. }
false;public;0;3;;public N getNamespace() {     return namespace. }
false;public;1;4;;@Override public int compareTo(Timer<K, N> o) {     return Long.compare(this.timestamp, o.timestamp). }
false;public;1;16;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     Timer<?, ?> timer = (Timer<?, ?>) o.     return timestamp == timer.timestamp && key.equals(timer.key) && namespace.equals(timer.namespace). }
false;public;0;7;;@Override public int hashCode() {     int result = (int) (timestamp ^ (timestamp >>> 32)).     result = 31 * result + key.hashCode().     result = 31 * result + namespace.hashCode().     return result. }
false;public;0;8;;@Override public String toString() {     return "Timer{" + "timestamp=" + timestamp + ", key=" + key + ", namespace=" + namespace + '}'. }
false;public;0;3;;public int numProcessingTimeTimers() {     return processingTimeTimers.size(). }
false;public;0;3;;public int numEventTimeTimers() {     return watermarkTimers.size(). }
false;public;1;10;;public int numProcessingTimeTimers(N namespace) {     int count = 0.     for (Timer<K, N> timer : processingTimeTimers) {         if (timer.getNamespace().equals(namespace)) {             count++.         }     }     return count. }
false;public;1;10;;public int numEventTimeTimers(N namespace) {     int count = 0.     for (Timer<K, N> timer : watermarkTimers) {         if (timer.getNamespace().equals(namespace)) {             count++.         }     }     return count. }
