commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void setup() {     executor = Executors.newFixedThreadPool(3). }
false;public,static;0;14;;@AfterClass public static void shutdown() {     executor.shutdown().     try {         if (!executor.awaitTermination(timeout, TimeUnit.MILLISECONDS)) {             executor.shutdownNow().         }     } catch (InterruptedException interrupted) {         executor.shutdownNow().         Thread.currentThread().interrupt().     } }
true;public;0;114;/**  * Tests that only elements before the oldest watermark are returned if they are completed.  */ ;/**  * Tests that only elements before the oldest watermark are returned if they are completed.  */ @Test public void testCompletionOrder() throws Exception {     OperatorActions operatorActions = mock(OperatorActions.class).     final UnorderedStreamElementQueue queue = new UnorderedStreamElementQueue(8, executor, operatorActions).     StreamRecordQueueEntry<Integer> record1 = new StreamRecordQueueEntry<>(new StreamRecord<>(1, 0L)).     StreamRecordQueueEntry<Integer> record2 = new StreamRecordQueueEntry<>(new StreamRecord<>(2, 1L)).     WatermarkQueueEntry watermark1 = new WatermarkQueueEntry(new Watermark(2L)).     StreamRecordQueueEntry<Integer> record3 = new StreamRecordQueueEntry<>(new StreamRecord<>(3, 3L)).     StreamRecordQueueEntry<Integer> record4 = new StreamRecordQueueEntry<>(new StreamRecord<>(4, 4L)).     WatermarkQueueEntry watermark2 = new WatermarkQueueEntry(new Watermark(5L)).     StreamRecordQueueEntry<Integer> record5 = new StreamRecordQueueEntry<>(new StreamRecord<>(5, 6L)).     StreamRecordQueueEntry<Integer> record6 = new StreamRecordQueueEntry<>(new StreamRecord<>(6, 7L)).     List<StreamElementQueueEntry<?>> entries = Arrays.asList(record1, record2, watermark1, record3, record4, watermark2, record5, record6).     // The queue should look like R1, R2, W1, R3, R4, W2, R5, R6     for (StreamElementQueueEntry<?> entry : entries) {         queue.put(entry).     }     Assert.assertTrue(8 == queue.size()).     CompletableFuture<AsyncResult> firstPoll = CompletableFuture.supplyAsync(() -> {         try {             return queue.poll().         } catch (InterruptedException e) {             throw new CompletionException(e).         }     }, executor).     // this should not fulfill the poll, because R3 is behind W1     record3.complete(Collections.<Integer>emptyList()).     Thread.sleep(10L).     Assert.assertFalse(firstPoll.isDone()).     record2.complete(Collections.<Integer>emptyList()).     Assert.assertEquals(record2, firstPoll.get()).     CompletableFuture<AsyncResult> secondPoll = CompletableFuture.supplyAsync(() -> {         try {             return queue.poll().         } catch (InterruptedException e) {             throw new CompletionException(e).         }     }, executor).     record6.complete(Collections.<Integer>emptyList()).     record4.complete(Collections.<Integer>emptyList()).     Thread.sleep(10L).     // The future should not be completed because R1 has not been completed yet     Assert.assertFalse(secondPoll.isDone()).     record1.complete(Collections.<Integer>emptyList()).     Assert.assertEquals(record1, secondPoll.get()).     // Now W1, R3, R4 and W2 are completed and should be pollable     Assert.assertEquals(watermark1, queue.poll()).     // The order of R3 and R4 is not specified     Set<AsyncResult> expected = new HashSet<>(2).     expected.add(record3).     expected.add(record4).     Set<AsyncResult> actual = new HashSet<>(2).     actual.add(queue.poll()).     actual.add(queue.poll()).     Assert.assertEquals(expected, actual).     Assert.assertEquals(watermark2, queue.poll()).     // since R6 has been completed before and W2 has been consumed, we should be able to poll     // this record as well     Assert.assertEquals(record6, queue.poll()).     // only R5 left in the queue     Assert.assertTrue(1 == queue.size()).     CompletableFuture<AsyncResult> thirdPoll = CompletableFuture.supplyAsync(() -> {         try {             return queue.poll().         } catch (InterruptedException e) {             throw new CompletionException(e).         }     }, executor).     Thread.sleep(10L).     Assert.assertFalse(thirdPoll.isDone()).     record5.complete(Collections.<Integer>emptyList()).     Assert.assertEquals(record5, thirdPoll.get()).     Assert.assertTrue(queue.isEmpty()).     verify(operatorActions, never()).failOperator(any(Exception.class)). }
